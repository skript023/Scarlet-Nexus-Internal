#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ActionSystem

#include "Basic.hpp"

#include "ActionSystem_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class ActionSystem.ASAnimNotifyState_Input
// 0x0020 (0x0050 - 0x0030)
class UASAnimNotifyState_Input final : public UAnimNotifyState
{
public:
	float                                         ShiftStartTime;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Commands;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASAnimNotifyState_Input">();
	}
	static class UASAnimNotifyState_Input* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASAnimNotifyState_Input>();
	}
};
static_assert(alignof(UASAnimNotifyState_Input) == 0x000008, "Wrong alignment on UASAnimNotifyState_Input");
static_assert(sizeof(UASAnimNotifyState_Input) == 0x000050, "Wrong size on UASAnimNotifyState_Input");
static_assert(offsetof(UASAnimNotifyState_Input, ShiftStartTime) == 0x000030, "Member 'UASAnimNotifyState_Input::ShiftStartTime' has a wrong offset!");
static_assert(offsetof(UASAnimNotifyState_Input, Commands) == 0x000038, "Member 'UASAnimNotifyState_Input::Commands' has a wrong offset!");

// Class ActionSystem.ASAnimInstance
// 0x03B0 (0x0620 - 0x0270)
class UASAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_270[0xA8];                                     // 0x0270(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DamageStateMachine;                                // 0x0318(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DamageState;                                       // 0x0328(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FASDamageState                         DamageCommand;                                     // 0x0338(0x01E0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_518[0x108];                                    // 0x0518(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimNotify_StateChange(class UASAnimNotify_StateChange* Notify);
	bool IsHitShift();
	void JumpDamageState(EDamageState State);
	void JumpMachineState(const class FString& MachinName, const class FString& StateName);
	void ReceiveStateChange(const class FString& PreviousStateName, const class FString& NextStateName);
	void SendCommand(const class FString& Command, const bool bForce);
	void SetDynamicSubMachine(const class FString& AnimNodeName, const class FString& StateName, const class UASStateMachine* StateMachineAsset);

	bool HasTag(const class FName& Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASAnimInstance">();
	}
	static class UASAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASAnimInstance>();
	}
};
static_assert(alignof(UASAnimInstance) == 0x000010, "Wrong alignment on UASAnimInstance");
static_assert(sizeof(UASAnimInstance) == 0x000620, "Wrong size on UASAnimInstance");
static_assert(offsetof(UASAnimInstance, DamageStateMachine) == 0x000318, "Member 'UASAnimInstance::DamageStateMachine' has a wrong offset!");
static_assert(offsetof(UASAnimInstance, DamageState) == 0x000328, "Member 'UASAnimInstance::DamageState' has a wrong offset!");
static_assert(offsetof(UASAnimInstance, DamageCommand) == 0x000338, "Member 'UASAnimInstance::DamageCommand' has a wrong offset!");

// Class ActionSystem.ASAnimationSet
// 0x0040 (0x0070 - 0x0030)
class UASAnimationSet final : public UDataAsset
{
public:
	class UASAnimationSet*                        Parent;                                            // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FASAnimationSetEntry_Sequence>  Sequences;                                         // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FASAnimationSetEntry_BlendSpace> BlendSpaces;                                       // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FASAnimationSetEntry_StateMachine> StateMachines;                                     // 0x0058(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASAnimationSet">();
	}
	static class UASAnimationSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASAnimationSet>();
	}
};
static_assert(alignof(UASAnimationSet) == 0x000008, "Wrong alignment on UASAnimationSet");
static_assert(sizeof(UASAnimationSet) == 0x000070, "Wrong size on UASAnimationSet");
static_assert(offsetof(UASAnimationSet, Parent) == 0x000030, "Member 'UASAnimationSet::Parent' has a wrong offset!");
static_assert(offsetof(UASAnimationSet, Sequences) == 0x000038, "Member 'UASAnimationSet::Sequences' has a wrong offset!");
static_assert(offsetof(UASAnimationSet, BlendSpaces) == 0x000048, "Member 'UASAnimationSet::BlendSpaces' has a wrong offset!");
static_assert(offsetof(UASAnimationSet, StateMachines) == 0x000058, "Member 'UASAnimationSet::StateMachines' has a wrong offset!");

// Class ActionSystem.ASAnimNotify_EndCancel
// 0x0000 (0x0038 - 0x0038)
class UASAnimNotify_EndCancel final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASAnimNotify_EndCancel">();
	}
	static class UASAnimNotify_EndCancel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASAnimNotify_EndCancel>();
	}
};
static_assert(alignof(UASAnimNotify_EndCancel) == 0x000008, "Wrong alignment on UASAnimNotify_EndCancel");
static_assert(sizeof(UASAnimNotify_EndCancel) == 0x000038, "Wrong size on UASAnimNotify_EndCancel");

// Class ActionSystem.ASAnimNotify_HitShift
// 0x0000 (0x0038 - 0x0038)
class UASAnimNotify_HitShift final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASAnimNotify_HitShift">();
	}
	static class UASAnimNotify_HitShift* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASAnimNotify_HitShift>();
	}
};
static_assert(alignof(UASAnimNotify_HitShift) == 0x000008, "Wrong alignment on UASAnimNotify_HitShift");
static_assert(sizeof(UASAnimNotify_HitShift) == 0x000038, "Wrong size on UASAnimNotify_HitShift");

// Class ActionSystem.ASAnimNotify_StateChange
// 0x0038 (0x0070 - 0x0038)
class UASAnimNotify_StateChange final : public UAnimNotify
{
public:
	uint8                                         Pad_38[0x38];                                      // 0x0038(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASAnimNotify_StateChange">();
	}
	static class UASAnimNotify_StateChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASAnimNotify_StateChange>();
	}
};
static_assert(alignof(UASAnimNotify_StateChange) == 0x000008, "Wrong alignment on UASAnimNotify_StateChange");
static_assert(sizeof(UASAnimNotify_StateChange) == 0x000070, "Wrong size on UASAnimNotify_StateChange");

// Class ActionSystem.ASAnimNotifyState_Attack
// 0x0030 (0x0060 - 0x0030)
class UASAnimNotifyState_Attack final : public UAnimNotifyState
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UASDamageType>              DamageType;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitCount;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitInterval;                                       // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackScale;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponId;                                          // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FASAttackCollision>             AttackCollisions;                                  // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASAnimNotifyState_Attack">();
	}
	static class UASAnimNotifyState_Attack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASAnimNotifyState_Attack>();
	}
};
static_assert(alignof(UASAnimNotifyState_Attack) == 0x000008, "Wrong alignment on UASAnimNotifyState_Attack");
static_assert(sizeof(UASAnimNotifyState_Attack) == 0x000060, "Wrong size on UASAnimNotifyState_Attack");
static_assert(offsetof(UASAnimNotifyState_Attack, DamageType) == 0x000038, "Member 'UASAnimNotifyState_Attack::DamageType' has a wrong offset!");
static_assert(offsetof(UASAnimNotifyState_Attack, HitCount) == 0x000040, "Member 'UASAnimNotifyState_Attack::HitCount' has a wrong offset!");
static_assert(offsetof(UASAnimNotifyState_Attack, HitInterval) == 0x000044, "Member 'UASAnimNotifyState_Attack::HitInterval' has a wrong offset!");
static_assert(offsetof(UASAnimNotifyState_Attack, AttackScale) == 0x000048, "Member 'UASAnimNotifyState_Attack::AttackScale' has a wrong offset!");
static_assert(offsetof(UASAnimNotifyState_Attack, WeaponId) == 0x00004C, "Member 'UASAnimNotifyState_Attack::WeaponId' has a wrong offset!");
static_assert(offsetof(UASAnimNotifyState_Attack, AttackCollisions) == 0x000050, "Member 'UASAnimNotifyState_Attack::AttackCollisions' has a wrong offset!");

// Class ActionSystem.ASAnimNotifyState_Float
// 0x0000 (0x0030 - 0x0030)
class UASAnimNotifyState_Float final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASAnimNotifyState_Float">();
	}
	static class UASAnimNotifyState_Float* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASAnimNotifyState_Float>();
	}
};
static_assert(alignof(UASAnimNotifyState_Float) == 0x000008, "Wrong alignment on UASAnimNotifyState_Float");
static_assert(sizeof(UASAnimNotifyState_Float) == 0x000030, "Wrong size on UASAnimNotifyState_Float");

// Class ActionSystem.ASAnimNotifyState_Invincible
// 0x0000 (0x0030 - 0x0030)
class UASAnimNotifyState_Invincible final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASAnimNotifyState_Invincible">();
	}
	static class UASAnimNotifyState_Invincible* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASAnimNotifyState_Invincible>();
	}
};
static_assert(alignof(UASAnimNotifyState_Invincible) == 0x000008, "Wrong alignment on UASAnimNotifyState_Invincible");
static_assert(sizeof(UASAnimNotifyState_Invincible) == 0x000030, "Wrong size on UASAnimNotifyState_Invincible");

// Class ActionSystem.ASAnimNotifyState_SuperArmor
// 0x0000 (0x0030 - 0x0030)
class UASAnimNotifyState_SuperArmor final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASAnimNotifyState_SuperArmor">();
	}
	static class UASAnimNotifyState_SuperArmor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASAnimNotifyState_SuperArmor>();
	}
};
static_assert(alignof(UASAnimNotifyState_SuperArmor) == 0x000008, "Wrong alignment on UASAnimNotifyState_SuperArmor");
static_assert(sizeof(UASAnimNotifyState_SuperArmor) == 0x000030, "Wrong size on UASAnimNotifyState_SuperArmor");

// Class ActionSystem.ASCharacterBase
// 0x0010 (0x04E0 - 0x04D0)
class AASCharacterBase : public ACharacter
{
public:
	TArray<int32>                                 ReplicateState;                                    // 0x04C8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D8[0x8];                                      // 0x04D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void JumpMachineState(const class FString& MachinName, const class FString& StateName);
	void OnRep_ReplicateState();
	void ReceiveStateChange(const class FString& PreviousStateName, const class FString& NextStateName);
	void SendAnimCommand(const class FString& Command, bool Force);
	void ServerStateChange(int32 MachineIndex, int32 PreviousState, int32 NextState);

	TArray<class FName> GetAnimTags() const;
	bool HasAnimTag(class FName Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASCharacterBase">();
	}
	static class AASCharacterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AASCharacterBase>();
	}
};
static_assert(alignof(AASCharacterBase) == 0x000010, "Wrong alignment on AASCharacterBase");
static_assert(sizeof(AASCharacterBase) == 0x0004E0, "Wrong size on AASCharacterBase");
static_assert(offsetof(AASCharacterBase, ReplicateState) == 0x0004C8, "Member 'AASCharacterBase::ReplicateState' has a wrong offset!");

// Class ActionSystem.ASCharacter
// 0x0150 (0x0630 - 0x04E0)
#pragma pack(push, 0x1)
class alignas(0x10) AASCharacter : public AASCharacterBase
{
public:
	uint8                                         Pad_4E0[0x8];                                      // 0x04E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FASTakeHitInfo                         LastTakeHitInfo;                                   // 0x04E8(0x0128)(Net, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_610[0x18];                                     // 0x0610(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientNotifyHit(class AASCharacter* OtherCharacter, const struct FHitResult& Impact, TSubclassOf<class UASDamageType> DamageTypeClass, float Damage, const struct FVector_NetQuantizeNormal& ShotDirection);
	void ClientTakeDamage(float Damage, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
	void ClientTakePointDamage(float Damage, const struct FPointDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
	void JumpDamageState(EDamageState State);
	bool OnAttackOverlap(class UPrimitiveComponent* MyComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FHitResult& SweepResult);
	void OnRep_LastTakeHitInfo();
	void ServerNotifyHit(class AASCharacter* OtherCharacter, const struct FHitResult& Impact, TSubclassOf<class UASDamageType> DamageTypeClass, float Damage, const struct FVector_NetQuantizeNormal& ShotDirection);
	void ServerTakeDamage(float Damage, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
	void ServerTakePointDamage(float Damage, const struct FPointDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASCharacter">();
	}
	static class AASCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AASCharacter>();
	}
};
#pragma pack(pop)
static_assert(alignof(AASCharacter) == 0x000010, "Wrong alignment on AASCharacter");
static_assert(sizeof(AASCharacter) == 0x000630, "Wrong size on AASCharacter");
static_assert(offsetof(AASCharacter, LastTakeHitInfo) == 0x0004E8, "Member 'AASCharacter::LastTakeHitInfo' has a wrong offset!");

// Class ActionSystem.ASCharacterMovementComponent
// 0x0020 (0x0660 - 0x0640)
class UASCharacterMovementComponent final : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_638[0x28];                                     // 0x0638(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearCurveMove();
	void SendAnimCommand(const class FString& Command, bool Force);
	void SetDirectMove(const struct FVector& MoveVelocity, bool bForceMaxSpeed);
	void SetImpulse(const struct FVector& Impulse, bool bVelocityChange);

	struct FVector GetLastNavMoveVelocity() const;
	bool HasAnimTag(class FName Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASCharacterMovementComponent">();
	}
	static class UASCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASCharacterMovementComponent>();
	}
};
static_assert(alignof(UASCharacterMovementComponent) == 0x000010, "Wrong alignment on UASCharacterMovementComponent");
static_assert(sizeof(UASCharacterMovementComponent) == 0x000660, "Wrong size on UASCharacterMovementComponent");

// Class ActionSystem.ASCollisionCapsuleComponent
// 0x0010 (0x0440 - 0x0430)
class UASCollisionCapsuleComponent final : public UCapsuleComponent
{
public:
	uint8                                         Pad_428[0x18];                                     // 0x0428(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAttackBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnAttackEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASCollisionCapsuleComponent">();
	}
	static class UASCollisionCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASCollisionCapsuleComponent>();
	}
};
static_assert(alignof(UASCollisionCapsuleComponent) == 0x000010, "Wrong alignment on UASCollisionCapsuleComponent");
static_assert(sizeof(UASCollisionCapsuleComponent) == 0x000440, "Wrong size on UASCollisionCapsuleComponent");

// Class ActionSystem.ASCollisionComponent
// 0x0010 (0x0440 - 0x0430)
class UASCollisionComponent final : public USphereComponent
{
public:
	uint8                                         Pad_428[0x18];                                     // 0x0428(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAttackBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnAttackEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASCollisionComponent">();
	}
	static class UASCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASCollisionComponent>();
	}
};
static_assert(alignof(UASCollisionComponent) == 0x000010, "Wrong alignment on UASCollisionComponent");
static_assert(sizeof(UASCollisionComponent) == 0x000440, "Wrong size on UASCollisionComponent");

// Class ActionSystem.ASCollisionGroupComponent
// 0x0030 (0x0230 - 0x0200)
class UASCollisionGroupComponent final : public USceneComponent
{
public:
	uint8                                         Pad_200[0x30];                                     // 0x0200(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAttackBeginOverlap(class UPrimitiveComponent* MyComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FHitResult& SweepResult);
	void OnAttackEndOverlap(class UPrimitiveComponent* MyComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp);
	void SetActiveCollision(bool Active);
	void StartAttack(int32 HitCount, float HitInterval);
	void StopAttack();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASCollisionGroupComponent">();
	}
	static class UASCollisionGroupComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASCollisionGroupComponent>();
	}
};
static_assert(alignof(UASCollisionGroupComponent) == 0x000010, "Wrong alignment on UASCollisionGroupComponent");
static_assert(sizeof(UASCollisionGroupComponent) == 0x000230, "Wrong size on UASCollisionGroupComponent");

// Class ActionSystem.ASCollisionInterface
// 0x0000 (0x0028 - 0x0028)
class IASCollisionInterface final : public IInterface
{
public:
	bool OnAttackOverlapCallback(class UPrimitiveComponent* MyComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASCollisionInterface">();
	}
	static class IASCollisionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IASCollisionInterface>();
	}
};
static_assert(alignof(IASCollisionInterface) == 0x000008, "Wrong alignment on IASCollisionInterface");
static_assert(sizeof(IASCollisionInterface) == 0x000028, "Wrong size on IASCollisionInterface");

// Class ActionSystem.ASDamageType
// 0x0018 (0x0058 - 0x0040)
class UASDamageType final : public UDamageType
{
public:
	EDamagePower                                  DamagePower;                                       // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseDirection : 1;                                 // 0x0041(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Direction;                                         // 0x0044(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopTimeAttack;                                 // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopTimeDamage;                                 // 0x0054(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASDamageType">();
	}
	static class UASDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASDamageType>();
	}
};
static_assert(alignof(UASDamageType) == 0x000008, "Wrong alignment on UASDamageType");
static_assert(sizeof(UASDamageType) == 0x000058, "Wrong size on UASDamageType");
static_assert(offsetof(UASDamageType, DamagePower) == 0x000040, "Member 'UASDamageType::DamagePower' has a wrong offset!");
static_assert(offsetof(UASDamageType, Direction) == 0x000044, "Member 'UASDamageType::Direction' has a wrong offset!");
static_assert(offsetof(UASDamageType, HitStopTimeAttack) == 0x000050, "Member 'UASDamageType::HitStopTimeAttack' has a wrong offset!");
static_assert(offsetof(UASDamageType, HitStopTimeDamage) == 0x000054, "Member 'UASDamageType::HitStopTimeDamage' has a wrong offset!");

// Class ActionSystem.ASSMNode
// 0x0028 (0x0050 - 0x0028)
class UASSMNode : public UObject
{
public:
	class FString                                 StateName;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UASSMNode*>                      LinkedTo;                                          // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UASStateMachine*                        MachineAsset;                                      // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASSMNode">();
	}
	static class UASSMNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASSMNode>();
	}
};
static_assert(alignof(UASSMNode) == 0x000008, "Wrong alignment on UASSMNode");
static_assert(sizeof(UASSMNode) == 0x000050, "Wrong size on UASSMNode");
static_assert(offsetof(UASSMNode, StateName) == 0x000028, "Member 'UASSMNode::StateName' has a wrong offset!");
static_assert(offsetof(UASSMNode, LinkedTo) == 0x000038, "Member 'UASSMNode::LinkedTo' has a wrong offset!");
static_assert(offsetof(UASSMNode, MachineAsset) == 0x000048, "Member 'UASSMNode::MachineAsset' has a wrong offset!");

// Class ActionSystem.ASSMStateNode
// 0x0038 (0x0088 - 0x0050)
class UASSMStateNode : public UASSMNode
{
public:
	TArray<class FName>                           Tags;                                              // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAlwaysCanceledCommand : 1;                        // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UASState_Base*                          Custom;                                            // 0x0068(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StateIndex;                                        // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UASSMTransitionNode*>            TransitionList;                                    // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASSMStateNode">();
	}
	static class UASSMStateNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASSMStateNode>();
	}
};
static_assert(alignof(UASSMStateNode) == 0x000008, "Wrong alignment on UASSMStateNode");
static_assert(sizeof(UASSMStateNode) == 0x000088, "Wrong size on UASSMStateNode");
static_assert(offsetof(UASSMStateNode, Tags) == 0x000050, "Member 'UASSMStateNode::Tags' has a wrong offset!");
static_assert(offsetof(UASSMStateNode, Custom) == 0x000068, "Member 'UASSMStateNode::Custom' has a wrong offset!");
static_assert(offsetof(UASSMStateNode, StateIndex) == 0x000070, "Member 'UASSMStateNode::StateIndex' has a wrong offset!");
static_assert(offsetof(UASSMStateNode, TransitionList) == 0x000078, "Member 'UASSMStateNode::TransitionList' has a wrong offset!");

// Class ActionSystem.ASSMState_BlendSpace
// 0x0018 (0x00A0 - 0x0088)
class UASSMState_BlendSpace final : public UASSMStateNode
{
public:
	float                                         PlayRate;                                          // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x008C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BlendSpaceName;                                    // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupIndex;                                        // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimGroupRole                                GroupRole;                                         // 0x009C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASSMState_BlendSpace">();
	}
	static class UASSMState_BlendSpace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASSMState_BlendSpace>();
	}
};
static_assert(alignof(UASSMState_BlendSpace) == 0x000008, "Wrong alignment on UASSMState_BlendSpace");
static_assert(sizeof(UASSMState_BlendSpace) == 0x0000A0, "Wrong size on UASSMState_BlendSpace");
static_assert(offsetof(UASSMState_BlendSpace, PlayRate) == 0x000088, "Member 'UASSMState_BlendSpace::PlayRate' has a wrong offset!");
static_assert(offsetof(UASSMState_BlendSpace, bLoop) == 0x00008C, "Member 'UASSMState_BlendSpace::bLoop' has a wrong offset!");
static_assert(offsetof(UASSMState_BlendSpace, BlendSpaceName) == 0x000090, "Member 'UASSMState_BlendSpace::BlendSpaceName' has a wrong offset!");
static_assert(offsetof(UASSMState_BlendSpace, GroupIndex) == 0x000098, "Member 'UASSMState_BlendSpace::GroupIndex' has a wrong offset!");
static_assert(offsetof(UASSMState_BlendSpace, GroupRole) == 0x00009C, "Member 'UASSMState_BlendSpace::GroupRole' has a wrong offset!");

// Class ActionSystem.ASSMState_Conduit
// 0x0000 (0x0088 - 0x0088)
class UASSMState_Conduit final : public UASSMStateNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASSMState_Conduit">();
	}
	static class UASSMState_Conduit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASSMState_Conduit>();
	}
};
static_assert(alignof(UASSMState_Conduit) == 0x000008, "Wrong alignment on UASSMState_Conduit");
static_assert(sizeof(UASSMState_Conduit) == 0x000088, "Wrong size on UASSMState_Conduit");

// Class ActionSystem.ASSMState_Sequence
// 0x0028 (0x00B0 - 0x0088)
class UASSMState_Sequence final : public UASSMStateNode
{
public:
	float                                         PlayRate;                                          // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x008C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SequenceName;                                      // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupIndex;                                        // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimGroupRole                                GroupRole;                                         // 0x009C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StateMachineResetSecond;                           // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StateMachineResetSecondMargin;                     // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StateMachineResetMontageRateScale;                 // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASSMState_Sequence">();
	}
	static class UASSMState_Sequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASSMState_Sequence>();
	}
};
static_assert(alignof(UASSMState_Sequence) == 0x000008, "Wrong alignment on UASSMState_Sequence");
static_assert(sizeof(UASSMState_Sequence) == 0x0000B0, "Wrong size on UASSMState_Sequence");
static_assert(offsetof(UASSMState_Sequence, PlayRate) == 0x000088, "Member 'UASSMState_Sequence::PlayRate' has a wrong offset!");
static_assert(offsetof(UASSMState_Sequence, bLoop) == 0x00008C, "Member 'UASSMState_Sequence::bLoop' has a wrong offset!");
static_assert(offsetof(UASSMState_Sequence, SequenceName) == 0x000090, "Member 'UASSMState_Sequence::SequenceName' has a wrong offset!");
static_assert(offsetof(UASSMState_Sequence, GroupIndex) == 0x000098, "Member 'UASSMState_Sequence::GroupIndex' has a wrong offset!");
static_assert(offsetof(UASSMState_Sequence, GroupRole) == 0x00009C, "Member 'UASSMState_Sequence::GroupRole' has a wrong offset!");
static_assert(offsetof(UASSMState_Sequence, StateMachineResetSecond) == 0x0000A0, "Member 'UASSMState_Sequence::StateMachineResetSecond' has a wrong offset!");
static_assert(offsetof(UASSMState_Sequence, StateMachineResetSecondMargin) == 0x0000A4, "Member 'UASSMState_Sequence::StateMachineResetSecondMargin' has a wrong offset!");
static_assert(offsetof(UASSMState_Sequence, StateMachineResetMontageRateScale) == 0x0000A8, "Member 'UASSMState_Sequence::StateMachineResetMontageRateScale' has a wrong offset!");

// Class ActionSystem.ASSMState_StateMachine
// 0x0010 (0x0098 - 0x0088)
class UASSMState_StateMachine final : public UASSMStateNode
{
public:
	float                                         PlayRate;                                          // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StateMachineName;                                  // 0x008C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASSMState_StateMachine">();
	}
	static class UASSMState_StateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASSMState_StateMachine>();
	}
};
static_assert(alignof(UASSMState_StateMachine) == 0x000008, "Wrong alignment on UASSMState_StateMachine");
static_assert(sizeof(UASSMState_StateMachine) == 0x000098, "Wrong size on UASSMState_StateMachine");
static_assert(offsetof(UASSMState_StateMachine, PlayRate) == 0x000088, "Member 'UASSMState_StateMachine::PlayRate' has a wrong offset!");
static_assert(offsetof(UASSMState_StateMachine, StateMachineName) == 0x00008C, "Member 'UASSMState_StateMachine::StateMachineName' has a wrong offset!");

// Class ActionSystem.ASSMStateMachineInterface
// 0x0000 (0x0028 - 0x0028)
class IASSMStateMachineInterface final : public IInterface
{
public:
	void AddResetSecondRate();
	bool GetAndUpdateContinuousSameDamageReaction();
	bool IsNeedResetStateMachine(float ElapsedTime, float ResetSecond);
	void UpdatePreviousElapsedTime(float ElapsedTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASSMStateMachineInterface">();
	}
	static class IASSMStateMachineInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IASSMStateMachineInterface>();
	}
};
static_assert(alignof(IASSMStateMachineInterface) == 0x000008, "Wrong alignment on IASSMStateMachineInterface");
static_assert(sizeof(IASSMStateMachineInterface) == 0x000028, "Wrong size on IASSMStateMachineInterface");

// Class ActionSystem.ASSMTransitionNode
// 0x0070 (0x00C0 - 0x0050)
class UASSMTransitionNode final : public UASSMNode
{
public:
	int32                                         PriorityOrder;                                     // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Bidirectional;                                     // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransitionRule                               TransitionRule;                                    // 0x0055(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNotEqual : 1;                                     // 0x0056(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_57[0x1];                                       // 0x0057(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Command;                                           // 0x0058(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 MovementMode;                                      // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CustomMovementMode;                                // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UASTransition_BlueprintBase*            Blueprint;                                         // 0x0070(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UASTransition_Base*                     Custom;                                            // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrossfadeDuration;                                 // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             BlendMode;                                         // 0x0084(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CustomBlendCurve;                                  // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSyncTime : 1;                                     // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTime;                                         // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StartStateName;                                    // 0x0098(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimNotify*                            InterruptNotify;                                   // 0x00A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UASSMStateNode*                         PreviousState;                                     // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UASSMStateNode*                         NextState;                                         // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASSMTransitionNode">();
	}
	static class UASSMTransitionNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASSMTransitionNode>();
	}
};
static_assert(alignof(UASSMTransitionNode) == 0x000008, "Wrong alignment on UASSMTransitionNode");
static_assert(sizeof(UASSMTransitionNode) == 0x0000C0, "Wrong size on UASSMTransitionNode");
static_assert(offsetof(UASSMTransitionNode, PriorityOrder) == 0x000050, "Member 'UASSMTransitionNode::PriorityOrder' has a wrong offset!");
static_assert(offsetof(UASSMTransitionNode, Bidirectional) == 0x000054, "Member 'UASSMTransitionNode::Bidirectional' has a wrong offset!");
static_assert(offsetof(UASSMTransitionNode, TransitionRule) == 0x000055, "Member 'UASSMTransitionNode::TransitionRule' has a wrong offset!");
static_assert(offsetof(UASSMTransitionNode, Command) == 0x000058, "Member 'UASSMTransitionNode::Command' has a wrong offset!");
static_assert(offsetof(UASSMTransitionNode, MovementMode) == 0x000068, "Member 'UASSMTransitionNode::MovementMode' has a wrong offset!");
static_assert(offsetof(UASSMTransitionNode, CustomMovementMode) == 0x000069, "Member 'UASSMTransitionNode::CustomMovementMode' has a wrong offset!");
static_assert(offsetof(UASSMTransitionNode, Blueprint) == 0x000070, "Member 'UASSMTransitionNode::Blueprint' has a wrong offset!");
static_assert(offsetof(UASSMTransitionNode, Custom) == 0x000078, "Member 'UASSMTransitionNode::Custom' has a wrong offset!");
static_assert(offsetof(UASSMTransitionNode, CrossfadeDuration) == 0x000080, "Member 'UASSMTransitionNode::CrossfadeDuration' has a wrong offset!");
static_assert(offsetof(UASSMTransitionNode, BlendMode) == 0x000084, "Member 'UASSMTransitionNode::BlendMode' has a wrong offset!");
static_assert(offsetof(UASSMTransitionNode, CustomBlendCurve) == 0x000088, "Member 'UASSMTransitionNode::CustomBlendCurve' has a wrong offset!");
static_assert(offsetof(UASSMTransitionNode, StartTime) == 0x000094, "Member 'UASSMTransitionNode::StartTime' has a wrong offset!");
static_assert(offsetof(UASSMTransitionNode, StartStateName) == 0x000098, "Member 'UASSMTransitionNode::StartStateName' has a wrong offset!");
static_assert(offsetof(UASSMTransitionNode, InterruptNotify) == 0x0000A8, "Member 'UASSMTransitionNode::InterruptNotify' has a wrong offset!");
static_assert(offsetof(UASSMTransitionNode, PreviousState) == 0x0000B0, "Member 'UASSMTransitionNode::PreviousState' has a wrong offset!");
static_assert(offsetof(UASSMTransitionNode, NextState) == 0x0000B8, "Member 'UASSMTransitionNode::NextState' has a wrong offset!");

// Class ActionSystem.ASSMTransitionNodeInterface
// 0x0000 (0x0028 - 0x0028)
class IASSMTransitionNodeInterface final : public IInterface
{
public:
	void MakeRulesShareable(class UASSMTransitionNode* Caller, TArray<int32>* Remap);
	void PropagateRulesSettings(class UASSMTransitionNode* Caller, int32 SharedRulesIdx);
	bool TransferSharedCustomRules(class UASSMTransitionNode* Caller, class UASTransition_Base* Custom, int32 SharedRulesIdx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASSMTransitionNodeInterface">();
	}
	static class IASSMTransitionNodeInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IASSMTransitionNodeInterface>();
	}
};
static_assert(alignof(IASSMTransitionNodeInterface) == 0x000008, "Wrong alignment on IASSMTransitionNodeInterface");
static_assert(sizeof(IASSMTransitionNodeInterface) == 0x000028, "Wrong size on IASSMTransitionNodeInterface");

// Class ActionSystem.ASState_Base
// 0x0000 (0x0028 - 0x0028)
class UASState_Base : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASState_Base">();
	}
	static class UASState_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASState_Base>();
	}
};
static_assert(alignof(UASState_Base) == 0x000008, "Wrong alignment on UASState_Base");
static_assert(sizeof(UASState_Base) == 0x000028, "Wrong size on UASState_Base");

// Class ActionSystem.ASState_BlueprintBase
// 0x0018 (0x0040 - 0x0028)
class UASState_BlueprintBase : public UASState_Base
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReceiveBeginPlay(class UAnimInstance* AnimInstance);
	void ReceiveTick(float DeltaTime, class UAnimInstance* AnimInstance);
	void SetBlendSpaceInput(const struct FVector& NewBlendInput);
	void SetPlayRate(float NewRate);

	float GetAnimTime() const;
	float GetAnimTimeLength() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASState_BlueprintBase">();
	}
	static class UASState_BlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASState_BlueprintBase>();
	}
};
static_assert(alignof(UASState_BlueprintBase) == 0x000008, "Wrong alignment on UASState_BlueprintBase");
static_assert(sizeof(UASState_BlueprintBase) == 0x000040, "Wrong size on UASState_BlueprintBase");

// Class ActionSystem.ASStateMachine
// 0x0020 (0x0048 - 0x0028)
class UASStateMachine final : public UObject
{
public:
	class UASSMStateNode*                         RootNode;                                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UASSMStateNode*>                 StateTable;                                        // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UASAnimationSet*                        AnimationSetAsset;                                 // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASStateMachine">();
	}
	static class UASStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASStateMachine>();
	}
};
static_assert(alignof(UASStateMachine) == 0x000008, "Wrong alignment on UASStateMachine");
static_assert(sizeof(UASStateMachine) == 0x000048, "Wrong size on UASStateMachine");
static_assert(offsetof(UASStateMachine, RootNode) == 0x000028, "Member 'UASStateMachine::RootNode' has a wrong offset!");
static_assert(offsetof(UASStateMachine, StateTable) == 0x000030, "Member 'UASStateMachine::StateTable' has a wrong offset!");
static_assert(offsetof(UASStateMachine, AnimationSetAsset) == 0x000040, "Member 'UASStateMachine::AnimationSetAsset' has a wrong offset!");

// Class ActionSystem.ASTransition_Base
// 0x0000 (0x0028 - 0x0028)
class UASTransition_Base : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASTransition_Base">();
	}
	static class UASTransition_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASTransition_Base>();
	}
};
static_assert(alignof(UASTransition_Base) == 0x000008, "Wrong alignment on UASTransition_Base");
static_assert(sizeof(UASTransition_Base) == 0x000028, "Wrong size on UASTransition_Base");

// Class ActionSystem.ASTransition_BlueprintBase
// 0x0028 (0x0050 - 0x0028)
class UASTransition_BlueprintBase : public UASTransition_Base
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckCommand(const class FString& Command) const;
	EAnimCommandState CheckCommandState(const class FString& Command) const;
	float GetAnimTime() const;
	float GetAnimTimeLength() const;
	float GetElapsedTime() const;
	bool IsPlayEnd() const;
	bool IsPlayEndForce() const;
	bool ReceiveCanEnter(class UAnimInstance* AnimInstance) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASTransition_BlueprintBase">();
	}
	static class UASTransition_BlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASTransition_BlueprintBase>();
	}
};
static_assert(alignof(UASTransition_BlueprintBase) == 0x000008, "Wrong alignment on UASTransition_BlueprintBase");
static_assert(sizeof(UASTransition_BlueprintBase) == 0x000050, "Wrong size on UASTransition_BlueprintBase");

// Class ActionSystem.ASWeapon
// 0x0028 (0x0258 - 0x0230)
class AASWeapon final : public AActor
{
public:
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UASCollisionGroupComponent*             Collision;                                         // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AASCharacter*                           Character;                                         // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASWeapon">();
	}
	static class AASWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AASWeapon>();
	}
};
static_assert(alignof(AASWeapon) == 0x000008, "Wrong alignment on AASWeapon");
static_assert(sizeof(AASWeapon) == 0x000258, "Wrong size on AASWeapon");
static_assert(offsetof(AASWeapon, Mesh) == 0x000240, "Member 'AASWeapon::Mesh' has a wrong offset!");
static_assert(offsetof(AASWeapon, Collision) == 0x000248, "Member 'AASWeapon::Collision' has a wrong offset!");
static_assert(offsetof(AASWeapon, Character) == 0x000250, "Member 'AASWeapon::Character' has a wrong offset!");

}

