#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ActionSystem

#include "Basic.hpp"

#include "ActionSystem_classes.hpp"
#include "ActionSystem_parameters.hpp"


namespace SDK
{

// Function ActionSystem.ASAnimInstance.AnimNotify_StateChange
// (Native, Public)
// Parameters:
// class UASAnimNotify_StateChange*        Notify                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UASAnimInstance::AnimNotify_StateChange(class UASAnimNotify_StateChange* Notify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASAnimInstance", "AnimNotify_StateChange");

	Params::ASAnimInstance_AnimNotify_StateChange Parms{};

	Parms.Notify = Notify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASAnimInstance.IsHitShift
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UASAnimInstance::IsHitShift()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASAnimInstance", "IsHitShift");

	Params::ASAnimInstance_IsHitShift Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ActionSystem.ASAnimInstance.JumpDamageState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDamageState                            State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UASAnimInstance::JumpDamageState(EDamageState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASAnimInstance", "JumpDamageState");

	Params::ASAnimInstance_JumpDamageState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASAnimInstance.JumpMachineState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MachinName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           StateName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UASAnimInstance::JumpMachineState(const class FString& MachinName, const class FString& StateName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASAnimInstance", "JumpMachineState");

	Params::ASAnimInstance_JumpMachineState Parms{};

	Parms.MachinName = std::move(MachinName);
	Parms.StateName = std::move(StateName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASAnimInstance.ReceiveStateChange
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           PreviousStateName                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NextStateName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UASAnimInstance::ReceiveStateChange(const class FString& PreviousStateName, const class FString& NextStateName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASAnimInstance", "ReceiveStateChange");

	Params::ASAnimInstance_ReceiveStateChange Parms{};

	Parms.PreviousStateName = std::move(PreviousStateName);
	Parms.NextStateName = std::move(NextStateName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ActionSystem.ASAnimInstance.SendCommand
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UASAnimInstance::SendCommand(const class FString& Command, const bool bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASAnimInstance", "SendCommand");

	Params::ASAnimInstance_SendCommand Parms{};

	Parms.Command = std::move(Command);
	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASAnimInstance.SetDynamicSubMachine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           AnimNodeName                                           (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           StateName                                              (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UASStateMachine*                  StateMachineAsset                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UASAnimInstance::SetDynamicSubMachine(const class FString& AnimNodeName, const class FString& StateName, const class UASStateMachine* StateMachineAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASAnimInstance", "SetDynamicSubMachine");

	Params::ASAnimInstance_SetDynamicSubMachine Parms{};

	Parms.AnimNodeName = std::move(AnimNodeName);
	Parms.StateName = std::move(StateName);
	Parms.StateMachineAsset = StateMachineAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASAnimInstance.HasTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Tag                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UASAnimInstance::HasTag(const class FName& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASAnimInstance", "HasTag");

	Params::ASAnimInstance_HasTag Parms{};

	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ActionSystem.ASCharacterBase.JumpMachineState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MachinName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           StateName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AASCharacterBase::JumpMachineState(const class FString& MachinName, const class FString& StateName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacterBase", "JumpMachineState");

	Params::ASCharacterBase_JumpMachineState Parms{};

	Parms.MachinName = std::move(MachinName);
	Parms.StateName = std::move(StateName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCharacterBase.OnRep_ReplicateState
// (Final, Native, Public)

void AASCharacterBase::OnRep_ReplicateState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacterBase", "OnRep_ReplicateState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCharacterBase.ReceiveStateChange
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           PreviousStateName                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NextStateName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AASCharacterBase::ReceiveStateChange(const class FString& PreviousStateName, const class FString& NextStateName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacterBase", "ReceiveStateChange");

	Params::ASCharacterBase_ReceiveStateChange Parms{};

	Parms.PreviousStateName = std::move(PreviousStateName);
	Parms.NextStateName = std::move(NextStateName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ActionSystem.ASCharacterBase.SendAnimCommand
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AASCharacterBase::SendAnimCommand(const class FString& Command, bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacterBase", "SendAnimCommand");

	Params::ASCharacterBase_SendAnimCommand Parms{};

	Parms.Command = std::move(Command);
	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCharacterBase.ServerStateChange
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PreviousState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NextState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AASCharacterBase::ServerStateChange(int32 MachineIndex, int32 PreviousState, int32 NextState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacterBase", "ServerStateChange");

	Params::ASCharacterBase_ServerStateChange Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.PreviousState = PreviousState;
	Parms.NextState = NextState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCharacterBase.GetAnimTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FName> AASCharacterBase::GetAnimTags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacterBase", "GetAnimTags");

	Params::ASCharacterBase_GetAnimTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ActionSystem.ASCharacterBase.HasAnimTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AASCharacterBase::HasAnimTag(class FName Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacterBase", "HasAnimTag");

	Params::ASCharacterBase_HasAnimTag Parms{};

	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ActionSystem.ASCharacter.ClientNotifyHit
// (Net, NetReliable, Native, Event, Protected, NetClient, NetValidate)
// Parameters:
// class AASCharacter*                     OtherCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Impact                                                 (ConstParm, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TSubclassOf<class UASDamageType>        DamageTypeClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ShotDirection                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AASCharacter::ClientNotifyHit(class AASCharacter* OtherCharacter, const struct FHitResult& Impact, TSubclassOf<class UASDamageType> DamageTypeClass, float Damage, const struct FVector_NetQuantizeNormal& ShotDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacter", "ClientNotifyHit");

	Params::ASCharacter_ClientNotifyHit Parms{};

	Parms.OtherCharacter = OtherCharacter;
	Parms.Impact = std::move(Impact);
	Parms.DamageTypeClass = DamageTypeClass;
	Parms.Damage = Damage;
	Parms.ShotDirection = std::move(ShotDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCharacter.ClientTakeDamage
// (Net, NetReliable, Native, Event, Public, NetClient, NetValidate)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageEvent                     DamageEvent                                            (ConstParm, Parm, NativeAccessSpecifierPublic)
// class AController*                      EventInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AASCharacter::ClientTakeDamage(float Damage, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacter", "ClientTakeDamage");

	Params::ASCharacter_ClientTakeDamage Parms{};

	Parms.Damage = Damage;
	Parms.DamageEvent = std::move(DamageEvent);
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCharacter.ClientTakePointDamage
// (Net, NetReliable, Native, Event, Public, NetClient, NetValidate)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPointDamageEvent                DamageEvent                                            (ConstParm, Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AController*                      EventInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AASCharacter::ClientTakePointDamage(float Damage, const struct FPointDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacter", "ClientTakePointDamage");

	Params::ASCharacter_ClientTakePointDamage Parms{};

	Parms.Damage = Damage;
	Parms.DamageEvent = std::move(DamageEvent);
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCharacter.JumpDamageState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDamageState                            State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AASCharacter::JumpDamageState(EDamageState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacter", "JumpDamageState");

	Params::ASCharacter_JumpDamageState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCharacter.OnAttackOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              MyComp                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AASCharacter::OnAttackOverlap(class UPrimitiveComponent* MyComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacter", "OnAttackOverlap");

	Params::ASCharacter_OnAttackOverlap Parms{};

	Parms.MyComp = MyComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ActionSystem.ASCharacter.OnRep_LastTakeHitInfo
// (Final, Native, Public)

void AASCharacter::OnRep_LastTakeHitInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacter", "OnRep_LastTakeHitInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCharacter.ServerNotifyHit
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class AASCharacter*                     OtherCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Impact                                                 (ConstParm, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TSubclassOf<class UASDamageType>        DamageTypeClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ShotDirection                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AASCharacter::ServerNotifyHit(class AASCharacter* OtherCharacter, const struct FHitResult& Impact, TSubclassOf<class UASDamageType> DamageTypeClass, float Damage, const struct FVector_NetQuantizeNormal& ShotDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacter", "ServerNotifyHit");

	Params::ASCharacter_ServerNotifyHit Parms{};

	Parms.OtherCharacter = OtherCharacter;
	Parms.Impact = std::move(Impact);
	Parms.DamageTypeClass = DamageTypeClass;
	Parms.Damage = Damage;
	Parms.ShotDirection = std::move(ShotDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCharacter.ServerTakeDamage
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageEvent                     DamageEvent                                            (ConstParm, Parm, NativeAccessSpecifierPublic)
// class AController*                      EventInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AASCharacter::ServerTakeDamage(float Damage, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacter", "ServerTakeDamage");

	Params::ASCharacter_ServerTakeDamage Parms{};

	Parms.Damage = Damage;
	Parms.DamageEvent = std::move(DamageEvent);
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCharacter.ServerTakePointDamage
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPointDamageEvent                DamageEvent                                            (ConstParm, Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AController*                      EventInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AASCharacter::ServerTakePointDamage(float Damage, const struct FPointDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacter", "ServerTakePointDamage");

	Params::ASCharacter_ServerTakePointDamage Parms{};

	Parms.Damage = Damage;
	Parms.DamageEvent = std::move(DamageEvent);
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCharacterMovementComponent.ClearCurveMove
// (Final, Native, Public, BlueprintCallable)

void UASCharacterMovementComponent::ClearCurveMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacterMovementComponent", "ClearCurveMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCharacterMovementComponent.SendAnimCommand
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UASCharacterMovementComponent::SendAnimCommand(const class FString& Command, bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacterMovementComponent", "SendAnimCommand");

	Params::ASCharacterMovementComponent_SendAnimCommand Parms{};

	Parms.Command = std::move(Command);
	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCharacterMovementComponent.SetDirectMove
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          MoveVelocity                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceMaxSpeed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UASCharacterMovementComponent::SetDirectMove(const struct FVector& MoveVelocity, bool bForceMaxSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacterMovementComponent", "SetDirectMove");

	Params::ASCharacterMovementComponent_SetDirectMove Parms{};

	Parms.MoveVelocity = std::move(MoveVelocity);
	Parms.bForceMaxSpeed = bForceMaxSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCharacterMovementComponent.SetImpulse
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Impulse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVelocityChange                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UASCharacterMovementComponent::SetImpulse(const struct FVector& Impulse, bool bVelocityChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacterMovementComponent", "SetImpulse");

	Params::ASCharacterMovementComponent_SetImpulse Parms{};

	Parms.Impulse = std::move(Impulse);
	Parms.bVelocityChange = bVelocityChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCharacterMovementComponent.GetLastNavMoveVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UASCharacterMovementComponent::GetLastNavMoveVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacterMovementComponent", "GetLastNavMoveVelocity");

	Params::ASCharacterMovementComponent_GetLastNavMoveVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ActionSystem.ASCharacterMovementComponent.HasAnimTag
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UASCharacterMovementComponent::HasAnimTag(class FName Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCharacterMovementComponent", "HasAnimTag");

	Params::ASCharacterMovementComponent_HasAnimTag Parms{};

	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ActionSystem.ASCollisionCapsuleComponent.OnAttackBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UASCollisionCapsuleComponent::OnAttackBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCollisionCapsuleComponent", "OnAttackBeginOverlap");

	Params::ASCollisionCapsuleComponent_OnAttackBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCollisionCapsuleComponent.OnAttackEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UASCollisionCapsuleComponent::OnAttackEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCollisionCapsuleComponent", "OnAttackEndOverlap");

	Params::ASCollisionCapsuleComponent_OnAttackEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCollisionComponent.OnAttackBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UASCollisionComponent::OnAttackBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCollisionComponent", "OnAttackBeginOverlap");

	Params::ASCollisionComponent_OnAttackBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCollisionComponent.OnAttackEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UASCollisionComponent::OnAttackEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCollisionComponent", "OnAttackEndOverlap");

	Params::ASCollisionComponent_OnAttackEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCollisionGroupComponent.OnAttackBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              MyComp                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UASCollisionGroupComponent::OnAttackBeginOverlap(class UPrimitiveComponent* MyComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCollisionGroupComponent", "OnAttackBeginOverlap");

	Params::ASCollisionGroupComponent_OnAttackBeginOverlap Parms{};

	Parms.MyComp = MyComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCollisionGroupComponent.OnAttackEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              MyComp                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UASCollisionGroupComponent::OnAttackEndOverlap(class UPrimitiveComponent* MyComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCollisionGroupComponent", "OnAttackEndOverlap");

	Params::ASCollisionGroupComponent_OnAttackEndOverlap Parms{};

	Parms.MyComp = MyComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCollisionGroupComponent.SetActiveCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UASCollisionGroupComponent::SetActiveCollision(bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCollisionGroupComponent", "SetActiveCollision");

	Params::ASCollisionGroupComponent_SetActiveCollision Parms{};

	Parms.Active = Active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCollisionGroupComponent.StartAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   HitCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HitInterval                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UASCollisionGroupComponent::StartAttack(int32 HitCount, float HitInterval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCollisionGroupComponent", "StartAttack");

	Params::ASCollisionGroupComponent_StartAttack Parms{};

	Parms.HitCount = HitCount;
	Parms.HitInterval = HitInterval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCollisionGroupComponent.StopAttack
// (Final, Native, Public, BlueprintCallable)

void UASCollisionGroupComponent::StopAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCollisionGroupComponent", "StopAttack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASCollisionInterface.OnAttackOverlapCallback
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              MyComp                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IASCollisionInterface::OnAttackOverlapCallback(class UPrimitiveComponent* MyComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASCollisionInterface", "OnAttackOverlapCallback");

	Params::ASCollisionInterface_OnAttackOverlapCallback Parms{};

	Parms.MyComp = MyComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ActionSystem.ASSMStateMachineInterface.AddResetSecondRate
// (Event, Public, BlueprintCallable, BlueprintEvent)

void IASSMStateMachineInterface::AddResetSecondRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASSMStateMachineInterface", "AddResetSecondRate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ActionSystem.ASSMStateMachineInterface.GetAndUpdateContinuousSameDamageReaction
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IASSMStateMachineInterface::GetAndUpdateContinuousSameDamageReaction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASSMStateMachineInterface", "GetAndUpdateContinuousSameDamageReaction");

	Params::ASSMStateMachineInterface_GetAndUpdateContinuousSameDamageReaction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ActionSystem.ASSMStateMachineInterface.IsNeedResetStateMachine
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   ElapsedTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ResetSecond                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IASSMStateMachineInterface::IsNeedResetStateMachine(float ElapsedTime, float ResetSecond)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASSMStateMachineInterface", "IsNeedResetStateMachine");

	Params::ASSMStateMachineInterface_IsNeedResetStateMachine Parms{};

	Parms.ElapsedTime = ElapsedTime;
	Parms.ResetSecond = ResetSecond;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ActionSystem.ASSMStateMachineInterface.UpdatePreviousElapsedTime
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   ElapsedTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IASSMStateMachineInterface::UpdatePreviousElapsedTime(float ElapsedTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASSMStateMachineInterface", "UpdatePreviousElapsedTime");

	Params::ASSMStateMachineInterface_UpdatePreviousElapsedTime Parms{};

	Parms.ElapsedTime = ElapsedTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ActionSystem.ASSMTransitionNodeInterface.MakeRulesShareable
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UASSMTransitionNode*              Caller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           Remap                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IASSMTransitionNodeInterface::MakeRulesShareable(class UASSMTransitionNode* Caller, TArray<int32>* Remap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASSMTransitionNodeInterface", "MakeRulesShareable");

	Params::ASSMTransitionNodeInterface_MakeRulesShareable Parms{};

	Parms.Caller = Caller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Remap != nullptr)
		*Remap = std::move(Parms.Remap);
}


// Function ActionSystem.ASSMTransitionNodeInterface.PropagateRulesSettings
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UASSMTransitionNode*              Caller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SharedRulesIdx                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IASSMTransitionNodeInterface::PropagateRulesSettings(class UASSMTransitionNode* Caller, int32 SharedRulesIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASSMTransitionNodeInterface", "PropagateRulesSettings");

	Params::ASSMTransitionNodeInterface_PropagateRulesSettings Parms{};

	Parms.Caller = Caller;
	Parms.SharedRulesIdx = SharedRulesIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASSMTransitionNodeInterface.TransferSharedCustomRules
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UASSMTransitionNode*              Caller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UASTransition_Base*               Custom                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SharedRulesIdx                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IASSMTransitionNodeInterface::TransferSharedCustomRules(class UASSMTransitionNode* Caller, class UASTransition_Base* Custom, int32 SharedRulesIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASSMTransitionNodeInterface", "TransferSharedCustomRules");

	Params::ASSMTransitionNodeInterface_TransferSharedCustomRules Parms{};

	Parms.Caller = Caller;
	Parms.Custom = Custom;
	Parms.SharedRulesIdx = SharedRulesIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ActionSystem.ASState_BlueprintBase.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UASState_BlueprintBase::ReceiveBeginPlay(class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASState_BlueprintBase", "ReceiveBeginPlay");

	Params::ASState_BlueprintBase_ReceiveBeginPlay Parms{};

	Parms.AnimInstance = AnimInstance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ActionSystem.ASState_BlueprintBase.ReceiveTick
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UASState_BlueprintBase::ReceiveTick(float DeltaTime, class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASState_BlueprintBase", "ReceiveTick");

	Params::ASState_BlueprintBase_ReceiveTick Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.AnimInstance = AnimInstance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ActionSystem.ASState_BlueprintBase.SetBlendSpaceInput
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewBlendInput                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UASState_BlueprintBase::SetBlendSpaceInput(const struct FVector& NewBlendInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASState_BlueprintBase", "SetBlendSpaceInput");

	Params::ASState_BlueprintBase_SetBlendSpaceInput Parms{};

	Parms.NewBlendInput = std::move(NewBlendInput);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASState_BlueprintBase.SetPlayRate
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   NewRate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UASState_BlueprintBase::SetPlayRate(float NewRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASState_BlueprintBase", "SetPlayRate");

	Params::ASState_BlueprintBase_SetPlayRate Parms{};

	Parms.NewRate = NewRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ActionSystem.ASState_BlueprintBase.GetAnimTime
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UASState_BlueprintBase::GetAnimTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASState_BlueprintBase", "GetAnimTime");

	Params::ASState_BlueprintBase_GetAnimTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ActionSystem.ASState_BlueprintBase.GetAnimTimeLength
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UASState_BlueprintBase::GetAnimTimeLength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASState_BlueprintBase", "GetAnimTimeLength");

	Params::ASState_BlueprintBase_GetAnimTimeLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ActionSystem.ASTransition_BlueprintBase.CheckCommand
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UASTransition_BlueprintBase::CheckCommand(const class FString& Command) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASTransition_BlueprintBase", "CheckCommand");

	Params::ASTransition_BlueprintBase_CheckCommand Parms{};

	Parms.Command = std::move(Command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ActionSystem.ASTransition_BlueprintBase.CheckCommandState
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimCommandState                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAnimCommandState UASTransition_BlueprintBase::CheckCommandState(const class FString& Command) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASTransition_BlueprintBase", "CheckCommandState");

	Params::ASTransition_BlueprintBase_CheckCommandState Parms{};

	Parms.Command = std::move(Command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ActionSystem.ASTransition_BlueprintBase.GetAnimTime
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UASTransition_BlueprintBase::GetAnimTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASTransition_BlueprintBase", "GetAnimTime");

	Params::ASTransition_BlueprintBase_GetAnimTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ActionSystem.ASTransition_BlueprintBase.GetAnimTimeLength
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UASTransition_BlueprintBase::GetAnimTimeLength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASTransition_BlueprintBase", "GetAnimTimeLength");

	Params::ASTransition_BlueprintBase_GetAnimTimeLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ActionSystem.ASTransition_BlueprintBase.GetElapsedTime
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UASTransition_BlueprintBase::GetElapsedTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASTransition_BlueprintBase", "GetElapsedTime");

	Params::ASTransition_BlueprintBase_GetElapsedTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ActionSystem.ASTransition_BlueprintBase.IsPlayEnd
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UASTransition_BlueprintBase::IsPlayEnd() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASTransition_BlueprintBase", "IsPlayEnd");

	Params::ASTransition_BlueprintBase_IsPlayEnd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ActionSystem.ASTransition_BlueprintBase.IsPlayEndForce
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UASTransition_BlueprintBase::IsPlayEndForce() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASTransition_BlueprintBase", "IsPlayEndForce");

	Params::ASTransition_BlueprintBase_IsPlayEndForce Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ActionSystem.ASTransition_BlueprintBase.ReceiveCanEnter
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UASTransition_BlueprintBase::ReceiveCanEnter(class UAnimInstance* AnimInstance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASTransition_BlueprintBase", "ReceiveCanEnter");

	Params::ASTransition_BlueprintBase_ReceiveCanEnter Parms{};

	Parms.AnimInstance = AnimInstance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

