#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BattlePrototype

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "BattlePrototype_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "HorizonUI_classes.hpp"
#include "AssetRegistry_structs.hpp"
#include "ActionSystem_classes.hpp"
#include "SlateCore_structs.hpp"
#include "CriWareRuntime_structs.hpp"
#include "CriWareRuntime_classes.hpp"
#include "REDAnimationNode_structs.hpp"
#include "NavigationSystem_classes.hpp"
#include "InputCore_structs.hpp"
#include "LevelSequence_classes.hpp"


namespace SDK
{

// Class BattlePrototype.BattlefieldFenceInterface
// 0x0000 (0x0028 - 0x0028)
class IBattlefieldFenceInterface final : public IInterface
{
public:
	bool GetBattlefieldEnable();
	class USplineComponent* GetBattlefieldSpline();
	void SetBattlefieldEnable(bool Enable);
	void SetBattlefieldVisibleForce(bool Visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlefieldFenceInterface">();
	}
	static class IBattlefieldFenceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBattlefieldFenceInterface>();
	}
};
static_assert(alignof(IBattlefieldFenceInterface) == 0x000008, "Wrong alignment on IBattlefieldFenceInterface");
static_assert(sizeof(IBattlefieldFenceInterface) == 0x000028, "Wrong size on IBattlefieldFenceInterface");

// Class BattlePrototype.REDUserTextWidget
// 0x0018 (0x0248 - 0x0230)
class UREDUserTextWidget : public UUserWidget
{
public:
	uint8                                         Pad_230[0x18];                                     // 0x0230(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyTextFormatFromBase(int32 StringIndex);
	void ChangeFont(int32 StringIndex, class UObject* Font);
	void ChangeRubyProperty(int32 StringIndex, float RubySizeRate, float RubyAdjustY);
	void ClearString(int32 StringIndex);
	void Destroy(int32 StringIndex);
	float GetGeometryScale();
	void GetTextRect(int32 StringIndex, struct FVector4* Rect);
	void GetTextRectLight(int32 StringIndex, struct FVector4* Rect);
	void InitializeString(int32 StringIndex, class UTextBlock* baseTextBlock, int32 TextBlockNum, class UImage* baseIconFont, int32 IconFontNum, bool IsUseRuby);
	void InitializeStringForKeyGuide(int32 StringIndex, int32 GuideNum, class UTextBlock* baseTextBlock, class UImage* baseIconFont);
	void MoveAll(int32 StringIndex, float FMoveX, float FMoveY);
	void ResetString();
	void SetString(int32 StringIndex, const class FString& String, bool bIsAnalyzeTag);
	void SetStringSlotVersion(int32 StringIndex, const class FString& String);

	class UTextBlock* GetBaseTextBlock(int32 StringIndex) const;
	struct FVector2D GetDefaultViewportSize() const;
	class UWidget* GetRootWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDUserTextWidget">();
	}
	static class UREDUserTextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDUserTextWidget>();
	}
};
static_assert(alignof(UREDUserTextWidget) == 0x000008, "Wrong alignment on UREDUserTextWidget");
static_assert(sizeof(UREDUserTextWidget) == 0x000248, "Wrong size on UREDUserTextWidget");

// Class BattlePrototype.UIBase
// 0x0140 (0x0388 - 0x0248)
class UUIBase : public UREDUserTextWidget
{
public:
	bool                                          FlagPlay;                                          // 0x0248(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FlagMouse;                                         // 0x0249(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24A[0x2];                                      // 0x024A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRedMouseArgument                      MouseCallArgument;                                 // 0x024C(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              MouseHitOffsetPos;                                 // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MouseHitOffsetSize;                                // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIMouseHitType                               MouseHitType;                                      // 0x0268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DebugMouseHitDisp;                                 // 0x0269(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26A[0x6];                                      // 0x026A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             M_BaseFocusMouse;                                  // 0x0270(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             M_BaseUnFocusMouse;                                // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             M_BaseDownMouse;                                   // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x1];                                      // 0x02A0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          FlagRemove;                                        // 0x02A1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagNotRemoveHud;                                  // 0x02A2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A3[0x1];                                      // 0x02A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentState;                                      // 0x02A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NextState;                                         // 0x02A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentSubState;                                   // 0x02AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NextSubState;                                      // 0x02B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWidgetAnimation*>               AnimationList;                                     // 0x02B8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PlayIndex;                                         // 0x02C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIViewPrio                                   ViewPortPrio;                                      // 0x02CC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CD[0x3];                                      // 0x02CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIChromaticAberration*                 ChromaticAberration;                               // 0x02D0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UWidget*>                        CA_WorkObject;                                     // 0x02D8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIChromaticAberration*>         ListChromaticAberration;                           // 0x02E8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UREDRetainerBox*>                ListControlRetainerBox;                            // 0x02F8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StateControlRetainerBox;                           // 0x0308(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            ControlWidget;                                     // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              LocalVisibility;                                   // 0x0318(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_319[0x3];                                      // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InputLevel;                                        // 0x031C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseScrollSpeed;                                   // 0x0320(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_324[0x1C];                                     // 0x0324(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class UREDebugLines*                          M_DebugDraw;                                       // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGeometry                              M_MyGeometry;                                      // 0x0348(0x0038)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_380[0x8];                                      // 0x0380(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToSetViewPortPrio(EUIViewPrio Viewprio);
	void AddViewPortPrio();
	void ChangeState(int32 NewState);
	void ChangeStateAllDirect(int32 NewState, int32 NewSubState);
	void ChangeStateDirect(int32 NewState);
	void ChangeSubState(int32 NewSubState);
	bool CheckAnyInput();
	bool CheckCircle();
	bool CheckCircleCore(const struct FVector2D& Position);
	bool CheckEqualName(const class FString& BaseString, const class FString& CheckString);
	void CheckInput(EUIInputButton KeyType, EUIInputType InputType, bool* IsInput);
	bool CheckRectangle();
	bool CheckRectangleCore(const struct FVector2D& Position);
	void Close();
	void CloseDirect();
	void DebugDrawLastAnimation(float DeltaSecond);
	void DebugDrawPlayingAnimation(float DeltaSecond);
	struct FVector2D GetAbsolutePosition();
	void GetAbsoluteScreenOfffset(const struct FVector2D& baseOffset, struct FVector2D* CalcOffset);
	struct FVector2D GetAbsoluteSize();
	void GetIconLimitLU(struct FVector2D* LimitPosition);
	void GetIconLimitRD(struct FVector2D* LimitPosition);
	class FText GetMenuCommonMessage(class UDatabaseManager* PDatabaseManager, class FName Name_0);
	void GetScreenOffset(const struct FVector2D& baseOffset, struct FVector2D* CalcOffset);
	void GetScreenOffsetReverse(const struct FVector2D& baseOffset, struct FVector2D* CalcOffset);
	void GetViewportOffset(const struct FVector2D& AbsolutePosition, struct FVector2D* CalcOffset);
	void InitChromaticAberration();
	void InitControlRetainerBox();
	bool IsLoopSE(class FName LoopSeName);
	void Open();
	void OpenDirect();
	void PlayLoopSe(EUI_SE SeType, class FName LoopSeName);
	class URSAtomComponentBase* PlaySE(EUI_SE SeType);
	class URSAtomComponentBase* PlaySEAtLocation(EUI_SE SeType, const struct FVector& Location);
	void PlayUIAnimation(int32 Index_0, float Speed, bool IsLoop);
	void ProjectWorldToScreen2(const struct FVector& WorldPosition, struct FVector2D* ScreenPosition);
	void RedWidgetDown__DelegateSignature(const struct FRedMouseArgument& Argument, class UUserWidget* PWidget);
	void RedWidgetFocus__DelegateSignature(const struct FRedMouseArgument& Argument, class UUserWidget* PWidget);
	void RedWidgetUnFocus__DelegateSignature(const struct FRedMouseArgument& Argument, class UUserWidget* PWidget);
	void RemoveFromParentRED();
	void SearchControlRetainerBox(class UWidget* Widget);
	void SetAnimation(int32 Index_0, class UWidgetAnimation* Animation);
	void SetAnimationNum(int32 Num);
	void SetControlWidget(class UUserWidget* Widget);
	void SetDebugInvisible(bool IsInvisible);
	void SetFlagUpdateAlways(bool Flag);
	void SetImageFromSprite(class UImage* Image, class UPaperSprite* Sprite);
	void SetInputLevel(int32 InputLevel_0);
	void SetMouseDisable(bool Flag);
	void SetMouseMode(bool Mousemode, int32 InputLevel_0);
	void SetUIAnimationFrame(int32 Index_0, float Time);
	void SetupChromaticAberrationImage(class UPanelWidget* Base);
	void SetupChromaticAberrationRetainerBox(class UPanelWidget* Base);
	void SetViewPortPrio(EUIViewPrio Viewprio);
	void SetVisible(ESlateVisibility Visiblity);
	void StopLoopSe(class FName LoopSeName);
	void StopUIAllAnimation();
	void StopUIAnimation(int32 Index_0);
	void StopUICurrentAnimation();
	void Update(float InDeltaTime);
	void UpdateChromaticAberration();
	void UpdateControlRetainerBox();
	void UpdateState(int32 State, int32 SubState, float DeltaSeconds);
	void UpdateVisible();

	void GetAnimation(int32 Index_0, class UWidgetAnimation** Animation) const;
	void GetCurrentState(int32* State) const;
	void GetFlagUpdateAlways(bool* Flag) const;
	void GetInputLevel(int32* InputLevel_0) const;
	bool GetMouseDisable() const;
	void GetUICurrentAnimationIndex(int32* Index_0) const;
	class FString IntToString(int32 Value, int32 MinLength, int32 MaxLength) const;
	void IsPlaying(bool* IsPlaying_0) const;
	void IsPlayUIAnimation(int32 Index_0, bool* IsPlay) const;
	void IsPlayUIAnyAnimation(bool* IsPlay) const;
	void IsPlayUICurrentAnimation(bool* IsPlay) const;
	void IsStatePlay(bool* IsPlay) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBase">();
	}
	static class UUIBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBase>();
	}
};
static_assert(alignof(UUIBase) == 0x000008, "Wrong alignment on UUIBase");
static_assert(sizeof(UUIBase) == 0x000388, "Wrong size on UUIBase");
static_assert(offsetof(UUIBase, FlagPlay) == 0x000248, "Member 'UUIBase::FlagPlay' has a wrong offset!");
static_assert(offsetof(UUIBase, FlagMouse) == 0x000249, "Member 'UUIBase::FlagMouse' has a wrong offset!");
static_assert(offsetof(UUIBase, MouseCallArgument) == 0x00024C, "Member 'UUIBase::MouseCallArgument' has a wrong offset!");
static_assert(offsetof(UUIBase, MouseHitOffsetPos) == 0x000258, "Member 'UUIBase::MouseHitOffsetPos' has a wrong offset!");
static_assert(offsetof(UUIBase, MouseHitOffsetSize) == 0x000260, "Member 'UUIBase::MouseHitOffsetSize' has a wrong offset!");
static_assert(offsetof(UUIBase, MouseHitType) == 0x000268, "Member 'UUIBase::MouseHitType' has a wrong offset!");
static_assert(offsetof(UUIBase, DebugMouseHitDisp) == 0x000269, "Member 'UUIBase::DebugMouseHitDisp' has a wrong offset!");
static_assert(offsetof(UUIBase, M_BaseFocusMouse) == 0x000270, "Member 'UUIBase::M_BaseFocusMouse' has a wrong offset!");
static_assert(offsetof(UUIBase, M_BaseUnFocusMouse) == 0x000280, "Member 'UUIBase::M_BaseUnFocusMouse' has a wrong offset!");
static_assert(offsetof(UUIBase, M_BaseDownMouse) == 0x000290, "Member 'UUIBase::M_BaseDownMouse' has a wrong offset!");
static_assert(offsetof(UUIBase, FlagRemove) == 0x0002A1, "Member 'UUIBase::FlagRemove' has a wrong offset!");
static_assert(offsetof(UUIBase, FlagNotRemoveHud) == 0x0002A2, "Member 'UUIBase::FlagNotRemoveHud' has a wrong offset!");
static_assert(offsetof(UUIBase, CurrentState) == 0x0002A4, "Member 'UUIBase::CurrentState' has a wrong offset!");
static_assert(offsetof(UUIBase, NextState) == 0x0002A8, "Member 'UUIBase::NextState' has a wrong offset!");
static_assert(offsetof(UUIBase, CurrentSubState) == 0x0002AC, "Member 'UUIBase::CurrentSubState' has a wrong offset!");
static_assert(offsetof(UUIBase, NextSubState) == 0x0002B0, "Member 'UUIBase::NextSubState' has a wrong offset!");
static_assert(offsetof(UUIBase, AnimationList) == 0x0002B8, "Member 'UUIBase::AnimationList' has a wrong offset!");
static_assert(offsetof(UUIBase, PlayIndex) == 0x0002C8, "Member 'UUIBase::PlayIndex' has a wrong offset!");
static_assert(offsetof(UUIBase, ViewPortPrio) == 0x0002CC, "Member 'UUIBase::ViewPortPrio' has a wrong offset!");
static_assert(offsetof(UUIBase, ChromaticAberration) == 0x0002D0, "Member 'UUIBase::ChromaticAberration' has a wrong offset!");
static_assert(offsetof(UUIBase, CA_WorkObject) == 0x0002D8, "Member 'UUIBase::CA_WorkObject' has a wrong offset!");
static_assert(offsetof(UUIBase, ListChromaticAberration) == 0x0002E8, "Member 'UUIBase::ListChromaticAberration' has a wrong offset!");
static_assert(offsetof(UUIBase, ListControlRetainerBox) == 0x0002F8, "Member 'UUIBase::ListControlRetainerBox' has a wrong offset!");
static_assert(offsetof(UUIBase, StateControlRetainerBox) == 0x000308, "Member 'UUIBase::StateControlRetainerBox' has a wrong offset!");
static_assert(offsetof(UUIBase, ControlWidget) == 0x000310, "Member 'UUIBase::ControlWidget' has a wrong offset!");
static_assert(offsetof(UUIBase, LocalVisibility) == 0x000318, "Member 'UUIBase::LocalVisibility' has a wrong offset!");
static_assert(offsetof(UUIBase, InputLevel) == 0x00031C, "Member 'UUIBase::InputLevel' has a wrong offset!");
static_assert(offsetof(UUIBase, BaseScrollSpeed) == 0x000320, "Member 'UUIBase::BaseScrollSpeed' has a wrong offset!");
static_assert(offsetof(UUIBase, M_DebugDraw) == 0x000340, "Member 'UUIBase::M_DebugDraw' has a wrong offset!");
static_assert(offsetof(UUIBase, M_MyGeometry) == 0x000348, "Member 'UUIBase::M_MyGeometry' has a wrong offset!");

// Class BattlePrototype.UIWorldMap
// 0x0010 (0x0398 - 0x0388)
class UUIWorldMap : public UUIBase
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFlagOpenDirect;                                   // 0x0390(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_391[0x7];                                      // 0x0391(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearCursorMemory();
	void GetCurrentAreaID(int32* AreaId);
	void GetCurrentLocationID(int32* LocationId);
	void GetCurrentLocationName(class FString* Name_0);
	void GetCurrentPortalID(int32* PortalID);
	void GetCurrentPortalName(class FName* Name_0);
	void GetLocationName(int32 Index_0, class FString* Name_0);
	void GetPortalName(int32 Index_0, class FName* Name_0);
	void InitializeScrollBox(class UREDScrollBox* ScrollBox);
	bool IsChange();
	bool IsDecide();
	void SetDebugUnlockFlag(bool UnlockFlag);
	void UpdateWorldMapMouseFocus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWorldMap">();
	}
	static class UUIWorldMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWorldMap>();
	}
};
static_assert(alignof(UUIWorldMap) == 0x000008, "Wrong alignment on UUIWorldMap");
static_assert(sizeof(UUIWorldMap) == 0x000398, "Wrong size on UUIWorldMap");
static_assert(offsetof(UUIWorldMap, bFlagOpenDirect) == 0x000390, "Member 'UUIWorldMap::bFlagOpenDirect' has a wrong offset!");

// Class BattlePrototype.BP_SM_MapModel_Base
// 0x00A8 (0x02E8 - 0x0240)
class ABP_SM_MapModel_Base : public AStaticMeshActor
{
public:
	bool                                          IsDetaileMap;                                      // 0x0240(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsScale;                                           // 0x0241(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_242[0x2];                                      // 0x0242(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Playerrate;                                        // 0x0244(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimapGradationValue;                             // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapIconScaleRate;                                  // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapIconDetail_ZOffset;                             // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimapOnlyIconGradationValue;                     // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MinimapOnlyIconGradationValueFlag;                 // 0x0258(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               M_MaterialDynamicMinimap;                          // 0x0260(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               M_MaterialDynamicDetail;                           // 0x0268(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           M_SubMapData;                                      // 0x0270(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIMapFloorAdjustData>          PGAdjuster;                                        // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_pgAdjusterFlag;                                  // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 PgHeightData;                                      // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_pgIconHeightFlag;                                // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isCenterOffsetProc;                              // 0x02B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B2[0x6];                                      // 0x02B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIDetaileMapSubAreaCenterPosition> M_AreaCenterPos;                                   // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_FloorWidthDataCheck;                             // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_FloorWidthIndex;                                 // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 M_FloorWidthData;                                  // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalcMaterialUpDateParam(float RateHeight, float Width);
	struct FVector GetAreaCenterPos();
	TArray<struct FUIDetaileMapSubAreaCenterPosition> GetAreaCenterPosArray();
	class UCapsuleComponent* GetCollisitonData();
	float GetDirectionRotate();
	TArray<struct FUIDetaileMapFloorData> GetFloorData();
	int32 GetFloorIndextoGameWidth();
	float GetFloorIndextoGameWidthData(int32 Floorindex);
	bool GetFloorIndextoGameWidthFlag();
	int32 GetFloorIndextoGameWidthNum();
	TArray<struct FUIMapFloorAdjustData> GetFloorPGAdjuster();
	float GetMapIconDetail_ZOffset();
	float GetMapIconScaleRate();
	float GetMinimapGradationValue();
	float GetMinimapOnlyIconGradationValue();
	TArray<float> GetPgIconHeightFlag();
	float GetZoomMax();
	float GetZoomMin();
	bool IsAdjusterFlag();
	bool IsBrainField();
	bool IsCenterOffsetProc();
	bool IsMinimapOnlyIconGradationValue();
	bool IsPgIconHeightFlag();
	bool MaterialUpdate();
	void SetBrainField(bool Flag);
	void SetDetaileMap(bool DetaileMap);
	bool SetFloorIndex(int32 Floorindex);
	void SetFloorIndextoGame(int32 Floorindex);
	void SetFloorPGAdjuster(const TArray<struct FUIMapFloorAdjustData>& Update);
	void SetGradationValue(float Gradation);
	void SetPersSwitch(bool Pers);
	void SetPlayerRate(float Playerrate_0);
	void SetScale(bool Scale);
	void SetSubModelVisible(class FName SubName, bool Flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BP_SM_MapModel_Base">();
	}
	static class ABP_SM_MapModel_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABP_SM_MapModel_Base>();
	}
};
static_assert(alignof(ABP_SM_MapModel_Base) == 0x000008, "Wrong alignment on ABP_SM_MapModel_Base");
static_assert(sizeof(ABP_SM_MapModel_Base) == 0x0002E8, "Wrong size on ABP_SM_MapModel_Base");
static_assert(offsetof(ABP_SM_MapModel_Base, IsDetaileMap) == 0x000240, "Member 'ABP_SM_MapModel_Base::IsDetaileMap' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, IsScale) == 0x000241, "Member 'ABP_SM_MapModel_Base::IsScale' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, Playerrate) == 0x000244, "Member 'ABP_SM_MapModel_Base::Playerrate' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, MinimapGradationValue) == 0x000248, "Member 'ABP_SM_MapModel_Base::MinimapGradationValue' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, MapIconScaleRate) == 0x00024C, "Member 'ABP_SM_MapModel_Base::MapIconScaleRate' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, MapIconDetail_ZOffset) == 0x000250, "Member 'ABP_SM_MapModel_Base::MapIconDetail_ZOffset' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, MinimapOnlyIconGradationValue) == 0x000254, "Member 'ABP_SM_MapModel_Base::MinimapOnlyIconGradationValue' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, MinimapOnlyIconGradationValueFlag) == 0x000258, "Member 'ABP_SM_MapModel_Base::MinimapOnlyIconGradationValueFlag' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_MaterialDynamicMinimap) == 0x000260, "Member 'ABP_SM_MapModel_Base::M_MaterialDynamicMinimap' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_MaterialDynamicDetail) == 0x000268, "Member 'ABP_SM_MapModel_Base::M_MaterialDynamicDetail' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_SubMapData) == 0x000270, "Member 'ABP_SM_MapModel_Base::M_SubMapData' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, PGAdjuster) == 0x000288, "Member 'ABP_SM_MapModel_Base::PGAdjuster' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_pgAdjusterFlag) == 0x000298, "Member 'ABP_SM_MapModel_Base::M_pgAdjusterFlag' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, PgHeightData) == 0x0002A0, "Member 'ABP_SM_MapModel_Base::PgHeightData' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_pgIconHeightFlag) == 0x0002B0, "Member 'ABP_SM_MapModel_Base::M_pgIconHeightFlag' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_isCenterOffsetProc) == 0x0002B1, "Member 'ABP_SM_MapModel_Base::M_isCenterOffsetProc' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_AreaCenterPos) == 0x0002B8, "Member 'ABP_SM_MapModel_Base::M_AreaCenterPos' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_FloorWidthDataCheck) == 0x0002C8, "Member 'ABP_SM_MapModel_Base::M_FloorWidthDataCheck' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_FloorWidthIndex) == 0x0002CC, "Member 'ABP_SM_MapModel_Base::M_FloorWidthIndex' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_FloorWidthData) == 0x0002D0, "Member 'ABP_SM_MapModel_Base::M_FloorWidthData' has a wrong offset!");

// Class BattlePrototype.RSActorSystemBase
// 0x0000 (0x0230 - 0x0230)
class ARSActorSystemBase : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorSystemBase">();
	}
	static class ARSActorSystemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSActorSystemBase>();
	}
};
static_assert(alignof(ARSActorSystemBase) == 0x000008, "Wrong alignment on ARSActorSystemBase");
static_assert(sizeof(ARSActorSystemBase) == 0x000230, "Wrong size on ARSActorSystemBase");

// Class BattlePrototype.BattlefieldManager
// 0x00E0 (0x0310 - 0x0230)
class ABattlefieldManager : public ARSActorSystemBase
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchBattleFieldBegin;                          // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchBattleFieldEnd;                            // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchBattleFieldRushEnd;                        // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FString, struct FBattlefieldInfo>  CurrentBFInfos;                                    // 0x0268(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         FenceLotterySeed;                                  // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandomStream                          RandomStream;                                      // 0x02BC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsActiveEvent;                                     // 0x02C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C5[0x3];                                      // 0x02C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AMakeEventActor>            MakeEventActorClass;                               // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMakeEventActor*                        MakeEventActor;                                    // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         AllFenceActors;                                    // 0x02E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         AllTriggerActors;                                  // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BroadcastBattlefieldRushEnd(int32 GroupID, int32 SubGroupID);
	bool EndAllBattlefieldForce();
	bool EndBattlefield(int32 BFGroupID);
	bool EndBattlefieldForce(int32 BFGroupID);
	bool EndEventBattlefield(int32 BFGroupID);
	void FinalizeAtStartArea();
	void GetBattlefieldInfo(int32 BFGroupID, struct FBattlefieldInfo* BFInfo, bool* IsExist);
	class AActor* GetBfFence(int32 GroupID);
	TArray<class AActor*> GetBfFenceAll(int32 GroupID);
	void GetBfFenceStatus(int32 GroupID, bool* Exist, bool* IsVisible);
	bool HaveDestroyedBattlefield(int32 BFGroupID, const class FString& TargetName);
	void InitializeAtStartArea();
	bool InitializeAtStartBattlefield(const struct FBattlefieldInfo& CurrentBFInfo);
	bool IsAnyFenceEnabled();
	bool IsBattlefieldWillAppear(int32 GroupID, float FenceBattleRate, const class FString& SeedString, const class FString& TargetName);
	bool IsExistBattlefieldEnemies(int32 BFGroupID, int32 SubGroupID, int32* FirstSubGroup);
	bool IsExistBattlefieldEnemiesStrictly(int32 BFGroupID, int32 SubGroupID);
	bool IsFenceEnabled(int32 GroupID);
	bool IsInFence(const struct FVector& Pos, int32 GroupID);
	bool IsInSplineLoop(const struct FVector& Pos, class USplineComponent* Spline);
	bool IsInSplineLoopDetail(const struct FVector& Pos, class USplineComponent* Spline);
	bool IsPlayerInFence(int32 GroupID);
	bool IsStartBattlefield(int32 BFGroupID);
	bool OnLoad_SaveData();
	bool OnSave_SaveData();
	bool OverwriteTmpBfInfo(int32 GroupID, const class FString& TriggerName);
	bool RepopBattlefieldEnemy(int32 BFGroupID);
	bool RepopBattlefieldInfos(int32 LocationId, int32 AreaId, const class FString& SeedString);
	bool ResetFenceRandomSeed();
	bool SetBattlefieldInfo(int32 BFGroupID, const struct FBattlefieldInfo& BFInfo);
	bool SetCurrentBattlefieldInfos(const TMap<class FString, struct FBattlefieldInfo>& Infos);
	void SetCurrentLocationAndArea(int32 LocationId, int32 AreaId);
	void SetEnableEnemyOutField(bool Enable, int32 BFGroupID);
	bool SetFenceEnable(int32 FenceID, bool Enable);
	bool SetFenceEnableForce(int32 FenceID, bool Enable);
	bool StartBattlefield(EBattlefieldEventType EventType, int32 BFGroupID, int32 SubGroupID, const TArray<struct FBattlefieldTutorialInfo>& AdditionalTutorialInfo, TSubclassOf<class AMakeEventActor> MakeEventActorClass_0, int32 TutorialGroupID, int32 TutorialSubGroupID, float FenceBattleRate, const class FString& SeedString, bool IsOnceBattle);
	bool StartEventBattlefield(int32 BFGroupID, int32 SubGroupID);
	bool StartEventInBattleField(TSubclassOf<class AMakeEventActor> MakeEventActorClass_0);
	bool StartWipeoutBattlefield(int32 BFGroupID);
	void UpdateAtStartArea();

	const struct FBattlefieldInfo GetCurrentBattlefieldInfo(bool* Exist) const;
	bool IsCharacterInBattleField(const struct FBattlefieldInfo& InInfo, class ARSCharacterBase* InCharacter) const;
	bool IsCharacterInCurrentBattleField(class ARSCharacterBase* InCharacter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlefieldManager">();
	}
	static class ABattlefieldManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattlefieldManager>();
	}
};
static_assert(alignof(ABattlefieldManager) == 0x000008, "Wrong alignment on ABattlefieldManager");
static_assert(sizeof(ABattlefieldManager) == 0x000310, "Wrong size on ABattlefieldManager");
static_assert(offsetof(ABattlefieldManager, DispatchBattleFieldBegin) == 0x000238, "Member 'ABattlefieldManager::DispatchBattleFieldBegin' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, DispatchBattleFieldEnd) == 0x000248, "Member 'ABattlefieldManager::DispatchBattleFieldEnd' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, DispatchBattleFieldRushEnd) == 0x000258, "Member 'ABattlefieldManager::DispatchBattleFieldRushEnd' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, CurrentBFInfos) == 0x000268, "Member 'ABattlefieldManager::CurrentBFInfos' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, FenceLotterySeed) == 0x0002B8, "Member 'ABattlefieldManager::FenceLotterySeed' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, RandomStream) == 0x0002BC, "Member 'ABattlefieldManager::RandomStream' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, IsActiveEvent) == 0x0002C4, "Member 'ABattlefieldManager::IsActiveEvent' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, MakeEventActorClass) == 0x0002C8, "Member 'ABattlefieldManager::MakeEventActorClass' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, MakeEventActor) == 0x0002D0, "Member 'ABattlefieldManager::MakeEventActor' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, AllFenceActors) == 0x0002E0, "Member 'ABattlefieldManager::AllFenceActors' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, AllTriggerActors) == 0x0002F8, "Member 'ABattlefieldManager::AllTriggerActors' has a wrong offset!");

// Class BattlePrototype.RSAsyncTaskActorComponent
// 0x0010 (0x00D0 - 0x00C0)
class URSAsyncTaskActorComponent : public UActorComponent
{
public:
	uint8                                         Pad_C0[0xA];                                       // 0x00C0(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugSyncExecFlag;                                // 0x00CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB[0x5];                                       // 0x00CB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetExecAsyncTask(bool bExec);

	bool IsDoneAsyncTask() const;
	bool IsIdleAsyncTask() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAsyncTaskActorComponent">();
	}
	static class URSAsyncTaskActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAsyncTaskActorComponent>();
	}
};
static_assert(alignof(URSAsyncTaskActorComponent) == 0x000008, "Wrong alignment on URSAsyncTaskActorComponent");
static_assert(sizeof(URSAsyncTaskActorComponent) == 0x0000D0, "Wrong size on URSAsyncTaskActorComponent");
static_assert(offsetof(URSAsyncTaskActorComponent, bDebugSyncExecFlag) == 0x0000CA, "Member 'URSAsyncTaskActorComponent::bDebugSyncExecFlag' has a wrong offset!");

// Class BattlePrototype.PlayerCameraComponent
// 0x13E8 (0x14B8 - 0x00D0)
class UPlayerCameraComponent : public URSAsyncTaskActorComponent
{
public:
	TWeakObjectPtr<class UUserParamManager>       PUserParamManager;                                 // 0x00D0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDeltaSecond;                                      // 0x00D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaleOwner;                                        // 0x00DC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaleOwnerCheck;                                   // 0x00DD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerCameraMode                             CameraMode;                                        // 0x00DE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerCameraLookAtMode                       LookAtMode;                                        // 0x00DF(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACameraActor*                           PCameraActor;                                      // 0x00E0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  PRootActor;                                        // 0x00E8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      PRootActorCapsule;                                 // 0x00F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootActorCapsuleHeight;                            // 0x00F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerScriptComponent*                 PRootActorPlayerScript;                            // 0x0100(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VRootActorPos;                                     // 0x0108(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VRootActorMove;                                    // 0x0114(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckRootPosType;                                 // 0x0120(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckRootPosMidCheck;                             // 0x0121(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_122[0x2];                                      // 0x0122(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FAspectRatio;                                      // 0x0124(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAspectRateVt;                                     // 0x0128(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAspectRateHz;                                     // 0x012C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DtActionParameter;                                 // 0x0130(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWorkPosPlayer;                                    // 0x0138(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VWorkPosPlayer;                                    // 0x013C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWorkPosRemote;                                    // 0x0148(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VWorkPosRemote;                                    // 0x014C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActionResetApply;                                 // 0x0158(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FActionResetLerpTime;                              // 0x015C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FActionResetLerpTimer;                             // 0x0160(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FActionResetKeepTime;                              // 0x0164(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FActionResetKeepTimer;                             // 0x0168(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FActionResetLerpAngleStt;                          // 0x016C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FActionResetLerpAngleEnd;                          // 0x0170(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintActionReset;                            // 0x0174(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovementDelay;                                    // 0x0175(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTemporaryCameraEnable;                            // 0x0176(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_177[0x1];                                      // 0x0177(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TemporaryCameraRefName;                            // 0x0178(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerCameraActionPriority                   TemporaryCameraPriority;                           // 0x0188(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTemporaryCameraApply;                             // 0x0189(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTemporaryRootOffsetApply;                         // 0x018A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTemporaryRootOffsetNoRotate;                      // 0x018B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TemporaryRootOffset;                               // 0x018C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTemporaryDistanceOffsetApply;                     // 0x0198(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TemporaryDistanceOffset;                           // 0x019C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTemporaryFovApply;                                // 0x01A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TemporaryFov;                                      // 0x01A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TemporaryLockOnRate;                               // 0x01A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TemporaryOptionSkipInput;                          // 0x01AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TemporaryOptionSkipReturn;                         // 0x01B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TemporaryOptionSkipKeepAngle;                      // 0x01B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8[0x3D];                                     // 0x01B8(0x003D)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugTemporaryUseNew;                             // 0x01F5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintTemporary;                              // 0x01F6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistEnable;                                // 0x01F7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistSkip;                                  // 0x01F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistAsyncRequestPrevProc;                  // 0x01F9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistAsyncRequestTaskProc;                  // 0x01FA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistAsyncRequestTaskDone;                  // 0x01FB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlopeAssistCheckNum;                               // 0x01FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistCheckInterval;                          // 0x0200(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistCheckIntervalAngle;                     // 0x0204(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistCheckAngleVtMax;                        // 0x0208(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistCheckAngleVtStt;                        // 0x020C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistCheckAngleVtEnd;                        // 0x0210(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistCheckAngleHz;                           // 0x0214(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VSlopeAssistMoveDirection;                         // 0x0218(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VSlopeAssistMoveDirectionHz;                       // 0x0224(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistSkipMoveDir;                           // 0x0230(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistLerpApply;                             // 0x0231(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_232[0x2];                                      // 0x0232(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlopeAssistLerpRate;                               // 0x0234(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VSlopeAssistLerpVector;                            // 0x0238(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistLerpAngleVt;                            // 0x0244(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistDelayTime;                              // 0x0248(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistDelayTimer;                             // 0x024C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistCheckBgEnable;                         // 0x0250(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SlopeAssistCheckBgOffset;                          // 0x0254(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistFixAngleEnable;                        // 0x0260(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlopeAssistFixAngleInterval;                       // 0x0264(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistFixAngleRange;                          // 0x0268(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistSpeedLerpEnable;                       // 0x026C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D[0x3];                                      // 0x026D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlopeAssistSpeedLerpMin;                           // 0x0270(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistSpeedLerpMax;                           // 0x0274(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistSpeedLerpRateMax;                       // 0x0278(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistSpeedLerpRate;                          // 0x027C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 SlopeAssistResultAngleList;                        // 0x0280(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0xD0];                                     // 0x0290(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugSlopeAssistSyncApply;                        // 0x0360(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintSlopeAssist;                            // 0x0361(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawSlopeAssistVector;                       // 0x0362(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawSlopeAssistCheckPoint;                   // 0x0363(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawSlopeAssistCheckHit;                     // 0x0364(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_365[0x33];                                     // 0x0365(0x0033)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugPrintDistance;                               // 0x0398(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugTraceHit;                                    // 0x0399(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputEnable;                                      // 0x039A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39B[0x1];                                      // 0x039B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FInputLtX;                                         // 0x039C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FInputLtY;                                         // 0x03A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FInputRtX;                                         // 0x03A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FInputRtY;                                         // 0x03A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputLt;                                          // 0x03AC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputRt;                                          // 0x03AD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputUp;                                          // 0x03AE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputDn;                                          // 0x03AF(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputAngle;                                       // 0x03B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnCheckEnable;                                  // 0x03B1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B2[0x2];                                      // 0x03B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VTurnCheckOffsetUpStt;                             // 0x03B4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VTurnCheckOffsetUpEnd;                             // 0x03C0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VTurnCheckOffsetDnStt;                             // 0x03CC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VTurnCheckOffsetDnEnd;                             // 0x03D8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VTurnCheckOffsetLtStt;                             // 0x03E4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VTurnCheckOffsetLtEnd;                             // 0x03F0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VTurnCheckOffsetRtStt;                             // 0x03FC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VTurnCheckOffsetRtEnd;                             // 0x0408(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnCheckReturnEnable;                            // 0x0414(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_415[0x3];                                      // 0x0415(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FTurnCheckReturnTime;                              // 0x0418(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41C[0x84];                                     // 0x041C(0x0084)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugTurnCheckFlag1;                              // 0x04A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugTurnCheckDrawCt;                             // 0x04A1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugTurnCheckDrawCtRay;                          // 0x04A2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A3[0x1];                                      // 0x04A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FDefaultFov;                                       // 0x04A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VDefaultOffset;                                    // 0x04A8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VDefaultOffsetWall;                                // 0x04B4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDefaultAngleVt;                                   // 0x04C0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDefaultAngleHz;                                   // 0x04C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDefaultDistance;                                  // 0x04C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDefaultDistanceMin;                               // 0x04CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FCurrentFov;                                       // 0x04D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FCurrentAngleVt;                                   // 0x04D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FCurrentAngleHz;                                   // 0x04D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FCurrentDistance;                                  // 0x04DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VCurrentRoot;                                      // 0x04E0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VCurrentPos;                                       // 0x04EC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VCurrentLookAt;                                    // 0x04F8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VCurrentDir;                                       // 0x0504(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RCurrentRot;                                       // 0x0510(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FDestinationAngleVt;                               // 0x051C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDestinationAngleHz;                               // 0x0520(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDestinationDistance;                              // 0x0524(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VDestinationRoot;                                  // 0x0528(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VDestinationPos;                                   // 0x0534(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VDestinationDir;                                   // 0x0540(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RDestinationRot;                                   // 0x054C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawDestinationRootList;                     // 0x0558(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattleOffsetEnable;                               // 0x0559(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattleOffset;                                     // 0x055A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattleOffsetLerp;                                 // 0x055B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattleOffsetLerpSign;                             // 0x055C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55D[0x3];                                      // 0x055D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FBattleOffsetTime;                                 // 0x0560(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_564[0x4];                                      // 0x0564(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PBattleOffsetLerpCurve;                            // 0x0568(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FBattleOffsetTimer;                                // 0x0570(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FBattleOffsetLerpRate;                             // 0x0574(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FBattleOffsetDistanceLerp;                         // 0x0578(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VBattleOffsetRootPosLerp;                          // 0x057C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FBattleOffsetDistance;                             // 0x0588(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VBattleOffsetRootPos;                              // 0x058C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintBattleOffset;                           // 0x0598(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockRootPosEnable;                                // 0x0599(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockRootPosSkip;                                  // 0x059A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59B[0x1];                                      // 0x059B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FRestoreRootPosLerpRate;                           // 0x059C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockRootPosDistance;                              // 0x05A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRestoreRootPosDistance;                           // 0x05A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VPrevRootPos;                                      // 0x05A8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintLockRootPos;                            // 0x05B4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B5[0x3];                                      // 0x05B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VPlayerInputMove;                                  // 0x05B8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootLerpEnable;                                   // 0x05C4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C5[0x3];                                      // 0x05C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FRootLerpValueDefault;                             // 0x05C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpValueAction;                              // 0x05CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpValue;                                    // 0x05D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpValueVt;                                  // 0x05D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpDistanceDefault;                          // 0x05D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpDistanceAction;                           // 0x05DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpDistance;                                 // 0x05E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpDistanceWork;                             // 0x05E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpDistanceMin;                              // 0x05E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpDistanceTarget;                           // 0x05EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpDistanceMove;                             // 0x05F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootLerpActionLerp;                               // 0x05F4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F5[0x3];                                      // 0x05F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RootLerpActionRefName;                             // 0x05F8(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerCameraActionPriority                   RootLerpActionPriority;                            // 0x0608(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_609[0x3];                                      // 0x0609(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FRootLerpActionLerpRate;                           // 0x060C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_610[0x14];                                     // 0x0610(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRootLerpAngleEnable;                              // 0x0624(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_625[0x3];                                      // 0x0625(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PRootLerpDirCurve;                                 // 0x0628(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpDirLerpRate;                              // 0x0630(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpDirLerpRateMin;                           // 0x0634(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpMoveLerpValue;                            // 0x0638(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpMoveLerpRate;                             // 0x063C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpMoveLerpRateMin;                          // 0x0640(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpAngleLerpRate;                            // 0x0644(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpAngleRate;                                // 0x0648(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootLerpCamDistEnable;                            // 0x064C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64D[0x3];                                      // 0x064D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FRootLerpCamDistRate;                              // 0x0650(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintRootLerp;                               // 0x0654(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintRootLerpAction;                         // 0x0655(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_656[0x2];                                      // 0x0656(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FSpinSpeedMaxHz;                                   // 0x0658(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinAccelHz;                                      // 0x065C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinDecelHz;                                      // 0x0660(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinDirectionHz;                                  // 0x0664(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinSpeedHz;                                      // 0x0668(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinInputHz;                                      // 0x066C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinMoveInputHz;                                  // 0x0670(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinMoveRateHz;                                   // 0x0674(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinMoveDecelHz;                                  // 0x0678(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinMoveSpeedHz;                                  // 0x067C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinAngleMin;                                     // 0x0680(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinAngleMax;                                     // 0x0684(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinSpeedMaxVt;                                   // 0x0688(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinAccelVt;                                      // 0x068C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinDecelVt;                                      // 0x0690(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinDirectionVt;                                  // 0x0694(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinSpeedVt;                                      // 0x0698(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinInputVt;                                      // 0x069C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinMoveInputVt;                                  // 0x06A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinMoveAngleMinVt;                               // 0x06A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinMoveAngleMaxVt;                               // 0x06A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAngleVtDistEnable;                                // 0x06AC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6AD[0x3];                                      // 0x06AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FAngleVtDistRate;                                  // 0x06B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B4[0x4];                                      // 0x06B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PAngleVtDistLerpCurve;                             // 0x06B8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAngleVtRootEnable;                                // 0x06C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C1[0x3];                                      // 0x06C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FAngleVtRootRate;                                  // 0x06C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VAngleVtRootOffset;                                // 0x06C8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D4[0x4];                                      // 0x06D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PAngleVtRootLerpCurve;                             // 0x06D8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnApply;                                      // 0x06E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E1[0x3];                                      // 0x06E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  PLockOnActor;                                      // 0x06E4(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LockOnOffset;                                      // 0x06EC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnAngleLimitPly;                               // 0x06F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnAngleLimitCam;                               // 0x06FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnAngleUp;                                    // 0x0700(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnAngleDn;                                    // 0x0704(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnAngleLt;                                    // 0x0708(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnAngleRt;                                    // 0x070C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugNoLerpVtAngle;                               // 0x0710(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_711[0x3];                                      // 0x0711(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VLockOnRootPly;                                    // 0x0714(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VLockOnRootEnm;                                    // 0x0720(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VLockOnLookAt;                                     // 0x072C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnRoot;                                       // 0x0738(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_739[0x3];                                      // 0x0739(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VLockOnRoot;                                       // 0x073C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLookAtDistanceOffset;                             // 0x0748(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintLogLockOn;                              // 0x074C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnLerp;                                       // 0x074D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74E[0x2];                                      // 0x074E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FLockOnLerpTime;                                   // 0x0750(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnLerpTimeSign;                               // 0x0754(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PLockOnLerpCurve;                                  // 0x0758(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnLerpTimer;                                  // 0x0760(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnLerpRate;                                   // 0x0764(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnLerpAngleVtEnable;                          // 0x0768(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnLerpAngleVtApply;                           // 0x0769(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76A[0x2];                                      // 0x076A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FLockOnLerpAngleVtStt;                             // 0x076C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnLerpAngleVtEnd;                             // 0x0770(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnLerpAngleVtEaseBlend;                       // 0x0774(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintLockOnLerp;                             // 0x0778(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_779[0x3];                                      // 0x0779(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  PLookAtObject;                                     // 0x077C(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnLookAtObj;                                  // 0x0784(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnObjLerp;                                    // 0x0785(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_786[0x2];                                      // 0x0786(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FLockOnObjLerpRateStt;                             // 0x0788(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnObjLerpRate;                                // 0x078C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnObjLerpAngleMax;                            // 0x0790(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnObjLerpTimeStart;                           // 0x0794(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnObjLerpTime;                                // 0x0798(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnObjLerpTimeEnd;                             // 0x079C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnObjLerpTimer;                               // 0x07A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnObjLerpTimeSign;                            // 0x07A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PLockOnObjLerpCurve;                               // 0x07A8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnObjLerpDelayApply;                          // 0x07B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B1[0x3];                                      // 0x07B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VLockOnObjLerpDelayOffsetEnd;                      // 0x07B4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VLockOnObjLerpDelayOffset;                         // 0x07C0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnObjLerpDelayTime;                           // 0x07CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnObjLerpDelayTimer;                          // 0x07D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintLockOnObjLerp;                          // 0x07D4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnLookAtDistAngleVtLerpEnable;                // 0x07D5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D6[0x2];                                      // 0x07D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PLockOnLookAtDistAngleVtLerp;                      // 0x07D8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnLookAtDistAngleVtLerpRate;                  // 0x07E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnLookAtDistCamDistEnable;                    // 0x07E4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E5[0x3];                                      // 0x07E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PLockOnLookAtDistCamDistLerp;                      // 0x07E8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnLookAtDistCamDistLerpRate;                  // 0x07F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnRotateSpeedRateEnable;                      // 0x07F4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F5[0x3];                                      // 0x07F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FLockOnRotateSpeedRateFovRateHz;                   // 0x07F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnRotateSpeedRateFovRateVt;                   // 0x07FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnRotateSpeedRateAngleHz;                     // 0x0800(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnRotateSpeedRateAngleVt;                     // 0x0804(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnRotateSpeedRateLerp;                        // 0x0808(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnRotateSpeedRateSign;                        // 0x0809(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80A[0x6];                                      // 0x080A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PLockOnRotateSpeedRateCurve;                       // 0x0810(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnRotateSpeedRateTimeDecel;                   // 0x0818(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnRotateSpeedRateTimeReturn;                  // 0x081C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnRotateSpeedRateTimer;                       // 0x0820(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnRotateSpeedRateCurrent;                     // 0x0824(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintLockOnRotateSpeed;                      // 0x0828(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawLockOnRotateLine;                        // 0x0829(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnEnable;                               // 0x082A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnSkip;                                 // 0x082B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnAngleHz;                              // 0x082C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnAngleVt;                              // 0x0830(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnCheck;                                // 0x0834(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnLerpStt;                              // 0x0835(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnLerpHz;                               // 0x0836(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnLerpHzPly;                            // 0x0837(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnLerpVt;                               // 0x0838(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_839[0x3];                                      // 0x0839(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FLockOnReturnLerpTime;                             // 0x083C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnLerpTimer;                            // 0x0840(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnAngleHzStt;                           // 0x0844(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnAngleHzEnd;                           // 0x0848(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnAngleVtStt;                           // 0x084C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnAngleVtEnd;                           // 0x0850(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnClockwise;                            // 0x0854(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_855[0x3];                                      // 0x0855(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PLockOnReturnLerpCurve;                            // 0x0858(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnActionEnableHz;                       // 0x0860(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnActionApplyHz;                        // 0x0861(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnActionLerpHz;                         // 0x0862(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnActionLerpEndHz;                      // 0x0863(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnActionLerpTimeHz;                     // 0x0864(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnActionLerpTimerHz;                    // 0x0868(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnActionAngleHz;                        // 0x086C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawLockOnReturnLine;                        // 0x0870(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintLockOnReturnSkip;                       // 0x0871(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepAngleEnable;                                  // 0x0872(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKeepAngleApply;                                   // 0x0873(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FKeepAngleLookAtDistance;                          // 0x0874(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLockOnKeepAngleEnable;                            // 0x0878(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnKeepAngleSpeedEnable;                       // 0x0879(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnKeepAngleSkip;                              // 0x087A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnKeepAngleHzSkip;                            // 0x087B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnKeepAngleHzSpeed;                           // 0x087C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnKeepAngleVtSkip;                            // 0x0880(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_881[0x3];                                      // 0x0881(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FLockOnKeepAngleVtSpeed;                           // 0x0884(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintLockOnKeepAngleSkip;                    // 0x0888(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockEnemyPosEnable;                               // 0x0889(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockEnemyPosUpdateParam;                          // 0x088A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockEnemyPosSkip;                                 // 0x088B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockEnemyPosUpdate;                               // 0x088C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88D[0x3];                                      // 0x088D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VLockEnemyPos;                                     // 0x0890(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockEnemyLerpRate;                                // 0x089C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockEnemyPosLockDistanceHz;                       // 0x08A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockEnemyPosRestoreDistanceHz;                    // 0x08A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VLockEnemyPosPrevHz;                               // 0x08A8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockEnemyPosSkipHz;                               // 0x08B4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B5[0x3];                                      // 0x08B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FLockEnemyPosLockDistanceVt;                       // 0x08B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockEnemyPosRestoreDistanceVt;                    // 0x08BC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VLockEnemyPosPrevVt;                               // 0x08C0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockEnemyPosSkipVt;                               // 0x08CC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8CD[0x3];                                      // 0x08CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FLockEnemyPosDistMaxHz;                            // 0x08D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockEnemyPosDistMaxVt;                            // 0x08D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintLockEnemyPos;                           // 0x08D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D9[0xB];                                      // 0x08D9(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LockOnMapGimmickLerpTime;                          // 0x08E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraApply;                          // 0x08E8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraSocketType;                     // 0x08E9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraSocketOption;                   // 0x08EA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8EB[0x5];                                      // 0x08EB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraUniqueObjectParameter           UniqueObjectCameraParam;                           // 0x08F0(0x0058)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UMeshComponent*                         PUniqueObjectCameraMeshComp;                       // 0x0948(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraPlayerFix;                      // 0x0950(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_951[0x3];                                      // 0x0951(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                UniqueObjectCameraPlayerPos;                       // 0x0954(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraSocketApply;                    // 0x0960(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_961[0x3];                                      // 0x0961(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                UniqueObjectCameraSocketPos;                       // 0x0964(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraSocketLerp;                     // 0x0970(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraSocketLerpEnd;                  // 0x0971(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_972[0x2];                                      // 0x0972(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UniqueObjectCameraSocketLerpTimeStt;               // 0x0974(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniqueObjectCameraSocketLerpTimeEnd;               // 0x0978(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniqueObjectCameraSocketLerpRate;                  // 0x097C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraControlType;                    // 0x0980(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_981[0x3];                                      // 0x0981(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               UniqueObjectCameraControlRot;                      // 0x0984(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraRemoteType;                     // 0x0990(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_991[0x3];                                      // 0x0991(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  PUniqueObjectCameraRemoteActor;                    // 0x0994(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraLookAtLerpApply;                // 0x099C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99D[0x3];                                      // 0x099D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UniqueObjectCameraLookAtRate;                      // 0x09A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniqueObjectCameraLookAtLerpTime;                  // 0x09A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniqueObjectCameraLookAtLerpTimer;                 // 0x09A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniqueObjectCameraLookAtDelayRate;                 // 0x09AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B0[0x8];                                      // 0x09B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  PUniqueObjectCameraEnemyActor;                     // 0x09B8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                UniqueObjectCameraEnemyActorPos;                   // 0x09C0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  PUniqueObjectCameraObjectActor;                    // 0x09CC(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VUniqueObjectCameraLookAtPos;                      // 0x09D4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraDistNear;                       // 0x09E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E1[0x3];                                      // 0x09E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UniqueObjectCameraDistRate;                        // 0x09E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PUniqueObjectCameraLerpCurveStt;                   // 0x09E8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PUniqueObjectCameraLerpCurveEnd;                   // 0x09F0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraLerp;                           // 0x09F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraLerpEnd;                        // 0x09F9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraLerpEndInstance;                // 0x09FA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9FB[0x1];                                      // 0x09FB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UniqueObjectCameraLerpTimer;                       // 0x09FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniqueObjectCameraLerpRate;                        // 0x0A00(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A04[0x90];                                     // 0x0A04(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUniqueObjectCameraPlayerLeft;                     // 0x0A94(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintUniqueObjectCamera;                     // 0x0A95(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintUniqueObjectCameraPos;                  // 0x0A96(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintUniqueObjectCameraPosLerp;              // 0x0A97(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintUniqueObjectCameraLookAt;               // 0x0A98(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintUniqueObjectCameraRot;                  // 0x0A99(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintUniqueObjectCameraFov;                  // 0x0A9A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintUniqueObjectCameraSocket;               // 0x0A9B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintUniqueObjectCameraControl;              // 0x0A9C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugUniqueObjectCameraNewLookAt;                 // 0x0A9D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintUniqueObjectCameraLookAtRate;           // 0x0A9E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawUniqueObjectCameraPos;                   // 0x0A9F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawUniqueObjectCameraPosLerp;               // 0x0AA0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawUniqueObjectCameraLookAt;                // 0x0AA1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA2[0x2];                                      // 0x0AA2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         bDebugDrawUniqueObjectCameraTime;                  // 0x0AA4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         bDebugDrawUniqueObjectCameraBgTrace;               // 0x0AA8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttentionCameraApply;                             // 0x0AAC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttentionLerpStt;                                 // 0x0AAD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttentionLerpEnd;                                 // 0x0AAE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttentionActor;                                   // 0x0AAF(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VAttentionPos;                                     // 0x0AB0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  PAttentionActor;                                   // 0x0ABC(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC4[0x4];                                      // 0x0AC4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PAttentionActorCurve;                              // 0x0AC8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttentionActorFixAngleVt;                         // 0x0AD0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD1[0x3];                                      // 0x0AD1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttentionActorFixAngleVt;                          // 0x0AD4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttentionActorOffsetDistHz;                       // 0x0AD8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD9[0x3];                                      // 0x0AD9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttentionActorOffsetDistHz;                        // 0x0ADC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttentionActorOffsetDistHzSign;                    // 0x0AE0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttentionFov;                                     // 0x0AE4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE5[0x3];                                      // 0x0AE5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PAttentionFovCurve;                                // 0x0AE8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttentionCameraLerpTime;                           // 0x0AF0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttentionCameraLerpRate;                           // 0x0AF4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AF8[0x18];                                     // 0x0AF8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugPrintAttentionCamera;                        // 0x0B10(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerLerpAuto;                                   // 0x0B11(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B12[0x6];                                      // 0x0B12(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FPlayerLerpTraceAngleList;                         // 0x0B18(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FPlayerLerpTraceDistance;                          // 0x0B28(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FPlayerLerpDistance;                               // 0x0B2C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerLerp;                                       // 0x0B30(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B31[0x3];                                      // 0x0B31(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VPlayerLerpPosStt;                                 // 0x0B34(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VPlayerLerpPosEnd;                                 // 0x0B40(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FPlayerLerpRadius;                                 // 0x0B4C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PPlayerLerpCurve;                                  // 0x0B50(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ARSCharacterBase>        PEnemyLerpActor;                                   // 0x0B58(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FEnemyLerpDistance;                                // 0x0B60(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FEnemyLerpRateDefault;                             // 0x0B64(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FEnemyLerpRate;                                    // 0x0B68(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FEnemyLerpRadius;                                  // 0x0B6C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FPlayerPullDistance;                               // 0x0B70(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FPlayerPullMoveDistMax;                            // 0x0B74(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnemyLerp;                                        // 0x0B78(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B79[0x3];                                      // 0x0B79(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VEnemyLerpPosStt;                                  // 0x0B7C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VEnemyLerpPosEnd;                                  // 0x0B88(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawPlayerLerpVector;                        // 0x0B94(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawPlayerLerpSphere;                        // 0x0B95(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawEnemyLerpSphere;                         // 0x0B96(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintEnemyLerpSphere;                        // 0x0B97(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLerpReset;                                        // 0x0B98(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLerpUpdateAngleHz;                                // 0x0B99(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraReset;                                      // 0x0B9A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9B[0x1];                                      // 0x0B9B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FLerpTime;                                         // 0x0B9C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLerpRate;                                         // 0x0BA0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA4[0x40];                                     // 0x0BA4(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FCameraHitRadius;                                  // 0x0BE4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FCameraHitRadiusPlane;                             // 0x0BE8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FCameraHitRadiusOffset;                            // 0x0BEC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraBuried;                                     // 0x0BF0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF1[0x3];                                      // 0x0BF1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FDistSpeedAccel;                                   // 0x0BF4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDistSpeedMax;                                     // 0x0BF8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDistSpeed;                                        // 0x0BFC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawTraceCorner;                             // 0x0C00(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawTraceCameraRoot;                         // 0x0C01(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawTraceCameraDistance;                     // 0x0C02(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C03[0x5];                                      // 0x0C03(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraTriggerInfo                     AreaTriggerInfo;                                   // 0x0C08(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCameraTriggerInfo                     CurrentTriggerInfo;                                // 0x0C30(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FCameraTriggerInfo>             TriggerInfoList;                                   // 0x0C58(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerInfoLerp;                                  // 0x0C68(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C69[0x3];                                      // 0x0C69(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TriggerInfoLerpTimer;                              // 0x0C6C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PTriggerInfoLerpCurve;                             // 0x0C70(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerInfoLerpTime;                               // 0x0C78(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C7C[0x4];                                      // 0x0C7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PTriggerInfoLerpCurveDefault;                      // 0x0C80(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerInfoLerpTimeDefault;                        // 0x0C88(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerInfoSkipLerp;                              // 0x0C8C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8D[0x3];                                      // 0x0C8D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         TriggerInfoSkipLerpRefList;                        // 0x0C90(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerCameraPreset                    PresetBasic;                                       // 0x0CA0(0x00D8)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPlayerCameraPreset                    PresetOffset;                                      // 0x0D78(0x00D8)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPlayerCameraPreset                    CurrentPreset;                                     // 0x0E50(0x00D8)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bDebugNewTriggerEndLerp;                           // 0x0F28(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F29[0x207];                                    // 0x0F29(0x0207)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraTriggerInfo                     NextTriggerInfo;                                   // 0x1130(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bAssistRootHeight;                                 // 0x1158(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1159[0x3];                                     // 0x1159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FAssistRootHeightDistYut;                          // 0x115C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAssistRootHeightDistKsn;                          // 0x1160(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAssistRootHeightDistMax;                          // 0x1164(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAssistRootHeightDistRangeMin;                     // 0x1168(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAssistRootHeightDistRangeMax;                     // 0x116C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAssistRootHeightAngleYut;                         // 0x1170(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAssistRootHeightAngleKsn;                         // 0x1174(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAssistRootHeightAngleMax;                         // 0x1178(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAssistRootHeightAngleRangeMin;                    // 0x117C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAssistRootHeightAngleRangeMax;                    // 0x1180(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDbDispAssistRootHeight;                           // 0x1184(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1185[0x7F];                                    // 0x1185(0x007F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAsyncRequestPrevProc;                             // 0x1204(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAsyncRequestTaskProc;                             // 0x1205(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAsyncTaskDone;                                    // 0x1206(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1207[0x1];                                     // 0x1207(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActorMoveDistMin;                                  // 0x1208(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_120C[0xA4];                                    // 0x120C(0x00A4)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DbDrawTrace;                                       // 0x12B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintRootOffsetHz;                           // 0x12B1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawTraceRootOffsetHz;                       // 0x12B2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDbTemp0;                                          // 0x12B3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDbTemp1;                                          // 0x12B4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDbTemp2;                                          // 0x12B5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12B6[0x202];                                   // 0x12B6(0x0202)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyCameraPreset(const struct FPlayerCameraPreset& Preset);
	void ApplyTriggerInfo(const struct FCameraTriggerInfo& TriggerInfo);
	void CalcAngleVtDistRate();
	void CalcDefaultCameraLocationRotation(const struct FVector& RootPos, const struct FRotator& RootRot, struct FVector* CamPos, struct FRotator* CamRot);
	float CalcUniqueObjectPlayerLerpAngle(const struct FVector& PosCam, const struct FVector& PosPly);
	bool CheckRootOffsetHz();
	struct FVector CheckRootPos(const struct FVector& PosRoot, bool bDebugDraw);
	void DebugAddRecordList(int32 Posidx, int32 LineIdx, const struct FVector& Value0, const struct FVector& Value1);
	void DebugAddRecordListCamPos(const struct FVector& PosCam);
	void DebugDrawLockOnReturnLine();
	void DebugDrawLockOnRotateSpeedRateLine();
	void DebugDrawRecordList();
	void DebugInitRecordList(const TArray<float>& Radius, const TArray<struct FColor>& Color);
	void DebugResetRecordList();
	void DebugSetRecordListDraw(bool Flag);
	void DebugSetRecordListShowIndex(int32 CommandNo);
	void DisableTemporaryParameter(float LerpTime, const class FString& RefName, EPlayerCameraActionPriority Prio, EEasingFunc EaseFunc, float EaseBlendExp);
	void EnableTemporaryParameter(float LerpTime, const class FString& RefName, EPlayerCameraActionPriority Prio, const struct FVector& Offset, bool bEnableRootOffset, bool bRootOffsetNoRotate, const struct FVector& RootOffset, bool bEnableDistance, float Distance, bool bEnableFov, float FOV, EEasingFunc EaseFunc, float EaseBlendExp);
	float GetAspectRatio();
	float GetCameraFieldOfView();
	struct FVector GetCameraLocation();
	float GetCameraLockOnLerpRate();
	bool GetCameraPreset(EPlayerCameraPreset PresetName, struct FPlayerCameraPreset* DstPreset, bool bOffset);
	struct FRotator GetCameraRotation();
	struct FVector GetLockEnemyPos();
	float GetLockOnLookAtObjRate();
	float GetLockOnReturnAngleHz();
	struct FVector GetLockRootPos(bool bLockCheck);
	EPlayerCameraMode GetPlayerCameraMode();
	struct FVector GetRootActorLocation(bool bSkipCheck);
	bool GetRootActorMeshComponent();
	struct FRotator GetRootActorRotation(bool bSkipCheck);
	void Initialize();
	bool IsMaleOwner();
	bool IsOptionSpinMoveDecelEnable();
	bool IsOptionSpinMoveInputEnable();
	void PostUpdateUniqueObjectCamera();
	void PrevAsyncSlopeAssist();
	void PrevUpdateUniqueObjectCamera();
	void ResetCamera(float LerpTime, bool bUpdateAngleHz, bool bSkipCheck);
	void ResetCameraHz(float LerpTime, bool bUpdateAngleHz, bool bSkipCheck);
	void ResetLockEnemyPos();
	void ResetLockOnRotateSpeedRate();
	void ResetSlopeAssist();
	void ResetTriggerInfo();
	void ResetTriggerInfoLerp();
	void SetAreaChangeSkipLerp(bool Flag, const class FString& RefName);
	void SetAreaTriggerInfo(const struct FCameraTriggerInfo& TriggerInfo, bool bLerp);
	void SetAssistKeepAngle(bool bFlag);
	void SetAssistRootHeight(bool Flag);
	void SetAssistRootHeightParam(float HeightDistY, float HeightDistK, float MinDist, float MaxDist, float HeightAngleY, float HeightAngleK, float MinAngle, float MaxAngle);
	void SetAttentionCamera(bool Flag, bool bLookAtActor, const struct FVector& LookAtPos, class AActor* PTgtActor, class UCurveFloat* PActorCurve, bool ChangeFov, float TgtFov, class UCurveFloat* PFovCurve);
	void SetAttentionCameraOption(bool bFixAngleVt, float FixAngleVt, bool bOffsetDistHz, float OffsetDistHz);
	void SetBattleCamera(bool bSign, bool bLerp);
	void SetCameraActionReset(bool Flag, float LerpTime, float KeepTime);
	void SetCameraByCameraActor(class ACameraActor* PCamActor, bool bPitch, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	void SetCameraCollisionParameter(float CamRadius, float DistSpeedAccel, float DistSpeedMax);
	void SetCameraDefault(float AngleVt, float AngleHz);
	void SetCameraFieldOfView(float FOV);
	void SetCameraInputMove(const struct FVector& InputMove, float HzRate, float VtRate);
	void SetCameraInputRotate(float SpinRateVt, float SpinRateHz);
	void SetCameraLocation(const struct FVector& Pos);
	void SetCameraLockOn(class AActor* PTargetActor);
	void SetCameraLockOnMapGimmick(class AMapGimmickObject* PMapGimmick, bool ResetOnly);
	void SetCameraMovementDelay(bool bDelay);
	void SetCameraPlayerParameter(bool bYuito);
	void SetCameraRoatatLimit(float VtAngleMin, float VtAngleMax);
	void SetCameraRoot(class AActor* PRootActor_0, const struct FVector& Offset, bool bAttachIn);
	void SetCameraRotation(const struct FRotator& Rot, bool bOverwrite);
	void SetCameraSpeed(float SpinSpeedVt, float SpinAccelVt, float SpinDecelVt, float SpinSpeedHz, float SpinAccelHz, float SpinDecelHz);
	void SetEventTriggerInfo(bool Flag, const struct FCameraTriggerInfo& TriggerInfo);
	void SetInputMoveParameter(float DelayValue, float DelayValueVt, float DelayDistMax, float SpeedRateHz, float DecelHz, float VtAngleMin, float VtAngleMax);
	void SetLerpTriggerInfo(const struct FCameraTriggerInfo& TriggerInfo, class UCurveFloat* PEndCurve);
	void SetLockOnKeepAngleSkip(bool Flag);
	void SetLockOnLookAtObj(bool bFlag, class AActor* PObjActor, bool bDelay);
	void SetLockOnReturnAction(bool bFlag, bool bLerpHz, float LerpTimeHz, float AngleRateHz);
	void SetLockOnReturnSkip(bool Flag);
	void SetLockOnRotateSpeedLerp(bool bSign);
	void SetLockRootPosParameter(float SkipDist, float RestoreDist);
	void SetMaleOwner(bool bFlag);
	void SetPlayerCamera(class AActor* CameraActor);
	void SetPlayerCameraMode(EPlayerCameraMode CamMode);
	void SetRootLerpActionName(bool Flag, const class FString& RefName, EPlayerCameraActionPriority Prio, float LerpTime, class FName ActionName);
	void SetRootLerpActionParameter(bool Flag, const class FString& RefName, EPlayerCameraActionPriority Prio, float LerpTime, float LerpValue, float MaxDist);
	void SetSlopeAssistSkip(bool Flag);
	void SetTemporaryOption(bool bSkipInput, bool bSkipReturn, bool bSkipKeepAngle);
	void SetTemporaryParameter(bool Flag, float LerpTime, const class FString& RefName, EPlayerCameraActionPriority Priority, bool bEnableRootOffset, bool bRootOffsetNoRotate, const struct FVector& RootOffset, bool bEnableCamDistance, float CamDistance, bool bEnableFov, float FOV, EEasingFunc EaseFunc, float EaseBlendExp);
	void SetUniqueObjectCamera(bool Flag, class AActor* PObjActor, class AActor* PEnmActor, const struct FCameraUniqueObjectParameter& Param);
	void SetUniqueObjectCameraControlType(bool Flag, class AActor* PObjActor, const struct FCameraUniqueObjectParameter& Param, bool bSkipResetCamera);
	void SetUniqueObjectCameraRemoteType(bool Flag, class AActor* PRemoteActor, const struct FCameraUniqueObjectParameter& Param);
	void SetUniqueObjectCameraSocketApply(bool Flag, float LerpTime);
	void SetUniqueObjectCameraSocketType(bool Flag, const struct FCameraUniqueObjectParameter& Param);
	void SetUniqueObjectCameraSocketTypeOption(class AActor* PObjActor);
	void SetUniqueObjectEnemyLerp(const struct FVector& TgtPos);
	void SetUniqueObjectLookAtRate(float LookAtRate, float LerpTime, float DelayRate);
	void SetUniqueObjectPlayerLerp(const struct FVector& TgtPos);
	void SetUniqueObjectPlayerLerpAuto(class ARSCharacterBase* PEnemyActor, float RadiusEnm, float RadiusPly);
	void SetUniqueObjectPlayerLerpParameter(const TArray<float>& AngleList, float TraceDist, float LerpDist, float EnmDist, float EnmRate);
	void SetUniqueObjectPlayerPullParameter(float PullDistance, float MoveDistMax);
	void TestTrace(const struct FVector& PosS, const struct FVector& Pose, float Radius, float DTime);
	void TickAsyncSlopeAssist();
	void UpdateAsyncParameter();
	void UpdateAsyncTrace();
	void UpdateAttentionCamera();
	void UpdateBattleCameraLerp();
	void UpdateCameraActionReset();
	void UpdateCameraLockOnLerp();
	void UpdateLockOnLookAtObjLerp(float Rate);
	void UpdateLockOnReturnAction();
	void UpdateLockOnRotateSpeedLerp();
	void UpdateRootLerpActionLerp();
	void UpdateTemporaryParameter();
	void UpdateTriggerInfoLerp();
	void UpdateUniqueObjectCameraRemoteType();
	void UpdateUniqueObjectPlayerLerp(float TimeRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCameraComponent">();
	}
	static class UPlayerCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerCameraComponent>();
	}
};
static_assert(alignof(UPlayerCameraComponent) == 0x000008, "Wrong alignment on UPlayerCameraComponent");
static_assert(sizeof(UPlayerCameraComponent) == 0x0014B8, "Wrong size on UPlayerCameraComponent");
static_assert(offsetof(UPlayerCameraComponent, PUserParamManager) == 0x0000D0, "Member 'UPlayerCameraComponent::PUserParamManager' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDeltaSecond) == 0x0000D8, "Member 'UPlayerCameraComponent::FDeltaSecond' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bMaleOwner) == 0x0000DC, "Member 'UPlayerCameraComponent::bMaleOwner' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bMaleOwnerCheck) == 0x0000DD, "Member 'UPlayerCameraComponent::bMaleOwnerCheck' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, CameraMode) == 0x0000DE, "Member 'UPlayerCameraComponent::CameraMode' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, LookAtMode) == 0x0000DF, "Member 'UPlayerCameraComponent::LookAtMode' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PCameraActor) == 0x0000E0, "Member 'UPlayerCameraComponent::PCameraActor' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PRootActor) == 0x0000E8, "Member 'UPlayerCameraComponent::PRootActor' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PRootActorCapsule) == 0x0000F0, "Member 'UPlayerCameraComponent::PRootActorCapsule' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, RootActorCapsuleHeight) == 0x0000F8, "Member 'UPlayerCameraComponent::RootActorCapsuleHeight' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PRootActorPlayerScript) == 0x000100, "Member 'UPlayerCameraComponent::PRootActorPlayerScript' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VRootActorPos) == 0x000108, "Member 'UPlayerCameraComponent::VRootActorPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VRootActorMove) == 0x000114, "Member 'UPlayerCameraComponent::VRootActorMove' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bCheckRootPosType) == 0x000120, "Member 'UPlayerCameraComponent::bCheckRootPosType' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bCheckRootPosMidCheck) == 0x000121, "Member 'UPlayerCameraComponent::bCheckRootPosMidCheck' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAspectRatio) == 0x000124, "Member 'UPlayerCameraComponent::FAspectRatio' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAspectRateVt) == 0x000128, "Member 'UPlayerCameraComponent::FAspectRateVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAspectRateHz) == 0x00012C, "Member 'UPlayerCameraComponent::FAspectRateHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, DtActionParameter) == 0x000130, "Member 'UPlayerCameraComponent::DtActionParameter' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bWorkPosPlayer) == 0x000138, "Member 'UPlayerCameraComponent::bWorkPosPlayer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VWorkPosPlayer) == 0x00013C, "Member 'UPlayerCameraComponent::VWorkPosPlayer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bWorkPosRemote) == 0x000148, "Member 'UPlayerCameraComponent::bWorkPosRemote' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VWorkPosRemote) == 0x00014C, "Member 'UPlayerCameraComponent::VWorkPosRemote' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bActionResetApply) == 0x000158, "Member 'UPlayerCameraComponent::bActionResetApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FActionResetLerpTime) == 0x00015C, "Member 'UPlayerCameraComponent::FActionResetLerpTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FActionResetLerpTimer) == 0x000160, "Member 'UPlayerCameraComponent::FActionResetLerpTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FActionResetKeepTime) == 0x000164, "Member 'UPlayerCameraComponent::FActionResetKeepTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FActionResetKeepTimer) == 0x000168, "Member 'UPlayerCameraComponent::FActionResetKeepTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FActionResetLerpAngleStt) == 0x00016C, "Member 'UPlayerCameraComponent::FActionResetLerpAngleStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FActionResetLerpAngleEnd) == 0x000170, "Member 'UPlayerCameraComponent::FActionResetLerpAngleEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintActionReset) == 0x000174, "Member 'UPlayerCameraComponent::bDebugPrintActionReset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bMovementDelay) == 0x000175, "Member 'UPlayerCameraComponent::bMovementDelay' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTemporaryCameraEnable) == 0x000176, "Member 'UPlayerCameraComponent::bTemporaryCameraEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TemporaryCameraRefName) == 0x000178, "Member 'UPlayerCameraComponent::TemporaryCameraRefName' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TemporaryCameraPriority) == 0x000188, "Member 'UPlayerCameraComponent::TemporaryCameraPriority' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTemporaryCameraApply) == 0x000189, "Member 'UPlayerCameraComponent::bTemporaryCameraApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTemporaryRootOffsetApply) == 0x00018A, "Member 'UPlayerCameraComponent::bTemporaryRootOffsetApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTemporaryRootOffsetNoRotate) == 0x00018B, "Member 'UPlayerCameraComponent::bTemporaryRootOffsetNoRotate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TemporaryRootOffset) == 0x00018C, "Member 'UPlayerCameraComponent::TemporaryRootOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTemporaryDistanceOffsetApply) == 0x000198, "Member 'UPlayerCameraComponent::bTemporaryDistanceOffsetApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TemporaryDistanceOffset) == 0x00019C, "Member 'UPlayerCameraComponent::TemporaryDistanceOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTemporaryFovApply) == 0x0001A0, "Member 'UPlayerCameraComponent::bTemporaryFovApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TemporaryFov) == 0x0001A4, "Member 'UPlayerCameraComponent::TemporaryFov' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TemporaryLockOnRate) == 0x0001A8, "Member 'UPlayerCameraComponent::TemporaryLockOnRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TemporaryOptionSkipInput) == 0x0001AC, "Member 'UPlayerCameraComponent::TemporaryOptionSkipInput' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TemporaryOptionSkipReturn) == 0x0001B0, "Member 'UPlayerCameraComponent::TemporaryOptionSkipReturn' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TemporaryOptionSkipKeepAngle) == 0x0001B4, "Member 'UPlayerCameraComponent::TemporaryOptionSkipKeepAngle' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugTemporaryUseNew) == 0x0001F5, "Member 'UPlayerCameraComponent::bDebugTemporaryUseNew' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintTemporary) == 0x0001F6, "Member 'UPlayerCameraComponent::bDebugPrintTemporary' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistEnable) == 0x0001F7, "Member 'UPlayerCameraComponent::bSlopeAssistEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistSkip) == 0x0001F8, "Member 'UPlayerCameraComponent::bSlopeAssistSkip' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistAsyncRequestPrevProc) == 0x0001F9, "Member 'UPlayerCameraComponent::bSlopeAssistAsyncRequestPrevProc' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistAsyncRequestTaskProc) == 0x0001FA, "Member 'UPlayerCameraComponent::bSlopeAssistAsyncRequestTaskProc' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistAsyncRequestTaskDone) == 0x0001FB, "Member 'UPlayerCameraComponent::bSlopeAssistAsyncRequestTaskDone' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistCheckNum) == 0x0001FC, "Member 'UPlayerCameraComponent::SlopeAssistCheckNum' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistCheckInterval) == 0x000200, "Member 'UPlayerCameraComponent::SlopeAssistCheckInterval' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistCheckIntervalAngle) == 0x000204, "Member 'UPlayerCameraComponent::SlopeAssistCheckIntervalAngle' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistCheckAngleVtMax) == 0x000208, "Member 'UPlayerCameraComponent::SlopeAssistCheckAngleVtMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistCheckAngleVtStt) == 0x00020C, "Member 'UPlayerCameraComponent::SlopeAssistCheckAngleVtStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistCheckAngleVtEnd) == 0x000210, "Member 'UPlayerCameraComponent::SlopeAssistCheckAngleVtEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistCheckAngleHz) == 0x000214, "Member 'UPlayerCameraComponent::SlopeAssistCheckAngleHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VSlopeAssistMoveDirection) == 0x000218, "Member 'UPlayerCameraComponent::VSlopeAssistMoveDirection' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VSlopeAssistMoveDirectionHz) == 0x000224, "Member 'UPlayerCameraComponent::VSlopeAssistMoveDirectionHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistSkipMoveDir) == 0x000230, "Member 'UPlayerCameraComponent::bSlopeAssistSkipMoveDir' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistLerpApply) == 0x000231, "Member 'UPlayerCameraComponent::bSlopeAssistLerpApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistLerpRate) == 0x000234, "Member 'UPlayerCameraComponent::SlopeAssistLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VSlopeAssistLerpVector) == 0x000238, "Member 'UPlayerCameraComponent::VSlopeAssistLerpVector' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistLerpAngleVt) == 0x000244, "Member 'UPlayerCameraComponent::SlopeAssistLerpAngleVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistDelayTime) == 0x000248, "Member 'UPlayerCameraComponent::SlopeAssistDelayTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistDelayTimer) == 0x00024C, "Member 'UPlayerCameraComponent::SlopeAssistDelayTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistCheckBgEnable) == 0x000250, "Member 'UPlayerCameraComponent::bSlopeAssistCheckBgEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistCheckBgOffset) == 0x000254, "Member 'UPlayerCameraComponent::SlopeAssistCheckBgOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistFixAngleEnable) == 0x000260, "Member 'UPlayerCameraComponent::bSlopeAssistFixAngleEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistFixAngleInterval) == 0x000264, "Member 'UPlayerCameraComponent::SlopeAssistFixAngleInterval' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistFixAngleRange) == 0x000268, "Member 'UPlayerCameraComponent::SlopeAssistFixAngleRange' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistSpeedLerpEnable) == 0x00026C, "Member 'UPlayerCameraComponent::bSlopeAssistSpeedLerpEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistSpeedLerpMin) == 0x000270, "Member 'UPlayerCameraComponent::SlopeAssistSpeedLerpMin' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistSpeedLerpMax) == 0x000274, "Member 'UPlayerCameraComponent::SlopeAssistSpeedLerpMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistSpeedLerpRateMax) == 0x000278, "Member 'UPlayerCameraComponent::SlopeAssistSpeedLerpRateMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistSpeedLerpRate) == 0x00027C, "Member 'UPlayerCameraComponent::SlopeAssistSpeedLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistResultAngleList) == 0x000280, "Member 'UPlayerCameraComponent::SlopeAssistResultAngleList' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugSlopeAssistSyncApply) == 0x000360, "Member 'UPlayerCameraComponent::bDebugSlopeAssistSyncApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintSlopeAssist) == 0x000361, "Member 'UPlayerCameraComponent::bDebugPrintSlopeAssist' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawSlopeAssistVector) == 0x000362, "Member 'UPlayerCameraComponent::bDebugDrawSlopeAssistVector' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawSlopeAssistCheckPoint) == 0x000363, "Member 'UPlayerCameraComponent::bDebugDrawSlopeAssistCheckPoint' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawSlopeAssistCheckHit) == 0x000364, "Member 'UPlayerCameraComponent::bDebugDrawSlopeAssistCheckHit' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintDistance) == 0x000398, "Member 'UPlayerCameraComponent::bDebugPrintDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugTraceHit) == 0x000399, "Member 'UPlayerCameraComponent::bDebugTraceHit' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bInputEnable) == 0x00039A, "Member 'UPlayerCameraComponent::bInputEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FInputLtX) == 0x00039C, "Member 'UPlayerCameraComponent::FInputLtX' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FInputLtY) == 0x0003A0, "Member 'UPlayerCameraComponent::FInputLtY' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FInputRtX) == 0x0003A4, "Member 'UPlayerCameraComponent::FInputRtX' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FInputRtY) == 0x0003A8, "Member 'UPlayerCameraComponent::FInputRtY' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bInputLt) == 0x0003AC, "Member 'UPlayerCameraComponent::bInputLt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bInputRt) == 0x0003AD, "Member 'UPlayerCameraComponent::bInputRt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bInputUp) == 0x0003AE, "Member 'UPlayerCameraComponent::bInputUp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bInputDn) == 0x0003AF, "Member 'UPlayerCameraComponent::bInputDn' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bInputAngle) == 0x0003B0, "Member 'UPlayerCameraComponent::bInputAngle' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTurnCheckEnable) == 0x0003B1, "Member 'UPlayerCameraComponent::bTurnCheckEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VTurnCheckOffsetUpStt) == 0x0003B4, "Member 'UPlayerCameraComponent::VTurnCheckOffsetUpStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VTurnCheckOffsetUpEnd) == 0x0003C0, "Member 'UPlayerCameraComponent::VTurnCheckOffsetUpEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VTurnCheckOffsetDnStt) == 0x0003CC, "Member 'UPlayerCameraComponent::VTurnCheckOffsetDnStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VTurnCheckOffsetDnEnd) == 0x0003D8, "Member 'UPlayerCameraComponent::VTurnCheckOffsetDnEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VTurnCheckOffsetLtStt) == 0x0003E4, "Member 'UPlayerCameraComponent::VTurnCheckOffsetLtStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VTurnCheckOffsetLtEnd) == 0x0003F0, "Member 'UPlayerCameraComponent::VTurnCheckOffsetLtEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VTurnCheckOffsetRtStt) == 0x0003FC, "Member 'UPlayerCameraComponent::VTurnCheckOffsetRtStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VTurnCheckOffsetRtEnd) == 0x000408, "Member 'UPlayerCameraComponent::VTurnCheckOffsetRtEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTurnCheckReturnEnable) == 0x000414, "Member 'UPlayerCameraComponent::bTurnCheckReturnEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FTurnCheckReturnTime) == 0x000418, "Member 'UPlayerCameraComponent::FTurnCheckReturnTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugTurnCheckFlag1) == 0x0004A0, "Member 'UPlayerCameraComponent::bDebugTurnCheckFlag1' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugTurnCheckDrawCt) == 0x0004A1, "Member 'UPlayerCameraComponent::bDebugTurnCheckDrawCt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugTurnCheckDrawCtRay) == 0x0004A2, "Member 'UPlayerCameraComponent::bDebugTurnCheckDrawCtRay' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDefaultFov) == 0x0004A4, "Member 'UPlayerCameraComponent::FDefaultFov' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VDefaultOffset) == 0x0004A8, "Member 'UPlayerCameraComponent::VDefaultOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VDefaultOffsetWall) == 0x0004B4, "Member 'UPlayerCameraComponent::VDefaultOffsetWall' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDefaultAngleVt) == 0x0004C0, "Member 'UPlayerCameraComponent::FDefaultAngleVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDefaultAngleHz) == 0x0004C4, "Member 'UPlayerCameraComponent::FDefaultAngleHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDefaultDistance) == 0x0004C8, "Member 'UPlayerCameraComponent::FDefaultDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDefaultDistanceMin) == 0x0004CC, "Member 'UPlayerCameraComponent::FDefaultDistanceMin' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FCurrentFov) == 0x0004D0, "Member 'UPlayerCameraComponent::FCurrentFov' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FCurrentAngleVt) == 0x0004D4, "Member 'UPlayerCameraComponent::FCurrentAngleVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FCurrentAngleHz) == 0x0004D8, "Member 'UPlayerCameraComponent::FCurrentAngleHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FCurrentDistance) == 0x0004DC, "Member 'UPlayerCameraComponent::FCurrentDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VCurrentRoot) == 0x0004E0, "Member 'UPlayerCameraComponent::VCurrentRoot' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VCurrentPos) == 0x0004EC, "Member 'UPlayerCameraComponent::VCurrentPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VCurrentLookAt) == 0x0004F8, "Member 'UPlayerCameraComponent::VCurrentLookAt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VCurrentDir) == 0x000504, "Member 'UPlayerCameraComponent::VCurrentDir' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, RCurrentRot) == 0x000510, "Member 'UPlayerCameraComponent::RCurrentRot' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDestinationAngleVt) == 0x00051C, "Member 'UPlayerCameraComponent::FDestinationAngleVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDestinationAngleHz) == 0x000520, "Member 'UPlayerCameraComponent::FDestinationAngleHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDestinationDistance) == 0x000524, "Member 'UPlayerCameraComponent::FDestinationDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VDestinationRoot) == 0x000528, "Member 'UPlayerCameraComponent::VDestinationRoot' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VDestinationPos) == 0x000534, "Member 'UPlayerCameraComponent::VDestinationPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VDestinationDir) == 0x000540, "Member 'UPlayerCameraComponent::VDestinationDir' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, RDestinationRot) == 0x00054C, "Member 'UPlayerCameraComponent::RDestinationRot' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawDestinationRootList) == 0x000558, "Member 'UPlayerCameraComponent::bDebugDrawDestinationRootList' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bBattleOffsetEnable) == 0x000559, "Member 'UPlayerCameraComponent::bBattleOffsetEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bBattleOffset) == 0x00055A, "Member 'UPlayerCameraComponent::bBattleOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bBattleOffsetLerp) == 0x00055B, "Member 'UPlayerCameraComponent::bBattleOffsetLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bBattleOffsetLerpSign) == 0x00055C, "Member 'UPlayerCameraComponent::bBattleOffsetLerpSign' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FBattleOffsetTime) == 0x000560, "Member 'UPlayerCameraComponent::FBattleOffsetTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PBattleOffsetLerpCurve) == 0x000568, "Member 'UPlayerCameraComponent::PBattleOffsetLerpCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FBattleOffsetTimer) == 0x000570, "Member 'UPlayerCameraComponent::FBattleOffsetTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FBattleOffsetLerpRate) == 0x000574, "Member 'UPlayerCameraComponent::FBattleOffsetLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FBattleOffsetDistanceLerp) == 0x000578, "Member 'UPlayerCameraComponent::FBattleOffsetDistanceLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VBattleOffsetRootPosLerp) == 0x00057C, "Member 'UPlayerCameraComponent::VBattleOffsetRootPosLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FBattleOffsetDistance) == 0x000588, "Member 'UPlayerCameraComponent::FBattleOffsetDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VBattleOffsetRootPos) == 0x00058C, "Member 'UPlayerCameraComponent::VBattleOffsetRootPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintBattleOffset) == 0x000598, "Member 'UPlayerCameraComponent::bDebugPrintBattleOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockRootPosEnable) == 0x000599, "Member 'UPlayerCameraComponent::bLockRootPosEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockRootPosSkip) == 0x00059A, "Member 'UPlayerCameraComponent::bLockRootPosSkip' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRestoreRootPosLerpRate) == 0x00059C, "Member 'UPlayerCameraComponent::FRestoreRootPosLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockRootPosDistance) == 0x0005A0, "Member 'UPlayerCameraComponent::FLockRootPosDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRestoreRootPosDistance) == 0x0005A4, "Member 'UPlayerCameraComponent::FRestoreRootPosDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VPrevRootPos) == 0x0005A8, "Member 'UPlayerCameraComponent::VPrevRootPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintLockRootPos) == 0x0005B4, "Member 'UPlayerCameraComponent::bDebugPrintLockRootPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VPlayerInputMove) == 0x0005B8, "Member 'UPlayerCameraComponent::VPlayerInputMove' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bRootLerpEnable) == 0x0005C4, "Member 'UPlayerCameraComponent::bRootLerpEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpValueDefault) == 0x0005C8, "Member 'UPlayerCameraComponent::FRootLerpValueDefault' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpValueAction) == 0x0005CC, "Member 'UPlayerCameraComponent::FRootLerpValueAction' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpValue) == 0x0005D0, "Member 'UPlayerCameraComponent::FRootLerpValue' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpValueVt) == 0x0005D4, "Member 'UPlayerCameraComponent::FRootLerpValueVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpDistanceDefault) == 0x0005D8, "Member 'UPlayerCameraComponent::FRootLerpDistanceDefault' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpDistanceAction) == 0x0005DC, "Member 'UPlayerCameraComponent::FRootLerpDistanceAction' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpDistance) == 0x0005E0, "Member 'UPlayerCameraComponent::FRootLerpDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpDistanceWork) == 0x0005E4, "Member 'UPlayerCameraComponent::FRootLerpDistanceWork' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpDistanceMin) == 0x0005E8, "Member 'UPlayerCameraComponent::FRootLerpDistanceMin' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpDistanceTarget) == 0x0005EC, "Member 'UPlayerCameraComponent::FRootLerpDistanceTarget' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpDistanceMove) == 0x0005F0, "Member 'UPlayerCameraComponent::FRootLerpDistanceMove' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bRootLerpActionLerp) == 0x0005F4, "Member 'UPlayerCameraComponent::bRootLerpActionLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, RootLerpActionRefName) == 0x0005F8, "Member 'UPlayerCameraComponent::RootLerpActionRefName' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, RootLerpActionPriority) == 0x000608, "Member 'UPlayerCameraComponent::RootLerpActionPriority' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpActionLerpRate) == 0x00060C, "Member 'UPlayerCameraComponent::FRootLerpActionLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bRootLerpAngleEnable) == 0x000624, "Member 'UPlayerCameraComponent::bRootLerpAngleEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PRootLerpDirCurve) == 0x000628, "Member 'UPlayerCameraComponent::PRootLerpDirCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpDirLerpRate) == 0x000630, "Member 'UPlayerCameraComponent::FRootLerpDirLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpDirLerpRateMin) == 0x000634, "Member 'UPlayerCameraComponent::FRootLerpDirLerpRateMin' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpMoveLerpValue) == 0x000638, "Member 'UPlayerCameraComponent::FRootLerpMoveLerpValue' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpMoveLerpRate) == 0x00063C, "Member 'UPlayerCameraComponent::FRootLerpMoveLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpMoveLerpRateMin) == 0x000640, "Member 'UPlayerCameraComponent::FRootLerpMoveLerpRateMin' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpAngleLerpRate) == 0x000644, "Member 'UPlayerCameraComponent::FRootLerpAngleLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpAngleRate) == 0x000648, "Member 'UPlayerCameraComponent::FRootLerpAngleRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bRootLerpCamDistEnable) == 0x00064C, "Member 'UPlayerCameraComponent::bRootLerpCamDistEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpCamDistRate) == 0x000650, "Member 'UPlayerCameraComponent::FRootLerpCamDistRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintRootLerp) == 0x000654, "Member 'UPlayerCameraComponent::bDebugPrintRootLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintRootLerpAction) == 0x000655, "Member 'UPlayerCameraComponent::bDebugPrintRootLerpAction' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinSpeedMaxHz) == 0x000658, "Member 'UPlayerCameraComponent::FSpinSpeedMaxHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinAccelHz) == 0x00065C, "Member 'UPlayerCameraComponent::FSpinAccelHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinDecelHz) == 0x000660, "Member 'UPlayerCameraComponent::FSpinDecelHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinDirectionHz) == 0x000664, "Member 'UPlayerCameraComponent::FSpinDirectionHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinSpeedHz) == 0x000668, "Member 'UPlayerCameraComponent::FSpinSpeedHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinInputHz) == 0x00066C, "Member 'UPlayerCameraComponent::FSpinInputHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinMoveInputHz) == 0x000670, "Member 'UPlayerCameraComponent::FSpinMoveInputHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinMoveRateHz) == 0x000674, "Member 'UPlayerCameraComponent::FSpinMoveRateHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinMoveDecelHz) == 0x000678, "Member 'UPlayerCameraComponent::FSpinMoveDecelHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinMoveSpeedHz) == 0x00067C, "Member 'UPlayerCameraComponent::FSpinMoveSpeedHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinAngleMin) == 0x000680, "Member 'UPlayerCameraComponent::FSpinAngleMin' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinAngleMax) == 0x000684, "Member 'UPlayerCameraComponent::FSpinAngleMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinSpeedMaxVt) == 0x000688, "Member 'UPlayerCameraComponent::FSpinSpeedMaxVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinAccelVt) == 0x00068C, "Member 'UPlayerCameraComponent::FSpinAccelVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinDecelVt) == 0x000690, "Member 'UPlayerCameraComponent::FSpinDecelVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinDirectionVt) == 0x000694, "Member 'UPlayerCameraComponent::FSpinDirectionVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinSpeedVt) == 0x000698, "Member 'UPlayerCameraComponent::FSpinSpeedVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinInputVt) == 0x00069C, "Member 'UPlayerCameraComponent::FSpinInputVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinMoveInputVt) == 0x0006A0, "Member 'UPlayerCameraComponent::FSpinMoveInputVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinMoveAngleMinVt) == 0x0006A4, "Member 'UPlayerCameraComponent::FSpinMoveAngleMinVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinMoveAngleMaxVt) == 0x0006A8, "Member 'UPlayerCameraComponent::FSpinMoveAngleMaxVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAngleVtDistEnable) == 0x0006AC, "Member 'UPlayerCameraComponent::bAngleVtDistEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAngleVtDistRate) == 0x0006B0, "Member 'UPlayerCameraComponent::FAngleVtDistRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PAngleVtDistLerpCurve) == 0x0006B8, "Member 'UPlayerCameraComponent::PAngleVtDistLerpCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAngleVtRootEnable) == 0x0006C0, "Member 'UPlayerCameraComponent::bAngleVtRootEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAngleVtRootRate) == 0x0006C4, "Member 'UPlayerCameraComponent::FAngleVtRootRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VAngleVtRootOffset) == 0x0006C8, "Member 'UPlayerCameraComponent::VAngleVtRootOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PAngleVtRootLerpCurve) == 0x0006D8, "Member 'UPlayerCameraComponent::PAngleVtRootLerpCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnApply) == 0x0006E0, "Member 'UPlayerCameraComponent::bLockOnApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PLockOnActor) == 0x0006E4, "Member 'UPlayerCameraComponent::PLockOnActor' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, LockOnOffset) == 0x0006EC, "Member 'UPlayerCameraComponent::LockOnOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, LockOnAngleLimitPly) == 0x0006F8, "Member 'UPlayerCameraComponent::LockOnAngleLimitPly' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, LockOnAngleLimitCam) == 0x0006FC, "Member 'UPlayerCameraComponent::LockOnAngleLimitCam' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnAngleUp) == 0x000700, "Member 'UPlayerCameraComponent::FLockOnAngleUp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnAngleDn) == 0x000704, "Member 'UPlayerCameraComponent::FLockOnAngleDn' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnAngleLt) == 0x000708, "Member 'UPlayerCameraComponent::FLockOnAngleLt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnAngleRt) == 0x00070C, "Member 'UPlayerCameraComponent::FLockOnAngleRt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugNoLerpVtAngle) == 0x000710, "Member 'UPlayerCameraComponent::bDebugNoLerpVtAngle' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VLockOnRootPly) == 0x000714, "Member 'UPlayerCameraComponent::VLockOnRootPly' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VLockOnRootEnm) == 0x000720, "Member 'UPlayerCameraComponent::VLockOnRootEnm' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VLockOnLookAt) == 0x00072C, "Member 'UPlayerCameraComponent::VLockOnLookAt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnRoot) == 0x000738, "Member 'UPlayerCameraComponent::bLockOnRoot' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VLockOnRoot) == 0x00073C, "Member 'UPlayerCameraComponent::VLockOnRoot' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLookAtDistanceOffset) == 0x000748, "Member 'UPlayerCameraComponent::FLookAtDistanceOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintLogLockOn) == 0x00074C, "Member 'UPlayerCameraComponent::bDebugPrintLogLockOn' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnLerp) == 0x00074D, "Member 'UPlayerCameraComponent::bLockOnLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnLerpTime) == 0x000750, "Member 'UPlayerCameraComponent::FLockOnLerpTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnLerpTimeSign) == 0x000754, "Member 'UPlayerCameraComponent::FLockOnLerpTimeSign' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PLockOnLerpCurve) == 0x000758, "Member 'UPlayerCameraComponent::PLockOnLerpCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnLerpTimer) == 0x000760, "Member 'UPlayerCameraComponent::FLockOnLerpTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnLerpRate) == 0x000764, "Member 'UPlayerCameraComponent::FLockOnLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnLerpAngleVtEnable) == 0x000768, "Member 'UPlayerCameraComponent::bLockOnLerpAngleVtEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnLerpAngleVtApply) == 0x000769, "Member 'UPlayerCameraComponent::bLockOnLerpAngleVtApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnLerpAngleVtStt) == 0x00076C, "Member 'UPlayerCameraComponent::FLockOnLerpAngleVtStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnLerpAngleVtEnd) == 0x000770, "Member 'UPlayerCameraComponent::FLockOnLerpAngleVtEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnLerpAngleVtEaseBlend) == 0x000774, "Member 'UPlayerCameraComponent::FLockOnLerpAngleVtEaseBlend' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintLockOnLerp) == 0x000778, "Member 'UPlayerCameraComponent::bDebugPrintLockOnLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PLookAtObject) == 0x00077C, "Member 'UPlayerCameraComponent::PLookAtObject' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnLookAtObj) == 0x000784, "Member 'UPlayerCameraComponent::bLockOnLookAtObj' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnObjLerp) == 0x000785, "Member 'UPlayerCameraComponent::bLockOnObjLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpRateStt) == 0x000788, "Member 'UPlayerCameraComponent::FLockOnObjLerpRateStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpRate) == 0x00078C, "Member 'UPlayerCameraComponent::FLockOnObjLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpAngleMax) == 0x000790, "Member 'UPlayerCameraComponent::FLockOnObjLerpAngleMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpTimeStart) == 0x000794, "Member 'UPlayerCameraComponent::FLockOnObjLerpTimeStart' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpTime) == 0x000798, "Member 'UPlayerCameraComponent::FLockOnObjLerpTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpTimeEnd) == 0x00079C, "Member 'UPlayerCameraComponent::FLockOnObjLerpTimeEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpTimer) == 0x0007A0, "Member 'UPlayerCameraComponent::FLockOnObjLerpTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpTimeSign) == 0x0007A4, "Member 'UPlayerCameraComponent::FLockOnObjLerpTimeSign' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PLockOnObjLerpCurve) == 0x0007A8, "Member 'UPlayerCameraComponent::PLockOnObjLerpCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnObjLerpDelayApply) == 0x0007B0, "Member 'UPlayerCameraComponent::bLockOnObjLerpDelayApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VLockOnObjLerpDelayOffsetEnd) == 0x0007B4, "Member 'UPlayerCameraComponent::VLockOnObjLerpDelayOffsetEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VLockOnObjLerpDelayOffset) == 0x0007C0, "Member 'UPlayerCameraComponent::VLockOnObjLerpDelayOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpDelayTime) == 0x0007CC, "Member 'UPlayerCameraComponent::FLockOnObjLerpDelayTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpDelayTimer) == 0x0007D0, "Member 'UPlayerCameraComponent::FLockOnObjLerpDelayTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintLockOnObjLerp) == 0x0007D4, "Member 'UPlayerCameraComponent::bDebugPrintLockOnObjLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnLookAtDistAngleVtLerpEnable) == 0x0007D5, "Member 'UPlayerCameraComponent::bLockOnLookAtDistAngleVtLerpEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PLockOnLookAtDistAngleVtLerp) == 0x0007D8, "Member 'UPlayerCameraComponent::PLockOnLookAtDistAngleVtLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnLookAtDistAngleVtLerpRate) == 0x0007E0, "Member 'UPlayerCameraComponent::FLockOnLookAtDistAngleVtLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnLookAtDistCamDistEnable) == 0x0007E4, "Member 'UPlayerCameraComponent::bLockOnLookAtDistCamDistEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PLockOnLookAtDistCamDistLerp) == 0x0007E8, "Member 'UPlayerCameraComponent::PLockOnLookAtDistCamDistLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnLookAtDistCamDistLerpRate) == 0x0007F0, "Member 'UPlayerCameraComponent::FLockOnLookAtDistCamDistLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnRotateSpeedRateEnable) == 0x0007F4, "Member 'UPlayerCameraComponent::bLockOnRotateSpeedRateEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnRotateSpeedRateFovRateHz) == 0x0007F8, "Member 'UPlayerCameraComponent::FLockOnRotateSpeedRateFovRateHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnRotateSpeedRateFovRateVt) == 0x0007FC, "Member 'UPlayerCameraComponent::FLockOnRotateSpeedRateFovRateVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnRotateSpeedRateAngleHz) == 0x000800, "Member 'UPlayerCameraComponent::FLockOnRotateSpeedRateAngleHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnRotateSpeedRateAngleVt) == 0x000804, "Member 'UPlayerCameraComponent::FLockOnRotateSpeedRateAngleVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnRotateSpeedRateLerp) == 0x000808, "Member 'UPlayerCameraComponent::bLockOnRotateSpeedRateLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnRotateSpeedRateSign) == 0x000809, "Member 'UPlayerCameraComponent::bLockOnRotateSpeedRateSign' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PLockOnRotateSpeedRateCurve) == 0x000810, "Member 'UPlayerCameraComponent::PLockOnRotateSpeedRateCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnRotateSpeedRateTimeDecel) == 0x000818, "Member 'UPlayerCameraComponent::FLockOnRotateSpeedRateTimeDecel' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnRotateSpeedRateTimeReturn) == 0x00081C, "Member 'UPlayerCameraComponent::FLockOnRotateSpeedRateTimeReturn' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnRotateSpeedRateTimer) == 0x000820, "Member 'UPlayerCameraComponent::FLockOnRotateSpeedRateTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnRotateSpeedRateCurrent) == 0x000824, "Member 'UPlayerCameraComponent::FLockOnRotateSpeedRateCurrent' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintLockOnRotateSpeed) == 0x000828, "Member 'UPlayerCameraComponent::bDebugPrintLockOnRotateSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawLockOnRotateLine) == 0x000829, "Member 'UPlayerCameraComponent::bDebugDrawLockOnRotateLine' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnEnable) == 0x00082A, "Member 'UPlayerCameraComponent::bLockOnReturnEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnSkip) == 0x00082B, "Member 'UPlayerCameraComponent::bLockOnReturnSkip' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnAngleHz) == 0x00082C, "Member 'UPlayerCameraComponent::FLockOnReturnAngleHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnAngleVt) == 0x000830, "Member 'UPlayerCameraComponent::FLockOnReturnAngleVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnCheck) == 0x000834, "Member 'UPlayerCameraComponent::bLockOnReturnCheck' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnLerpStt) == 0x000835, "Member 'UPlayerCameraComponent::bLockOnReturnLerpStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnLerpHz) == 0x000836, "Member 'UPlayerCameraComponent::bLockOnReturnLerpHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnLerpHzPly) == 0x000837, "Member 'UPlayerCameraComponent::bLockOnReturnLerpHzPly' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnLerpVt) == 0x000838, "Member 'UPlayerCameraComponent::bLockOnReturnLerpVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnLerpTime) == 0x00083C, "Member 'UPlayerCameraComponent::FLockOnReturnLerpTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnLerpTimer) == 0x000840, "Member 'UPlayerCameraComponent::FLockOnReturnLerpTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnAngleHzStt) == 0x000844, "Member 'UPlayerCameraComponent::FLockOnReturnAngleHzStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnAngleHzEnd) == 0x000848, "Member 'UPlayerCameraComponent::FLockOnReturnAngleHzEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnAngleVtStt) == 0x00084C, "Member 'UPlayerCameraComponent::FLockOnReturnAngleVtStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnAngleVtEnd) == 0x000850, "Member 'UPlayerCameraComponent::FLockOnReturnAngleVtEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnClockwise) == 0x000854, "Member 'UPlayerCameraComponent::bLockOnReturnClockwise' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PLockOnReturnLerpCurve) == 0x000858, "Member 'UPlayerCameraComponent::PLockOnReturnLerpCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnActionEnableHz) == 0x000860, "Member 'UPlayerCameraComponent::bLockOnReturnActionEnableHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnActionApplyHz) == 0x000861, "Member 'UPlayerCameraComponent::bLockOnReturnActionApplyHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnActionLerpHz) == 0x000862, "Member 'UPlayerCameraComponent::bLockOnReturnActionLerpHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnActionLerpEndHz) == 0x000863, "Member 'UPlayerCameraComponent::bLockOnReturnActionLerpEndHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnActionLerpTimeHz) == 0x000864, "Member 'UPlayerCameraComponent::FLockOnReturnActionLerpTimeHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnActionLerpTimerHz) == 0x000868, "Member 'UPlayerCameraComponent::FLockOnReturnActionLerpTimerHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnActionAngleHz) == 0x00086C, "Member 'UPlayerCameraComponent::FLockOnReturnActionAngleHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawLockOnReturnLine) == 0x000870, "Member 'UPlayerCameraComponent::bDebugDrawLockOnReturnLine' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintLockOnReturnSkip) == 0x000871, "Member 'UPlayerCameraComponent::bDebugPrintLockOnReturnSkip' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bKeepAngleEnable) == 0x000872, "Member 'UPlayerCameraComponent::bKeepAngleEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bKeepAngleApply) == 0x000873, "Member 'UPlayerCameraComponent::bKeepAngleApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FKeepAngleLookAtDistance) == 0x000874, "Member 'UPlayerCameraComponent::FKeepAngleLookAtDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnKeepAngleEnable) == 0x000878, "Member 'UPlayerCameraComponent::bLockOnKeepAngleEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnKeepAngleSpeedEnable) == 0x000879, "Member 'UPlayerCameraComponent::bLockOnKeepAngleSpeedEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnKeepAngleSkip) == 0x00087A, "Member 'UPlayerCameraComponent::bLockOnKeepAngleSkip' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnKeepAngleHzSkip) == 0x00087B, "Member 'UPlayerCameraComponent::bLockOnKeepAngleHzSkip' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnKeepAngleHzSpeed) == 0x00087C, "Member 'UPlayerCameraComponent::FLockOnKeepAngleHzSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnKeepAngleVtSkip) == 0x000880, "Member 'UPlayerCameraComponent::bLockOnKeepAngleVtSkip' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnKeepAngleVtSpeed) == 0x000884, "Member 'UPlayerCameraComponent::FLockOnKeepAngleVtSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintLockOnKeepAngleSkip) == 0x000888, "Member 'UPlayerCameraComponent::bDebugPrintLockOnKeepAngleSkip' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockEnemyPosEnable) == 0x000889, "Member 'UPlayerCameraComponent::bLockEnemyPosEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockEnemyPosUpdateParam) == 0x00088A, "Member 'UPlayerCameraComponent::bLockEnemyPosUpdateParam' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockEnemyPosSkip) == 0x00088B, "Member 'UPlayerCameraComponent::bLockEnemyPosSkip' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockEnemyPosUpdate) == 0x00088C, "Member 'UPlayerCameraComponent::bLockEnemyPosUpdate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VLockEnemyPos) == 0x000890, "Member 'UPlayerCameraComponent::VLockEnemyPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockEnemyLerpRate) == 0x00089C, "Member 'UPlayerCameraComponent::FLockEnemyLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockEnemyPosLockDistanceHz) == 0x0008A0, "Member 'UPlayerCameraComponent::FLockEnemyPosLockDistanceHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockEnemyPosRestoreDistanceHz) == 0x0008A4, "Member 'UPlayerCameraComponent::FLockEnemyPosRestoreDistanceHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VLockEnemyPosPrevHz) == 0x0008A8, "Member 'UPlayerCameraComponent::VLockEnemyPosPrevHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockEnemyPosSkipHz) == 0x0008B4, "Member 'UPlayerCameraComponent::bLockEnemyPosSkipHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockEnemyPosLockDistanceVt) == 0x0008B8, "Member 'UPlayerCameraComponent::FLockEnemyPosLockDistanceVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockEnemyPosRestoreDistanceVt) == 0x0008BC, "Member 'UPlayerCameraComponent::FLockEnemyPosRestoreDistanceVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VLockEnemyPosPrevVt) == 0x0008C0, "Member 'UPlayerCameraComponent::VLockEnemyPosPrevVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockEnemyPosSkipVt) == 0x0008CC, "Member 'UPlayerCameraComponent::bLockEnemyPosSkipVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockEnemyPosDistMaxHz) == 0x0008D0, "Member 'UPlayerCameraComponent::FLockEnemyPosDistMaxHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockEnemyPosDistMaxVt) == 0x0008D4, "Member 'UPlayerCameraComponent::FLockEnemyPosDistMaxVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintLockEnemyPos) == 0x0008D8, "Member 'UPlayerCameraComponent::bDebugPrintLockEnemyPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, LockOnMapGimmickLerpTime) == 0x0008E4, "Member 'UPlayerCameraComponent::LockOnMapGimmickLerpTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraApply) == 0x0008E8, "Member 'UPlayerCameraComponent::bUniqueObjectCameraApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraSocketType) == 0x0008E9, "Member 'UPlayerCameraComponent::bUniqueObjectCameraSocketType' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraSocketOption) == 0x0008EA, "Member 'UPlayerCameraComponent::bUniqueObjectCameraSocketOption' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraParam) == 0x0008F0, "Member 'UPlayerCameraComponent::UniqueObjectCameraParam' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PUniqueObjectCameraMeshComp) == 0x000948, "Member 'UPlayerCameraComponent::PUniqueObjectCameraMeshComp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraPlayerFix) == 0x000950, "Member 'UPlayerCameraComponent::bUniqueObjectCameraPlayerFix' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraPlayerPos) == 0x000954, "Member 'UPlayerCameraComponent::UniqueObjectCameraPlayerPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraSocketApply) == 0x000960, "Member 'UPlayerCameraComponent::bUniqueObjectCameraSocketApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraSocketPos) == 0x000964, "Member 'UPlayerCameraComponent::UniqueObjectCameraSocketPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraSocketLerp) == 0x000970, "Member 'UPlayerCameraComponent::bUniqueObjectCameraSocketLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraSocketLerpEnd) == 0x000971, "Member 'UPlayerCameraComponent::bUniqueObjectCameraSocketLerpEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraSocketLerpTimeStt) == 0x000974, "Member 'UPlayerCameraComponent::UniqueObjectCameraSocketLerpTimeStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraSocketLerpTimeEnd) == 0x000978, "Member 'UPlayerCameraComponent::UniqueObjectCameraSocketLerpTimeEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraSocketLerpRate) == 0x00097C, "Member 'UPlayerCameraComponent::UniqueObjectCameraSocketLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraControlType) == 0x000980, "Member 'UPlayerCameraComponent::bUniqueObjectCameraControlType' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraControlRot) == 0x000984, "Member 'UPlayerCameraComponent::UniqueObjectCameraControlRot' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraRemoteType) == 0x000990, "Member 'UPlayerCameraComponent::bUniqueObjectCameraRemoteType' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PUniqueObjectCameraRemoteActor) == 0x000994, "Member 'UPlayerCameraComponent::PUniqueObjectCameraRemoteActor' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraLookAtLerpApply) == 0x00099C, "Member 'UPlayerCameraComponent::bUniqueObjectCameraLookAtLerpApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraLookAtRate) == 0x0009A0, "Member 'UPlayerCameraComponent::UniqueObjectCameraLookAtRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraLookAtLerpTime) == 0x0009A4, "Member 'UPlayerCameraComponent::UniqueObjectCameraLookAtLerpTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraLookAtLerpTimer) == 0x0009A8, "Member 'UPlayerCameraComponent::UniqueObjectCameraLookAtLerpTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraLookAtDelayRate) == 0x0009AC, "Member 'UPlayerCameraComponent::UniqueObjectCameraLookAtDelayRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PUniqueObjectCameraEnemyActor) == 0x0009B8, "Member 'UPlayerCameraComponent::PUniqueObjectCameraEnemyActor' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraEnemyActorPos) == 0x0009C0, "Member 'UPlayerCameraComponent::UniqueObjectCameraEnemyActorPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PUniqueObjectCameraObjectActor) == 0x0009CC, "Member 'UPlayerCameraComponent::PUniqueObjectCameraObjectActor' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VUniqueObjectCameraLookAtPos) == 0x0009D4, "Member 'UPlayerCameraComponent::VUniqueObjectCameraLookAtPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraDistNear) == 0x0009E0, "Member 'UPlayerCameraComponent::bUniqueObjectCameraDistNear' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraDistRate) == 0x0009E4, "Member 'UPlayerCameraComponent::UniqueObjectCameraDistRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PUniqueObjectCameraLerpCurveStt) == 0x0009E8, "Member 'UPlayerCameraComponent::PUniqueObjectCameraLerpCurveStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PUniqueObjectCameraLerpCurveEnd) == 0x0009F0, "Member 'UPlayerCameraComponent::PUniqueObjectCameraLerpCurveEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraLerp) == 0x0009F8, "Member 'UPlayerCameraComponent::bUniqueObjectCameraLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraLerpEnd) == 0x0009F9, "Member 'UPlayerCameraComponent::bUniqueObjectCameraLerpEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraLerpEndInstance) == 0x0009FA, "Member 'UPlayerCameraComponent::bUniqueObjectCameraLerpEndInstance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraLerpTimer) == 0x0009FC, "Member 'UPlayerCameraComponent::UniqueObjectCameraLerpTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraLerpRate) == 0x000A00, "Member 'UPlayerCameraComponent::UniqueObjectCameraLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraPlayerLeft) == 0x000A94, "Member 'UPlayerCameraComponent::bUniqueObjectCameraPlayerLeft' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintUniqueObjectCamera) == 0x000A95, "Member 'UPlayerCameraComponent::bDebugPrintUniqueObjectCamera' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintUniqueObjectCameraPos) == 0x000A96, "Member 'UPlayerCameraComponent::bDebugPrintUniqueObjectCameraPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintUniqueObjectCameraPosLerp) == 0x000A97, "Member 'UPlayerCameraComponent::bDebugPrintUniqueObjectCameraPosLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintUniqueObjectCameraLookAt) == 0x000A98, "Member 'UPlayerCameraComponent::bDebugPrintUniqueObjectCameraLookAt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintUniqueObjectCameraRot) == 0x000A99, "Member 'UPlayerCameraComponent::bDebugPrintUniqueObjectCameraRot' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintUniqueObjectCameraFov) == 0x000A9A, "Member 'UPlayerCameraComponent::bDebugPrintUniqueObjectCameraFov' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintUniqueObjectCameraSocket) == 0x000A9B, "Member 'UPlayerCameraComponent::bDebugPrintUniqueObjectCameraSocket' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintUniqueObjectCameraControl) == 0x000A9C, "Member 'UPlayerCameraComponent::bDebugPrintUniqueObjectCameraControl' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugUniqueObjectCameraNewLookAt) == 0x000A9D, "Member 'UPlayerCameraComponent::bDebugUniqueObjectCameraNewLookAt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintUniqueObjectCameraLookAtRate) == 0x000A9E, "Member 'UPlayerCameraComponent::bDebugPrintUniqueObjectCameraLookAtRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawUniqueObjectCameraPos) == 0x000A9F, "Member 'UPlayerCameraComponent::bDebugDrawUniqueObjectCameraPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawUniqueObjectCameraPosLerp) == 0x000AA0, "Member 'UPlayerCameraComponent::bDebugDrawUniqueObjectCameraPosLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawUniqueObjectCameraLookAt) == 0x000AA1, "Member 'UPlayerCameraComponent::bDebugDrawUniqueObjectCameraLookAt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawUniqueObjectCameraTime) == 0x000AA4, "Member 'UPlayerCameraComponent::bDebugDrawUniqueObjectCameraTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawUniqueObjectCameraBgTrace) == 0x000AA8, "Member 'UPlayerCameraComponent::bDebugDrawUniqueObjectCameraBgTrace' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAttentionCameraApply) == 0x000AAC, "Member 'UPlayerCameraComponent::bAttentionCameraApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAttentionLerpStt) == 0x000AAD, "Member 'UPlayerCameraComponent::bAttentionLerpStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAttentionLerpEnd) == 0x000AAE, "Member 'UPlayerCameraComponent::bAttentionLerpEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAttentionActor) == 0x000AAF, "Member 'UPlayerCameraComponent::bAttentionActor' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VAttentionPos) == 0x000AB0, "Member 'UPlayerCameraComponent::VAttentionPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PAttentionActor) == 0x000ABC, "Member 'UPlayerCameraComponent::PAttentionActor' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PAttentionActorCurve) == 0x000AC8, "Member 'UPlayerCameraComponent::PAttentionActorCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAttentionActorFixAngleVt) == 0x000AD0, "Member 'UPlayerCameraComponent::bAttentionActorFixAngleVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, AttentionActorFixAngleVt) == 0x000AD4, "Member 'UPlayerCameraComponent::AttentionActorFixAngleVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAttentionActorOffsetDistHz) == 0x000AD8, "Member 'UPlayerCameraComponent::bAttentionActorOffsetDistHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, AttentionActorOffsetDistHz) == 0x000ADC, "Member 'UPlayerCameraComponent::AttentionActorOffsetDistHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, AttentionActorOffsetDistHzSign) == 0x000AE0, "Member 'UPlayerCameraComponent::AttentionActorOffsetDistHzSign' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAttentionFov) == 0x000AE4, "Member 'UPlayerCameraComponent::bAttentionFov' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PAttentionFovCurve) == 0x000AE8, "Member 'UPlayerCameraComponent::PAttentionFovCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, AttentionCameraLerpTime) == 0x000AF0, "Member 'UPlayerCameraComponent::AttentionCameraLerpTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, AttentionCameraLerpRate) == 0x000AF4, "Member 'UPlayerCameraComponent::AttentionCameraLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintAttentionCamera) == 0x000B10, "Member 'UPlayerCameraComponent::bDebugPrintAttentionCamera' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bPlayerLerpAuto) == 0x000B11, "Member 'UPlayerCameraComponent::bPlayerLerpAuto' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FPlayerLerpTraceAngleList) == 0x000B18, "Member 'UPlayerCameraComponent::FPlayerLerpTraceAngleList' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FPlayerLerpTraceDistance) == 0x000B28, "Member 'UPlayerCameraComponent::FPlayerLerpTraceDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FPlayerLerpDistance) == 0x000B2C, "Member 'UPlayerCameraComponent::FPlayerLerpDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bPlayerLerp) == 0x000B30, "Member 'UPlayerCameraComponent::bPlayerLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VPlayerLerpPosStt) == 0x000B34, "Member 'UPlayerCameraComponent::VPlayerLerpPosStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VPlayerLerpPosEnd) == 0x000B40, "Member 'UPlayerCameraComponent::VPlayerLerpPosEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FPlayerLerpRadius) == 0x000B4C, "Member 'UPlayerCameraComponent::FPlayerLerpRadius' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PPlayerLerpCurve) == 0x000B50, "Member 'UPlayerCameraComponent::PPlayerLerpCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PEnemyLerpActor) == 0x000B58, "Member 'UPlayerCameraComponent::PEnemyLerpActor' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FEnemyLerpDistance) == 0x000B60, "Member 'UPlayerCameraComponent::FEnemyLerpDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FEnemyLerpRateDefault) == 0x000B64, "Member 'UPlayerCameraComponent::FEnemyLerpRateDefault' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FEnemyLerpRate) == 0x000B68, "Member 'UPlayerCameraComponent::FEnemyLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FEnemyLerpRadius) == 0x000B6C, "Member 'UPlayerCameraComponent::FEnemyLerpRadius' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FPlayerPullDistance) == 0x000B70, "Member 'UPlayerCameraComponent::FPlayerPullDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FPlayerPullMoveDistMax) == 0x000B74, "Member 'UPlayerCameraComponent::FPlayerPullMoveDistMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bEnemyLerp) == 0x000B78, "Member 'UPlayerCameraComponent::bEnemyLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VEnemyLerpPosStt) == 0x000B7C, "Member 'UPlayerCameraComponent::VEnemyLerpPosStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VEnemyLerpPosEnd) == 0x000B88, "Member 'UPlayerCameraComponent::VEnemyLerpPosEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawPlayerLerpVector) == 0x000B94, "Member 'UPlayerCameraComponent::bDebugDrawPlayerLerpVector' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawPlayerLerpSphere) == 0x000B95, "Member 'UPlayerCameraComponent::bDebugDrawPlayerLerpSphere' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawEnemyLerpSphere) == 0x000B96, "Member 'UPlayerCameraComponent::bDebugDrawEnemyLerpSphere' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintEnemyLerpSphere) == 0x000B97, "Member 'UPlayerCameraComponent::bDebugPrintEnemyLerpSphere' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLerpReset) == 0x000B98, "Member 'UPlayerCameraComponent::bLerpReset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLerpUpdateAngleHz) == 0x000B99, "Member 'UPlayerCameraComponent::bLerpUpdateAngleHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bCameraReset) == 0x000B9A, "Member 'UPlayerCameraComponent::bCameraReset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLerpTime) == 0x000B9C, "Member 'UPlayerCameraComponent::FLerpTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLerpRate) == 0x000BA0, "Member 'UPlayerCameraComponent::FLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FCameraHitRadius) == 0x000BE4, "Member 'UPlayerCameraComponent::FCameraHitRadius' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FCameraHitRadiusPlane) == 0x000BE8, "Member 'UPlayerCameraComponent::FCameraHitRadiusPlane' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FCameraHitRadiusOffset) == 0x000BEC, "Member 'UPlayerCameraComponent::FCameraHitRadiusOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bCameraBuried) == 0x000BF0, "Member 'UPlayerCameraComponent::bCameraBuried' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDistSpeedAccel) == 0x000BF4, "Member 'UPlayerCameraComponent::FDistSpeedAccel' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDistSpeedMax) == 0x000BF8, "Member 'UPlayerCameraComponent::FDistSpeedMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDistSpeed) == 0x000BFC, "Member 'UPlayerCameraComponent::FDistSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawTraceCorner) == 0x000C00, "Member 'UPlayerCameraComponent::bDebugDrawTraceCorner' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawTraceCameraRoot) == 0x000C01, "Member 'UPlayerCameraComponent::bDebugDrawTraceCameraRoot' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawTraceCameraDistance) == 0x000C02, "Member 'UPlayerCameraComponent::bDebugDrawTraceCameraDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, AreaTriggerInfo) == 0x000C08, "Member 'UPlayerCameraComponent::AreaTriggerInfo' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, CurrentTriggerInfo) == 0x000C30, "Member 'UPlayerCameraComponent::CurrentTriggerInfo' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TriggerInfoList) == 0x000C58, "Member 'UPlayerCameraComponent::TriggerInfoList' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTriggerInfoLerp) == 0x000C68, "Member 'UPlayerCameraComponent::bTriggerInfoLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TriggerInfoLerpTimer) == 0x000C6C, "Member 'UPlayerCameraComponent::TriggerInfoLerpTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PTriggerInfoLerpCurve) == 0x000C70, "Member 'UPlayerCameraComponent::PTriggerInfoLerpCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TriggerInfoLerpTime) == 0x000C78, "Member 'UPlayerCameraComponent::TriggerInfoLerpTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PTriggerInfoLerpCurveDefault) == 0x000C80, "Member 'UPlayerCameraComponent::PTriggerInfoLerpCurveDefault' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TriggerInfoLerpTimeDefault) == 0x000C88, "Member 'UPlayerCameraComponent::TriggerInfoLerpTimeDefault' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTriggerInfoSkipLerp) == 0x000C8C, "Member 'UPlayerCameraComponent::bTriggerInfoSkipLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TriggerInfoSkipLerpRefList) == 0x000C90, "Member 'UPlayerCameraComponent::TriggerInfoSkipLerpRefList' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PresetBasic) == 0x000CA0, "Member 'UPlayerCameraComponent::PresetBasic' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PresetOffset) == 0x000D78, "Member 'UPlayerCameraComponent::PresetOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, CurrentPreset) == 0x000E50, "Member 'UPlayerCameraComponent::CurrentPreset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugNewTriggerEndLerp) == 0x000F28, "Member 'UPlayerCameraComponent::bDebugNewTriggerEndLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, NextTriggerInfo) == 0x001130, "Member 'UPlayerCameraComponent::NextTriggerInfo' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAssistRootHeight) == 0x001158, "Member 'UPlayerCameraComponent::bAssistRootHeight' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightDistYut) == 0x00115C, "Member 'UPlayerCameraComponent::FAssistRootHeightDistYut' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightDistKsn) == 0x001160, "Member 'UPlayerCameraComponent::FAssistRootHeightDistKsn' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightDistMax) == 0x001164, "Member 'UPlayerCameraComponent::FAssistRootHeightDistMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightDistRangeMin) == 0x001168, "Member 'UPlayerCameraComponent::FAssistRootHeightDistRangeMin' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightDistRangeMax) == 0x00116C, "Member 'UPlayerCameraComponent::FAssistRootHeightDistRangeMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightAngleYut) == 0x001170, "Member 'UPlayerCameraComponent::FAssistRootHeightAngleYut' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightAngleKsn) == 0x001174, "Member 'UPlayerCameraComponent::FAssistRootHeightAngleKsn' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightAngleMax) == 0x001178, "Member 'UPlayerCameraComponent::FAssistRootHeightAngleMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightAngleRangeMin) == 0x00117C, "Member 'UPlayerCameraComponent::FAssistRootHeightAngleRangeMin' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightAngleRangeMax) == 0x001180, "Member 'UPlayerCameraComponent::FAssistRootHeightAngleRangeMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDbDispAssistRootHeight) == 0x001184, "Member 'UPlayerCameraComponent::bDbDispAssistRootHeight' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAsyncRequestPrevProc) == 0x001204, "Member 'UPlayerCameraComponent::bAsyncRequestPrevProc' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAsyncRequestTaskProc) == 0x001205, "Member 'UPlayerCameraComponent::bAsyncRequestTaskProc' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAsyncTaskDone) == 0x001206, "Member 'UPlayerCameraComponent::bAsyncTaskDone' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, ActorMoveDistMin) == 0x001208, "Member 'UPlayerCameraComponent::ActorMoveDistMin' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, DbDrawTrace) == 0x0012B0, "Member 'UPlayerCameraComponent::DbDrawTrace' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintRootOffsetHz) == 0x0012B1, "Member 'UPlayerCameraComponent::bDebugPrintRootOffsetHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawTraceRootOffsetHz) == 0x0012B2, "Member 'UPlayerCameraComponent::bDebugDrawTraceRootOffsetHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDbTemp0) == 0x0012B3, "Member 'UPlayerCameraComponent::bDbTemp0' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDbTemp1) == 0x0012B4, "Member 'UPlayerCameraComponent::bDbTemp1' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDbTemp2) == 0x0012B5, "Member 'UPlayerCameraComponent::bDbTemp2' has a wrong offset!");

// Class BattlePrototype.BP_UI_SceneMap
// 0x02F0 (0x0520 - 0x0230)
class alignas(0x10) ABP_UI_SceneMap : public AActor
{
public:
	struct FVector                                ObjectIconScale;                                   // 0x0230(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugCameraPers;                                   // 0x023C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D[0x3];                                      // 0x023D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ViewModeCameraLocation;                            // 0x0240(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ViewModeViewLocation;                              // 0x024C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewModeZoom;                                      // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapGradationValue;                                 // 0x025C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapHeightValue;                                    // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_FootPrintSpanNormal;                             // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_FootPrintSpanExtent;                             // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_FootPrintSpanMax;                                // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_FootPrintStop;                                   // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_CameraHeight;                                    // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_CameraOrthoWidth;                                // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_CameraRotatePitch;                               // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_RotateCamera;                                    // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_CameraRoll;                                      // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_CameraRollBase;                                  // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsScaleFlag;                                       // 0x028C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCameraRotateFlag;                                // 0x028D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDetailMap;                                       // 0x028E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_IsPerspective;                                   // 0x028F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_AreaMax;                                         // 0x0290(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_FloorMax;                                        // 0x0294(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_CurrentFloor;                                    // 0x0298(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_CurrentArea;                                     // 0x029C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_CurrentLevel;                                    // 0x02A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentFloorPlayer;                                // 0x02A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentAreaPlayer;                                 // 0x02A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentFloorMain;                                  // 0x02AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentFloorSub;                                   // 0x02B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentFloorBonds;                                 // 0x02B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_CurrentIndex;                                    // 0x02B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_ChapterNo;                                       // 0x02BC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_ProgressNo;                                      // 0x02C0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIDetaileMapFloorData>         M_FloorData;                                       // 0x02C8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TDelegate<void(int32 Floor)>                  M_OnMinimapChangeFloor;                            // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             M_MaterialIconArray;                               // 0x02E8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       M_MaterialDynamicIconArray;                        // 0x02F8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_minimapDistanceSquareEnemy;                      // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ABP_SM_MapModel_Base*                   M_SM_MapModel_Base;                                // 0x0310(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           M_MeshList;                                        // 0x0318(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUIDetaileMapCheckData                 M_DetailMapData;                                   // 0x0328(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x30];                                     // 0x0350(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_AsyncLineActor;                                  // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_388[0xC0];                                     // 0x0388(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	class URSGameInstance*                        Instance;                                          // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEnemyManager*                          EnemyManager;                                      // 0x0450(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerCameraManager*                   CameraManager;                                     // 0x0458(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEventManager*                          EventManager;                                      // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneCaptureComponent2D*               CaptureCamera;                                     // 0x0468(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APawn*                                  M_player;                                          // 0x0470(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          ObjectInstancedMesh;                               // 0x0478(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          NpcPlInstancedMesh;                                // 0x0480(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          EnemyInstancedMeshNormal;                          // 0x0488(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          EnemyInstancedMesh0630;                            // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          FootInstancedMesh;                                 // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          MainQuestInstancedMesh;                            // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          SubQuestActiveInstancedMesh;                       // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          SubQuestCompActiveInstancedMesh;                   // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          BoudsQuestInstancedMesh;                           // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APsychicObjectManager*                  PsychicObjectManager;                              // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerManager*                         PlayerManager;                                     // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ARSCharacterBase>> PlayerCharacterList;                               // 0x04D0(0x0010)(ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ARSCharacterBase*>               M_EnemyList;                                       // 0x04E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FTransform>                     M_PlPosDataListNormal;                             // 0x04F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FTransform>                     M_PlPosDataListExtent;                             // 0x0500(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARSHUDBase*                             M_pHudBase;                                        // 0x0510(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_518[0x8];                                      // 0x0518(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BgModelLoadNextAreaNative(int32* Area, int32* Lc);
	void BgModelLoadPreviousAreaNative(int32* Area, int32* Lc);
	struct FVector CalcMapIconLocation(EUIMapIconNative Type, const struct FVector& InputLocation, float AddZ);
	bool Camera_UpdateDetailMap();
	bool CameraSetPerspectiveNative(bool Isperspective);
	void CameraUpdateMinimapPerspective();
	bool DebugUpdateIcon();
	bool End();
	void EndMinimapBrainField();
	void EnemyIconInit(class UInstancedStaticMeshComponent* InstancedMeshNormal, class UInstancedStaticMeshComponent* InstancedMesh0630, float Square);
	void EnemyIconUpdate();
	int32 GetAreaMax(class FName AssetClass, class FName AssetDataPath);
	float GetCameraRoll();
	float GetCameraRollBase();
	int32 GetCurrentAreaPlayer();
	int32 GetCurrentFloorBonds();
	int32 GetCurrentFloorMain();
	int32 GetCurrentFloorPlayer();
	int32 GetCurrentFloorSub();
	class AEventManager* GetEventManager();
	int32 GetFloorIndexCore(float Floorrate);
	int32 GetFloorIndexCore2(float Floorrate, bool Detail);
	class FName GetGimmickActorName(class AActor* Actor);
	class AActor* GetIconAdjustVector(TSubclassOf<class AActor> ActorClass, class FName FindName);
	class UInstancedStaticMeshComponent* GetInstanceMeshBondsQuest();
	class UInstancedStaticMeshComponent* GetInstanceMeshMainQuest();
	class UInstancedStaticMeshComponent* GetInstanceMeshSubQuestActive();
	class UInstancedStaticMeshComponent* GetInstanceMeshSubQuestCompActive();
	struct FVector GetLineTraceActorLocation();
	class UMaterialInstanceDynamic* GetMaterialInstanceNative(EUIMapIconNative IconTypeNatice);
	TSubclassOf<class AStaticMeshActor> GetMeshClassRefalence(const class FString& Path);
	TArray<class ANpcTownPeople*> GetMinimapNpcList();
	EQuestProgressState GetQuestInfoState(const class FName& QuestId);
	float GetRateData(const struct FVector& Inputpos);
	float GetRotateCamera();
	class ASceneManager* GetSceneManager();
	void InitializeMaterialNative();
	void InitializePlayerFootIconArray();
	void InstanceObjInit(class UInstancedStaticMeshComponent* Mainquest, class UInstancedStaticMeshComponent* SubquestActive, class UInstancedStaticMeshComponent* SubquestCompActive, class UInstancedStaticMeshComponent* boudsquest);
	bool IsActorTick();
	bool IsAysncLocation();
	bool IsBrainField();
	bool IsCheckFlag(const struct FUIDetaileMapCheckCoreData& Data);
	bool IsCheckProg(const struct FUIDetaileMapCheckCoreData& Data);
	void NpcPlayerInit(class UInstancedStaticMeshComponent* InstancedMesh);
	void NpcPlayerUpdate();
	void OnEnemyListUpdate();
	void PlayerFootIconInit(class UInstancedStaticMeshComponent* InstancedMesh);
	void PlayerFootIconUpdate();
	void PsychicObjInit(class UInstancedStaticMeshComponent* InstancedMesh, float Square);
	void PsychicObjUpdate();
	bool QuestIconInit_Native();
	void SceneCaptureCameraInit(class USceneCaptureComponent2D* PCamera);
	void SetBrainField(bool Flag);
	void SetChapterNoIndex(int32 No);
	void SetCurrentIndex(int32 Index_0);
	void SetDetailMapData(const struct FUIDetaileMapCheckData& Data, int32 Initareano);
	void SetIconUpdateFlag(bool Flag);
	void SetMapGradation(float Gradation);
	void SetMapHeight(float Height);
	void SetProgressNo(int32 Progress);
	void SetSubModel();
	void SetWantsTraceRequest(class AActor* Actor, bool Flag);
	bool Start();
	void StartMinimapBrainField();
	void UpdateDetailmapCalc();
	void UpdateMaterialCalc(float Rate, bool Update);
	void UpdateMinimapCalc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BP_UI_SceneMap">();
	}
	static class ABP_UI_SceneMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABP_UI_SceneMap>();
	}
};
static_assert(alignof(ABP_UI_SceneMap) == 0x000010, "Wrong alignment on ABP_UI_SceneMap");
static_assert(sizeof(ABP_UI_SceneMap) == 0x000520, "Wrong size on ABP_UI_SceneMap");
static_assert(offsetof(ABP_UI_SceneMap, ObjectIconScale) == 0x000230, "Member 'ABP_UI_SceneMap::ObjectIconScale' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, DebugCameraPers) == 0x00023C, "Member 'ABP_UI_SceneMap::DebugCameraPers' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, ViewModeCameraLocation) == 0x000240, "Member 'ABP_UI_SceneMap::ViewModeCameraLocation' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, ViewModeViewLocation) == 0x00024C, "Member 'ABP_UI_SceneMap::ViewModeViewLocation' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, ViewModeZoom) == 0x000258, "Member 'ABP_UI_SceneMap::ViewModeZoom' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, MapGradationValue) == 0x00025C, "Member 'ABP_UI_SceneMap::MapGradationValue' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, MapHeightValue) == 0x000260, "Member 'ABP_UI_SceneMap::MapHeightValue' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_FootPrintSpanNormal) == 0x000264, "Member 'ABP_UI_SceneMap::M_FootPrintSpanNormal' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_FootPrintSpanExtent) == 0x000268, "Member 'ABP_UI_SceneMap::M_FootPrintSpanExtent' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_FootPrintSpanMax) == 0x00026C, "Member 'ABP_UI_SceneMap::M_FootPrintSpanMax' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_FootPrintStop) == 0x000270, "Member 'ABP_UI_SceneMap::M_FootPrintStop' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_CameraHeight) == 0x000274, "Member 'ABP_UI_SceneMap::M_CameraHeight' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_CameraOrthoWidth) == 0x000278, "Member 'ABP_UI_SceneMap::M_CameraOrthoWidth' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_CameraRotatePitch) == 0x00027C, "Member 'ABP_UI_SceneMap::M_CameraRotatePitch' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_RotateCamera) == 0x000280, "Member 'ABP_UI_SceneMap::M_RotateCamera' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_CameraRoll) == 0x000284, "Member 'ABP_UI_SceneMap::M_CameraRoll' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_CameraRollBase) == 0x000288, "Member 'ABP_UI_SceneMap::M_CameraRollBase' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, IsScaleFlag) == 0x00028C, "Member 'ABP_UI_SceneMap::IsScaleFlag' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, IsCameraRotateFlag) == 0x00028D, "Member 'ABP_UI_SceneMap::IsCameraRotateFlag' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, IsDetailMap) == 0x00028E, "Member 'ABP_UI_SceneMap::IsDetailMap' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_IsPerspective) == 0x00028F, "Member 'ABP_UI_SceneMap::M_IsPerspective' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_AreaMax) == 0x000290, "Member 'ABP_UI_SceneMap::M_AreaMax' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_FloorMax) == 0x000294, "Member 'ABP_UI_SceneMap::M_FloorMax' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_CurrentFloor) == 0x000298, "Member 'ABP_UI_SceneMap::M_CurrentFloor' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_CurrentArea) == 0x00029C, "Member 'ABP_UI_SceneMap::M_CurrentArea' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_CurrentLevel) == 0x0002A0, "Member 'ABP_UI_SceneMap::M_CurrentLevel' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, CurrentFloorPlayer) == 0x0002A4, "Member 'ABP_UI_SceneMap::CurrentFloorPlayer' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, CurrentAreaPlayer) == 0x0002A8, "Member 'ABP_UI_SceneMap::CurrentAreaPlayer' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, CurrentFloorMain) == 0x0002AC, "Member 'ABP_UI_SceneMap::CurrentFloorMain' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, CurrentFloorSub) == 0x0002B0, "Member 'ABP_UI_SceneMap::CurrentFloorSub' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, CurrentFloorBonds) == 0x0002B4, "Member 'ABP_UI_SceneMap::CurrentFloorBonds' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_CurrentIndex) == 0x0002B8, "Member 'ABP_UI_SceneMap::M_CurrentIndex' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_ChapterNo) == 0x0002BC, "Member 'ABP_UI_SceneMap::M_ChapterNo' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_ProgressNo) == 0x0002C0, "Member 'ABP_UI_SceneMap::M_ProgressNo' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_FloorData) == 0x0002C8, "Member 'ABP_UI_SceneMap::M_FloorData' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_OnMinimapChangeFloor) == 0x0002D8, "Member 'ABP_UI_SceneMap::M_OnMinimapChangeFloor' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_MaterialIconArray) == 0x0002E8, "Member 'ABP_UI_SceneMap::M_MaterialIconArray' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_MaterialDynamicIconArray) == 0x0002F8, "Member 'ABP_UI_SceneMap::M_MaterialDynamicIconArray' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_minimapDistanceSquareEnemy) == 0x000308, "Member 'ABP_UI_SceneMap::M_minimapDistanceSquareEnemy' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_SM_MapModel_Base) == 0x000310, "Member 'ABP_UI_SceneMap::M_SM_MapModel_Base' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_MeshList) == 0x000318, "Member 'ABP_UI_SceneMap::M_MeshList' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_DetailMapData) == 0x000328, "Member 'ABP_UI_SceneMap::M_DetailMapData' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_AsyncLineActor) == 0x000380, "Member 'ABP_UI_SceneMap::M_AsyncLineActor' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, Instance) == 0x000448, "Member 'ABP_UI_SceneMap::Instance' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, EnemyManager) == 0x000450, "Member 'ABP_UI_SceneMap::EnemyManager' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, CameraManager) == 0x000458, "Member 'ABP_UI_SceneMap::CameraManager' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, EventManager) == 0x000460, "Member 'ABP_UI_SceneMap::EventManager' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, CaptureCamera) == 0x000468, "Member 'ABP_UI_SceneMap::CaptureCamera' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_player) == 0x000470, "Member 'ABP_UI_SceneMap::M_player' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, ObjectInstancedMesh) == 0x000478, "Member 'ABP_UI_SceneMap::ObjectInstancedMesh' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, NpcPlInstancedMesh) == 0x000480, "Member 'ABP_UI_SceneMap::NpcPlInstancedMesh' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, EnemyInstancedMeshNormal) == 0x000488, "Member 'ABP_UI_SceneMap::EnemyInstancedMeshNormal' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, EnemyInstancedMesh0630) == 0x000490, "Member 'ABP_UI_SceneMap::EnemyInstancedMesh0630' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, FootInstancedMesh) == 0x000498, "Member 'ABP_UI_SceneMap::FootInstancedMesh' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, MainQuestInstancedMesh) == 0x0004A0, "Member 'ABP_UI_SceneMap::MainQuestInstancedMesh' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, SubQuestActiveInstancedMesh) == 0x0004A8, "Member 'ABP_UI_SceneMap::SubQuestActiveInstancedMesh' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, SubQuestCompActiveInstancedMesh) == 0x0004B0, "Member 'ABP_UI_SceneMap::SubQuestCompActiveInstancedMesh' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, BoudsQuestInstancedMesh) == 0x0004B8, "Member 'ABP_UI_SceneMap::BoudsQuestInstancedMesh' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, PsychicObjectManager) == 0x0004C0, "Member 'ABP_UI_SceneMap::PsychicObjectManager' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, PlayerManager) == 0x0004C8, "Member 'ABP_UI_SceneMap::PlayerManager' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, PlayerCharacterList) == 0x0004D0, "Member 'ABP_UI_SceneMap::PlayerCharacterList' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_EnemyList) == 0x0004E0, "Member 'ABP_UI_SceneMap::M_EnemyList' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_PlPosDataListNormal) == 0x0004F0, "Member 'ABP_UI_SceneMap::M_PlPosDataListNormal' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_PlPosDataListExtent) == 0x000500, "Member 'ABP_UI_SceneMap::M_PlPosDataListExtent' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_pHudBase) == 0x000510, "Member 'ABP_UI_SceneMap::M_pHudBase' has a wrong offset!");

// Class BattlePrototype.MakeEventActor
// 0x01D8 (0x0408 - 0x0230)
class AMakeEventActor : public AActor
{
public:
	TDelegate<void()>                             OnEvent;                                           // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           CharaPresetNameList;                               // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           TextureRowNameList;                                // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           MovieTextureRowNameList;                           // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           AnimAssetPathList;                                 // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           AnimBPPathList;                                    // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EEventPostProcessID>                   EventPostProcessIDList;                            // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSkip;                                            // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActiveBPEvent;                                   // 0x02A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStaticToInGame;                                   // 0x02A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStoreSequencerInGameTransform;                    // 0x02A3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerActor;                                        // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkipUnableSpaceString;                             // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_InterludeID;                                     // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          SkipMessageSE;                                     // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_isWait;                                          // 0x02D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEventWaitMode                                M_waitMode;                                        // 0x02D1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D2[0x2];                                      // 0x02D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_waitSecond;                                      // 0x02D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      M_PlayerController;                                // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_IsEndMotion;                                     // 0x02E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                M_AnimationActor;                                  // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isStartDynamicCutscene;                          // 0x02F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isCallSkipMessage;                               // 0x02F9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FA[0x6];                                      // 0x02FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pWaitAnimMontageActor;                           // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           M_pWaitAnimMontageMontage;                         // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEventAsset*                            M_pWaitLoadAsset;                                  // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EStoreSeqCapStatus                            M_StoreSeqCapStatus;                               // 0x0318(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESequenceSkipPhase                            M_SequenceSkipPhase;                               // 0x0319(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_IsStopBoadMotion;                                // 0x031A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_IsSkipLatentNode;                                // 0x031B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_bInputOnSkipLatentNode;                          // 0x031C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31D[0x3];                                      // 0x031D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AMainEventLatentActor*                  M_Latenter;                                        // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsKeyDown;                                         // 0x0328(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_329[0x3];                                      // 0x0329(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KeyDownTime;                                       // 0x032C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_IsOrWaitInput;                                   // 0x0330(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsCurrentStaticEvent;                              // 0x0331(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_332[0x6];                                      // 0x0332(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UAnimationAsset*>     M_PreLoadAnimationMap;                             // 0x0338(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, class UClass*>              M_PreLoadAnimationBPMap;                           // 0x0388(0x0050)(NativeAccessSpecifierPrivate)
	class UCurveFloat*                            M_PreLoadCurveFloat[0x3];                          // 0x03D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInterface*>             M_PreLoadPPMList;                                  // 0x03F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBoardAnimation(int32 CaptureActorIndex, const class FString& BoardAnimNamePath, bool IsLoop);
	void AddBoardBGAnimation(const class FString& BoardAnimNamePath, bool IsLoop);
	void AddBondsLevel(EPlayerID HeroID, EPlayerID PartnerId, int32 AddNum);
	void AddBondsValue(EPlayerID HeroID, EPlayerID PartnerId, float AddNum);
	void BGEffectFringe(class UCurveFloat* Curve, bool IsLoop);
	void BGEffectGlitch(class UCurveFloat* Curve, bool IsLoop);
	void BGEffectNoise(class UCurveFloat* Curve, bool IsLoop);
	void BGEffectScanline(class UCurveFloat* Curve, bool IsLoop);
	void BoardEffectAnimationAlpha(int32 CaptureActorIndex, float Time, float Start, float End, class UCurveFloat* Curve, bool Loop);
	void CaptureScene(int32 CaptureActorIndex);
	void CaptureSceneBG(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void CaptureSceneBGForLevelSequencerAndDelay(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, class ULevelSequence* CaptureSequence, float CaptureSequencePosition);
	void ChangeMainPlayer();
	void ChangePlayerFromClass(ERSPartyPlayerKind PartyPlayerType, TSoftClassPtr<class UClass> CharacterClass);
	void ChangePresetCamera(const struct FCameraTriggerInfo& TriggerInfo, bool bLerp);
	bool CheckBondsLevelUp(EPlayerID PlayerId, EPlayerID TargetID);
	int32 CheckSubQuestRewardResult();
	void CloseForceUITutoOperation();
	void CloseScarletLogo();
	void CloseUITutoOperation(class FName ClosehelpTutoID);
	void CloseUITutoTips();
	bool DisableEventBattlefieldFence(int32 FenceGroupID);
	int32 DrawChoiceMessage(const class FString& Choice1, const class FString& Choice2, const class FString& Choice3, const class FString& Choice4, const class FString& Choice5, int32 DefaultCursor, float DrawSecond);
	void DrawGeneralChoice1(ETextType TextType, class FName TextMain, class FName Choice1, bool IsCancelable);
	void DrawGeneralChoice2(ETextType TextType, class FName TextMain, int32 DefaultCursor, class FName Choice1, class FName Choice2, bool IsCancelable);
	void DrawGeneralChoice3(ETextType TextType, class FName TextMain, int32 DefaultCursor, class FName Choice1, class FName Choice2, class FName Choice3, bool IsCancelable);
	void DrawGeneralChoice4(ETextType TextType, class FName TextMain, int32 DefaultCursor, class FName Choice1, class FName Choice2, class FName Choice3, class FName Choice4, bool IsCancelable);
	void DrawMessage(int32 WindowType, const class FString& MessageLabel, class FName RipSyncBoardJointID, bool Skipable, float DrawSecond, bool IsSkipVoiceEnd, bool IsVoiceOnlyMessage);
	void EffectBokeh(int32 CaptureActorIndex, class UCurveFloat* Curve, bool CurveReverse);
	bool EnableEventBattlefieldFence(int32 FenceGroupID);
	void EndBattlefieldForce(int32 GroupID);
	void EndCutScene(bool IsEndEvent, float PlayerCameraBlendTime, EViewTargetBlendFunction PlayerCameraBlendFunc, float PlayerCameraBlendExp, class FName SkipENPCCamRowName);
	bool EndEventBattlefield(int32 GroupID, bool ForceCloseFence);
	void EndFade(float FadeSeconds, bool IsUnderCaption);
	void EndHighSpeedMode();
	void EndTalkEvent(bool IsRestoreTransform);
	void EventAllManagerEnd(bool RestoreTickEnable, bool RestoreVisibility);
	void EventAllManagerStart(bool TickEnable, bool Visibility);
	void FinishSubQuest(bool NoCheck, bool UiEffectFlag);
	void FinishSubQuestById(class FName SubQuestID, bool NoCheck, bool UiEffectFlag);
	void FinishUIEffectBondsQuest(class FName bondsQuestId);
	void FinishUIEffectSubQuest(class FName SubQuestID);
	float GetBondsFValue(EPlayerID HeroID, EPlayerID PartnerId);
	int32 GetBondsLevel(EPlayerID HeroID, EPlayerID PartnerId);
	int32 GetBondsProgress(EPlayerID HeroID, EPlayerID PartnerId);
	int32 GetBondsValue(EPlayerID HeroID, EPlayerID PartnerId);
	int32 GetChoiceResult(int32 MessageIndex);
	const struct FBattlefieldInfo GetCurrentBattlefieldInfo();
	int32 GetEnemyNumInGroup(int32 GroupID);
	int32 GetEnemyNumInSubGroup(int32 GroupID, int32 SubGroupID);
	int32 GetGeneralChoiceResult();
	int32 GetLastChoiceResult();
	class FString GetMessageForMessageLabel(const class FString& MessageLabel);
	class FName GetResultCode();
	class FString GetResultKeyword();
	bool IsCanceledCode();
	bool IsCancelKeyword();
	bool IsSavedSaveLoadMenu();
	bool IsSavedSaveLoadMenuError();
	bool IsSeamlessStart();
	bool IsStartBattlefield(int32 GroupID);
	bool IsWaitEndSASCutinCh0400_0600();
	bool IsWaitEndSASCutinCh0500_0700();
	int32 LC21ChangePhase(int32 PhaseNo);
	void LoadMessage(const class FString& MessageDataPath, bool PreLoad);
	void LockInputSubMenu();
	void NPCLookAtPlayer(bool IsLookAt);
	void NPCPlayAnimation(const ENpcAnimationKind AnimKind);
	void NPCTurnToPlayer(float Speed);
	void OffSkipLatentNodeFlag();
	void OffSkipUnableFlag();
	void OnFinishEvent();
	void OnSkipUnableFlag();
	void OnStartEvent();
	void OnStartGameEventNative();
	void OpenEventBrainFieldTuto();
	void OpenScarletLogo();
	void PlayBoardAnimation(int32 CaptureActorIndex, const class FString& BoardAnimNamePath, bool IsLoop, class FName SocketName, TSoftObjectPtr<class UCurveFloat> PlayRateCurveData);
	void PlayBoardBGAnimation(const class FString& BoardAnimNamePath, bool IsLoop);
	void PlayGeneralBoardAnimation(int32 CaptureActorIndex, const class FString& boardAnimationName, int32 AttachCaptureActorIndex, class UAnimMontage* AddAnimMontage, TSoftObjectPtr<class UCurveFloat> PlayRateCurveData);
	void PreLoadAllVoice();
	void RequestChangeScene(int32 LocationId, int32 AreaId, int32 PortalID, class FName StartPortalName, bool NoFade, ELoadingScreenType LoadingScreenType, int32 LoadingScreenParam, bool IsAutoSaveEnable);
	void RestartUpdatingBrainMessage();
	void SaveLoad(EEventSaveLoadType SaveType, EEventSaveLoadExType Mode);
	void SetActionIconType(bool NeedKizunaIcon);
	void SetActiveSubQuest(class FName SubQuestID);
	void SetAnimationActor(class UObject* Object);
	void SetBondsProgress(EPlayerID HeroID, EPlayerID PartnerId, int32 SetValue, bool NotUpdateBrainMes);
	void SetBondsQuestState(class FName bondsQuestId, EQuestProgressState SetState);
	void SetDirectionalLight(class FName LightPresetName);
	void SetEventMovieTextureAndPrepare(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, class UManaTexture* MovieTexture);
	void SetEventPause(bool IsPause);
	void SetIsEndMotion(bool IsEndMotion);
	void SetIsWaitFlag(bool IsWait);
	void SetPlayBattleUI(bool IsVisible);
	void SetPlayerController(class APlayerController* PlayerController);
	void SetStopBoadMotionFlag(bool IsStop);
	void SetSubQuestState(class FName SubQuestID, EQuestProgressState SetState);
	void SettingCapture(int32 CaptureActorIndex, int32 BoardMeshIndex, class FName CapturePresetName, class FName CharaBodyAnimationSectionName, class FName CharaFaceAnimationSectionName, int32 NpcMeshTableID, int32 NpcMaterialTableID, class FName LightPresetName, class ULevelSequence* CaptureSequnece, float CaptureSequnecePositon, class FName TextureRowName, EStaticPlType StaticPlType, class FName MovieTextureRowName, bool IsUseSaveTexture, bool IsSeamlessInGameCapture, bool IsHiddenPlFrameEffect, class FName CharaEyePresetName, float EyeXAxisThreshold, float EyeYAxisThreshold, const class FString& CharaPartsMontagePath);
	void SetTransformCaptureBG(const struct FTransform& Transform);
	void SetTransformCaptureBGCamera(const struct FTransform& Transform);
	void Shop(EEventShopType ShopType, int32 ShopParam, int32 TradeShopParam);
	void SkipEvent();
	void SkipMessage(bool NoPlaySE);
	void SpawnEnemiesByGroup(int32 GroupID);
	void SpawnEnemiesBySubGroup(int32 GroupID, int32 SubGroupID);
	void StartAutoBoardAnimation(int32 CaptureActorIndex, const class FString& BoardAnimNamePath, class UAnimMontage* AddAnimMontage, EStaticPlType StaticPlType, TSoftObjectPtr<class UCurveFloat> PlayRateCurveData);
	bool StartBattlefield(EBattlefieldEventType Type, int32 GroupID, int32 SubGroupID, const TArray<struct FBattlefieldTutorialInfo>& AdditionalTutorialInfo, TSubclassOf<class AMakeEventActor> MakeEventActorClass, int32 TutorialGroupID, int32 TutorialSubGroupID, float FenceBattleRate, const class FString& SeedString, bool IsOnceBattle);
	void StartBondsQuestById(class FName bondsQuestId, bool NoCheck, bool UiEffectFlag);
	void StartCode();
	void StartDynamicCutscene(class ULevelSequence* Sequence, bool IsSeamlessInGame, class FName OwnerShipExternalActorTag);
	void StartEvent();
	bool StartEventBattlefield(int32 GroupID, int32 SubGroupID);
	void StartFade(float FadeSeconds, float ColorR, float ColorG, float ColorB, float ColorA, bool IsUnderCaption);
	void StartFadeIn(float FadeSeconds, float ColorR, float ColorG, float ColorB, float ColorA, bool IsUnderCaption);
	void StartFadeOut(float FadeSeconds, float ColorR, float ColorG, float ColorB, float ColorA, bool IsUnderCaption);
	void StartHighSpeedMode();
	void StartKeyword();
	void StartSubQuest(bool NoCheck, bool UiEffectFlag);
	void StartSubQuestById(class FName SubQuestID, bool NoCheck, bool UiEffectFlag);
	void StartTalkEvent(bool IsAutoInput);
	void StartUIEffectBondsQuest(class FName bondsQuestId);
	void StartUIEffectSubQuest(class FName SubQuestID);
	void StartUIRewardSubQuest(class FName SubQuestID);
	void StartUITutoOperation(class FName HelpTutoID);
	void StartUITutoTips(class FName HelpTutoID);
	void StartUITutoTipsByID(EHelpTutorial HelpTutoID, bool NotPauseControll, bool NotCloseOfPause);
	void StartupCutscene(bool IsPartyPlayerBattleReady, bool IsENPCBattleReady, bool PreLoad);
	void StaticEventEnd(bool IsRestoreTransform);
	void StaticEventStart();
	void StoreSequencerInGameTransform(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, class ULevelSequence* Sequnece, float SequencePosition);
	void UnloadMessage();
	void UnLockInputSubMenu();
	bool UpdateBondsLevel(EPlayerID PlayerId, EPlayerID TargetID, bool IsSingleLvUp);
	void UpdateBondsLevelAllMembers(EPlayerID PlayerId, TArray<EPlayerID>* LevelupMembers, bool IsSingleLvUp);
	void UpdateTownPeopleSubQuestState();
	void WaitBoardAnimation(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, int32 CaptureActorIndex);
	void WaitBoardBGAnimation(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitBrainField(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitBrainFieldButton(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitBrainFieldDangerLV(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, EPlayerBrainFieldDanger DangerLvType);
	void WaitCharacterEventMoveEnd(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitCloseSystemMessage(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitDelayOrInput(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, float Duration, bool OnSkipLatentNodeFlag);
	void WaitDynamicCutscene(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitEndBrainTalk(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitEndCode(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitEndCreditEvent(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitEndKeyword(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitEndSubMenu(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitEventBrainFieldTuto(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitEventTips(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitFade(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitGeneralChoice(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitInput(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitLoadAssetAll(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitLoadChangeScene(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitLoadingInterlude(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, const TDelegate<void(class AMainEventLatentActor* Latenter)> OnEventDispatcher, int32 ID);
	void WaitLoadMakeEventAsset(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitLogMessage(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitMainEvent(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, const TDelegate<void(class AMainEventLatentActor* Latenter)> OnEventDispatcher);
	void WaitMessage(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitMipLoadReady(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, float TimeLimitSeconds);
	void WaitMipLoadReadyMesh(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, class FName MeshName, float TimeLimitSeconds);
	void WaitNewStaticInGeneralAnimation(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitPhaseAnimation(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, bool IsOrWaitInput, bool OnSkipLatentNodeFlag);
	void WaitPostProcessSequencer(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitSASCutinCh0400_0600(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitSASCutinCh0500_0700(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitSASCutinExtra(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitSasWindow(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitSaveLoad(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitShop(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitSubQuestReward(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitTutoTips(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);

	const EQuestProgressState GetBondsQuestProgressById(class FName bondsQuestId) const;
	const EQuestProgressState GetSubQuestProgress() const;
	const EQuestProgressState GetSubQuestProgressById(class FName SubQuestID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MakeEventActor">();
	}
	static class AMakeEventActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMakeEventActor>();
	}
};
static_assert(alignof(AMakeEventActor) == 0x000008, "Wrong alignment on AMakeEventActor");
static_assert(sizeof(AMakeEventActor) == 0x000408, "Wrong size on AMakeEventActor");
static_assert(offsetof(AMakeEventActor, OnEvent) == 0x000230, "Member 'AMakeEventActor::OnEvent' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, CharaPresetNameList) == 0x000240, "Member 'AMakeEventActor::CharaPresetNameList' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, TextureRowNameList) == 0x000250, "Member 'AMakeEventActor::TextureRowNameList' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, MovieTextureRowNameList) == 0x000260, "Member 'AMakeEventActor::MovieTextureRowNameList' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, AnimAssetPathList) == 0x000270, "Member 'AMakeEventActor::AnimAssetPathList' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, AnimBPPathList) == 0x000280, "Member 'AMakeEventActor::AnimBPPathList' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, EventPostProcessIDList) == 0x000290, "Member 'AMakeEventActor::EventPostProcessIDList' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, IsSkip) == 0x0002A0, "Member 'AMakeEventActor::IsSkip' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, IsActiveBPEvent) == 0x0002A1, "Member 'AMakeEventActor::IsActiveBPEvent' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, bStaticToInGame) == 0x0002A2, "Member 'AMakeEventActor::bStaticToInGame' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, bStoreSequencerInGameTransform) == 0x0002A3, "Member 'AMakeEventActor::bStoreSequencerInGameTransform' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, OwnerActor) == 0x0002A8, "Member 'AMakeEventActor::OwnerActor' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, SkipUnableSpaceString) == 0x0002B0, "Member 'AMakeEventActor::SkipUnableSpaceString' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_InterludeID) == 0x0002C0, "Member 'AMakeEventActor::M_InterludeID' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, SkipMessageSE) == 0x0002C8, "Member 'AMakeEventActor::SkipMessageSE' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_isWait) == 0x0002D0, "Member 'AMakeEventActor::M_isWait' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_waitMode) == 0x0002D1, "Member 'AMakeEventActor::M_waitMode' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_waitSecond) == 0x0002D4, "Member 'AMakeEventActor::M_waitSecond' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_PlayerController) == 0x0002E0, "Member 'AMakeEventActor::M_PlayerController' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_IsEndMotion) == 0x0002E8, "Member 'AMakeEventActor::M_IsEndMotion' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_AnimationActor) == 0x0002F0, "Member 'AMakeEventActor::M_AnimationActor' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_isStartDynamicCutscene) == 0x0002F8, "Member 'AMakeEventActor::M_isStartDynamicCutscene' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_isCallSkipMessage) == 0x0002F9, "Member 'AMakeEventActor::M_isCallSkipMessage' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_pWaitAnimMontageActor) == 0x000300, "Member 'AMakeEventActor::M_pWaitAnimMontageActor' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_pWaitAnimMontageMontage) == 0x000308, "Member 'AMakeEventActor::M_pWaitAnimMontageMontage' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_pWaitLoadAsset) == 0x000310, "Member 'AMakeEventActor::M_pWaitLoadAsset' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_StoreSeqCapStatus) == 0x000318, "Member 'AMakeEventActor::M_StoreSeqCapStatus' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_SequenceSkipPhase) == 0x000319, "Member 'AMakeEventActor::M_SequenceSkipPhase' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_IsStopBoadMotion) == 0x00031A, "Member 'AMakeEventActor::M_IsStopBoadMotion' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_IsSkipLatentNode) == 0x00031B, "Member 'AMakeEventActor::M_IsSkipLatentNode' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_bInputOnSkipLatentNode) == 0x00031C, "Member 'AMakeEventActor::M_bInputOnSkipLatentNode' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_Latenter) == 0x000320, "Member 'AMakeEventActor::M_Latenter' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, IsKeyDown) == 0x000328, "Member 'AMakeEventActor::IsKeyDown' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, KeyDownTime) == 0x00032C, "Member 'AMakeEventActor::KeyDownTime' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_IsOrWaitInput) == 0x000330, "Member 'AMakeEventActor::M_IsOrWaitInput' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, IsCurrentStaticEvent) == 0x000331, "Member 'AMakeEventActor::IsCurrentStaticEvent' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_PreLoadAnimationMap) == 0x000338, "Member 'AMakeEventActor::M_PreLoadAnimationMap' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_PreLoadAnimationBPMap) == 0x000388, "Member 'AMakeEventActor::M_PreLoadAnimationBPMap' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_PreLoadCurveFloat) == 0x0003D8, "Member 'AMakeEventActor::M_PreLoadCurveFloat' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_PreLoadPPMList) == 0x0003F0, "Member 'AMakeEventActor::M_PreLoadPPMList' has a wrong offset!");

// Class BattlePrototype.BattleLogBuffer
// 0x0010 (0x0038 - 0x0028)
class UBattleLogBuffer final : public UObject
{
public:
	TArray<struct FBattleLogParam>                battleLogBufferArray;                              // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddBattleLogBuffer(const struct FBattleLogParam& Param);
	void Clear();
	TArray<struct FBattleLogParam> GetBattleLogBuffer();
	void Initialize();

	bool IsExistLogBuffer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleLogBuffer">();
	}
	static class UBattleLogBuffer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleLogBuffer>();
	}
};
static_assert(alignof(UBattleLogBuffer) == 0x000008, "Wrong alignment on UBattleLogBuffer");
static_assert(sizeof(UBattleLogBuffer) == 0x000038, "Wrong size on UBattleLogBuffer");
static_assert(offsetof(UBattleLogBuffer, battleLogBufferArray) == 0x000028, "Member 'UBattleLogBuffer::battleLogBufferArray' has a wrong offset!");

// Class BattlePrototype.UISceneMapFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UUISceneMapFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void MinimapIconGetArrangeElementList(class UObject* WorldContextObject, class UDataTable* ArrangePointTable, int32 LocationNo, int32 AreaNo, EMapIconType Map_Icon_Type, TArray<struct FMapArrangeItemNode>& ResultList);
	static EMapIconType MinimapIconGetArrangeIconType(class UObject* WorldContextObject, const TArray<class UDataTable*>& IconTables, class FName PointName);
	static void MinimapIconGetElementList(class UObject* WorldContextObject, const TArray<class UDataTable*>& IconTables, EUiSceneMapIconType Type, TArray<struct FUiSceneMapIconNode>& ResultList);
	static void MinimapIconGetElementList_OtherArea(class UObject* WorldContextObject, const TArray<class UDataTable*>& IconTables, EUiSceneMapIconType Type, TArray<struct FUiSceneMapIconNode>& ResultList, class FName AreaName);
	static void MinimapIconGetElementListUse(class UObject* WorldContextObject, int32 Location, int32 Area, int32 Valiation, const TArray<class UDataTable*>& IconTables, EUiSceneMapIconType Type, TArray<struct FUiSceneMapIconNode>& ResultList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISceneMapFunctionLibrary">();
	}
	static class UUISceneMapFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISceneMapFunctionLibrary>();
	}
};
static_assert(alignof(UUISceneMapFunctionLibrary) == 0x000008, "Wrong alignment on UUISceneMapFunctionLibrary");
static_assert(sizeof(UUISceneMapFunctionLibrary) == 0x000028, "Wrong size on UUISceneMapFunctionLibrary");

// Class BattlePrototype.EventCableMeshOptionBase
// 0x0008 (0x0238 - 0x0230)
class AEventCableMeshOptionBase : public AActor
{
public:
	class USkeletalMeshComponent*                 ParentSkeletalMesh_;                               // 0x0230(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool AttachToPlayerSocket();
	struct FTransform CalcSASCodeSocketWorldTransform(class FName SocketName);
	void CalcSASCodeSocketWorldTransforms(const TArray<class FName>& SocketNames, TMap<class FName, struct FTransform>* OutSocketLocations);
	bool GetParent();
	bool Initialize();
	bool SetAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventCableMeshOptionBase">();
	}
	static class AEventCableMeshOptionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventCableMeshOptionBase>();
	}
};
static_assert(alignof(AEventCableMeshOptionBase) == 0x000008, "Wrong alignment on AEventCableMeshOptionBase");
static_assert(sizeof(AEventCableMeshOptionBase) == 0x000238, "Wrong size on AEventCableMeshOptionBase");
static_assert(offsetof(AEventCableMeshOptionBase, ParentSkeletalMesh_) == 0x000230, "Member 'AEventCableMeshOptionBase::ParentSkeletalMesh_' has a wrong offset!");

// Class BattlePrototype.SoundVolumeController
// 0x0178 (0x0238 - 0x00C0)
class USoundVolumeController final : public UActorComponent
{
public:
	float                                         M_MasterVolume;                                    // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoundVolumeSetting                    M_SoundVolumeSetting[0x7];                         // 0x00C4(0x0034)(NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          M_IsFadeExitting;                                  // 0x0230(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float _GetAcfVolumeByCategoryName(ESoundCategory Category);
	float _GetConfigVolumeByCategoryName(ESoundCategory Category);
	float _GetDestVolumeByCategoryName(ESoundCategory Category);
	float _GetFadeTimeByCategoryName(ESoundCategory Category);
	float _GetInGameVolumeByCategoryName(ESoundCategory Category);
	bool _GetIsFadeByCategoryName(ESoundCategory Category);
	bool _GetIsTick();
	float _GetNowVolumeByCategoryName(ESoundCategory Category);
	float _GetPassedTimeByCategoryName(ESoundCategory Category);
	void Finalize();
	void Initialize();
	void SetConfigVolumeByCategoryName(ESoundCategory Category, float DestVol);
	void SetExitFadeAll();
	void SetFadeAllCategory(float FadeTime, float DestVol);
	void SetFadeByCategoryName(ESoundCategory Category, float FadeTime, float DestVol);
	void SetInGameVolumeAll(float DestVol);
	void SetInGameVolumeByCategoryName(ESoundCategory Category, float DestVol);
	void SetMuteAll();
	void SetRestertFadeAll();
	void SetResumeFromMuteAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundVolumeController">();
	}
	static class USoundVolumeController* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundVolumeController>();
	}
};
static_assert(alignof(USoundVolumeController) == 0x000008, "Wrong alignment on USoundVolumeController");
static_assert(sizeof(USoundVolumeController) == 0x000238, "Wrong size on USoundVolumeController");
static_assert(offsetof(USoundVolumeController, M_MasterVolume) == 0x0000C0, "Member 'USoundVolumeController::M_MasterVolume' has a wrong offset!");
static_assert(offsetof(USoundVolumeController, M_SoundVolumeSetting) == 0x0000C4, "Member 'USoundVolumeController::M_SoundVolumeSetting' has a wrong offset!");
static_assert(offsetof(USoundVolumeController, M_IsFadeExitting) == 0x000230, "Member 'USoundVolumeController::M_IsFadeExitting' has a wrong offset!");

// Class BattlePrototype.DebuggingItemBase
// 0x0098 (0x02C8 - 0x0230)
class ADebuggingItemBase : public AActor
{
public:
	int32                                         Priority;                                          // 0x0230(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   HashName;                                          // 0x0238(0x0018)(BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FText                                   DispName;                                          // 0x0250(0x0018)(BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInFocus;                                         // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLostFocus;                                       // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnKeyLeft;                                         // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnKeyRight;                                        // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnKeySelect;                                       // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UWidget* CreateWidgetBP();
	void DestroyItem(bool DestroyChild);
	void Dump(int32 InIndent);
	class ADebuggingItemBase* SearchItem(const class FText& InHashName, bool InRecursive, bool InIgnoreCase);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemBase">();
	}
	static class ADebuggingItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemBase>();
	}
};
static_assert(alignof(ADebuggingItemBase) == 0x000008, "Wrong alignment on ADebuggingItemBase");
static_assert(sizeof(ADebuggingItemBase) == 0x0002C8, "Wrong size on ADebuggingItemBase");
static_assert(offsetof(ADebuggingItemBase, Priority) == 0x000230, "Member 'ADebuggingItemBase::Priority' has a wrong offset!");
static_assert(offsetof(ADebuggingItemBase, HashName) == 0x000238, "Member 'ADebuggingItemBase::HashName' has a wrong offset!");
static_assert(offsetof(ADebuggingItemBase, DispName) == 0x000250, "Member 'ADebuggingItemBase::DispName' has a wrong offset!");
static_assert(offsetof(ADebuggingItemBase, OnInFocus) == 0x000268, "Member 'ADebuggingItemBase::OnInFocus' has a wrong offset!");
static_assert(offsetof(ADebuggingItemBase, OnLostFocus) == 0x000278, "Member 'ADebuggingItemBase::OnLostFocus' has a wrong offset!");
static_assert(offsetof(ADebuggingItemBase, OnKeyLeft) == 0x000288, "Member 'ADebuggingItemBase::OnKeyLeft' has a wrong offset!");
static_assert(offsetof(ADebuggingItemBase, OnKeyRight) == 0x000298, "Member 'ADebuggingItemBase::OnKeyRight' has a wrong offset!");
static_assert(offsetof(ADebuggingItemBase, OnKeySelect) == 0x0002A8, "Member 'ADebuggingItemBase::OnKeySelect' has a wrong offset!");

// Class BattlePrototype.SIWManager
// 0x0080 (0x0140 - 0x00C0)
class USIWManager : public UActorComponent
{
public:
	float                                         WithoutCalcAttenuationNearDistance;                // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WithoutCalcAttenuationFarDistance;                 // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x78];                                      // 0x00C8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SIWManager">();
	}
	static class USIWManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USIWManager>();
	}
};
static_assert(alignof(USIWManager) == 0x000008, "Wrong alignment on USIWManager");
static_assert(sizeof(USIWManager) == 0x000140, "Wrong size on USIWManager");
static_assert(offsetof(USIWManager, WithoutCalcAttenuationNearDistance) == 0x0000C0, "Member 'USIWManager::WithoutCalcAttenuationNearDistance' has a wrong offset!");
static_assert(offsetof(USIWManager, WithoutCalcAttenuationFarDistance) == 0x0000C4, "Member 'USIWManager::WithoutCalcAttenuationFarDistance' has a wrong offset!");

// Class BattlePrototype.DebuggingItemGroup
// 0x0008 (0x02D0 - 0x02C8)
class ADebuggingItemGroup : public ADebuggingItemBase
{
public:
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterChild(class ADebuggingItemBase* InItem);
	void UnregisterChildFromHashName(const class FText& InHashName);
	void UnregisterChildFromItem(class ADebuggingItemBase* InItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemGroup">();
	}
	static class ADebuggingItemGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemGroup>();
	}
};
static_assert(alignof(ADebuggingItemGroup) == 0x000008, "Wrong alignment on ADebuggingItemGroup");
static_assert(sizeof(ADebuggingItemGroup) == 0x0002D0, "Wrong size on ADebuggingItemGroup");

// Class BattlePrototype.DebuggingItemAchievementGroup
// 0x0038 (0x0308 - 0x02D0)
class ADebuggingItemAchievementGroup final : public ADebuggingItemGroup
{
public:
	uint8                                         Pad_2D0[0x4];                                      // 0x02D0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ADebuggingItemStringArray> StringList;                                        // 0x02D4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemLabel>     Label;                                             // 0x02DC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemEvent>     Unlock;                                            // 0x02E4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemEvent>     Lock;                                              // 0x02EC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 EnumValueList;                                     // 0x02F8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnChangeSelected(const class ADebuggingItemStringArray* Item);
	void OnExexLock(const class ADebuggingItemEvent* Item);
	void OnExexUnlock(const class ADebuggingItemEvent* Item);
	void Update();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemAchievementGroup">();
	}
	static class ADebuggingItemAchievementGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemAchievementGroup>();
	}
};
static_assert(alignof(ADebuggingItemAchievementGroup) == 0x000008, "Wrong alignment on ADebuggingItemAchievementGroup");
static_assert(sizeof(ADebuggingItemAchievementGroup) == 0x000308, "Wrong size on ADebuggingItemAchievementGroup");
static_assert(offsetof(ADebuggingItemAchievementGroup, StringList) == 0x0002D4, "Member 'ADebuggingItemAchievementGroup::StringList' has a wrong offset!");
static_assert(offsetof(ADebuggingItemAchievementGroup, Label) == 0x0002DC, "Member 'ADebuggingItemAchievementGroup::Label' has a wrong offset!");
static_assert(offsetof(ADebuggingItemAchievementGroup, Unlock) == 0x0002E4, "Member 'ADebuggingItemAchievementGroup::Unlock' has a wrong offset!");
static_assert(offsetof(ADebuggingItemAchievementGroup, Lock) == 0x0002EC, "Member 'ADebuggingItemAchievementGroup::Lock' has a wrong offset!");
static_assert(offsetof(ADebuggingItemAchievementGroup, EnumValueList) == 0x0002F8, "Member 'ADebuggingItemAchievementGroup::EnumValueList' has a wrong offset!");

// Class BattlePrototype.CharacterVitalityDataAsset
// 0x0030 (0x0060 - 0x0030)
class UCharacterVitalityDataAsset final : public UDataAsset
{
public:
	float                                         OccurrenceSlowSpeed;                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTimeBeforeNextWave;                           // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllWaveDeleteTime;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CenterWaveRandomRangeMin;                          // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CenterWaveRandomRangeMax;                          // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SideWaveRandomRangeMin;                            // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SideWaveRandomRangeMax;                            // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CenterWaveRandomRightMoveRange;                    // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CenterWaveRandomLeftMoveRange;                     // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SideWaveRandomMinMoveRange;                        // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SideWaveRandomMaxMoveRange;                        // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecialGapBaseValue;                               // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterVitalityDataAsset">();
	}
	static class UCharacterVitalityDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterVitalityDataAsset>();
	}
};
static_assert(alignof(UCharacterVitalityDataAsset) == 0x000008, "Wrong alignment on UCharacterVitalityDataAsset");
static_assert(sizeof(UCharacterVitalityDataAsset) == 0x000060, "Wrong size on UCharacterVitalityDataAsset");
static_assert(offsetof(UCharacterVitalityDataAsset, OccurrenceSlowSpeed) == 0x000030, "Member 'UCharacterVitalityDataAsset::OccurrenceSlowSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, DelayTimeBeforeNextWave) == 0x000034, "Member 'UCharacterVitalityDataAsset::DelayTimeBeforeNextWave' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, AllWaveDeleteTime) == 0x000038, "Member 'UCharacterVitalityDataAsset::AllWaveDeleteTime' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, CenterWaveRandomRangeMin) == 0x00003C, "Member 'UCharacterVitalityDataAsset::CenterWaveRandomRangeMin' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, CenterWaveRandomRangeMax) == 0x000040, "Member 'UCharacterVitalityDataAsset::CenterWaveRandomRangeMax' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, SideWaveRandomRangeMin) == 0x000044, "Member 'UCharacterVitalityDataAsset::SideWaveRandomRangeMin' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, SideWaveRandomRangeMax) == 0x000048, "Member 'UCharacterVitalityDataAsset::SideWaveRandomRangeMax' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, CenterWaveRandomRightMoveRange) == 0x00004C, "Member 'UCharacterVitalityDataAsset::CenterWaveRandomRightMoveRange' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, CenterWaveRandomLeftMoveRange) == 0x000050, "Member 'UCharacterVitalityDataAsset::CenterWaveRandomLeftMoveRange' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, SideWaveRandomMinMoveRange) == 0x000054, "Member 'UCharacterVitalityDataAsset::SideWaveRandomMinMoveRange' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, SideWaveRandomMaxMoveRange) == 0x000058, "Member 'UCharacterVitalityDataAsset::SideWaveRandomMaxMoveRange' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, SpecialGapBaseValue) == 0x00005C, "Member 'UCharacterVitalityDataAsset::SpecialGapBaseValue' has a wrong offset!");

// Class BattlePrototype.DebuggingItemInt
// 0x0038 (0x0300 - 0x02C8)
class ADebuggingItemInt : public ADebuggingItemBase
{
public:
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSliderSettingChanged;                            // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         Min;                                               // 0x02E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Max;                                               // 0x02EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Step;                                              // 0x02F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Value;                                             // 0x02F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKeyLeftFunc(const class ADebuggingItemBase* InItem, bool IsRepeat, int32 InSpeed);
	void OnKeyRightFunc(const class ADebuggingItemBase* InItem, bool IsRepeat, int32 InSpeed);
	void SetSliderSettings(int32 InMin, int32 InMax, int32 InStep);
	void SetValue(int32 InValue);

	int32 GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemInt">();
	}
	static class ADebuggingItemInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemInt>();
	}
};
static_assert(alignof(ADebuggingItemInt) == 0x000008, "Wrong alignment on ADebuggingItemInt");
static_assert(sizeof(ADebuggingItemInt) == 0x000300, "Wrong size on ADebuggingItemInt");
static_assert(offsetof(ADebuggingItemInt, OnChanged) == 0x0002C8, "Member 'ADebuggingItemInt::OnChanged' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInt, OnSliderSettingChanged) == 0x0002D8, "Member 'ADebuggingItemInt::OnSliderSettingChanged' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInt, Min) == 0x0002E8, "Member 'ADebuggingItemInt::Min' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInt, Max) == 0x0002EC, "Member 'ADebuggingItemInt::Max' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInt, Step) == 0x0002F0, "Member 'ADebuggingItemInt::Step' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInt, Value) == 0x0002F4, "Member 'ADebuggingItemInt::Value' has a wrong offset!");

// Class BattlePrototype.HoveringComponent
// 0x0038 (0x00F8 - 0x00C0)
class UHoveringComponent final : public UActorComponent
{
public:
	float                                         _minFlightAltitude;                                // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxFlightAltitude;                                // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoveringCharacter;                              // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _disableClaimantNames;                             // 0x00D0(0x0010)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _claimantName;                                     // 0x00E0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHoveringComponent* GetHoveringComponent(class AActor* Actor);

	void ClearDisableHovering(const class FName& ClaimantName);
	void SetDisableHovering(const class FName& ClaimantName);

	float GetFlightAltitudeAverage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoveringComponent">();
	}
	static class UHoveringComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoveringComponent>();
	}
};
static_assert(alignof(UHoveringComponent) == 0x000008, "Wrong alignment on UHoveringComponent");
static_assert(sizeof(UHoveringComponent) == 0x0000F8, "Wrong size on UHoveringComponent");
static_assert(offsetof(UHoveringComponent, _minFlightAltitude) == 0x0000C0, "Member 'UHoveringComponent::_minFlightAltitude' has a wrong offset!");
static_assert(offsetof(UHoveringComponent, _maxFlightAltitude) == 0x0000C4, "Member 'UHoveringComponent::_maxFlightAltitude' has a wrong offset!");
static_assert(offsetof(UHoveringComponent, _isHoveringCharacter) == 0x0000C8, "Member 'UHoveringComponent::_isHoveringCharacter' has a wrong offset!");
static_assert(offsetof(UHoveringComponent, _disableClaimantNames) == 0x0000D0, "Member 'UHoveringComponent::_disableClaimantNames' has a wrong offset!");
static_assert(offsetof(UHoveringComponent, _claimantName) == 0x0000E0, "Member 'UHoveringComponent::_claimantName' has a wrong offset!");

// Class BattlePrototype.DebuggingItemInt2
// 0x0008 (0x0308 - 0x0300)
class ADebuggingItemInt2 final : public ADebuggingItemInt
{
public:
	int32                                         Index_0;                                           // 0x0300(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemInt2">();
	}
	static class ADebuggingItemInt2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemInt2>();
	}
};
static_assert(alignof(ADebuggingItemInt2) == 0x000008, "Wrong alignment on ADebuggingItemInt2");
static_assert(sizeof(ADebuggingItemInt2) == 0x000308, "Wrong size on ADebuggingItemInt2");
static_assert(offsetof(ADebuggingItemInt2, Index_0) == 0x000300, "Member 'ADebuggingItemInt2::Index_0' has a wrong offset!");

// Class BattlePrototype.Wp0200AnimInstance
// 0x0180 (0x03F0 - 0x0270)
class UWp0200AnimInstance : public UAnimInstance
{
public:
	TWeakObjectPtr<class USceneComponent>         OwnerMeshComponent;                                // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WeaponScale;                                       // 0x0278(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location0;                                         // 0x0284(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation0;                                         // 0x0290(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale0;                                            // 0x029C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location1;                                         // 0x02A8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation1;                                         // 0x02B4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale1;                                            // 0x02C0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location2;                                         // 0x02CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation2;                                         // 0x02D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale2;                                            // 0x02E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location3;                                         // 0x02F0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation3;                                         // 0x02FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale3;                                            // 0x0308(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location4;                                         // 0x0314(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation4;                                         // 0x0320(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale4;                                            // 0x032C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location5;                                         // 0x0338(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation5;                                         // 0x0344(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale5;                                            // 0x0350(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location6;                                         // 0x035C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation6;                                         // 0x0368(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale6;                                            // 0x0374(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location7;                                         // 0x0380(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation7;                                         // 0x038C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale7;                                            // 0x0398(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location8;                                         // 0x03A4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation8;                                         // 0x03B0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale8;                                            // 0x03BC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location9;                                         // 0x03C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation9;                                         // 0x03D4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale9;                                            // 0x03E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Wp0200AnimInstance">();
	}
	static class UWp0200AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWp0200AnimInstance>();
	}
};
static_assert(alignof(UWp0200AnimInstance) == 0x000010, "Wrong alignment on UWp0200AnimInstance");
static_assert(sizeof(UWp0200AnimInstance) == 0x0003F0, "Wrong size on UWp0200AnimInstance");
static_assert(offsetof(UWp0200AnimInstance, OwnerMeshComponent) == 0x000270, "Member 'UWp0200AnimInstance::OwnerMeshComponent' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, WeaponScale) == 0x000278, "Member 'UWp0200AnimInstance::WeaponScale' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location0) == 0x000284, "Member 'UWp0200AnimInstance::Location0' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation0) == 0x000290, "Member 'UWp0200AnimInstance::Rotation0' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale0) == 0x00029C, "Member 'UWp0200AnimInstance::Scale0' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location1) == 0x0002A8, "Member 'UWp0200AnimInstance::Location1' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation1) == 0x0002B4, "Member 'UWp0200AnimInstance::Rotation1' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale1) == 0x0002C0, "Member 'UWp0200AnimInstance::Scale1' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location2) == 0x0002CC, "Member 'UWp0200AnimInstance::Location2' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation2) == 0x0002D8, "Member 'UWp0200AnimInstance::Rotation2' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale2) == 0x0002E4, "Member 'UWp0200AnimInstance::Scale2' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location3) == 0x0002F0, "Member 'UWp0200AnimInstance::Location3' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation3) == 0x0002FC, "Member 'UWp0200AnimInstance::Rotation3' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale3) == 0x000308, "Member 'UWp0200AnimInstance::Scale3' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location4) == 0x000314, "Member 'UWp0200AnimInstance::Location4' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation4) == 0x000320, "Member 'UWp0200AnimInstance::Rotation4' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale4) == 0x00032C, "Member 'UWp0200AnimInstance::Scale4' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location5) == 0x000338, "Member 'UWp0200AnimInstance::Location5' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation5) == 0x000344, "Member 'UWp0200AnimInstance::Rotation5' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale5) == 0x000350, "Member 'UWp0200AnimInstance::Scale5' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location6) == 0x00035C, "Member 'UWp0200AnimInstance::Location6' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation6) == 0x000368, "Member 'UWp0200AnimInstance::Rotation6' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale6) == 0x000374, "Member 'UWp0200AnimInstance::Scale6' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location7) == 0x000380, "Member 'UWp0200AnimInstance::Location7' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation7) == 0x00038C, "Member 'UWp0200AnimInstance::Rotation7' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale7) == 0x000398, "Member 'UWp0200AnimInstance::Scale7' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location8) == 0x0003A4, "Member 'UWp0200AnimInstance::Location8' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation8) == 0x0003B0, "Member 'UWp0200AnimInstance::Rotation8' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale8) == 0x0003BC, "Member 'UWp0200AnimInstance::Scale8' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location9) == 0x0003C8, "Member 'UWp0200AnimInstance::Location9' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation9) == 0x0003D4, "Member 'UWp0200AnimInstance::Rotation9' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale9) == 0x0003E0, "Member 'UWp0200AnimInstance::Scale9' has a wrong offset!");

// Class BattlePrototype.DebuggingItemBool
// 0x0020 (0x02E8 - 0x02C8)
class ADebuggingItemBool : public ADebuggingItemBase
{
public:
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          Value;                                             // 0x02D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0xF];                                      // 0x02D9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKeySelectFunc(const class ADebuggingItemBase* InItem, bool IsRepeat);
	void SetValue(bool InValue);

	bool GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemBool">();
	}
	static class ADebuggingItemBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemBool>();
	}
};
static_assert(alignof(ADebuggingItemBool) == 0x000008, "Wrong alignment on ADebuggingItemBool");
static_assert(sizeof(ADebuggingItemBool) == 0x0002E8, "Wrong size on ADebuggingItemBool");
static_assert(offsetof(ADebuggingItemBool, OnChanged) == 0x0002C8, "Member 'ADebuggingItemBool::OnChanged' has a wrong offset!");
static_assert(offsetof(ADebuggingItemBool, Value) == 0x0002D8, "Member 'ADebuggingItemBool::Value' has a wrong offset!");

// Class BattlePrototype.DebuggingItemBool2
// 0x0008 (0x02F0 - 0x02E8)
class ADebuggingItemBool2 final : public ADebuggingItemBool
{
public:
	int32                                         Index_0;                                           // 0x02E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemBool2">();
	}
	static class ADebuggingItemBool2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemBool2>();
	}
};
static_assert(alignof(ADebuggingItemBool2) == 0x000008, "Wrong alignment on ADebuggingItemBool2");
static_assert(sizeof(ADebuggingItemBool2) == 0x0002F0, "Wrong size on ADebuggingItemBool2");
static_assert(offsetof(ADebuggingItemBool2, Index_0) == 0x0002E8, "Member 'ADebuggingItemBool2::Index_0' has a wrong offset!");

// Class BattlePrototype.MaterialStealthParam
// 0x0010 (0x0040 - 0x0030)
class UMaterialStealthParam final : public UDataAsset
{
public:
	int32                                         SampleFrame;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelaySec;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialStealthParam">();
	}
	static class UMaterialStealthParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialStealthParam>();
	}
};
static_assert(alignof(UMaterialStealthParam) == 0x000008, "Wrong alignment on UMaterialStealthParam");
static_assert(sizeof(UMaterialStealthParam) == 0x000040, "Wrong size on UMaterialStealthParam");
static_assert(offsetof(UMaterialStealthParam, SampleFrame) == 0x000030, "Member 'UMaterialStealthParam::SampleFrame' has a wrong offset!");
static_assert(offsetof(UMaterialStealthParam, InterpSpeed) == 0x000034, "Member 'UMaterialStealthParam::InterpSpeed' has a wrong offset!");
static_assert(offsetof(UMaterialStealthParam, DelaySec) == 0x000038, "Member 'UMaterialStealthParam::DelaySec' has a wrong offset!");

// Class BattlePrototype.DebuggingItemInGameAchievementGroup
// 0x0090 (0x0360 - 0x02D0)
class ADebuggingItemInGameAchievementGroup final : public ADebuggingItemGroup
{
public:
	TArray<TWeakObjectPtr<class ADebuggingItemInt2>> IntList;                                           // 0x02D0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemInt>       IntReport;                                         // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ADebuggingItemBool2>> TradeBool;                                         // 0x02E8(0x0010)(ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ADebuggingItemBool2>> QuestBool;                                         // 0x02F8(0x0010)(ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ADebuggingItemBool2>> AttachmentBool;                                    // 0x0308(0x0010)(ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ADebuggingItemBool2>> EnemyBool;                                         // 0x0318(0x0010)(ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemInt2>      IntMoney;                                          // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemEvent>     ExecMoney;                                         // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ADebuggingItemBool2>> PresentBool;                                       // 0x0338(0x0010)(ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAchievementManager*                    Manager;                                           // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAchievementParamDBAsset*               DBAsset;                                           // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeBoolAttachment(const class ADebuggingItemBool* Item);
	void OnChangeBoolEnemy(const class ADebuggingItemBool* Item);
	void OnChangeBoolPresent(const class ADebuggingItemBool* Item);
	void OnChangeBoolQuest(const class ADebuggingItemBool* Item);
	void OnChangeBoolTrade(const class ADebuggingItemBool* Item);
	void OnChangeIntParam(const class ADebuggingItemInt* Item);
	void OnChangeReportCount(const class ADebuggingItemInt* Item);
	void OnEventChangeKins(const class ADebuggingItemEvent* Item);
	void OnPageOpened();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemInGameAchievementGroup">();
	}
	static class ADebuggingItemInGameAchievementGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemInGameAchievementGroup>();
	}
};
static_assert(alignof(ADebuggingItemInGameAchievementGroup) == 0x000008, "Wrong alignment on ADebuggingItemInGameAchievementGroup");
static_assert(sizeof(ADebuggingItemInGameAchievementGroup) == 0x000360, "Wrong size on ADebuggingItemInGameAchievementGroup");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, IntList) == 0x0002D0, "Member 'ADebuggingItemInGameAchievementGroup::IntList' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, IntReport) == 0x0002E0, "Member 'ADebuggingItemInGameAchievementGroup::IntReport' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, TradeBool) == 0x0002E8, "Member 'ADebuggingItemInGameAchievementGroup::TradeBool' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, QuestBool) == 0x0002F8, "Member 'ADebuggingItemInGameAchievementGroup::QuestBool' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, AttachmentBool) == 0x000308, "Member 'ADebuggingItemInGameAchievementGroup::AttachmentBool' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, EnemyBool) == 0x000318, "Member 'ADebuggingItemInGameAchievementGroup::EnemyBool' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, IntMoney) == 0x000328, "Member 'ADebuggingItemInGameAchievementGroup::IntMoney' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, ExecMoney) == 0x000330, "Member 'ADebuggingItemInGameAchievementGroup::ExecMoney' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, PresentBool) == 0x000338, "Member 'ADebuggingItemInGameAchievementGroup::PresentBool' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, Manager) == 0x000348, "Member 'ADebuggingItemInGameAchievementGroup::Manager' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, DBAsset) == 0x000350, "Member 'ADebuggingItemInGameAchievementGroup::DBAsset' has a wrong offset!");

// Class BattlePrototype.BlendableVolumeManager
// 0x0018 (0x0248 - 0x0230)
class ABlendableVolumeManager : public AActor
{
public:
	uint8                                         Pad_230[0x18];                                     // 0x0230(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintAddCalcVolume(const class ABlendableVolume* Volume, float Weight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlendableVolumeManager">();
	}
	static class ABlendableVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlendableVolumeManager>();
	}
};
static_assert(alignof(ABlendableVolumeManager) == 0x000008, "Wrong alignment on ABlendableVolumeManager");
static_assert(sizeof(ABlendableVolumeManager) == 0x000248, "Wrong size on ABlendableVolumeManager");

// Class BattlePrototype.StageParameterSettingVolumeManager
// 0x0838 (0x0A80 - 0x0248)
class AStageParameterSettingVolumeManager : public ABlendableVolumeManager
{
public:
	struct FStageParameterSettings                Parameter;                                         // 0x0248(0x00E0)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x50];                                     // 0x0328(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class AStageEffectParameterSettingVolumeManager* EffectManager;                                     // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_380[0x700];                                    // 0x0380(0x0700)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAppendActor(class AActor* Actor);
	const struct FStageParameterSettings CalcParameter(const struct FVector& Location);
	struct FStageParameterSettings CalcParameterEffect(const struct FVector& Location);
	void ClearParameter(class AActor* Actor);
	void ConvertSettingToParameters(const struct FStageParameterSettings& Settings, TArray<class FName>* ParamScalarNames, TArray<float>* ParamScalars, TArray<class FName>* ParamVectorNames, TArray<struct FLinearColor>* ParamVectors);
	void ForceAllUpdate();
	void ForceAllUpdateOption(bool bUpdatePlayer, bool bUpdateAppendActor);
	void ForceUpdateActor(class AActor* Actor, const struct FVector& Location);
	class AStageEffectParameterSettingVolumeManager* GetEffectManager();
	void RecalcSceneLightVector();
	void RemoveAppendActor(class AActor* Actor);
	void SetDebugDisableCache(bool DisableCache);
	void SetupActorInternal(const class AActor* Actor, const struct FVector& Location, const TArray<class FName>& ParamScalarNames, const TArray<float>& ParamScalars, const TArray<class FName>& ParamVectorNames, const TArray<struct FLinearColor>& ParamVectors);
	void SetupMPC(class UMaterialParameterCollection* Collection, const struct FStageParameterSettings& Settings);
	void SetUseReferenceLocationMode(bool Use);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageParameterSettingVolumeManager">();
	}
	static class AStageParameterSettingVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStageParameterSettingVolumeManager>();
	}
};
static_assert(alignof(AStageParameterSettingVolumeManager) == 0x000008, "Wrong alignment on AStageParameterSettingVolumeManager");
static_assert(sizeof(AStageParameterSettingVolumeManager) == 0x000A80, "Wrong size on AStageParameterSettingVolumeManager");
static_assert(offsetof(AStageParameterSettingVolumeManager, Parameter) == 0x000248, "Member 'AStageParameterSettingVolumeManager::Parameter' has a wrong offset!");
static_assert(offsetof(AStageParameterSettingVolumeManager, EffectManager) == 0x000378, "Member 'AStageParameterSettingVolumeManager::EffectManager' has a wrong offset!");

// Class BattlePrototype.RSTickableManagerBase
// 0x0010 (0x0038 - 0x0028)
class URSTickableManagerBase : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSTickableManagerBase">();
	}
	static class URSTickableManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSTickableManagerBase>();
	}
};
static_assert(alignof(URSTickableManagerBase) == 0x000008, "Wrong alignment on URSTickableManagerBase");
static_assert(sizeof(URSTickableManagerBase) == 0x000038, "Wrong size on URSTickableManagerBase");

// Class BattlePrototype.SplineLooperBase
// 0x0070 (0x02A0 - 0x0230)
class alignas(0x10) ASplineLooperBase : public AActor
{
public:
	class USplineComponent*                       SpawnSplineNv;                                     // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         SplineActorsNv;                                    // 0x0238(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_248[0x58];                                     // 0x0248(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetupParameters(class USplineComponent* InSpawnSpline, const TArray<class AActor*>& InSplineActors, const TArray<float>& InInitialSplineLocations, const struct FTransform& InAdditonalTransform, float InSpeed, float InDirectionRotationSpeed, bool bInRotateAlongSpline, bool bInFlipToSpeedDirection, bool bInUpdateScale, bool bInUseScaleToSpeedRotation);
	void Update(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplineLooperBase">();
	}
	static class ASplineLooperBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASplineLooperBase>();
	}
};
static_assert(alignof(ASplineLooperBase) == 0x000010, "Wrong alignment on ASplineLooperBase");
static_assert(sizeof(ASplineLooperBase) == 0x0002A0, "Wrong size on ASplineLooperBase");
static_assert(offsetof(ASplineLooperBase, SpawnSplineNv) == 0x000230, "Member 'ASplineLooperBase::SpawnSplineNv' has a wrong offset!");
static_assert(offsetof(ASplineLooperBase, SplineActorsNv) == 0x000238, "Member 'ASplineLooperBase::SplineActorsNv' has a wrong offset!");

// Class BattlePrototype.AchievementManager
// 0x01C0 (0x01F8 - 0x0038)
class UAchievementManager final : public URSTickableManagerBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URSGameInstance*                        _gameInstance;                                     // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAchievementParam                      Parameter;                                         // 0x0060(0x0130)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_190[0x28];                                     // 0x0190(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AchievementQueue;                                  // 0x01B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           AchievementFailedQueue;                            // 0x01C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D8[0x8];                                      // 0x01D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           OpenCompleted;                                     // 0x01E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F0[0x8];                                      // 0x01F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AcquireSkill(EPlayerID PlayerId, EPlayerSkill Skill);
	void AddMoney(int32 Num);
	void BondsLvOver6(EPlayerID PlayerId, EPlayerID TargetID);
	void BrainCrashKillsSameTime(int32 Num);
	void ChaseAttack();
	void CheckCompleteSkill(EPlayerID PlayerId);
	void ClearBondsEp(EPlayerID PlayerId, EPlayerID TargetID, int32 EpisodeNo);
	void ClearQuest(class FName QuestId);
	void CompleteEnemyLibrary();
	void DriveMaxBonus();
	void EndPsychicObjectBus();
	void EndStory(EPlayerID PlayerId);
	void EquipItems(EPlayerID PlayerId, class FName ItemId);
	void FinishLastBattle();
	void GatherAllMember();
	const class FString GetDebugString(int32 Idx);
	void GetItem(class FName ItemId);
	bool IsOpenAchievement(const EAchievementsType Type);
	void JustDodge();
	void Kill_UseBus(int32 Num);
	void KillEnemyDataForAchievement(class FName EnemyName, const struct FHCHitResult& HcResult, EPsychicObjectUniqueType PoType, bool bBrainCrashMulti);
	void KillEnemys(int32 Num);
	void KillsInBrainField(int32 Num);
	void MaMoRu();
	bool OpenAchievement(const EAchievementsType Type);
	bool OpenAchievementCheckProgress_EnemyKill();
	void PlayVoice(const class FString& CueName);
	void Present(EPlayerID PlayerId, EPlayerID TargetID, class FName ItemId);
	void Protected();
	void QueryAchievements();
	void Resuscitated();
	void ResuscitateFollow();
	void SasHologram();
	void StartPsychicObjectBus();
	void StartStory(EPlayerID PlayerId);
	void SuohIncident(EPlayerID PlayerId);
	void SupportedInBrainField();
	void TimeoverInBF();
	void TradeItem(class FName ItemId);
	void Use4CVinCombo();
	void UseBrainCrash();
	void UseCombinationVision(EPlayerID PlayerId, EPlayerID VisionCharID);
	void UseDrive();
	void UsePKObject();
	void UseSas();
	void WatchOpeningMovie();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementManager">();
	}
	static class UAchievementManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementManager>();
	}
};
static_assert(alignof(UAchievementManager) == 0x000008, "Wrong alignment on UAchievementManager");
static_assert(sizeof(UAchievementManager) == 0x0001F8, "Wrong size on UAchievementManager");
static_assert(offsetof(UAchievementManager, _gameInstance) == 0x000048, "Member 'UAchievementManager::_gameInstance' has a wrong offset!");
static_assert(offsetof(UAchievementManager, Parameter) == 0x000060, "Member 'UAchievementManager::Parameter' has a wrong offset!");
static_assert(offsetof(UAchievementManager, AchievementQueue) == 0x0001B8, "Member 'UAchievementManager::AchievementQueue' has a wrong offset!");
static_assert(offsetof(UAchievementManager, AchievementFailedQueue) == 0x0001C8, "Member 'UAchievementManager::AchievementFailedQueue' has a wrong offset!");
static_assert(offsetof(UAchievementManager, OpenCompleted) == 0x0001E0, "Member 'UAchievementManager::OpenCompleted' has a wrong offset!");

// Class BattlePrototype.AchievementUtility
// 0x0000 (0x0028 - 0x0028)
class UAchievementUtility final : public UBlueprintFunctionLibrary
{
public:
	static void AcquireSkill(const class UObject* WorldContextObject, EPlayerID PlayerId, EPlayerSkill Skill);
	static void AddMoney(const class UObject* WorldContextObject, int32 Num);
	static void BondsLvOver6(const class UObject* WorldContextObject, EPlayerID PlayerId, EPlayerID TargetID);
	static void BrainCrashKillsSameTime(const class UObject* WorldContextObject, int32 Num);
	static void ChaseAttack(const class UObject* WorldContextObject);
	static void CheckCompleteSkill(const class UObject* WorldContextObject, EPlayerID PlayerId);
	static void Clear(const class UObject* WorldContextObject);
	static void ClearBondsEp(const class UObject* WorldContextObject, EPlayerID PlayerId, EPlayerID TargetID, int32 EpisodeNo);
	static void ClearQuest(const class UObject* WorldContextObject, class FName QuestId);
	static void CompleteEnemyLibrary(const class UObject* WorldContextObject);
	static void DriveMaxBonus(const class UObject* WorldContextObject);
	static void EndPsychicObjectBus(const class UObject* WorldContextObject);
	static void EndStory(const class UObject* WorldContextObject, EPlayerID PlayerId);
	static void EquipItems(const class UObject* WorldContextObject, EPlayerID PlayerId, class FName ItemId);
	static void FinishLastBattle(const class UObject* WorldContextObject);
	static void GatherAllMember(const class UObject* WorldContextObject);
	static void GetItem(const class UObject* WorldContextObject, class FName ItemId);
	static void JustDodge(const class UObject* WorldContextObject);
	static void Kill_UseBus(const class UObject* WorldContextObject, int32 Num);
	static void KillEnemyDataForAchievement(const class UObject* WorldContextObject, class FName EnemyName, const struct FHCHitResult& HcResult, EPsychicObjectUniqueType PoType, bool bBrainCrashMulti);
	static void KillEnemys(const class UObject* WorldContextObject, int32 Num);
	static void KillsInBrainField(const class UObject* WorldContextObject, int32 Num);
	static void MaMoRu(const class UObject* WorldContextObject);
	static void PlayVoice(const class UObject* WorldContextObject, const class FString& CueName);
	static void Present(const class UObject* WorldContextObject, EPlayerID PlayerId, EPlayerID TargetID, class FName ItemId);
	static void Protected(const class UObject* WorldContextObject);
	static void Resuscitated(const class UObject* WorldContextObject);
	static void ResuscitateFollow(const class UObject* WorldContextObject);
	static void SasHologram(const class UObject* WorldContextObject);
	static void StartPsychicObjectBus(const class UObject* WorldContextObject);
	static void StartStory(const class UObject* WorldContextObject, EPlayerID PlayerId);
	static void SuohIncident(const class UObject* WorldContextObject, EPlayerID PlayerId);
	static void SupportedInBrainField(const class UObject* WorldContextObject);
	static void TimeoverInBF(const class UObject* WorldContextObject);
	static void TradeItem(const class UObject* WorldContextObject, class FName ItemId);
	static void Use4CVinCombo(const class UObject* WorldContextObject);
	static void UseBrainCrash(const class UObject* WorldContextObject);
	static void UseCombinationVision(const class UObject* WorldContextObject, EPlayerID PlayerId, EPlayerID VisionCharID);
	static void UseDrive(const class UObject* WorldContextObject);
	static void UsePKObject(const class UObject* WorldContextObject);
	static void UseSas(const class UObject* WorldContextObject);
	static void WatchOpeningMovie(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementUtility">();
	}
	static class UAchievementUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementUtility>();
	}
};
static_assert(alignof(UAchievementUtility) == 0x000008, "Wrong alignment on UAchievementUtility");
static_assert(sizeof(UAchievementUtility) == 0x000028, "Wrong size on UAchievementUtility");

// Class BattlePrototype.LibraryCharaData
// 0x0018 (0x0040 - 0x0028)
class ULibraryCharaData final : public UObject
{
public:
	class ULibraryCharaDBAsset*                   Asset;                                             // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             OpenDataM;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             OpenDataF;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool LoadDataAsset(const class FString& Path, const class FString& OpenDataPathM, const class FString& OpenDataPathF);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LibraryCharaData">();
	}
	static class ULibraryCharaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULibraryCharaData>();
	}
};
static_assert(alignof(ULibraryCharaData) == 0x000008, "Wrong alignment on ULibraryCharaData");
static_assert(sizeof(ULibraryCharaData) == 0x000040, "Wrong size on ULibraryCharaData");
static_assert(offsetof(ULibraryCharaData, Asset) == 0x000028, "Member 'ULibraryCharaData::Asset' has a wrong offset!");
static_assert(offsetof(ULibraryCharaData, OpenDataM) == 0x000030, "Member 'ULibraryCharaData::OpenDataM' has a wrong offset!");
static_assert(offsetof(ULibraryCharaData, OpenDataF) == 0x000038, "Member 'ULibraryCharaData::OpenDataF' has a wrong offset!");

// Class BattlePrototype.EnemyAddDamageShakeComponentBase
// 0x0088 (0x0148 - 0x00C0)
class UEnemyAddDamageShakeComponentBase : public UActorComponent
{
public:
	class ARSCharacterBase*                       MOwnerCharacter;                                   // 0x00C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MShakeMaxCount;                                    // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MShakeScale;                                       // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            MShakeCurveData;                                   // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MRotateRange;                                      // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MShakeRangeMin;                                    // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MShakeRangeMax;                                    // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MOneShakeTimer;                                    // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MTriggerShakeScale;                                // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MKnockBackShakeScale;                              // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MCharaTypeShakeScale;                              // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC[0x4C];                                      // 0x00FC(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalcShakeScale_Native();
	void End_Native();
	struct FVector GetRandomVec_Native(const struct FVector& CurrentVec, float Range, bool IsRight);
	void Start_Native(bool TriggerAttack);
	void Update_Native(float DeltaSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyAddDamageShakeComponentBase">();
	}
	static class UEnemyAddDamageShakeComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyAddDamageShakeComponentBase>();
	}
};
static_assert(alignof(UEnemyAddDamageShakeComponentBase) == 0x000008, "Wrong alignment on UEnemyAddDamageShakeComponentBase");
static_assert(sizeof(UEnemyAddDamageShakeComponentBase) == 0x000148, "Wrong size on UEnemyAddDamageShakeComponentBase");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MOwnerCharacter) == 0x0000C0, "Member 'UEnemyAddDamageShakeComponentBase::MOwnerCharacter' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MShakeMaxCount) == 0x0000D0, "Member 'UEnemyAddDamageShakeComponentBase::MShakeMaxCount' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MShakeScale) == 0x0000D4, "Member 'UEnemyAddDamageShakeComponentBase::MShakeScale' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MShakeCurveData) == 0x0000D8, "Member 'UEnemyAddDamageShakeComponentBase::MShakeCurveData' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MRotateRange) == 0x0000E0, "Member 'UEnemyAddDamageShakeComponentBase::MRotateRange' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MShakeRangeMin) == 0x0000E4, "Member 'UEnemyAddDamageShakeComponentBase::MShakeRangeMin' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MShakeRangeMax) == 0x0000E8, "Member 'UEnemyAddDamageShakeComponentBase::MShakeRangeMax' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MOneShakeTimer) == 0x0000EC, "Member 'UEnemyAddDamageShakeComponentBase::MOneShakeTimer' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MTriggerShakeScale) == 0x0000F0, "Member 'UEnemyAddDamageShakeComponentBase::MTriggerShakeScale' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MKnockBackShakeScale) == 0x0000F4, "Member 'UEnemyAddDamageShakeComponentBase::MKnockBackShakeScale' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MCharaTypeShakeScale) == 0x0000F8, "Member 'UEnemyAddDamageShakeComponentBase::MCharaTypeShakeScale' has a wrong offset!");

// Class BattlePrototype.AchievementParamDBAsset
// 0x0258 (0x0280 - 0x0028)
class UAchievementParamDBAsset final : public UObject
{
public:
	TMap<EPlayerID, struct FAchievementPresentItem> PresentItemListM;                                  // 0x0028(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<EPlayerID, struct FAchievementPresentItem> PresentItemListF;                                  // 0x0078(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	int32                                         PresentItemTotal;                                  // 0x00C8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AttachmentItemList;                                // 0x00D0(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           TradeItemList;                                     // 0x00E0(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           CostumeEquipItemList;                              // 0x00F0(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           BakiHeadItemList;                                  // 0x0100(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FString>                         BoredomVoiceList;                                  // 0x0110(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           QuestList;                                         // 0x0120(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EPlayerID, int32>                        bondsProgressM;                                    // 0x0130(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<EPlayerID, int32>                        bondsProgressF;                                    // 0x0180(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TArray<class FName>                           EnemyLibraryList;                                  // 0x01D0(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EPlayerSkillCategory, struct FAchievementSkillItem> SkillListM;                                        // 0x01E0(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<EPlayerSkillCategory, struct FAchievementSkillItem> SkillListF;                                        // 0x0230(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)

public:
	void Convert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementParamDBAsset">();
	}
	static class UAchievementParamDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementParamDBAsset>();
	}
};
static_assert(alignof(UAchievementParamDBAsset) == 0x000008, "Wrong alignment on UAchievementParamDBAsset");
static_assert(sizeof(UAchievementParamDBAsset) == 0x000280, "Wrong size on UAchievementParamDBAsset");
static_assert(offsetof(UAchievementParamDBAsset, PresentItemListM) == 0x000028, "Member 'UAchievementParamDBAsset::PresentItemListM' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, PresentItemListF) == 0x000078, "Member 'UAchievementParamDBAsset::PresentItemListF' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, PresentItemTotal) == 0x0000C8, "Member 'UAchievementParamDBAsset::PresentItemTotal' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, AttachmentItemList) == 0x0000D0, "Member 'UAchievementParamDBAsset::AttachmentItemList' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, TradeItemList) == 0x0000E0, "Member 'UAchievementParamDBAsset::TradeItemList' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, CostumeEquipItemList) == 0x0000F0, "Member 'UAchievementParamDBAsset::CostumeEquipItemList' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, BakiHeadItemList) == 0x000100, "Member 'UAchievementParamDBAsset::BakiHeadItemList' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, BoredomVoiceList) == 0x000110, "Member 'UAchievementParamDBAsset::BoredomVoiceList' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, QuestList) == 0x000120, "Member 'UAchievementParamDBAsset::QuestList' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, bondsProgressM) == 0x000130, "Member 'UAchievementParamDBAsset::bondsProgressM' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, bondsProgressF) == 0x000180, "Member 'UAchievementParamDBAsset::bondsProgressF' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, EnemyLibraryList) == 0x0001D0, "Member 'UAchievementParamDBAsset::EnemyLibraryList' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, SkillListM) == 0x0001E0, "Member 'UAchievementParamDBAsset::SkillListM' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, SkillListF) == 0x000230, "Member 'UAchievementParamDBAsset::SkillListF' has a wrong offset!");

// Class BattlePrototype.OnlineTestJoinSession
// 0x0150 (0x0180 - 0x0030)
class UOnlineTestJoinSession final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x130];                                     // 0x0050(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOnlineTestJoinSession* OnlineTestJoinSession(class UObject* WorldContextObject, class APlayerController* PlayerController, const struct FBlueprintSessionResult& SearchResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineTestJoinSession">();
	}
	static class UOnlineTestJoinSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineTestJoinSession>();
	}
};
static_assert(alignof(UOnlineTestJoinSession) == 0x000008, "Wrong alignment on UOnlineTestJoinSession");
static_assert(sizeof(UOnlineTestJoinSession) == 0x000180, "Wrong size on UOnlineTestJoinSession");
static_assert(offsetof(UOnlineTestJoinSession, OnSuccess) == 0x000030, "Member 'UOnlineTestJoinSession::OnSuccess' has a wrong offset!");
static_assert(offsetof(UOnlineTestJoinSession, OnFailure) == 0x000040, "Member 'UOnlineTestJoinSession::OnFailure' has a wrong offset!");

// Class BattlePrototype.ActionIcon
// 0x0068 (0x0298 - 0x0230)
class AActionIcon final : public AActor
{
public:
	class AActionIcon*                            PairActionIconActor;                               // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          ShowBoxComponent;                                  // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          EventBoxComponent;                                 // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x20];                                     // 0x0250(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldPositionOffset;                               // 0x0270(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionIconType                               ActionIconType;                                    // 0x027C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionIconSubQuestState                      ActionIconSubQuestState;                           // 0x027D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ActionIconSubQuestActive;                          // 0x027E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27F[0x1];                                      // 0x027F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIActionIcon*                          UIActionIcon;                                      // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActionIcon*                            PairActionIcon;                                    // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x4];                                      // 0x0290(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          OverlapEventInvalidFlag;                           // 0x0294(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_295[0x3];                                      // 0x0295(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckVisibleIcon(class AActor* Actor);
	bool GetOverlapEventInvalidFlag();
	void OnDecide();
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnReActivate();
	void RestoreVisible();
	void SafeSetIconMode(EActionIconMode Mode);
	void SetActionCollisionEnable(bool Enable);
	void SetActionIconSupportParam(const struct FActionIconSupportParam& ActionIconSupportParam);
	void SetBattleFlag(bool bBattle);
	void SetIconType(EActionIconType ActionIconType_0, bool IsActive);
	void SetLockIconMode(bool IsLock);
	void SetOverlapEventInvalidFlag(bool Enable);
	void SetSubQuestState(EActionIconSubQuestState State, bool SubquestActive);
	void SetVisible(const bool Flag, const bool UpdateState);
	void SetWorldPositionOffset(const struct FVector& WorldPositionOffset_0);
	void UpdateActionIconState();

	EActionIconType GetIconType() const;
	EActionIconSubQuestState GetSubQuestState() const;
	bool IsActionAbleIcon() const;
	bool IsPlayingActionIcon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionIcon">();
	}
	static class AActionIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActionIcon>();
	}
};
static_assert(alignof(AActionIcon) == 0x000008, "Wrong alignment on AActionIcon");
static_assert(sizeof(AActionIcon) == 0x000298, "Wrong size on AActionIcon");
static_assert(offsetof(AActionIcon, PairActionIconActor) == 0x000230, "Member 'AActionIcon::PairActionIconActor' has a wrong offset!");
static_assert(offsetof(AActionIcon, ShowBoxComponent) == 0x000240, "Member 'AActionIcon::ShowBoxComponent' has a wrong offset!");
static_assert(offsetof(AActionIcon, EventBoxComponent) == 0x000248, "Member 'AActionIcon::EventBoxComponent' has a wrong offset!");
static_assert(offsetof(AActionIcon, WorldPositionOffset) == 0x000270, "Member 'AActionIcon::WorldPositionOffset' has a wrong offset!");
static_assert(offsetof(AActionIcon, ActionIconType) == 0x00027C, "Member 'AActionIcon::ActionIconType' has a wrong offset!");
static_assert(offsetof(AActionIcon, ActionIconSubQuestState) == 0x00027D, "Member 'AActionIcon::ActionIconSubQuestState' has a wrong offset!");
static_assert(offsetof(AActionIcon, ActionIconSubQuestActive) == 0x00027E, "Member 'AActionIcon::ActionIconSubQuestActive' has a wrong offset!");
static_assert(offsetof(AActionIcon, UIActionIcon) == 0x000280, "Member 'AActionIcon::UIActionIcon' has a wrong offset!");
static_assert(offsetof(AActionIcon, PairActionIcon) == 0x000288, "Member 'AActionIcon::PairActionIcon' has a wrong offset!");
static_assert(offsetof(AActionIcon, OverlapEventInvalidFlag) == 0x000294, "Member 'AActionIcon::OverlapEventInvalidFlag' has a wrong offset!");

// Class BattlePrototype.ActionManager
// 0x0068 (0x0298 - 0x0230)
class AActionManager final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VisibilityCheckDistance;                           // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDispAreaNextUI;                                  // 0x023C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDebug;                                           // 0x023D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23E[0x5A];                                     // 0x023E(0x005A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearActionAll();
	int32 RegisterAction(class AActor* Actor);
	int32 RegisterAction2(class AActor* Actor);
	void SetBattleFlag(bool bBattle);
	void SetEnableActionCheck(bool bEnable);
	void UnregistAction(int32 Handle);
	void UnregistAction2(int32 Handle);

	bool IsExistEnableAction() const;
	bool IsExistEnableAction2() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionManager">();
	}
	static class AActionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActionManager>();
	}
};
static_assert(alignof(AActionManager) == 0x000008, "Wrong alignment on AActionManager");
static_assert(sizeof(AActionManager) == 0x000298, "Wrong size on AActionManager");
static_assert(offsetof(AActionManager, VisibilityCheckDistance) == 0x000238, "Member 'AActionManager::VisibilityCheckDistance' has a wrong offset!");
static_assert(offsetof(AActionManager, IsDispAreaNextUI) == 0x00023C, "Member 'AActionManager::IsDispAreaNextUI' has a wrong offset!");
static_assert(offsetof(AActionManager, IsDebug) == 0x00023D, "Member 'AActionManager::IsDebug' has a wrong offset!");

// Class BattlePrototype.ActionManagerInterface
// 0x0000 (0x0028 - 0x0028)
class IActionManagerInterface final : public IInterface
{
public:
	bool ActionManagerExecute(int32 Handle);
	class AActor* ActionManagerGetPairActor();
	void ActionManagerSetBattleFlag(bool bBattle);
	void ActionManagerSetIconMode(int32 Handle, EActionIconMode Mode);

	bool ActionManagerCheck(int32 Handle) const;
	float ActionManagerGetEditableAngle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionManagerInterface">();
	}
	static class IActionManagerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IActionManagerInterface>();
	}
};
static_assert(alignof(IActionManagerInterface) == 0x000008, "Wrong alignment on IActionManagerInterface");
static_assert(sizeof(IActionManagerInterface) == 0x000028, "Wrong size on IActionManagerInterface");

// Class BattlePrototype.PlayerSASHologramAttackCheckComponent
// 0x0090 (0x0150 - 0x00C0)
class UPlayerSASHologramAttackCheckComponent : public UActorComponent
{
public:
	float                                         ENABLE_CALLTIME;                                   // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ATTACK_INTERVAL_TIME;                              // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CANCEL_INTERVAL_TIME;                              // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         REQUEST_DISTANCE_MAX;                              // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSASHologramAttackCheckData>    CallDataTable;                                     // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSASHologramAttackProbabilityData> ProbabilityDataTable;                              // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x60];                                      // 0x00F0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginCallUI(EPlayerID PlayerId);
	void CancelCall(bool bInterval);
	void CheckHologramAttack(ESASHologramAttackTiming Timing, class ARSCharacterBase* RequestCharacter);
	void DebugPrintLog(bool bSet);
	void DebugSetAlways(bool bSet);
	void DebugSetFixPlayerID(EPlayerID PlayerId);
	void DebugSetIgnoreInterval(bool bSet);
	void EndCallUI(bool bSuccess);
	int32 GetHologramRushCount();
	bool IsEnableSASHologram(EPlayerID PlayerId);
	void LoadDataTable();
	void NotifyAttackBegin();
	void NotifyAttackEnd();
	void SetEnableCheck(bool bSet);
	void SetTimerPause(bool bPause);

	EPlayerID GetCallPlayer() const;
	bool IsAttackState() const;
	bool IsDoneCallPlayer() const;
	bool IsExistCall() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerSASHologramAttackCheckComponent">();
	}
	static class UPlayerSASHologramAttackCheckComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerSASHologramAttackCheckComponent>();
	}
};
static_assert(alignof(UPlayerSASHologramAttackCheckComponent) == 0x000008, "Wrong alignment on UPlayerSASHologramAttackCheckComponent");
static_assert(sizeof(UPlayerSASHologramAttackCheckComponent) == 0x000150, "Wrong size on UPlayerSASHologramAttackCheckComponent");
static_assert(offsetof(UPlayerSASHologramAttackCheckComponent, ENABLE_CALLTIME) == 0x0000C0, "Member 'UPlayerSASHologramAttackCheckComponent::ENABLE_CALLTIME' has a wrong offset!");
static_assert(offsetof(UPlayerSASHologramAttackCheckComponent, ATTACK_INTERVAL_TIME) == 0x0000C4, "Member 'UPlayerSASHologramAttackCheckComponent::ATTACK_INTERVAL_TIME' has a wrong offset!");
static_assert(offsetof(UPlayerSASHologramAttackCheckComponent, CANCEL_INTERVAL_TIME) == 0x0000C8, "Member 'UPlayerSASHologramAttackCheckComponent::CANCEL_INTERVAL_TIME' has a wrong offset!");
static_assert(offsetof(UPlayerSASHologramAttackCheckComponent, REQUEST_DISTANCE_MAX) == 0x0000CC, "Member 'UPlayerSASHologramAttackCheckComponent::REQUEST_DISTANCE_MAX' has a wrong offset!");
static_assert(offsetof(UPlayerSASHologramAttackCheckComponent, CallDataTable) == 0x0000D0, "Member 'UPlayerSASHologramAttackCheckComponent::CallDataTable' has a wrong offset!");
static_assert(offsetof(UPlayerSASHologramAttackCheckComponent, ProbabilityDataTable) == 0x0000E0, "Member 'UPlayerSASHologramAttackCheckComponent::ProbabilityDataTable' has a wrong offset!");

// Class BattlePrototype.ActorVisibleChangeBase
// 0x0030 (0x0260 - 0x0230)
class AActorVisibleChangeBase : public AActor
{
public:
	bool                                          IsCollectArrangeItem;                              // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCollectArrangeObject;                            // 0x0231(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCollectAnotherActor;                             // 0x0232(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_233[0x5];                                      // 0x0233(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       CollectorComponent;                                // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ChangeActors;                                      // 0x0240(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AArrangeItemBase*>               ChangeActors_ArrangeItemBase;                      // 0x0250(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CollectActors();
	void UnvisibleActors();
	void VisibleActors();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorVisibleChangeBase">();
	}
	static class AActorVisibleChangeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActorVisibleChangeBase>();
	}
};
static_assert(alignof(AActorVisibleChangeBase) == 0x000008, "Wrong alignment on AActorVisibleChangeBase");
static_assert(sizeof(AActorVisibleChangeBase) == 0x000260, "Wrong size on AActorVisibleChangeBase");
static_assert(offsetof(AActorVisibleChangeBase, IsCollectArrangeItem) == 0x000230, "Member 'AActorVisibleChangeBase::IsCollectArrangeItem' has a wrong offset!");
static_assert(offsetof(AActorVisibleChangeBase, IsCollectArrangeObject) == 0x000231, "Member 'AActorVisibleChangeBase::IsCollectArrangeObject' has a wrong offset!");
static_assert(offsetof(AActorVisibleChangeBase, IsCollectAnotherActor) == 0x000232, "Member 'AActorVisibleChangeBase::IsCollectAnotherActor' has a wrong offset!");
static_assert(offsetof(AActorVisibleChangeBase, CollectorComponent) == 0x000238, "Member 'AActorVisibleChangeBase::CollectorComponent' has a wrong offset!");
static_assert(offsetof(AActorVisibleChangeBase, ChangeActors) == 0x000240, "Member 'AActorVisibleChangeBase::ChangeActors' has a wrong offset!");
static_assert(offsetof(AActorVisibleChangeBase, ChangeActors_ArrangeItemBase) == 0x000250, "Member 'AActorVisibleChangeBase::ChangeActors_ArrangeItemBase' has a wrong offset!");

// Class BattlePrototype.LibraryCharacterParamUtility
// 0x0000 (0x0028 - 0x0028)
class ULibraryCharacterParamUtility final : public UBlueprintFunctionLibrary
{
public:
	static bool CharaLibraryCheckFlag(const class UObject* WorldContextObject, ELibraryFlagType FlagNo);
	static bool CharaLibraryOffFlag(const class UObject* WorldContextObject, ELibraryFlagType FlagNo);
	static bool CharaLibraryOnFlag(const class UObject* WorldContextObject, ELibraryFlagType FlagNo);
	static int32 CheckLibraryOpenByProgresNo(const class UObject* WorldContextObject, int32 ProgressNo);
	static bool OpenCharacterLibray(const class UObject* WorldContextObject, class FName LibName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LibraryCharacterParamUtility">();
	}
	static class ULibraryCharacterParamUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULibraryCharacterParamUtility>();
	}
};
static_assert(alignof(ULibraryCharacterParamUtility) == 0x000008, "Wrong alignment on ULibraryCharacterParamUtility");
static_assert(sizeof(ULibraryCharacterParamUtility) == 0x000028, "Wrong size on ULibraryCharacterParamUtility");

// Class BattlePrototype.AddContentManager
// 0x00B0 (0x00D8 - 0x0028)
class UAddContentManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             _RefDataTable;                                     // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             _AddContentsPresentListDataTable;                  // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, bool>                       _EntitledData;                                     // 0x0040(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x48];                                      // 0x0090(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsCheckingEntitlementInProgress();

	bool ConstructLocalEntitleData();
	bool GetAddContentRefDataCell(struct FAddContentRefDataCell* RowParam, class FName AddContentName);
	bool GetAddContentRefDataID(class FName* ID, class FName AddContentName);
	bool GetAddContentsPresentInfo(TArray<struct FAddContentsPresentInfo>* InfoList, class FName AddContentName);
	bool GetAddContentsTitleIdAndExplanationId(class FName AddContentName, class FString* TitleID, class FString* ExplanationID);
	TArray<class FName> GetAllContentsList();
	TArray<class FName> GetInvalidContentsList(const TArray<class FName>& PossessionContentsList);

	TArray<class FName> GetEntitledContentsList() const;
	bool IsEntitled(class FName AddContentName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddContentManager">();
	}
	static class UAddContentManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddContentManager>();
	}
};
static_assert(alignof(UAddContentManager) == 0x000008, "Wrong alignment on UAddContentManager");
static_assert(sizeof(UAddContentManager) == 0x0000D8, "Wrong size on UAddContentManager");
static_assert(offsetof(UAddContentManager, _RefDataTable) == 0x000030, "Member 'UAddContentManager::_RefDataTable' has a wrong offset!");
static_assert(offsetof(UAddContentManager, _AddContentsPresentListDataTable) == 0x000038, "Member 'UAddContentManager::_AddContentsPresentListDataTable' has a wrong offset!");
static_assert(offsetof(UAddContentManager, _EntitledData) == 0x000040, "Member 'UAddContentManager::_EntitledData' has a wrong offset!");

// Class BattlePrototype.AjitoBase
// 0x0000 (0x0230 - 0x0230)
class AAjitoBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AjitoBase">();
	}
	static class AAjitoBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAjitoBase>();
	}
};
static_assert(alignof(AAjitoBase) == 0x000008, "Wrong alignment on AAjitoBase");
static_assert(sizeof(AAjitoBase) == 0x000230, "Wrong size on AAjitoBase");

// Class BattlePrototype.AjitoManager
// 0x0008 (0x0238 - 0x0230)
class AAjitoManager : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AjitoManager">();
	}
	static class AAjitoManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAjitoManager>();
	}
};
static_assert(alignof(AAjitoManager) == 0x000008, "Wrong alignment on AAjitoManager");
static_assert(sizeof(AAjitoManager) == 0x000238, "Wrong size on AAjitoManager");

// Class BattlePrototype.PlayerAIBaseComponent
// 0x0300 (0x03C0 - 0x00C0)
class UPlayerAIBaseComponent : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameTimer>                     ThinkTimerList;                                    // 0x00C8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Param_ThreatTime;                                  // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerAIThreatActorData>       ThreatDataArray;                                   // 0x00E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameTimer                             EventMoveForceEndTimer;                            // 0x00F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         DodgeRangeAttackDistance;                          // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnpcUniqueObjDodgeProbability;                     // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x28];                                     // 0x010C(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	EPlayerAIMoveModeCPP                          MoveModeCPP;                                       // 0x0134(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLeftPos;                                          // 0x0135(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCircleDirClockwise;                               // 0x0136(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_137[0x1];                                      // 0x0137(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveCircleSpeed;                                   // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                JumpDestination;                                   // 0x013C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OrderJumpNum;                                      // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThinkDistance;                                     // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CurrentGoalBaseLocation;                           // 0x0150(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CurrentGoalRelativeLocation;                       // 0x015C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CurrentGoalDesiredRelativeLocation;                // 0x0168(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableGoalRelativeLocation;                       // 0x0174(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_175[0x3];                                      // 0x0175(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSGoalActorBase*                       MoveGoalActor;                                     // 0x0178(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentGoalArmLength;                              // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentGoalYaw;                                    // 0x0184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PrevThinkLastActorForward;                         // 0x0188(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCircleNear;                                       // 0x0194(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_195[0x3];                                      // 0x0195(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameTimer                             NearCircleMoveTimer;                               // 0x0198(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         NearCircleMoveNearDist;                            // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NearCircleMoveFarDist;                             // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                JumpDir;                                           // 0x01AC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPlayerAICheckMoveWallParamIn          AsyncCheckWallParamIn;                             // 0x01B8(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bOwnerENPC;                                        // 0x01D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInvalidKeepOut;                                   // 0x01D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttackHit;                                        // 0x01DA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DB[0x1];                                      // 0x01DB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ARSCharacterBase>        BattleTargetActor;                                 // 0x01DC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameTimer                             UpdateTargetTimer;                                 // 0x01E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bUpdateBattleTarget;                               // 0x01F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBattleModeFlag;                                   // 0x01F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceUpdateTarget;                                // 0x01F2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F3[0x1];                                      // 0x01F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AttackCount;                                       // 0x01F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NoAttackTime;                                      // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBattleActionStartFlag;                            // 0x01FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FD[0x3];                                      // 0x01FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateBattleTargetIntervalTime;                    // 0x0200(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDodgeAble;                                        // 0x0204(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDodgeAttack;                                      // 0x0205(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_206[0x2];                                      // 0x0206(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameTimer                             DodgeIntervalTimer;                                // 0x0208(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                BattleDodgeDir;                                    // 0x0214(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDodgeRangeAttack;                                 // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DodgeRangeAttackDir;                               // 0x0224(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DodgeIntervalTime;                                 // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForceDodgeIntervalTime;                            // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              LeftStick;                                         // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeftStickScale;                                    // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLeftStickScaleEnable;                             // 0x0244(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_245[0x3];                                      // 0x0245(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, bool>                       bEnableInputStick;                                 // 0x0248(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bMoveStickBack;                                    // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMoveStickDetour;                                  // 0x0299(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29A[0x2];                                      // 0x029A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveStickDetourYawAngle;                           // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerAITargetSearchModeCPP                  TargetSearchModeCPP;                               // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerAIOrder                                Order;                                             // 0x02A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A2[0x2];                                      // 0x02A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RANGE_NEAR;                                        // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RANGE_FAR;                                         // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RANGE_TOO_FAR;                                     // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MOVE_AIM_CIRRCLE_SPEED;                            // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MOVE_CIRCLE_SPEED;                                 // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MOVE_CIRCLE_SPEED_FAR;                             // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPC_WARY_HP_RATE_1;                                // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPC_WARY_HP_RATE_2;                                // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NPC_WARY_PROBABILITY_DOWN_1;                       // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NPC_WARY_PROBABILITY_DOWN_2;                       // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPC_ATTACK_PROBABILITY_UP_TIME_1;                  // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPC_ATTACK_PROBABILITY_UP_TIME_2;                  // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NPC_ATTACK_PROBABILITY_UP_VALUE_1;                 // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NPC_ATTACK_PROBABILITY_UP_VALUE_2;                 // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPC_MOVE_PROBABILITY_DOWN_TIME;                    // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NPC_MOVE_PROBABILITY_DOWN_VALUE;                   // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NPC_ATTACK_PROBABILITY_DOWN_THREAT_VALUE;          // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NPC_ASSIST_ATTACK_PROBABILITY_UP_VALUE;            // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPC_REVIVE_DISTANCE;                               // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPC_REVIVE_DISTANCE_FAR;                           // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CONFUSION_FRIEND_PRIORITY_OFFSET;                  // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           EvaluateLocationTimerHandle;                       // 0x02F8(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBeginEvaluateLocation;                            // 0x0300(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFirstEvaluate;                                    // 0x0301(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResetBehaviorTree;                                // 0x0302(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEventWait;                                        // 0x0303(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerAIBattleThinkTypeCPP                   CurrentBattleThinkCPP;                             // 0x0304(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerAIBattleThinkParamCPP                  CurrentBattleThinkParamCPP;                        // 0x0305(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_306[0x2];                                      // 0x0306(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 StealthThinkRateList;                              // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EPlayerAIBattleThinkTypeCPP>           StealthThinkTypeListCPP;                           // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerAIBattleThinkTypeCPP                   ReserveThinkTypeCPP;                               // 0x0328(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerAIBattleThinkParamCPP                  ReserveThinkParamCPP;                              // 0x0329(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReserveNextThink;                                 // 0x032A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFinishMetamorphosis;                              // 0x032B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ThinkPhaseTransition;                              // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerAIThinkTableTypeCPP                    CurrentThinkTableTypeCPP;                          // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEventMove;                                        // 0x0331(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_332[0x6];                                      // 0x0332(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        EventMovePosList;                                  // 0x0338(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 EventMoveRadiusList;                               // 0x0348(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EventMoveWalkScale;                                // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ClaimantNameEventMove;                             // 0x035C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharacterHitPriority                         StoreCharacterHitPriority;                         // 0x0364(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStoreCharacterHitPriority;                        // 0x0365(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEventMoveAfterWait;                               // 0x0366(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEventMoveWalkFlag;                                // 0x0367(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseItemThink;                                     // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EConsumeItemID                                UseItemID;                                         // 0x0369(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAssistItem;                                       // 0x036A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36B[0x1];                                      // 0x036B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ControlPlayerDist;                                 // 0x036C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BattleTargetDist;                                  // 0x0378(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BattleTargetAngle;                                 // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSelfRecoveryFlag;                                 // 0x0388(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_389[0x3];                                      // 0x0389(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelfRecoveryNum;                                   // 0x038C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDrawLocationEvaluate;                        // 0x0390(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_391[0x3];                                      // 0x0391(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialTargetLength;                               // 0x0394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableTargetChangeResetThink;                    // 0x0398(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerScriptComponent*                 OwnerPlayerScript;                                 // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCppFunc;                                       // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      CollisionObjectTypesForGroundHit;                  // 0x03B0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool BeginEvaluateLocation_CallFromCPP();
	bool BindCheckBattleActionStart_CallFromCPP();
	float CalcDistanceTargetEvaluateCPP(const struct FVector& TargetLocation);
	struct FVector CalcMoveToActorLocationCPP(class ACharacter* Self);
	struct FVector CalcStickDir_BattleDodgeCPP();
	struct FVector2D CalcStickDirCPP();
	float CalcTargetEvaluate_CallFromCPP(class ARSCharacterBase* EvaluateTarget);
	int32 CalcThinkTransitionProbabilityCPP(int32 Probability, EPlayerAIBattleThinkTypeCPP Action);
	int32 CalcThinkTransitionProbabilityCPP_CheckMoveOrAttackOrOthers(EPlayerAIBattleThinkTypeCPP Action);
	bool CalcThinkTransitionProbabilityCPP_NeedsHPCheckByThinkType(EPlayerAIBattleThinkTypeCPP Action);
	void CancelUseItemCPP();
	void ChangeThinkTableTypeCPP(EPlayerAIThinkTableTypeCPP ThinkTableType, bool bResetThink);
	bool CheckBattleThinkTransition_CallFromCPP(EPlayerAIBattleThinkTransitionCPP Transition);
	bool CheckDodgeRangeAttack(struct FVector* DodgeDir);
	bool CheckEventMovePosCPP(bool bCheckDistance);
	void CheckGoalLocationKeepOutCPP();
	bool CheckInAttackArea_CallFromCPP(const struct FVector& CheckLocation);
	bool CheckMovePosCPP();
	void CheckMoveWallCPP(EPlayerAIMoveWallCPP* OutWall, struct FVector* OutLocation);
	bool CheckPsychicObjectCPP(bool bCapture, bool bAttack);
	bool CheckSelfRecovery_CallFromCPP();
	void ClearDodgeRangeAttackData();
	TArray<struct FPlayerAIThreatActorData> DebugGetThreatDataArray();
	bool DebugUpdate_CallFromCPP();
	void DecreaseSelfRecoveryNumCPP();
	void DisableStickInputCPP(class FName ClaimantName);
	void EnableStickInputCPP(class FName ClaimantName);
	bool EndEvaluateLocation_CallFromCPP();
	void EndEventMoveCPP();
	void EndEventWaitCPP();
	TArray<EObjectTypeQuery> GetCollisionObjectTypesForGroundHit_CallFromCPP();
	void GetEventMovePosActorCPP(class AActor** OutPosActor, float* OutAcceptRadius);
	EPlayerAIBattleThinkTypeCPP GetStealthThinkCPP();
	void InitializeAI();
	void InitializeFixParam(const struct FPlayerAIComponentInitializeParam& Param);
	void InitializeThinkTimerList(int32 TimerNum);
	bool IsPsychicAbleCPP();
	bool IsRegisterThreatActor(class AActor* CheckActor);
	bool IsThinkTimerOverByIndex(int32 Index_0);
	void JumpOrderCPP(const struct FVector& Destination);
	void MainUpdateCPP();
	bool NextBattleThink_CallFromCPP();
	struct FVector NormalizeVectorXY_CPP(const struct FVector& InVec);
	void NotifyAttackStartCPP();
	void NotifyForceWarpCPP();
	void NotifyMoveBrainFieldCPP(bool bToBrainField);
	void NotifyResetBehaviorTreeCPP();
	void OnAttackHitCPP();
	void OnClearReserveReturnMovePlayer();
	void OnEventStartCPP();
	void OnInitializeAI();
	void OnJumpCPP();
	void OnMovementCollisionLandCPP();
	void OnReserveReturnMovePlayer();
	void OnUpdateAI();
	void OnUpdateUpdateEvaluateLocationCPP();
	void PostUpdateCPP();
	void PreUpdateCPP();
	bool PreUpdateCPP_RangeAttack_BPImplement();
	void RegisterEvaluateLocationCPP();
	void RegisterThreatActor(class AActor* ThreatActor);
	void RequestUseItemCPP(EConsumeItemID Item_id_in, bool bAssist);
	void ReserveNextThinkCPP(EPlayerAIBattleThinkTypeCPP ThinkType, EPlayerAIBattleThinkParamCPP Param);
	void ResetBattleThinkCPP();
	bool RestartBattleAI_CallFromCPP(bool bInEvent);
	class ARSCharacterBase* SearchTargetCPP(const TArray<class ARSCharacterBase*>& TargetList);
	void SetAttackHit(bool Value);
	void SetBattleModeCPP(bool bBattle);
	void SetBattleTargetCPP(class ARSCharacterBase* TargetActor);
	void SetBattleTargetDist(const struct FVector& Value);
	bool SetBattleThink_CallFromCPP(EPlayerAIBattleThinkTypeCPP Action, EPlayerAIBattleThinkParamCPP Param);
	void SetDisableChangeTargetResetThinkCPP(bool InDisable);
	void SetEventMoveCPP(const TArray<struct FVector>& Pos_list_in, const TArray<float>& Radius_list_in, bool Walk, bool bAfterWait, float MaxMoveTime);
	void SetEventWaitCPP();
	bool SetFinishMetamorphosisCPP(bool bFinish);
	void SetForceUpdateTarget(bool Value);
	void SetInvalidKeepOutCPP(bool IsInvalid);
	void SetLeftStickScale(bool bEnable, float Scale);
	void SetMoveLocationCPP(const struct FVector& Location, float ArmLength, float Yaw);
	void SetMoveModeCPP(EPlayerAIMoveModeCPP Mode);
	void SetMoveModeFromThinkCPP(EPlayerAIBattleThinkTypeCPP Think);
	void SetMoveStickBackCPP(bool bBack);
	void SetMoveStickDetourCPP(bool bEnable, float YawAngle);
	void SetOrderCPP(EPlayerAIOrder _Order);
	void SetOwnerPlayerScript(class UPlayerScriptComponent* Comp);
	void SetSelfRecoveryNum(int32 Value);
	void SetTargetSearchModeCPP(EPlayerAITargetSearchModeCPP Value);
	void SetThinkKeepOutCPP();
	bool SetThinkPhaseTransitionCPP(int32 NewPhase);
	void SetThinkTimerByIndex(int32 Index_0, float Time);
	bool SetupUseItem_CallFromCPP();
	bool UnbindCheckBattleActionStart_CallFromCPP();
	void UpdateAI();
	bool UpdateBattleDodgeDir_CallFromCPP();
	void UpdateBattleTargetActorCPP();
	bool UpdateCheckBattleActionStartCPP();
	void UpdateCheckRangeAttack(class UHitCheckComponent* HitCheck);
	void UpdateCheckRangeAttackEnpc(class UHitCheckComponent* HitCheck);
	void UpdateCounterCPP();
	void UpdateCPP();
	void UpdateDataCPP();
	void UpdateDodge_BattleCPP();
	void UpdateDodge_FollowPlayerCPP();
	void UpdateDodgeBattle_Enpc_BPImplement(bool* bOK, bool* OutDodgeNormalAttack, bool* OutDodgeRangeAttack, bool* OutForceDodge);
	void UpdateDodgeCPP();
	void UpdateEventMoveCPP();
	void UpdateMovePos_ApproachTargetCPP();
	void UpdateMovePos_CircleCPP();
	void UpdateMovePos_FollowPlayerCPP();
	void UpdateMovePosCPP();
	void UpdateMoveWallCPP();
	void UpdateThinkTimerList(class AActor* UpdateActor);
	void UpdateThreatData(float DeltaSeconds);

	struct FVector CalcStickDir_BattleAttackCPP() const;
	bool CheckDistanceCPP(const struct FVector& RefPos1, const struct FVector& RefPos2, float Distance, bool bIgnoreHeight) const;
	bool CheckDistanceFromVectorCPP(const struct FVector& Dist, float Distance, bool bIgnoreHeight) const;
	bool CheckDistanceFromVectorXY_CPP(const struct FVector& Vec, float Distance) const;
	bool CheckDistanceFromVectorXYZ_CPP(const struct FVector& Vec, float Distance) const;
	bool CheckNpcReviveCPP(float InDistance) const;
	bool CheckUnderSiegeCPP() const;
	int32 GetAttackCountCPP() const;
	ERSAttackInputKind GetAttackInputKindCPP() const;
	class AActor* GetBattleTargetActorCPP() const;
	struct FVector GetBattleTargetDist() const;
	struct FVector GetControlPlayerDistCPP() const;
	EPlayerAIBattleThinkTypeCPP GetCurrentBattleThinkCPP() const;
	EPlayerAIBattleThinkParamCPP GetCurrentBattleThinkParamCPP() const;
	class UDataTable* GetCurrentThinkTable_CallFromCPP() const;
	class UPlayerAIEvaluateLocationComponent* GetEvaluateLocation() const;
	float GetEventMoveLeftStickX_CPP() const;
	float GetEventMoveLeftStickY_CPP() const;
	float GetLeftStickScale() const;
	EPlayerAIMoveModeCPP GetMoveModeCPP() const;
	class AActor* GetMovePosActorCPP() const;
	EPlayerAIOrder GetOrderCPP() const;
	int32 GetSelfRecoveryNum() const;
	float GetTargetAngleCPP(const struct FVector& BaseDirection, const struct FVector& TargetDirection) const;
	float GetTargetAngleXY_CPP(const struct FVector& BaseDirection, const struct FVector& TargetDirection) const;
	void GetTargetEvaluateData_CallFromCPP(struct FPlayerAIEvaluateTargetParameter* OutParam) const;
	int32 GetThinkPhaseTransitionCPP() const;
	EConsumeItemID GetUseItemID_CPP() const;
	bool IsAttackAbleCPP() const;
	bool IsAttackAbleCPP_TypeCheck(EPlayerAIBattleThinkTypeCPP ThinkType) const;
	bool IsAttackHit() const;
	bool IsAttackThinkCPP(EPlayerAIBattleThinkTypeCPP Type) const;
	bool IsBattleActionStartCPP() const;
	bool IsBattleThinkCPP(EPlayerAIBattleThinkTypeCPP Type) const;
	bool IsDodgeAbleCPP() const;
	bool IsEnableStickInputCPP() const;
	bool IsEventMoveCPP() const;
	bool IsEventMoveEndCPP() const;
	bool IsEventWaitCPP() const;
	bool IsFinishMetamorphosisCPP() const;
	bool IsForceUpdateTarget() const;
	bool IsJumpAbleCPP() const;
	bool IsLeftStickScaleEnable() const;
	bool IsPsychicAbleCPP_TypeCheck(EPlayerAIBattleThinkTypeCPP ThinkType) const;
	bool IsPsychicComboThinkCPP() const;
	bool IsRangeFarCPP(const struct FVector& Dist) const;
	bool IsRangeMiddleCPP(const struct FVector& Dist) const;
	bool IsRangeNearCPP(const struct FVector& Dist) const;
	bool IsRangeTooFarCPP(const struct FVector& Dist) const;
	bool IsResetBehaviorTreeCPP() const;
	bool IsSelfRecoveryCPP() const;
	bool IsUpdateCPP() const;
	bool IsUseCppFunc() const;
	bool IsUseItemThinkCPP() const;
	bool IsWaitBattleStartCPP() const;
	bool SearchPsychicObjectCPP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerAIBaseComponent">();
	}
	static class UPlayerAIBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerAIBaseComponent>();
	}
};
static_assert(alignof(UPlayerAIBaseComponent) == 0x000008, "Wrong alignment on UPlayerAIBaseComponent");
static_assert(sizeof(UPlayerAIBaseComponent) == 0x0003C0, "Wrong size on UPlayerAIBaseComponent");
static_assert(offsetof(UPlayerAIBaseComponent, ThinkTimerList) == 0x0000C8, "Member 'UPlayerAIBaseComponent::ThinkTimerList' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, Param_ThreatTime) == 0x0000E0, "Member 'UPlayerAIBaseComponent::Param_ThreatTime' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, ThreatDataArray) == 0x0000E8, "Member 'UPlayerAIBaseComponent::ThreatDataArray' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, EventMoveForceEndTimer) == 0x0000F8, "Member 'UPlayerAIBaseComponent::EventMoveForceEndTimer' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, DodgeRangeAttackDistance) == 0x000104, "Member 'UPlayerAIBaseComponent::DodgeRangeAttackDistance' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, EnpcUniqueObjDodgeProbability) == 0x000108, "Member 'UPlayerAIBaseComponent::EnpcUniqueObjDodgeProbability' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, MoveModeCPP) == 0x000134, "Member 'UPlayerAIBaseComponent::MoveModeCPP' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bLeftPos) == 0x000135, "Member 'UPlayerAIBaseComponent::bLeftPos' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bCircleDirClockwise) == 0x000136, "Member 'UPlayerAIBaseComponent::bCircleDirClockwise' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, MoveCircleSpeed) == 0x000138, "Member 'UPlayerAIBaseComponent::MoveCircleSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, JumpDestination) == 0x00013C, "Member 'UPlayerAIBaseComponent::JumpDestination' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, OrderJumpNum) == 0x000148, "Member 'UPlayerAIBaseComponent::OrderJumpNum' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, ThinkDistance) == 0x00014C, "Member 'UPlayerAIBaseComponent::ThinkDistance' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CurrentGoalBaseLocation) == 0x000150, "Member 'UPlayerAIBaseComponent::CurrentGoalBaseLocation' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CurrentGoalRelativeLocation) == 0x00015C, "Member 'UPlayerAIBaseComponent::CurrentGoalRelativeLocation' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CurrentGoalDesiredRelativeLocation) == 0x000168, "Member 'UPlayerAIBaseComponent::CurrentGoalDesiredRelativeLocation' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bEnableGoalRelativeLocation) == 0x000174, "Member 'UPlayerAIBaseComponent::bEnableGoalRelativeLocation' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, MoveGoalActor) == 0x000178, "Member 'UPlayerAIBaseComponent::MoveGoalActor' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CurrentGoalArmLength) == 0x000180, "Member 'UPlayerAIBaseComponent::CurrentGoalArmLength' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CurrentGoalYaw) == 0x000184, "Member 'UPlayerAIBaseComponent::CurrentGoalYaw' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, PrevThinkLastActorForward) == 0x000188, "Member 'UPlayerAIBaseComponent::PrevThinkLastActorForward' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bCircleNear) == 0x000194, "Member 'UPlayerAIBaseComponent::bCircleNear' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NearCircleMoveTimer) == 0x000198, "Member 'UPlayerAIBaseComponent::NearCircleMoveTimer' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NearCircleMoveNearDist) == 0x0001A4, "Member 'UPlayerAIBaseComponent::NearCircleMoveNearDist' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NearCircleMoveFarDist) == 0x0001A8, "Member 'UPlayerAIBaseComponent::NearCircleMoveFarDist' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, JumpDir) == 0x0001AC, "Member 'UPlayerAIBaseComponent::JumpDir' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, AsyncCheckWallParamIn) == 0x0001B8, "Member 'UPlayerAIBaseComponent::AsyncCheckWallParamIn' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bOwnerENPC) == 0x0001D8, "Member 'UPlayerAIBaseComponent::bOwnerENPC' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bInvalidKeepOut) == 0x0001D9, "Member 'UPlayerAIBaseComponent::bInvalidKeepOut' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bAttackHit) == 0x0001DA, "Member 'UPlayerAIBaseComponent::bAttackHit' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, BattleTargetActor) == 0x0001DC, "Member 'UPlayerAIBaseComponent::BattleTargetActor' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, UpdateTargetTimer) == 0x0001E4, "Member 'UPlayerAIBaseComponent::UpdateTargetTimer' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bUpdateBattleTarget) == 0x0001F0, "Member 'UPlayerAIBaseComponent::bUpdateBattleTarget' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bBattleModeFlag) == 0x0001F1, "Member 'UPlayerAIBaseComponent::bBattleModeFlag' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bForceUpdateTarget) == 0x0001F2, "Member 'UPlayerAIBaseComponent::bForceUpdateTarget' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, AttackCount) == 0x0001F4, "Member 'UPlayerAIBaseComponent::AttackCount' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NoAttackTime) == 0x0001F8, "Member 'UPlayerAIBaseComponent::NoAttackTime' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bBattleActionStartFlag) == 0x0001FC, "Member 'UPlayerAIBaseComponent::bBattleActionStartFlag' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, UpdateBattleTargetIntervalTime) == 0x000200, "Member 'UPlayerAIBaseComponent::UpdateBattleTargetIntervalTime' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bDodgeAble) == 0x000204, "Member 'UPlayerAIBaseComponent::bDodgeAble' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bDodgeAttack) == 0x000205, "Member 'UPlayerAIBaseComponent::bDodgeAttack' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, DodgeIntervalTimer) == 0x000208, "Member 'UPlayerAIBaseComponent::DodgeIntervalTimer' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, BattleDodgeDir) == 0x000214, "Member 'UPlayerAIBaseComponent::BattleDodgeDir' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bDodgeRangeAttack) == 0x000220, "Member 'UPlayerAIBaseComponent::bDodgeRangeAttack' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, DodgeRangeAttackDir) == 0x000224, "Member 'UPlayerAIBaseComponent::DodgeRangeAttackDir' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, DodgeIntervalTime) == 0x000230, "Member 'UPlayerAIBaseComponent::DodgeIntervalTime' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, ForceDodgeIntervalTime) == 0x000234, "Member 'UPlayerAIBaseComponent::ForceDodgeIntervalTime' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, LeftStick) == 0x000238, "Member 'UPlayerAIBaseComponent::LeftStick' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, LeftStickScale) == 0x000240, "Member 'UPlayerAIBaseComponent::LeftStickScale' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bLeftStickScaleEnable) == 0x000244, "Member 'UPlayerAIBaseComponent::bLeftStickScaleEnable' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bEnableInputStick) == 0x000248, "Member 'UPlayerAIBaseComponent::bEnableInputStick' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bMoveStickBack) == 0x000298, "Member 'UPlayerAIBaseComponent::bMoveStickBack' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bMoveStickDetour) == 0x000299, "Member 'UPlayerAIBaseComponent::bMoveStickDetour' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, MoveStickDetourYawAngle) == 0x00029C, "Member 'UPlayerAIBaseComponent::MoveStickDetourYawAngle' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, TargetSearchModeCPP) == 0x0002A0, "Member 'UPlayerAIBaseComponent::TargetSearchModeCPP' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, Order) == 0x0002A1, "Member 'UPlayerAIBaseComponent::Order' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, RANGE_NEAR) == 0x0002A4, "Member 'UPlayerAIBaseComponent::RANGE_NEAR' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, RANGE_FAR) == 0x0002A8, "Member 'UPlayerAIBaseComponent::RANGE_FAR' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, RANGE_TOO_FAR) == 0x0002AC, "Member 'UPlayerAIBaseComponent::RANGE_TOO_FAR' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, MOVE_AIM_CIRRCLE_SPEED) == 0x0002B0, "Member 'UPlayerAIBaseComponent::MOVE_AIM_CIRRCLE_SPEED' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, MOVE_CIRCLE_SPEED) == 0x0002B4, "Member 'UPlayerAIBaseComponent::MOVE_CIRCLE_SPEED' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, MOVE_CIRCLE_SPEED_FAR) == 0x0002B8, "Member 'UPlayerAIBaseComponent::MOVE_CIRCLE_SPEED_FAR' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_WARY_HP_RATE_1) == 0x0002BC, "Member 'UPlayerAIBaseComponent::NPC_WARY_HP_RATE_1' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_WARY_HP_RATE_2) == 0x0002C0, "Member 'UPlayerAIBaseComponent::NPC_WARY_HP_RATE_2' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_WARY_PROBABILITY_DOWN_1) == 0x0002C4, "Member 'UPlayerAIBaseComponent::NPC_WARY_PROBABILITY_DOWN_1' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_WARY_PROBABILITY_DOWN_2) == 0x0002C8, "Member 'UPlayerAIBaseComponent::NPC_WARY_PROBABILITY_DOWN_2' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_ATTACK_PROBABILITY_UP_TIME_1) == 0x0002CC, "Member 'UPlayerAIBaseComponent::NPC_ATTACK_PROBABILITY_UP_TIME_1' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_ATTACK_PROBABILITY_UP_TIME_2) == 0x0002D0, "Member 'UPlayerAIBaseComponent::NPC_ATTACK_PROBABILITY_UP_TIME_2' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_ATTACK_PROBABILITY_UP_VALUE_1) == 0x0002D4, "Member 'UPlayerAIBaseComponent::NPC_ATTACK_PROBABILITY_UP_VALUE_1' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_ATTACK_PROBABILITY_UP_VALUE_2) == 0x0002D8, "Member 'UPlayerAIBaseComponent::NPC_ATTACK_PROBABILITY_UP_VALUE_2' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_MOVE_PROBABILITY_DOWN_TIME) == 0x0002DC, "Member 'UPlayerAIBaseComponent::NPC_MOVE_PROBABILITY_DOWN_TIME' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_MOVE_PROBABILITY_DOWN_VALUE) == 0x0002E0, "Member 'UPlayerAIBaseComponent::NPC_MOVE_PROBABILITY_DOWN_VALUE' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_ATTACK_PROBABILITY_DOWN_THREAT_VALUE) == 0x0002E4, "Member 'UPlayerAIBaseComponent::NPC_ATTACK_PROBABILITY_DOWN_THREAT_VALUE' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_ASSIST_ATTACK_PROBABILITY_UP_VALUE) == 0x0002E8, "Member 'UPlayerAIBaseComponent::NPC_ASSIST_ATTACK_PROBABILITY_UP_VALUE' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_REVIVE_DISTANCE) == 0x0002EC, "Member 'UPlayerAIBaseComponent::NPC_REVIVE_DISTANCE' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_REVIVE_DISTANCE_FAR) == 0x0002F0, "Member 'UPlayerAIBaseComponent::NPC_REVIVE_DISTANCE_FAR' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CONFUSION_FRIEND_PRIORITY_OFFSET) == 0x0002F4, "Member 'UPlayerAIBaseComponent::CONFUSION_FRIEND_PRIORITY_OFFSET' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, EvaluateLocationTimerHandle) == 0x0002F8, "Member 'UPlayerAIBaseComponent::EvaluateLocationTimerHandle' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bBeginEvaluateLocation) == 0x000300, "Member 'UPlayerAIBaseComponent::bBeginEvaluateLocation' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bFirstEvaluate) == 0x000301, "Member 'UPlayerAIBaseComponent::bFirstEvaluate' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bResetBehaviorTree) == 0x000302, "Member 'UPlayerAIBaseComponent::bResetBehaviorTree' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bEventWait) == 0x000303, "Member 'UPlayerAIBaseComponent::bEventWait' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CurrentBattleThinkCPP) == 0x000304, "Member 'UPlayerAIBaseComponent::CurrentBattleThinkCPP' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CurrentBattleThinkParamCPP) == 0x000305, "Member 'UPlayerAIBaseComponent::CurrentBattleThinkParamCPP' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, StealthThinkRateList) == 0x000308, "Member 'UPlayerAIBaseComponent::StealthThinkRateList' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, StealthThinkTypeListCPP) == 0x000318, "Member 'UPlayerAIBaseComponent::StealthThinkTypeListCPP' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, ReserveThinkTypeCPP) == 0x000328, "Member 'UPlayerAIBaseComponent::ReserveThinkTypeCPP' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, ReserveThinkParamCPP) == 0x000329, "Member 'UPlayerAIBaseComponent::ReserveThinkParamCPP' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bReserveNextThink) == 0x00032A, "Member 'UPlayerAIBaseComponent::bReserveNextThink' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bFinishMetamorphosis) == 0x00032B, "Member 'UPlayerAIBaseComponent::bFinishMetamorphosis' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, ThinkPhaseTransition) == 0x00032C, "Member 'UPlayerAIBaseComponent::ThinkPhaseTransition' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CurrentThinkTableTypeCPP) == 0x000330, "Member 'UPlayerAIBaseComponent::CurrentThinkTableTypeCPP' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bEventMove) == 0x000331, "Member 'UPlayerAIBaseComponent::bEventMove' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, EventMovePosList) == 0x000338, "Member 'UPlayerAIBaseComponent::EventMovePosList' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, EventMoveRadiusList) == 0x000348, "Member 'UPlayerAIBaseComponent::EventMoveRadiusList' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, EventMoveWalkScale) == 0x000358, "Member 'UPlayerAIBaseComponent::EventMoveWalkScale' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, ClaimantNameEventMove) == 0x00035C, "Member 'UPlayerAIBaseComponent::ClaimantNameEventMove' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, StoreCharacterHitPriority) == 0x000364, "Member 'UPlayerAIBaseComponent::StoreCharacterHitPriority' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bStoreCharacterHitPriority) == 0x000365, "Member 'UPlayerAIBaseComponent::bStoreCharacterHitPriority' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bEventMoveAfterWait) == 0x000366, "Member 'UPlayerAIBaseComponent::bEventMoveAfterWait' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bEventMoveWalkFlag) == 0x000367, "Member 'UPlayerAIBaseComponent::bEventMoveWalkFlag' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bUseItemThink) == 0x000368, "Member 'UPlayerAIBaseComponent::bUseItemThink' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, UseItemID) == 0x000369, "Member 'UPlayerAIBaseComponent::UseItemID' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bAssistItem) == 0x00036A, "Member 'UPlayerAIBaseComponent::bAssistItem' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, ControlPlayerDist) == 0x00036C, "Member 'UPlayerAIBaseComponent::ControlPlayerDist' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, BattleTargetDist) == 0x000378, "Member 'UPlayerAIBaseComponent::BattleTargetDist' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, BattleTargetAngle) == 0x000384, "Member 'UPlayerAIBaseComponent::BattleTargetAngle' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bSelfRecoveryFlag) == 0x000388, "Member 'UPlayerAIBaseComponent::bSelfRecoveryFlag' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, SelfRecoveryNum) == 0x00038C, "Member 'UPlayerAIBaseComponent::SelfRecoveryNum' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bDebugDrawLocationEvaluate) == 0x000390, "Member 'UPlayerAIBaseComponent::bDebugDrawLocationEvaluate' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, InitialTargetLength) == 0x000394, "Member 'UPlayerAIBaseComponent::InitialTargetLength' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bDisableTargetChangeResetThink) == 0x000398, "Member 'UPlayerAIBaseComponent::bDisableTargetChangeResetThink' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, OwnerPlayerScript) == 0x0003A0, "Member 'UPlayerAIBaseComponent::OwnerPlayerScript' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bUseCppFunc) == 0x0003A8, "Member 'UPlayerAIBaseComponent::bUseCppFunc' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CollisionObjectTypesForGroundHit) == 0x0003B0, "Member 'UPlayerAIBaseComponent::CollisionObjectTypesForGroundHit' has a wrong offset!");

// Class BattlePrototype.EnemyCheckDodgeJustComponent
// 0x0008 (0x00C8 - 0x00C0)
class UEnemyCheckDodgeJustComponent final : public UActorComponent
{
public:
	float                                         MDodgeRadius;                                      // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MDodgeRadiusRangeAttack;                           // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CheckEnableDodgeJust(const struct FVector& Location, const struct FVector& UpDir, const struct FVector& Offset, float Height, float Radius, class UHitCheckComponent* HitCheck, float CheckScale, float CheckRangeScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyCheckDodgeJustComponent">();
	}
	static class UEnemyCheckDodgeJustComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyCheckDodgeJustComponent>();
	}
};
static_assert(alignof(UEnemyCheckDodgeJustComponent) == 0x000008, "Wrong alignment on UEnemyCheckDodgeJustComponent");
static_assert(sizeof(UEnemyCheckDodgeJustComponent) == 0x0000C8, "Wrong size on UEnemyCheckDodgeJustComponent");
static_assert(offsetof(UEnemyCheckDodgeJustComponent, MDodgeRadius) == 0x0000C0, "Member 'UEnemyCheckDodgeJustComponent::MDodgeRadius' has a wrong offset!");
static_assert(offsetof(UEnemyCheckDodgeJustComponent, MDodgeRadiusRangeAttack) == 0x0000C4, "Member 'UEnemyCheckDodgeJustComponent::MDodgeRadiusRangeAttack' has a wrong offset!");

// Class BattlePrototype.AjitoMember
// 0x0160 (0x0390 - 0x0230)
class AAjitoMember : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTransform                             M_storeSkeletalMeshTransform;                      // 0x0240(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x4];                                      // 0x0270(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EPlayerID                                     PlayerId;                                          // 0x0274(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_275[0x3];                                      // 0x0275(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlaceID;                                           // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaceNo;                                           // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ExclusivePlaceNoList;                              // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         WithPlaceNoList;                                   // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionName;                                        // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLookAtPlayer;                                    // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      CharacterCapsuleComponent;                         // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          ShowBoxComponent;                                  // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          EventBoxComponent;                                 // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AMakeEventActor>            MakeEventActorClass;                               // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMakeEventActor*                        MakeEventActor;                                    // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x1];                                      // 0x02D8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsOverlappingPlayer;                               // 0x02D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DA[0x6];                                      // 0x02DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActionIconCoolTime;                                // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvalableAction;                                  // 0x02E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E5[0xB];                                      // 0x02E5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class UChildActorComponent*                   ChildActionIcon;                                   // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActionIcon*                            ActionIcon;                                        // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActionIconWorldPositionOffset;                     // 0x0300(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionIconType                               ActionIconType;                                    // 0x030C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30D[0x3];                                      // 0x030D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetIconOffsetZ;                                 // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URSAjitoAnimInstance>       AnimClass;                                         // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class URSAjitoAnimInstance>    AnimationBP;                                       // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             IconOffsetDataTable;                               // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FNpcIconOffsetInfo>  IconOffsetDataInfos;                               // 0x0330(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         WaitTimeTransitionToTalk;                          // 0x0380(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTimeTransitionToIdle;                          // 0x0384(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdjustIconOffsetByHeadHeight();
	void AdjustIconOffsetByHeadHeightForce(float HeadHeight);
	void ClearWaitTransitionToIdle();
	void ClearWaitTransitionToTalk();
	TArray<class AActor*> GetAllOmActors();
	float GetHeadHeight();
	bool IsActiveMakeEvent();
	bool IsTalkEnablePlayer();
	void PresentEventEnd();
	void PresentEventStart();
	void RequestTalkEnd();
	void RequestTalkStart();
	void SetActionIconType(EActionIconType Type);
	void SetActionIcoVisible(bool Visible);
	bool SetAttachmentVisible(bool Visible);
	void SetIconOffsetPreset(class FName RawName);
	void SetTargetIconOffsetZ(float HeadHeight);
	bool UpdateActionIcon();
	void UpdateTargetIconOffsetZ();
	void WaitTransitionToIdle(float WaitTime);
	void WaitTransitionToTalk(float WaitTime);

	bool IsReadyToTalk() const;
	bool IsWaitTransitionToIdle() const;
	bool IsWaitTransitionToTalk() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AjitoMember">();
	}
	static class AAjitoMember* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAjitoMember>();
	}
};
static_assert(alignof(AAjitoMember) == 0x000010, "Wrong alignment on AAjitoMember");
static_assert(sizeof(AAjitoMember) == 0x000390, "Wrong size on AAjitoMember");
static_assert(offsetof(AAjitoMember, SkeletalMeshComponent) == 0x000238, "Member 'AAjitoMember::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AAjitoMember, M_storeSkeletalMeshTransform) == 0x000240, "Member 'AAjitoMember::M_storeSkeletalMeshTransform' has a wrong offset!");
static_assert(offsetof(AAjitoMember, PlayerId) == 0x000274, "Member 'AAjitoMember::PlayerId' has a wrong offset!");
static_assert(offsetof(AAjitoMember, PlaceID) == 0x000278, "Member 'AAjitoMember::PlaceID' has a wrong offset!");
static_assert(offsetof(AAjitoMember, PlaceNo) == 0x00027C, "Member 'AAjitoMember::PlaceNo' has a wrong offset!");
static_assert(offsetof(AAjitoMember, ExclusivePlaceNoList) == 0x000280, "Member 'AAjitoMember::ExclusivePlaceNoList' has a wrong offset!");
static_assert(offsetof(AAjitoMember, WithPlaceNoList) == 0x000290, "Member 'AAjitoMember::WithPlaceNoList' has a wrong offset!");
static_assert(offsetof(AAjitoMember, ActionName) == 0x0002A0, "Member 'AAjitoMember::ActionName' has a wrong offset!");
static_assert(offsetof(AAjitoMember, IsLookAtPlayer) == 0x0002A8, "Member 'AAjitoMember::IsLookAtPlayer' has a wrong offset!");
static_assert(offsetof(AAjitoMember, CharacterCapsuleComponent) == 0x0002B0, "Member 'AAjitoMember::CharacterCapsuleComponent' has a wrong offset!");
static_assert(offsetof(AAjitoMember, ShowBoxComponent) == 0x0002B8, "Member 'AAjitoMember::ShowBoxComponent' has a wrong offset!");
static_assert(offsetof(AAjitoMember, EventBoxComponent) == 0x0002C0, "Member 'AAjitoMember::EventBoxComponent' has a wrong offset!");
static_assert(offsetof(AAjitoMember, MakeEventActorClass) == 0x0002C8, "Member 'AAjitoMember::MakeEventActorClass' has a wrong offset!");
static_assert(offsetof(AAjitoMember, MakeEventActor) == 0x0002D0, "Member 'AAjitoMember::MakeEventActor' has a wrong offset!");
static_assert(offsetof(AAjitoMember, IsOverlappingPlayer) == 0x0002D9, "Member 'AAjitoMember::IsOverlappingPlayer' has a wrong offset!");
static_assert(offsetof(AAjitoMember, ActionIconCoolTime) == 0x0002E0, "Member 'AAjitoMember::ActionIconCoolTime' has a wrong offset!");
static_assert(offsetof(AAjitoMember, IsAvalableAction) == 0x0002E4, "Member 'AAjitoMember::IsAvalableAction' has a wrong offset!");
static_assert(offsetof(AAjitoMember, ChildActionIcon) == 0x0002F0, "Member 'AAjitoMember::ChildActionIcon' has a wrong offset!");
static_assert(offsetof(AAjitoMember, ActionIcon) == 0x0002F8, "Member 'AAjitoMember::ActionIcon' has a wrong offset!");
static_assert(offsetof(AAjitoMember, ActionIconWorldPositionOffset) == 0x000300, "Member 'AAjitoMember::ActionIconWorldPositionOffset' has a wrong offset!");
static_assert(offsetof(AAjitoMember, ActionIconType) == 0x00030C, "Member 'AAjitoMember::ActionIconType' has a wrong offset!");
static_assert(offsetof(AAjitoMember, TargetIconOffsetZ) == 0x000310, "Member 'AAjitoMember::TargetIconOffsetZ' has a wrong offset!");
static_assert(offsetof(AAjitoMember, AnimClass) == 0x000318, "Member 'AAjitoMember::AnimClass' has a wrong offset!");
static_assert(offsetof(AAjitoMember, AnimationBP) == 0x000320, "Member 'AAjitoMember::AnimationBP' has a wrong offset!");
static_assert(offsetof(AAjitoMember, IconOffsetDataTable) == 0x000328, "Member 'AAjitoMember::IconOffsetDataTable' has a wrong offset!");
static_assert(offsetof(AAjitoMember, IconOffsetDataInfos) == 0x000330, "Member 'AAjitoMember::IconOffsetDataInfos' has a wrong offset!");
static_assert(offsetof(AAjitoMember, WaitTimeTransitionToTalk) == 0x000380, "Member 'AAjitoMember::WaitTimeTransitionToTalk' has a wrong offset!");
static_assert(offsetof(AAjitoMember, WaitTimeTransitionToIdle) == 0x000384, "Member 'AAjitoMember::WaitTimeTransitionToIdle' has a wrong offset!");

// Class BattlePrototype.OutgameDebuggingWindowInterface
// 0x0000 (0x0028 - 0x0028)
class IOutgameDebuggingWindowInterface final : public IInterface
{
public:
	void OnChangePage(EOutgameDebuggingPage NewPage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutgameDebuggingWindowInterface">();
	}
	static class IOutgameDebuggingWindowInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOutgameDebuggingWindowInterface>();
	}
};
static_assert(alignof(IOutgameDebuggingWindowInterface) == 0x000008, "Wrong alignment on IOutgameDebuggingWindowInterface");
static_assert(sizeof(IOutgameDebuggingWindowInterface) == 0x000028, "Wrong size on IOutgameDebuggingWindowInterface");

// Class BattlePrototype.AjitoNpcPlaceHolderBase
// 0x0008 (0x0238 - 0x0230)
class AAjitoNpcPlaceHolderBase final : public AActor
{
public:
	int32                                         PlacementID;                                       // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvailable;                                       // 0x0234(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235[0x3];                                      // 0x0235(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetVisible(bool Visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AjitoNpcPlaceHolderBase">();
	}
	static class AAjitoNpcPlaceHolderBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAjitoNpcPlaceHolderBase>();
	}
};
static_assert(alignof(AAjitoNpcPlaceHolderBase) == 0x000008, "Wrong alignment on AAjitoNpcPlaceHolderBase");
static_assert(sizeof(AAjitoNpcPlaceHolderBase) == 0x000238, "Wrong size on AAjitoNpcPlaceHolderBase");
static_assert(offsetof(AAjitoNpcPlaceHolderBase, PlacementID) == 0x000230, "Member 'AAjitoNpcPlaceHolderBase::PlacementID' has a wrong offset!");
static_assert(offsetof(AAjitoNpcPlaceHolderBase, IsAvailable) == 0x000234, "Member 'AAjitoNpcPlaceHolderBase::IsAvailable' has a wrong offset!");

// Class BattlePrototype.AjitoPlacementManager
// 0x0018 (0x0248 - 0x0230)
class AAjitoPlacementManager : public ARSActorSystemBase
{
public:
	EPlayerID                                     PlayerId;                                          // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAjitoPlacementInfo>            ActorInfos;                                        // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AjitoPlacementManager">();
	}
	static class AAjitoPlacementManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAjitoPlacementManager>();
	}
};
static_assert(alignof(AAjitoPlacementManager) == 0x000008, "Wrong alignment on AAjitoPlacementManager");
static_assert(sizeof(AAjitoPlacementManager) == 0x000248, "Wrong size on AAjitoPlacementManager");
static_assert(offsetof(AAjitoPlacementManager, PlayerId) == 0x000230, "Member 'AAjitoPlacementManager::PlayerId' has a wrong offset!");
static_assert(offsetof(AAjitoPlacementManager, ActorInfos) == 0x000238, "Member 'AAjitoPlacementManager::ActorInfos' has a wrong offset!");

// Class BattlePrototype.PresentData
// 0x0010 (0x0038 - 0x0028)
class UPresentData final : public UObject
{
public:
	class UDataTable*                             PresentData_;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PresentLocationData_;                              // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool GetPresentEventData(struct FPresentEventDataCell* PresentEventData, class FName ItemId, class FName FromCharaID, class FName ForCharaID);
	void LoadPresentDataTable(const class FString& PresentDataPath, const class FString& PresentLocationDatapath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresentData">();
	}
	static class UPresentData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPresentData>();
	}
};
static_assert(alignof(UPresentData) == 0x000008, "Wrong alignment on UPresentData");
static_assert(sizeof(UPresentData) == 0x000038, "Wrong size on UPresentData");
static_assert(offsetof(UPresentData, PresentData_) == 0x000028, "Member 'UPresentData::PresentData_' has a wrong offset!");
static_assert(offsetof(UPresentData, PresentLocationData_) == 0x000030, "Member 'UPresentData::PresentLocationData_' has a wrong offset!");

// Class BattlePrototype.AnimControllerComponent
// 0x0020 (0x00E0 - 0x00C0)
class UAnimControllerComponent : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x20];                                      // 0x00C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAnimControllerComponent* GetAnimControllerComponentFromActor(class AActor* Actor);

	void ReceiveNotifyDirectionControl(class UObject* Notify, bool bBegin, float RotateSpeed, bool bUseSocket, class FName SocketName);
	void ReceiveNotifySuperArmor(class UObject* Notify, int32 ResistStagger, bool bBegin);
	void RequestDamage(EHCDamageKind DamageKind, float StiffenSec, float HitStopSec, float HitStopRate, const struct FRotator& Rot);
	void RequestDamageFly();
	void RequestDamageFlyWakeup();
	void RequestFaint();
	void RequestFaintWakeup();
	void RequestTumble();
	void RequestTumbleWakeup();

	float GetDirectionControllRotateSpeed() const;
	class FName GetDirectionControlSocketName() const;
	int32 GetResistStagger() const;
	bool IsAnimDamageFly() const;
	bool IsAnimDamageFlyLanding() const;
	bool IsAnimDamageFlyRise() const;
	bool IsAnimFaint() const;
	bool IsAnimFaintDowning() const;
	bool IsAnimTumble() const;
	bool IsAnimTumbleDowning() const;
	bool IsEnableDirectionControl() const;
	bool IsUseSocketDirectionControl() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimControllerComponent">();
	}
	static class UAnimControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimControllerComponent>();
	}
};
static_assert(alignof(UAnimControllerComponent) == 0x000008, "Wrong alignment on UAnimControllerComponent");
static_assert(sizeof(UAnimControllerComponent) == 0x0000E0, "Wrong size on UAnimControllerComponent");

// Class BattlePrototype.PlayerAnimControllerComponent
// 0x0158 (0x0238 - 0x00E0)
class UPlayerAnimControllerComponent final : public UAnimControllerComponent
{
public:
	TWeakObjectPtr<class URSPlayerAnimInstance>   _animBP;                                           // 0x00E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchChangeAnimKind;                            // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchChangeWalkRunStateKind;                    // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRequestParticleEffect;                     // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchMontageStarted;                            // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchMontageBlendingOut;                        // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchMontageEnded;                              // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         _SprintWalkSpeedRate;                              // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WALK_SPEED;                                        // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RUN_SPEED;                                         // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AJITO_RUN_SPEED;                                   // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RUN_TO_WALK_DELAY;                                 // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RUN_TO_WALK_INTERP;                                // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WALK_TO_RUN_INTERP;                                // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WALK_TO_RUN_INTERP_TOWN;                           // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DISABLE_TOWN_RUN_TIMER;                            // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _bNotifyEnableMove;                                // 0x0170(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _bNotifyEnableAction;                              // 0x0180(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _bNotifyEnableAttack;                              // 0x0190(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _bNotifyEnablePsychic;                             // 0x01A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _bNotifyEnablePsychicEx;                           // 0x01B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _bNotifyEnableAirJump;                             // 0x01C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _bNotifyEnableBrainCrash;                          // 0x01D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _bNotifyEnableWeaponCharge;                        // 0x01E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _bNotifyEnableWalkStop;                            // 0x01F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_200[0x38];                                     // 0x0200(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPlayerAnimControllerComponent* GetPlayerAnimControllerComponentFromActor(class AActor* Actor);

	void BeginPlayPublic();
	void ClearAllCancelFlag();
	float GetRigidbodyAlpha();
	bool IsNotifyEnableAttackOptionNotComboEnd();
	void OnChangeAnimKind(EPlayerAnimKind NewAnimKind, EPlayerAnimKind OldAnimKind);
	void OnChangeWalkRunStateKind(EPlayerWalkRunStateKind NewKind);
	void OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageStarted(class UAnimMontage* Montage);
	void OnRequestParticleEffect(class URequestParticleEffectArgs* Args);
	void ReceiveNotifyEnableAction(bool bEnable, class FName ClaimantName);
	void ReceiveNotifyEnableAirJump(bool bEnable, class FName ClaimantName);
	void ReceiveNotifyEnableAttack(bool bEnable, bool bNotComboEnd, class FName ClaimantName);
	void ReceiveNotifyEnableBrainCrash(bool bEnable, class FName ClaimantName);
	void ReceiveNotifyEnableMove(bool bEnable, class FName ClaimantName);
	void ReceiveNotifyEnablePsychic(bool bEnable, class FName ClaimantName);
	void ReceiveNotifyEnablePsychicEx(bool bEnable, class FName ClaimantName);
	void ReceiveNotifyEnableWalkStop(bool bEnable, class FName ClaimantName);
	void ReceiveNotifyEnableWeaponCharge(bool bEnable, class FName ClaimantName);
	void ReceiveNotifyInputAttack(bool bEnable);
	void ReceiveNotifyInputDodge(bool bEnable);
	void ReceiveNotifyInputPsychic(bool bEnable);
	void RequestAnim(EPlayerAnimKind Kind, int32 Param, bool bFlying);
	void RequestAttack(class UAnimMontage* AnimMontage, float InPlayRate, class FName StartSectionName);
	void RequestBattleIdle(bool IsStart);
	void RequestStep(const struct FVector& StepDirection, EPlayerAnimDir Dir, int32 Param, bool bFlying);
	void SetAimRotator(const struct FRotator& Rotator);
	void SetAjitoFlag(bool bAjito);
	void SetBattleEm1500(bool bBattle);
	void SetLeftStickPower(float Power, float PrevDiff);
	void SetRigidbodyAlpha(float Alpha, float LerpTime);
	void SetTalkMode(bool bTalk);
	void SetUniquePsychicAim(bool bFlag);
	void SetupAnimBP();
	void SetUpperAction(bool bSet);
	void UpdateWalkSpeed(float DeltaSeconds);

	float GetBaseWalkSpeed() const;
	float GetWalkRunMoveScale() const;
	EPlayerWalkRunStateKind GetWalkRunStateKind() const;
	bool IsAnimAnyAttack() const;
	bool IsAnimAttack() const;
	bool IsAnimBrake() const;
	bool IsAnimDamage() const;
	bool IsAnimDead() const;
	bool IsAnimEndBattle() const;
	bool IsAnimFall() const;
	bool IsAnimIdleWalkRun() const;
	bool IsAnimJump() const;
	bool IsAnimKind(EPlayerAnimKind Kind) const;
	bool IsAnimLand() const;
	bool IsAnimPsychic() const;
	bool IsAnimSideStep() const;
	bool IsAnimSprint() const;
	bool IsAnimStartBattle() const;
	bool IsAnimStep() const;
	bool IsAnimStepEnd() const;
	bool IsASAnimPlayEnd(EPlayerAnimKind Kind) const;
	bool IsASNodePlayEnd() const;
	bool IsAttackInputAccept(int32 AttackId) const;
	bool IsCheckIdle() const;
	bool IsExistAnimRequest() const;
	bool IsNotifyEnableAction() const;
	bool IsNotifyEnableAirJump() const;
	bool IsNotifyEnableAttack() const;
	bool IsNotifyEnableBrainCrash() const;
	bool IsNotifyEnableMove() const;
	bool IsNotifyEnablePsychic() const;
	bool IsNotifyEnablePsychicEx() const;
	bool IsNotifyEnableWalkStop() const;
	bool IsNotifyEnableWeaponCharge() const;
	bool IsNotifyInputAttack() const;
	bool IsNotifyInputDodge() const;
	bool IsNotifyInputPsychic() const;
	bool IsPsychicCaptureNoMotionAction() const;
	bool IsRunningAnimStateForAIMove() const;
	bool IsUpperAction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerAnimControllerComponent">();
	}
	static class UPlayerAnimControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerAnimControllerComponent>();
	}
};
static_assert(alignof(UPlayerAnimControllerComponent) == 0x000008, "Wrong alignment on UPlayerAnimControllerComponent");
static_assert(sizeof(UPlayerAnimControllerComponent) == 0x000238, "Wrong size on UPlayerAnimControllerComponent");
static_assert(offsetof(UPlayerAnimControllerComponent, _animBP) == 0x0000E0, "Member 'UPlayerAnimControllerComponent::_animBP' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, DispatchChangeAnimKind) == 0x0000E8, "Member 'UPlayerAnimControllerComponent::DispatchChangeAnimKind' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, DispatchChangeWalkRunStateKind) == 0x0000F8, "Member 'UPlayerAnimControllerComponent::DispatchChangeWalkRunStateKind' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, DispatchRequestParticleEffect) == 0x000108, "Member 'UPlayerAnimControllerComponent::DispatchRequestParticleEffect' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, DispatchMontageStarted) == 0x000118, "Member 'UPlayerAnimControllerComponent::DispatchMontageStarted' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, DispatchMontageBlendingOut) == 0x000128, "Member 'UPlayerAnimControllerComponent::DispatchMontageBlendingOut' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, DispatchMontageEnded) == 0x000138, "Member 'UPlayerAnimControllerComponent::DispatchMontageEnded' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _SprintWalkSpeedRate) == 0x000148, "Member 'UPlayerAnimControllerComponent::_SprintWalkSpeedRate' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, WALK_SPEED) == 0x00014C, "Member 'UPlayerAnimControllerComponent::WALK_SPEED' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, RUN_SPEED) == 0x000150, "Member 'UPlayerAnimControllerComponent::RUN_SPEED' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, AJITO_RUN_SPEED) == 0x000154, "Member 'UPlayerAnimControllerComponent::AJITO_RUN_SPEED' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, RUN_TO_WALK_DELAY) == 0x000158, "Member 'UPlayerAnimControllerComponent::RUN_TO_WALK_DELAY' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, RUN_TO_WALK_INTERP) == 0x00015C, "Member 'UPlayerAnimControllerComponent::RUN_TO_WALK_INTERP' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, WALK_TO_RUN_INTERP) == 0x000160, "Member 'UPlayerAnimControllerComponent::WALK_TO_RUN_INTERP' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, WALK_TO_RUN_INTERP_TOWN) == 0x000164, "Member 'UPlayerAnimControllerComponent::WALK_TO_RUN_INTERP_TOWN' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, DISABLE_TOWN_RUN_TIMER) == 0x000168, "Member 'UPlayerAnimControllerComponent::DISABLE_TOWN_RUN_TIMER' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _bNotifyEnableMove) == 0x000170, "Member 'UPlayerAnimControllerComponent::_bNotifyEnableMove' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _bNotifyEnableAction) == 0x000180, "Member 'UPlayerAnimControllerComponent::_bNotifyEnableAction' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _bNotifyEnableAttack) == 0x000190, "Member 'UPlayerAnimControllerComponent::_bNotifyEnableAttack' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _bNotifyEnablePsychic) == 0x0001A0, "Member 'UPlayerAnimControllerComponent::_bNotifyEnablePsychic' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _bNotifyEnablePsychicEx) == 0x0001B0, "Member 'UPlayerAnimControllerComponent::_bNotifyEnablePsychicEx' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _bNotifyEnableAirJump) == 0x0001C0, "Member 'UPlayerAnimControllerComponent::_bNotifyEnableAirJump' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _bNotifyEnableBrainCrash) == 0x0001D0, "Member 'UPlayerAnimControllerComponent::_bNotifyEnableBrainCrash' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _bNotifyEnableWeaponCharge) == 0x0001E0, "Member 'UPlayerAnimControllerComponent::_bNotifyEnableWeaponCharge' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _bNotifyEnableWalkStop) == 0x0001F0, "Member 'UPlayerAnimControllerComponent::_bNotifyEnableWalkStop' has a wrong offset!");

// Class BattlePrototype.AnimeInterlockingManager
// 0x0088 (0x00B0 - 0x0028)
class UAnimeInterlockingManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URSGameInstance*                        M_gameInstance;                                    // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_AnimeInterlockingData_DataTable;                 // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_AnimeInterlockingReward_DataTable;               // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_AnimeInterlockingSubReward_DataTable;            // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_AnimeInterlockingNumData_DataTable;              // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_AnimeInterlockingNumReward_DataTable;            // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_AnimeInterlockingSubNumReward_DataTable;         // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_AnimeInterlockingRewardToKins_DataTable;         // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimeInterlockingChallengeQuestInfo   M_ChallengeInfo;                                   // 0x0078(0x0018)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FAnimeInterlockingSaveParams>   M_AnimeInterlockingSaveParamsList;                 // 0x0090(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAnimeInterlockingNumRewardSaveParams> M_AnimeInterlockingNumRewardSaveParamsList;        // 0x00A0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddAnimeInterlockingIncorrectAnswerNum(class FName AnimeInterlockingName);
	void GetAcquirableButNotAcquiredNumRewardNameList(TArray<class FName>* NameList);
	int32 GetAnimeInterlockingIncorrectAnswerNum(class FName AnimeInterlockingName);
	bool GetAnimeInterlockingNumRefData(class FName AnimeInterlockingNumName, struct FAnimeInterlockingNumRefDataCell* RefData);
	void GetAnimeInterlockingNumRefDataList(class FName AnimeInterlockingNumName, TArray<struct FAnimeInterlockingNumRefDataCell>* RefDataList);
	bool GetAnimeInterlockingNumReward(class FName AnimeInterlockingNumName, struct FAnimeInterlockingsPresentList* PresentList);
	bool GetAnimeInterlockingNumRewardSaveParams(class FName AnimeInterlockingNumName, struct FAnimeInterlockingNumRewardSaveParams* SaveParams);
	bool GetAnimeInterlockingNumSubReward(class FName AnimeInterlockingNumName, struct FAnimeInterlockingsPresentList* PresentList);
	bool GetAnimeInterlockingRefData(class FName AnimeInterlockingName, struct FAnimeInterlockingRefDataCell* RefData);
	void GetAnimeInterlockingRefDataList(class FName AnimeInterlockingName, TArray<struct FAnimeInterlockingRefDataCell>* RefDataList);
	bool GetAnimeInterlockingReward(class FName AnimeInterlockingName, struct FAnimeInterlockingsPresentList* PresentList);
	bool GetAnimeInterlockingRewardToKins(const class FString& ItemId, int32* KinsNum);
	bool GetAnimeInterlockingSaveParams(class FName AnimeInterlockingName, struct FAnimeInterlockingSaveParams* SaveParams);
	bool GetAnimeInterlockingSubReward(class FName AnimeInterlockingName, struct FAnimeInterlockingsPresentList* PresentList);
	class FName GetChallengeInfoAnimeInterlockingName();
	int32 GetQuestClearNum();
	bool IsAnimeInterlockingAchievementQuest(class FName AnimeInterlockingName);
	bool IsAnimeInterlockingGetNumReward(class FName AnimeInterlockingNumRewardName);
	bool IsAnimeInterlockingGetReward(class FName AnimeInterlockingName);
	bool IsAnimeInterlockingNewFlag(class FName AnimeInterlockingName);
	bool IsAnimeInterlockingNoticedFlag(class FName AnimeInterlockingName);
	bool IsAnimeInterlockingNumRewardAchievement(class FName AnimeInterlockingNumRewardName);
	bool IsChallengeInfoCorrectAnswer();
	bool IsEnableQuest(class FName AnimeInterlockingName);
	void SetAnimeInterlockingIncorrectAnswerNum(class FName AnimeInterlockingName, const int32 IncorrectAnswerNum);
	bool SetAnimeInterlockingNumRewardSaveParams(class FName AnimeInterlockingNumName, struct FAnimeInterlockingNumRewardSaveParams* SaveParams);
	bool SetAnimeInterlockingSaveParams(class FName AnimeInterlockingName, struct FAnimeInterlockingSaveParams* SaveParams);
	void SetChallengeInfoAnimeInterlockingName(class FName AnimeInterlockingName);
	void SetIsAnimeInterlockingAchievementQuest(class FName AnimeInterlockingName, const bool IsAchievementQuest);
	void SetIsAnimeInterlockingGetNumReward(class FName AnimeInterlockingNumRewardName, const bool IsGetNumReward);
	void SetIsAnimeInterlockingGetReward(class FName AnimeInterlockingName, const bool IsGetReward);
	void SetIsAnimeInterlockingNewFlag(class FName AnimeInterlockingName, const bool IsNewFlag);
	void SetIsAnimeInterlockingNoticedFlag(class FName AnimeInterlockingName, const bool IsNoticed);
	void SetIsAnimeInterlockingNumRewardAchievement(class FName AnimeInterlockingNumRewardName, const bool IsAchievement);
	void SetIsChallengeInfoCorrectAnswer(bool IsCorrectAnswer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimeInterlockingManager">();
	}
	static class UAnimeInterlockingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimeInterlockingManager>();
	}
};
static_assert(alignof(UAnimeInterlockingManager) == 0x000008, "Wrong alignment on UAnimeInterlockingManager");
static_assert(sizeof(UAnimeInterlockingManager) == 0x0000B0, "Wrong size on UAnimeInterlockingManager");
static_assert(offsetof(UAnimeInterlockingManager, M_gameInstance) == 0x000038, "Member 'UAnimeInterlockingManager::M_gameInstance' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_AnimeInterlockingData_DataTable) == 0x000040, "Member 'UAnimeInterlockingManager::M_AnimeInterlockingData_DataTable' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_AnimeInterlockingReward_DataTable) == 0x000048, "Member 'UAnimeInterlockingManager::M_AnimeInterlockingReward_DataTable' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_AnimeInterlockingSubReward_DataTable) == 0x000050, "Member 'UAnimeInterlockingManager::M_AnimeInterlockingSubReward_DataTable' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_AnimeInterlockingNumData_DataTable) == 0x000058, "Member 'UAnimeInterlockingManager::M_AnimeInterlockingNumData_DataTable' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_AnimeInterlockingNumReward_DataTable) == 0x000060, "Member 'UAnimeInterlockingManager::M_AnimeInterlockingNumReward_DataTable' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_AnimeInterlockingSubNumReward_DataTable) == 0x000068, "Member 'UAnimeInterlockingManager::M_AnimeInterlockingSubNumReward_DataTable' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_AnimeInterlockingRewardToKins_DataTable) == 0x000070, "Member 'UAnimeInterlockingManager::M_AnimeInterlockingRewardToKins_DataTable' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_ChallengeInfo) == 0x000078, "Member 'UAnimeInterlockingManager::M_ChallengeInfo' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_AnimeInterlockingSaveParamsList) == 0x000090, "Member 'UAnimeInterlockingManager::M_AnimeInterlockingSaveParamsList' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_AnimeInterlockingNumRewardSaveParamsList) == 0x0000A0, "Member 'UAnimeInterlockingManager::M_AnimeInterlockingNumRewardSaveParamsList' has a wrong offset!");

// Class BattlePrototype.AnimNotify_OnRadialBlur
// 0x0030 (0x0068 - 0x0038)
class UAnimNotify_OnRadialBlur : public UAnimNotify
{
public:
	int32                                         Priority;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           CurveData;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENotifyRadialBlurModulateType                 ModulateType;                                      // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x004C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseExecuteKind;                                  // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UCurveVector* GetUseCurveData(class USkeletalMeshComponent* MeshComp) const;
	void PlayBlur(class USkeletalMeshComponent* MeshComp) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_OnRadialBlur">();
	}
	static class UAnimNotify_OnRadialBlur* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_OnRadialBlur>();
	}
};
static_assert(alignof(UAnimNotify_OnRadialBlur) == 0x000008, "Wrong alignment on UAnimNotify_OnRadialBlur");
static_assert(sizeof(UAnimNotify_OnRadialBlur) == 0x000068, "Wrong size on UAnimNotify_OnRadialBlur");
static_assert(offsetof(UAnimNotify_OnRadialBlur, Priority) == 0x000038, "Member 'UAnimNotify_OnRadialBlur::Priority' has a wrong offset!");
static_assert(offsetof(UAnimNotify_OnRadialBlur, CurveData) == 0x000040, "Member 'UAnimNotify_OnRadialBlur::CurveData' has a wrong offset!");
static_assert(offsetof(UAnimNotify_OnRadialBlur, ModulateType) == 0x000048, "Member 'UAnimNotify_OnRadialBlur::ModulateType' has a wrong offset!");
static_assert(offsetof(UAnimNotify_OnRadialBlur, Location) == 0x00004C, "Member 'UAnimNotify_OnRadialBlur::Location' has a wrong offset!");
static_assert(offsetof(UAnimNotify_OnRadialBlur, BoneName) == 0x000058, "Member 'UAnimNotify_OnRadialBlur::BoneName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_OnRadialBlur, IsUseExecuteKind) == 0x000060, "Member 'UAnimNotify_OnRadialBlur::IsUseExecuteKind' has a wrong offset!");

// Class BattlePrototype.EnemyAsyncTaskComponentBase
// 0x0000 (0x00D0 - 0x00D0)
class UEnemyAsyncTaskComponentBase : public URSAsyncTaskActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyAsyncTaskComponentBase">();
	}
	static class UEnemyAsyncTaskComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyAsyncTaskComponentBase>();
	}
};
static_assert(alignof(UEnemyAsyncTaskComponentBase) == 0x000008, "Wrong alignment on UEnemyAsyncTaskComponentBase");
static_assert(sizeof(UEnemyAsyncTaskComponentBase) == 0x0000D0, "Wrong size on UEnemyAsyncTaskComponentBase");

// Class BattlePrototype.EnemyGroundCheckComponent
// 0x00A8 (0x0178 - 0x00D0)
class UEnemyGroundCheckComponent final : public UEnemyAsyncTaskComponentBase
{
public:
	uint8                                         Pad_D0[0xA8];                                      // 0x00D0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginGroundCheck();
	void CalcRotateMesh(class USkeletalMeshComponent* MeshComp, float InterpSpeed, float AngleLimit, bool EndFit);
	void CalcRotateRot(float OffsetYaw, const struct FVector& ForwardVector, const struct FTransform& Transform, const struct FVector& baseUpVector, const struct FRotator& baseRot, float InterpSpeed, float AngleLimit, bool EndFit);
	void CalcRotateRotMesh(class USkeletalMeshComponent* MeshComp, float OffsetYaw, float InterpSpeed, float AngleLimit, bool EndFit);
	void CalcRotateRotToMesh(class USkeletalMeshComponent* MeshComp, float OffsetYaw, float InterpSpeed, float AngleLimit, bool EndFit);
	struct FRotator CalcRotation(const struct FRotator& baseRot, float InterpSpeed);
	struct FRotator CalcRotationToUpVector(float OffsetYaw, const struct FVector& ForwardVector, const struct FTransform& Transform, const struct FRotator& baseRot, float InterpSpeed, const struct FVector& UpVector);
	void EndGroundCheck();
	void InitSetting(bool MultipleChecks, float CheckHeight, float CapsuleRadius);
	void SetCheckPos(const struct FVector& Position);
	void SetIntervalTime(float NewIntervalTime);
	void SetRotateMesh(class USkeletalMeshComponent* MeshComp, float InterpSpeed, float AngleLimit, bool EndFit);
	void SetRotation(class USkeletalMeshComponent* MeshComp, float InterpSpeed);
	void SetRotationToUpVector(class USkeletalMeshComponent* MeshComp, float InterpSpeed, const struct FVector& UpVector);

	struct FRotator GetCalcRotator() const;
	struct FVector GetUpVector() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyGroundCheckComponent">();
	}
	static class UEnemyGroundCheckComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyGroundCheckComponent>();
	}
};
static_assert(alignof(UEnemyGroundCheckComponent) == 0x000008, "Wrong alignment on UEnemyGroundCheckComponent");
static_assert(sizeof(UEnemyGroundCheckComponent) == 0x000178, "Wrong size on UEnemyGroundCheckComponent");

// Class BattlePrototype.AnimNotify_RSPlayParticleEffect
// 0x0040 (0x00D0 - 0x0090)
class UAnimNotify_RSPlayParticleEffect : public UAnimNotify_PlayParticleEffect
{
public:
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URSParticleSystemComponentBase> ComponentClass;                                    // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ignore;                                            // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ScaleOffset;                                       // 0x00A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OptionSeeThrough;                                  // 0x00B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRegistToChara;                                   // 0x00B2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInterruptTelepo;                                 // 0x00B3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoolVector                            SocketLocation;                                    // 0x00B4(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoolVector                            SocketRotation;                                    // 0x00B7(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	ERSParticleSystemAttachRotationOffMode        SocketRotationOffMode;                             // 0x00BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoolVector                            SocketScale;                                       // 0x00BB(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	ESequencerDilationOwner                       DilationOwner;                                     // 0x00BE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF[0x1];                                       // 0x00BF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleComponentListManager*          ParticleComponentManager;                          // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_RSPlayParticleEffect">();
	}
	static class UAnimNotify_RSPlayParticleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_RSPlayParticleEffect>();
	}
};
static_assert(alignof(UAnimNotify_RSPlayParticleEffect) == 0x000010, "Wrong alignment on UAnimNotify_RSPlayParticleEffect");
static_assert(sizeof(UAnimNotify_RSPlayParticleEffect) == 0x0000D0, "Wrong size on UAnimNotify_RSPlayParticleEffect");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, ComponentClass) == 0x000098, "Member 'UAnimNotify_RSPlayParticleEffect::ComponentClass' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, Ignore) == 0x0000A0, "Member 'UAnimNotify_RSPlayParticleEffect::Ignore' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, ScaleOffset) == 0x0000A4, "Member 'UAnimNotify_RSPlayParticleEffect::ScaleOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, LocationType) == 0x0000B0, "Member 'UAnimNotify_RSPlayParticleEffect::LocationType' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, OptionSeeThrough) == 0x0000B1, "Member 'UAnimNotify_RSPlayParticleEffect::OptionSeeThrough' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, IsRegistToChara) == 0x0000B2, "Member 'UAnimNotify_RSPlayParticleEffect::IsRegistToChara' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, IsInterruptTelepo) == 0x0000B3, "Member 'UAnimNotify_RSPlayParticleEffect::IsInterruptTelepo' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, SocketLocation) == 0x0000B4, "Member 'UAnimNotify_RSPlayParticleEffect::SocketLocation' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, SocketRotation) == 0x0000B7, "Member 'UAnimNotify_RSPlayParticleEffect::SocketRotation' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, SocketRotationOffMode) == 0x0000BA, "Member 'UAnimNotify_RSPlayParticleEffect::SocketRotationOffMode' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, SocketScale) == 0x0000BB, "Member 'UAnimNotify_RSPlayParticleEffect::SocketScale' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, DilationOwner) == 0x0000BE, "Member 'UAnimNotify_RSPlayParticleEffect::DilationOwner' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, ParticleComponentManager) == 0x0000C0, "Member 'UAnimNotify_RSPlayParticleEffect::ParticleComponentManager' has a wrong offset!");

// Class BattlePrototype.RSPlatformFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URSPlatformFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FName ConvertKeyboardName(const class FName OldKey, ELocalizedKeyboardType OldType, ELocalizedKeyboardType NewType);
	static void ConvertKeyboardNames(const TArray<class FName>& OldKeys, ELocalizedKeyboardType OldType, TArray<class FName>* NewKeys, ELocalizedKeyboardType NewType);
	static void DisplayRequestActive();
	static void DisplayRequestRelease();
	static bool GetDisplayRequestState();
	static ELocalizedKeyboardType GetLocalizedKeyboardType();
	static class FString GetLocalizedPath(ETextLanguage TextLang);
	static EPlatFormConsoleType GetPlatformConsoleType();
	static ERegionType GetPlatformRegion();
	static EPlatFormType GetPlatformType();
	static ETextLanguage GetSystemTextLanguage();
	static ETextLanguage GetSystemVoiceLanguage();
	static bool IsCrossButtonDecide();
	static bool IsEnableShareRecording();
	static bool SetCurrentCulture(ETextLanguage TextLang);
	static void SetEnableShareRecording(bool IsEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSPlatformFunctionLibrary">();
	}
	static class URSPlatformFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSPlatformFunctionLibrary>();
	}
};
static_assert(alignof(URSPlatformFunctionLibrary) == 0x000008, "Wrong alignment on URSPlatformFunctionLibrary");
static_assert(sizeof(URSPlatformFunctionLibrary) == 0x000028, "Wrong size on URSPlatformFunctionLibrary");

// Class BattlePrototype.UIGameOver
// 0x00D0 (0x0458 - 0x0388)
class UUIGameOver : public UUIBase
{
public:
	int32                                         DefaultIndex;                                      // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0xCC];                                     // 0x038C(0x00CC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FName GetTargetBossID();
	void InitializeIndex(int32 Index_0, class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimDecision);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOutRetry, class UWidgetAnimation* AnimOutTitle, class UTextBlock* TextGameOver, class UTextBlock* TextDescription, class UTextBlock* TextRetry, class UTextBlock* TextReturnToTitle, class UUIGuide* ChildKeyGuide, class UUserWidget* ChildWidget, class UWidgetAnimation* AnimChildDefault, class UWidgetAnimation* AnimChildIn, class UWidgetAnimation* AnimChildOutRetry, class UWidgetAnimation* AnimChildOutTitle);
	void StartGameOver();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	EGameOverResult GetResult() const;
	bool IsEnd() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGameOver">();
	}
	static class UUIGameOver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGameOver>();
	}
};
static_assert(alignof(UUIGameOver) == 0x000008, "Wrong alignment on UUIGameOver");
static_assert(sizeof(UUIGameOver) == 0x000458, "Wrong size on UUIGameOver");
static_assert(offsetof(UUIGameOver, DefaultIndex) == 0x000388, "Member 'UUIGameOver::DefaultIndex' has a wrong offset!");

// Class BattlePrototype.AnimNotify_RSPlayParticleEffect_SASCopyBase
// 0x0000 (0x00D0 - 0x00D0)
class UAnimNotify_RSPlayParticleEffect_SASCopyBase : public UAnimNotify_RSPlayParticleEffect
{
public:
	bool CheckExecNotify(class USkeletalMeshComponent* MeshComp) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_RSPlayParticleEffect_SASCopyBase">();
	}
	static class UAnimNotify_RSPlayParticleEffect_SASCopyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_RSPlayParticleEffect_SASCopyBase>();
	}
};
static_assert(alignof(UAnimNotify_RSPlayParticleEffect_SASCopyBase) == 0x000010, "Wrong alignment on UAnimNotify_RSPlayParticleEffect_SASCopyBase");
static_assert(sizeof(UAnimNotify_RSPlayParticleEffect_SASCopyBase) == 0x0000D0, "Wrong size on UAnimNotify_RSPlayParticleEffect_SASCopyBase");

// Class BattlePrototype.AnimNotify_RSPlayParticleEffectWithCondition
// 0x0000 (0x00D0 - 0x00D0)
class UAnimNotify_RSPlayParticleEffectWithCondition : public UAnimNotify_RSPlayParticleEffect
{
public:
	bool CheckCondition(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_RSPlayParticleEffectWithCondition">();
	}
	static class UAnimNotify_RSPlayParticleEffectWithCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_RSPlayParticleEffectWithCondition>();
	}
};
static_assert(alignof(UAnimNotify_RSPlayParticleEffectWithCondition) == 0x000010, "Wrong alignment on UAnimNotify_RSPlayParticleEffectWithCondition");
static_assert(sizeof(UAnimNotify_RSPlayParticleEffectWithCondition) == 0x0000D0, "Wrong size on UAnimNotify_RSPlayParticleEffectWithCondition");

// Class BattlePrototype.DetailedMapData
// 0x0008 (0x0030 - 0x0028)
class UDetailedMapData final : public UObject
{
public:
	class UDetailedMapDBAsset*                    DetailedMapAsset_;                                 // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GetDetailedMapAreaData(class FName LocationName, class FName AreaName, TArray<struct FDetailedMapContentFloorDataCell>* RDetailedMapArea);
	void GetDetailedMapDataAsset(TMap<class FName, struct FDetailedMapDBDataCell>* RDetailedMap);
	void GetDetailedMapLocationData(class FName LocationName, TMap<class FName, struct FDetailedMapContentFloorDataArrayCell>* RDetailedMapLocation);
	bool LoadDataAsset(const class FString& DtPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DetailedMapData">();
	}
	static class UDetailedMapData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDetailedMapData>();
	}
};
static_assert(alignof(UDetailedMapData) == 0x000008, "Wrong alignment on UDetailedMapData");
static_assert(sizeof(UDetailedMapData) == 0x000030, "Wrong size on UDetailedMapData");
static_assert(offsetof(UDetailedMapData, DetailedMapAsset_) == 0x000028, "Member 'UDetailedMapData::DetailedMapAsset_' has a wrong offset!");

// Class BattlePrototype.AnimNotifyState_DirectionControl
// 0x0000 (0x0030 - 0x0030)
class UAnimNotifyState_DirectionControl final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_DirectionControl">();
	}
	static class UAnimNotifyState_DirectionControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_DirectionControl>();
	}
};
static_assert(alignof(UAnimNotifyState_DirectionControl) == 0x000008, "Wrong alignment on UAnimNotifyState_DirectionControl");
static_assert(sizeof(UAnimNotifyState_DirectionControl) == 0x000030, "Wrong size on UAnimNotifyState_DirectionControl");

// Class BattlePrototype.NpcSkeletalMeshComponent
// 0x0080 (0x0280 - 0x0200)
class UNpcSkeletalMeshComponent final : public USceneComponent
{
public:
	bool                                          bBeginPlaySetup;                                   // 0x0200(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201[0x3];                                      // 0x0201(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NpcMeshDataTableID;                                // 0x0204(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NpcMaterialDataTableID;                            // 0x0208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOptimizeMergeMesh;                                // 0x020C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20D[0x3];                                      // 0x020D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Body;                                              // 0x0210(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 BodyLower;                                         // 0x0218(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Face;                                              // 0x0220(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Hair;                                              // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USkeletalMeshComponent*>         Parts;                                             // 0x0230(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             MeshDataTable;                                     // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             MaterialDataTable;                                 // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             MaterialSkeletonDataTable;                         // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENpcMeshSkeletonType                          SkeletonType;                                      // 0x0258(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x27];                                     // 0x0259(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 GetPartsMaxNum();

	void BeginPlaySetup();
	class USkeletalMeshComponent* GetAnimationComponent();
	class USkeletalMeshComponent* GetRootComponent();
	void GetValidSkeletalMeshComponents(TArray<class USkeletalMeshComponent*>* MeshComps);
	void ResetMaterial(int32 InNpcMaterialDataTableID);
	void ResetMesh(int32 InNpcMeshDataTableID);
	void SetHideOverlap(bool bHide, bool bOneFrame);
	void SetMaterialAmbToBaseSkin(float Value);
	void SetMaterialBaseToAmbSkin(float Value);
	void SetScalarArrayParameterValue(const TArray<class FName>& ParameterNames, const TArray<float>& ParameterValues);
	void SetScalarParameterValue(class FName ParameterName, float ParameterValue);
	void Setup(class AActor* Owner, int32 InNpcMeshDataTableID, class USkeletalMeshComponent* InBody, class USkeletalMeshComponent* InBodyLower, class USkeletalMeshComponent* InFace, class USkeletalMeshComponent* InHair, TArray<class USkeletalMeshComponent*>* InParts);
	void SetupLanding(float Height);
	void SetUseAttachParentBounds(bool IsUse);
	void SetVector4ArrayParameterValue(const TArray<class FName>& ParameterNames, const TArray<struct FLinearColor>& ParameterValues);
	void SetVector4ParameterValue(class FName ParameterName, const struct FLinearColor& ParameterValue);
	void SetVectorParameterValue(class FName ParameterName, const struct FVector& ParameterValue);

	class FString GetSkeletonName() const;
	ENpcMeshSkeletonType GetSkeletonType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcSkeletalMeshComponent">();
	}
	static class UNpcSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNpcSkeletalMeshComponent>();
	}
};
static_assert(alignof(UNpcSkeletalMeshComponent) == 0x000010, "Wrong alignment on UNpcSkeletalMeshComponent");
static_assert(sizeof(UNpcSkeletalMeshComponent) == 0x000280, "Wrong size on UNpcSkeletalMeshComponent");
static_assert(offsetof(UNpcSkeletalMeshComponent, bBeginPlaySetup) == 0x000200, "Member 'UNpcSkeletalMeshComponent::bBeginPlaySetup' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, NpcMeshDataTableID) == 0x000204, "Member 'UNpcSkeletalMeshComponent::NpcMeshDataTableID' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, NpcMaterialDataTableID) == 0x000208, "Member 'UNpcSkeletalMeshComponent::NpcMaterialDataTableID' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, bOptimizeMergeMesh) == 0x00020C, "Member 'UNpcSkeletalMeshComponent::bOptimizeMergeMesh' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, Body) == 0x000210, "Member 'UNpcSkeletalMeshComponent::Body' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, BodyLower) == 0x000218, "Member 'UNpcSkeletalMeshComponent::BodyLower' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, Face) == 0x000220, "Member 'UNpcSkeletalMeshComponent::Face' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, Hair) == 0x000228, "Member 'UNpcSkeletalMeshComponent::Hair' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, Parts) == 0x000230, "Member 'UNpcSkeletalMeshComponent::Parts' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, MeshDataTable) == 0x000240, "Member 'UNpcSkeletalMeshComponent::MeshDataTable' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, MaterialDataTable) == 0x000248, "Member 'UNpcSkeletalMeshComponent::MaterialDataTable' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, MaterialSkeletonDataTable) == 0x000250, "Member 'UNpcSkeletalMeshComponent::MaterialSkeletonDataTable' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, SkeletonType) == 0x000258, "Member 'UNpcSkeletalMeshComponent::SkeletonType' has a wrong offset!");

// Class BattlePrototype.AnimNotifyState_RSTimedFootStepEffect
// 0x0068 (0x0098 - 0x0030)
class UAnimNotifyState_RSTimedFootStepEffect final : public UAnimNotifyState
{
public:
	TSubclassOf<class URSParticleSystemComponentBase> ComponentClass;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionType;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitSegmentOffset;                                  // 0x0040(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ignore;                                            // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ScaleOffset;                                       // 0x0050(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x005C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OptionSeeThrough;                                  // 0x005D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoolVector                            SocketLocation;                                    // 0x005E(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoolVector                            SocketRotation;                                    // 0x0061(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoolVector                            SocketScale;                                       // 0x0064(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_67[0x1];                                       // 0x0067(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0068(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0070(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x007C(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ESequencerDilationOwner                       DilationOwner;                                     // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URSParticleSystemComponentBase*         M_pParticle;                                       // 0x0090(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_RSTimedFootStepEffect">();
	}
	static class UAnimNotifyState_RSTimedFootStepEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_RSTimedFootStepEffect>();
	}
};
static_assert(alignof(UAnimNotifyState_RSTimedFootStepEffect) == 0x000008, "Wrong alignment on UAnimNotifyState_RSTimedFootStepEffect");
static_assert(sizeof(UAnimNotifyState_RSTimedFootStepEffect) == 0x000098, "Wrong size on UAnimNotifyState_RSTimedFootStepEffect");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, ComponentClass) == 0x000030, "Member 'UAnimNotifyState_RSTimedFootStepEffect::ComponentClass' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, ActionType) == 0x000038, "Member 'UAnimNotifyState_RSTimedFootStepEffect::ActionType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, HitSegmentOffset) == 0x000040, "Member 'UAnimNotifyState_RSTimedFootStepEffect::HitSegmentOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, Ignore) == 0x00004C, "Member 'UAnimNotifyState_RSTimedFootStepEffect::Ignore' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, ScaleOffset) == 0x000050, "Member 'UAnimNotifyState_RSTimedFootStepEffect::ScaleOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, LocationType) == 0x00005C, "Member 'UAnimNotifyState_RSTimedFootStepEffect::LocationType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, OptionSeeThrough) == 0x00005D, "Member 'UAnimNotifyState_RSTimedFootStepEffect::OptionSeeThrough' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, SocketLocation) == 0x00005E, "Member 'UAnimNotifyState_RSTimedFootStepEffect::SocketLocation' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, SocketRotation) == 0x000061, "Member 'UAnimNotifyState_RSTimedFootStepEffect::SocketRotation' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, SocketScale) == 0x000064, "Member 'UAnimNotifyState_RSTimedFootStepEffect::SocketScale' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, SocketName) == 0x000068, "Member 'UAnimNotifyState_RSTimedFootStepEffect::SocketName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, LocationOffset) == 0x000070, "Member 'UAnimNotifyState_RSTimedFootStepEffect::LocationOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, RotationOffset) == 0x00007C, "Member 'UAnimNotifyState_RSTimedFootStepEffect::RotationOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, DilationOwner) == 0x000088, "Member 'UAnimNotifyState_RSTimedFootStepEffect::DilationOwner' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, M_pParticle) == 0x000090, "Member 'UAnimNotifyState_RSTimedFootStepEffect::M_pParticle' has a wrong offset!");

// Class BattlePrototype.AnimNotifyState_RSTimedParticleSystem
// 0x0028 (0x0088 - 0x0060)
class UAnimNotifyState_RSTimedParticleSystem : public UAnimNotifyState_TimedParticleEffect
{
public:
	TSubclassOf<class URSParticleSystemComponentBase> ComponentClass;                                    // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ignore;                                            // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ScaleOffset;                                       // 0x006C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OptionSeeThrough;                                  // 0x0079(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRegistToChara;                                   // 0x007A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInterruptTelepo;                                 // 0x007B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoolVector                            SocketLocation;                                    // 0x007C(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoolVector                            SocketRotation;                                    // 0x007F(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	ERSParticleSystemAttachRotationOffMode        SocketRotationOffMode;                             // 0x0082(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoolVector                            SocketScale;                                       // 0x0083(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	ESequencerDilationOwner                       DilationOwner;                                     // 0x0086(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_87[0x1];                                       // 0x0087(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_RSTimedParticleSystem">();
	}
	static class UAnimNotifyState_RSTimedParticleSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_RSTimedParticleSystem>();
	}
};
static_assert(alignof(UAnimNotifyState_RSTimedParticleSystem) == 0x000008, "Wrong alignment on UAnimNotifyState_RSTimedParticleSystem");
static_assert(sizeof(UAnimNotifyState_RSTimedParticleSystem) == 0x000088, "Wrong size on UAnimNotifyState_RSTimedParticleSystem");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, ComponentClass) == 0x000060, "Member 'UAnimNotifyState_RSTimedParticleSystem::ComponentClass' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, Ignore) == 0x000068, "Member 'UAnimNotifyState_RSTimedParticleSystem::Ignore' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, ScaleOffset) == 0x00006C, "Member 'UAnimNotifyState_RSTimedParticleSystem::ScaleOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, LocationType) == 0x000078, "Member 'UAnimNotifyState_RSTimedParticleSystem::LocationType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, OptionSeeThrough) == 0x000079, "Member 'UAnimNotifyState_RSTimedParticleSystem::OptionSeeThrough' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, IsRegistToChara) == 0x00007A, "Member 'UAnimNotifyState_RSTimedParticleSystem::IsRegistToChara' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, IsInterruptTelepo) == 0x00007B, "Member 'UAnimNotifyState_RSTimedParticleSystem::IsInterruptTelepo' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, SocketLocation) == 0x00007C, "Member 'UAnimNotifyState_RSTimedParticleSystem::SocketLocation' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, SocketRotation) == 0x00007F, "Member 'UAnimNotifyState_RSTimedParticleSystem::SocketRotation' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, SocketRotationOffMode) == 0x000082, "Member 'UAnimNotifyState_RSTimedParticleSystem::SocketRotationOffMode' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, SocketScale) == 0x000083, "Member 'UAnimNotifyState_RSTimedParticleSystem::SocketScale' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, DilationOwner) == 0x000086, "Member 'UAnimNotifyState_RSTimedParticleSystem::DilationOwner' has a wrong offset!");

// Class BattlePrototype.UIEquipParts5
// 0x0010 (0x0398 - 0x0388)
class UUIEquipParts5 : public UUIBase
{
public:
	class UFlagManager*                           FlagManager;                                       // 0x0388(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x8];                                      // 0x0390(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ClearCurrentNewFlagNative(int32 Index_0);
	void InitializeList(class UREDScrollBox* ScrollBox);
	bool IsUpdateEquipListMouseFocus(int32* CursorIndex);
	void ListFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);

	int32 StringCompare(const class FString& String1, const class FString& String2) const;
	int32 TextCompare(const class FText& Text1, const class FText& Text2) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEquipParts5">();
	}
	static class UUIEquipParts5* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEquipParts5>();
	}
};
static_assert(alignof(UUIEquipParts5) == 0x000008, "Wrong alignment on UUIEquipParts5");
static_assert(sizeof(UUIEquipParts5) == 0x000398, "Wrong size on UUIEquipParts5");
static_assert(offsetof(UUIEquipParts5, FlagManager) == 0x000388, "Member 'UUIEquipParts5::FlagManager' has a wrong offset!");

// Class BattlePrototype.AnimNotifyState_RSTimedParticleSystem_SASCopyBase
// 0x0000 (0x0088 - 0x0088)
class UAnimNotifyState_RSTimedParticleSystem_SASCopyBase : public UAnimNotifyState_RSTimedParticleSystem
{
public:
	bool CheckExecNotifyBegin(class USkeletalMeshComponent* MeshComp) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_RSTimedParticleSystem_SASCopyBase">();
	}
	static class UAnimNotifyState_RSTimedParticleSystem_SASCopyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_RSTimedParticleSystem_SASCopyBase>();
	}
};
static_assert(alignof(UAnimNotifyState_RSTimedParticleSystem_SASCopyBase) == 0x000008, "Wrong alignment on UAnimNotifyState_RSTimedParticleSystem_SASCopyBase");
static_assert(sizeof(UAnimNotifyState_RSTimedParticleSystem_SASCopyBase) == 0x000088, "Wrong size on UAnimNotifyState_RSTimedParticleSystem_SASCopyBase");

// Class BattlePrototype.DataTableExtends
// 0x0000 (0x00C8 - 0x00C8)
class UDataTableExtends final : public UDataTable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataTableExtends">();
	}
	static class UDataTableExtends* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataTableExtends>();
	}
};
static_assert(alignof(UDataTableExtends) == 0x000008, "Wrong alignment on UDataTableExtends");
static_assert(sizeof(UDataTableExtends) == 0x0000C8, "Wrong size on UDataTableExtends");

// Class BattlePrototype.AnimNotifyState_RSTimedParticleSystemWithCondition
// 0x0000 (0x0088 - 0x0088)
class UAnimNotifyState_RSTimedParticleSystemWithCondition : public UAnimNotifyState_RSTimedParticleSystem
{
public:
	bool CheckCondition(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_RSTimedParticleSystemWithCondition">();
	}
	static class UAnimNotifyState_RSTimedParticleSystemWithCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_RSTimedParticleSystemWithCondition>();
	}
};
static_assert(alignof(UAnimNotifyState_RSTimedParticleSystemWithCondition) == 0x000008, "Wrong alignment on UAnimNotifyState_RSTimedParticleSystemWithCondition");
static_assert(sizeof(UAnimNotifyState_RSTimedParticleSystemWithCondition) == 0x000088, "Wrong size on UAnimNotifyState_RSTimedParticleSystemWithCondition");

// Class BattlePrototype.AnimNotifyState_RSTrail
// 0x0040 (0x0098 - 0x0058)
class UAnimNotifyState_RSTrail final : public UAnimNotifyState_Trail
{
public:
	uint8                                         Pad_58[0x1];                                       // 0x0058(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPlayerCopyMode;                                   // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreOriginal;                                   // 0x005A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCopy;                                       // 0x005B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URSParticleSystemComponentBase> ComponentClass;                                    // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ignore;                                            // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleComponentListManager*          ParticleComponentManager;                          // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WidthScale;                                        // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutStart;                                      // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FadeOutMaterialScalarName;                         // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OptionSeeThrough;                                  // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESequencerDilationOwner                       DilationOwner;                                     // 0x0089(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRegistToChara;                                   // 0x008A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInterruptTelepo;                                 // 0x008B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0xC];                                       // 0x008C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_RSTrail">();
	}
	static class UAnimNotifyState_RSTrail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_RSTrail>();
	}
};
static_assert(alignof(UAnimNotifyState_RSTrail) == 0x000008, "Wrong alignment on UAnimNotifyState_RSTrail");
static_assert(sizeof(UAnimNotifyState_RSTrail) == 0x000098, "Wrong size on UAnimNotifyState_RSTrail");
static_assert(offsetof(UAnimNotifyState_RSTrail, bPlayerCopyMode) == 0x000059, "Member 'UAnimNotifyState_RSTrail::bPlayerCopyMode' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, bIgnoreOriginal) == 0x00005A, "Member 'UAnimNotifyState_RSTrail::bIgnoreOriginal' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, bIgnoreCopy) == 0x00005B, "Member 'UAnimNotifyState_RSTrail::bIgnoreCopy' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, ComponentClass) == 0x000060, "Member 'UAnimNotifyState_RSTrail::ComponentClass' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, Ignore) == 0x000068, "Member 'UAnimNotifyState_RSTrail::Ignore' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, ParticleComponentManager) == 0x000070, "Member 'UAnimNotifyState_RSTrail::ParticleComponentManager' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, WidthScale) == 0x000078, "Member 'UAnimNotifyState_RSTrail::WidthScale' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, FadeOutStart) == 0x00007C, "Member 'UAnimNotifyState_RSTrail::FadeOutStart' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, FadeOutMaterialScalarName) == 0x000080, "Member 'UAnimNotifyState_RSTrail::FadeOutMaterialScalarName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, OptionSeeThrough) == 0x000088, "Member 'UAnimNotifyState_RSTrail::OptionSeeThrough' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, DilationOwner) == 0x000089, "Member 'UAnimNotifyState_RSTrail::DilationOwner' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, IsRegistToChara) == 0x00008A, "Member 'UAnimNotifyState_RSTrail::IsRegistToChara' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, IsInterruptTelepo) == 0x00008B, "Member 'UAnimNotifyState_RSTrail::IsInterruptTelepo' has a wrong offset!");

// Class BattlePrototype.RSActorBackgroundBase
// 0x0000 (0x0230 - 0x0230)
class ARSActorBackgroundBase : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorBackgroundBase">();
	}
	static class ARSActorBackgroundBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSActorBackgroundBase>();
	}
};
static_assert(alignof(ARSActorBackgroundBase) == 0x000008, "Wrong alignment on ARSActorBackgroundBase");
static_assert(sizeof(ARSActorBackgroundBase) == 0x000230, "Wrong size on ARSActorBackgroundBase");

// Class BattlePrototype.EffectBackground
// 0x0058 (0x0288 - 0x0230)
class AEffectBackground : public ARSActorBackgroundBase
{
public:
	class URSParticleSystemComponentBase*         ParticleComponent;                                 // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         PlayEventName_;                                    // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         StopEventName_;                                    // 0x0248(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x10];                                     // 0x0258(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseCameraDither_;                                 // 0x0268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DitherDistance_;                                   // 0x026C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DitherSpeed_;                                      // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       CameraComp_;                                       // 0x0278(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayParticleImplements();
	void ProtectedAttachParticle(class AActor* Parent);
	void ProtectedDetachParticle();
	bool SetDitherValue(float Value);
	void SetupUseAttachment();
	void StopAndHideParticleImplements();
	void StopParticleImplements();

	bool IsEffectAttachUse() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectBackground">();
	}
	static class AEffectBackground* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEffectBackground>();
	}
};
static_assert(alignof(AEffectBackground) == 0x000008, "Wrong alignment on AEffectBackground");
static_assert(sizeof(AEffectBackground) == 0x000288, "Wrong size on AEffectBackground");
static_assert(offsetof(AEffectBackground, ParticleComponent) == 0x000230, "Member 'AEffectBackground::ParticleComponent' has a wrong offset!");
static_assert(offsetof(AEffectBackground, PlayEventName_) == 0x000238, "Member 'AEffectBackground::PlayEventName_' has a wrong offset!");
static_assert(offsetof(AEffectBackground, StopEventName_) == 0x000248, "Member 'AEffectBackground::StopEventName_' has a wrong offset!");
static_assert(offsetof(AEffectBackground, bUseCameraDither_) == 0x000268, "Member 'AEffectBackground::bUseCameraDither_' has a wrong offset!");
static_assert(offsetof(AEffectBackground, DitherDistance_) == 0x00026C, "Member 'AEffectBackground::DitherDistance_' has a wrong offset!");
static_assert(offsetof(AEffectBackground, DitherSpeed_) == 0x000270, "Member 'AEffectBackground::DitherSpeed_' has a wrong offset!");
static_assert(offsetof(AEffectBackground, CameraComp_) == 0x000278, "Member 'AEffectBackground::CameraComp_' has a wrong offset!");

// Class BattlePrototype.AnimNotifyState_SuperArmor
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_SuperArmor final : public UAnimNotifyState
{
public:
	int32                                         ResistStagger;                                     // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_SuperArmor">();
	}
	static class UAnimNotifyState_SuperArmor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_SuperArmor>();
	}
};
static_assert(alignof(UAnimNotifyState_SuperArmor) == 0x000008, "Wrong alignment on UAnimNotifyState_SuperArmor");
static_assert(sizeof(UAnimNotifyState_SuperArmor) == 0x000038, "Wrong size on UAnimNotifyState_SuperArmor");
static_assert(offsetof(UAnimNotifyState_SuperArmor, ResistStagger) == 0x000030, "Member 'UAnimNotifyState_SuperArmor::ResistStagger' has a wrong offset!");

// Class BattlePrototype.AnyObjectCreator
// 0x0030 (0x0058 - 0x0028)
class UAnyObjectCreator final : public UObject
{
public:
	TSubclassOf<class AActor>                     SpawnClass;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 SpawnObject;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSuccessConstruct;                                 // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LoadAssetName;                                     // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObject*                                LoadedObject;                                      // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnyObjectCreator">();
	}
	static class UAnyObjectCreator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnyObjectCreator>();
	}
};
static_assert(alignof(UAnyObjectCreator) == 0x000008, "Wrong alignment on UAnyObjectCreator");
static_assert(sizeof(UAnyObjectCreator) == 0x000058, "Wrong size on UAnyObjectCreator");
static_assert(offsetof(UAnyObjectCreator, SpawnClass) == 0x000028, "Member 'UAnyObjectCreator::SpawnClass' has a wrong offset!");
static_assert(offsetof(UAnyObjectCreator, SpawnObject) == 0x000030, "Member 'UAnyObjectCreator::SpawnObject' has a wrong offset!");
static_assert(offsetof(UAnyObjectCreator, bSuccessConstruct) == 0x000038, "Member 'UAnyObjectCreator::bSuccessConstruct' has a wrong offset!");
static_assert(offsetof(UAnyObjectCreator, LoadAssetName) == 0x000040, "Member 'UAnyObjectCreator::LoadAssetName' has a wrong offset!");
static_assert(offsetof(UAnyObjectCreator, LoadedObject) == 0x000050, "Member 'UAnyObjectCreator::LoadedObject' has a wrong offset!");

// Class BattlePrototype.PlayerRenderSettings
// 0x0010 (0x0038 - 0x0028)
class UPlayerRenderSettings final : public UObject
{
public:
	TArray<struct FHeightGradationSettings>       HeightGradationSettingsArray;                      // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerRenderSettings">();
	}
	static class UPlayerRenderSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerRenderSettings>();
	}
};
static_assert(alignof(UPlayerRenderSettings) == 0x000008, "Wrong alignment on UPlayerRenderSettings");
static_assert(sizeof(UPlayerRenderSettings) == 0x000038, "Wrong size on UPlayerRenderSettings");
static_assert(offsetof(UPlayerRenderSettings, HeightGradationSettingsArray) == 0x000028, "Member 'UPlayerRenderSettings::HeightGradationSettingsArray' has a wrong offset!");

// Class BattlePrototype.DebuggingItemAppVersionGroup
// 0x0010 (0x02E0 - 0x02D0)
class ADebuggingItemAppVersionGroup final : public ADebuggingItemGroup
{
public:
	TWeakObjectPtr<class ADebuggingItemLabel>     DispLabel;                                         // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemInt>       VersionInt;                                        // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnExecChangeReleaseVersion(const class ADebuggingItemEvent* Item);
	void OnPageOpened();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemAppVersionGroup">();
	}
	static class ADebuggingItemAppVersionGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemAppVersionGroup>();
	}
};
static_assert(alignof(ADebuggingItemAppVersionGroup) == 0x000008, "Wrong alignment on ADebuggingItemAppVersionGroup");
static_assert(sizeof(ADebuggingItemAppVersionGroup) == 0x0002E0, "Wrong size on ADebuggingItemAppVersionGroup");
static_assert(offsetof(ADebuggingItemAppVersionGroup, DispLabel) == 0x0002D0, "Member 'ADebuggingItemAppVersionGroup::DispLabel' has a wrong offset!");
static_assert(offsetof(ADebuggingItemAppVersionGroup, VersionInt) == 0x0002D8, "Member 'ADebuggingItemAppVersionGroup::VersionInt' has a wrong offset!");

// Class BattlePrototype.ArrangeItemBase
// 0x00E8 (0x0318 - 0x0230)
class AArrangeItemBase : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsDoBeginPlay;                                     // 0x0238(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UChildActorComponent*                   ChildActionIcon;                                   // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ActionIconSupportParamID;                          // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ActionIconWorldPositionOffset;                     // 0x0250(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionIconType                               ActionIconType;                                    // 0x025C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25D[0x3];                                      // 0x025D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ID;                                                // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 RandomArrangeItemID;                               // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_280[0x4];                                      // 0x0280(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LevelID;                                           // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GroupID;                                           // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ArrangeItemId;                                     // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FArrangeItemDataCell                   ArrangeItemDataCell;                               // 0x02A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          Acquired;                                          // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInvisivleInEvent;                                // 0x02C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CA[0x6];                                      // 0x02CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        IntervalTime;                                      // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OnScenarioFlagName;                                // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          AddItemSeCue;                                      // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          AcquisitionFailureSound;                           // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          ShowBoxComponent;                                  // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          EventBoxComponent;                                 // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x6];                                      // 0x0300(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          WhetherToGetFullItem;                              // 0x0306(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EArrangeItemBrainTalkType                     BrainTalkType;                                     // 0x0307(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoGet;                                          // 0x0308(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_309[0x3];                                      // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EvetBoxSize;                                       // 0x030C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnAcquire(bool IsInitialize);
	void OnBindAcquire(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnBindShowBoxBeginOverlap(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnRebirth(bool IsInitialize);
	void RestoreVisible();
	void Setup();
	void SetVisible(const bool Flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrangeItemBase">();
	}
	static class AArrangeItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArrangeItemBase>();
	}
};
static_assert(alignof(AArrangeItemBase) == 0x000008, "Wrong alignment on AArrangeItemBase");
static_assert(sizeof(AArrangeItemBase) == 0x000318, "Wrong size on AArrangeItemBase");
static_assert(offsetof(AArrangeItemBase, IsDoBeginPlay) == 0x000238, "Member 'AArrangeItemBase::IsDoBeginPlay' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, ChildActionIcon) == 0x000240, "Member 'AArrangeItemBase::ChildActionIcon' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, ActionIconSupportParamID) == 0x000248, "Member 'AArrangeItemBase::ActionIconSupportParamID' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, ActionIconWorldPositionOffset) == 0x000250, "Member 'AArrangeItemBase::ActionIconWorldPositionOffset' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, ActionIconType) == 0x00025C, "Member 'AArrangeItemBase::ActionIconType' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, ID) == 0x000260, "Member 'AArrangeItemBase::ID' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, RandomArrangeItemID) == 0x000270, "Member 'AArrangeItemBase::RandomArrangeItemID' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, LevelID) == 0x000284, "Member 'AArrangeItemBase::LevelID' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, GroupID) == 0x000288, "Member 'AArrangeItemBase::GroupID' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, ArrangeItemId) == 0x000290, "Member 'AArrangeItemBase::ArrangeItemId' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, ArrangeItemDataCell) == 0x0002A0, "Member 'AArrangeItemBase::ArrangeItemDataCell' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, Acquired) == 0x0002C8, "Member 'AArrangeItemBase::Acquired' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, IsInvisivleInEvent) == 0x0002C9, "Member 'AArrangeItemBase::IsInvisivleInEvent' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, IntervalTime) == 0x0002D0, "Member 'AArrangeItemBase::IntervalTime' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, OnScenarioFlagName) == 0x0002D8, "Member 'AArrangeItemBase::OnScenarioFlagName' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, AddItemSeCue) == 0x0002E0, "Member 'AArrangeItemBase::AddItemSeCue' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, AcquisitionFailureSound) == 0x0002E8, "Member 'AArrangeItemBase::AcquisitionFailureSound' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, ShowBoxComponent) == 0x0002F0, "Member 'AArrangeItemBase::ShowBoxComponent' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, EventBoxComponent) == 0x0002F8, "Member 'AArrangeItemBase::EventBoxComponent' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, WhetherToGetFullItem) == 0x000306, "Member 'AArrangeItemBase::WhetherToGetFullItem' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, BrainTalkType) == 0x000307, "Member 'AArrangeItemBase::BrainTalkType' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, bAutoGet) == 0x000308, "Member 'AArrangeItemBase::bAutoGet' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, EvetBoxSize) == 0x00030C, "Member 'AArrangeItemBase::EvetBoxSize' has a wrong offset!");

// Class BattlePrototype.UIHelpParts
// 0x0020 (0x03A8 - 0x0388)
class UUIHelpParts : public UUIBase
{
public:
	uint8                                         Pad_388[0x20];                                     // 0x0388(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeAnime(class UWidgetAnimation* Cursor_select, class UWidgetAnimation* Cursor_default_none, class UWidgetAnimation* Cursor_default);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHelpParts">();
	}
	static class UUIHelpParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHelpParts>();
	}
};
static_assert(alignof(UUIHelpParts) == 0x000008, "Wrong alignment on UUIHelpParts");
static_assert(sizeof(UUIHelpParts) == 0x0003A8, "Wrong size on UUIHelpParts");

// Class BattlePrototype.ArrangeItemIDSetter
// 0x0000 (0x0028 - 0x0028)
class UArrangeItemIDSetter final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrangeItemIDSetter">();
	}
	static class UArrangeItemIDSetter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArrangeItemIDSetter>();
	}
};
static_assert(alignof(UArrangeItemIDSetter) == 0x000008, "Wrong alignment on UArrangeItemIDSetter");
static_assert(sizeof(UArrangeItemIDSetter) == 0x000028, "Wrong size on UArrangeItemIDSetter");

// Class BattlePrototype.ArrangeItemManager
// 0x0090 (0x02C0 - 0x0230)
class AArrangeItemManager final : public AActor
{
public:
	uint8                                         Pad_230[0x18];                                     // 0x0230(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FArrangeItemListForSaveData>    M_allArrangeItemList;                              // 0x0248(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRandomArrangeItemIDInfo>       M_allRandomArrangeItemIDInfo;                      // 0x0258(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        M_timerCount;                                      // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EChangeMinimapStateType ChangeType, class FName ID)> OnChangeMinimapStateDelegate;                      // 0x0270(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAcquireDispather;                                // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRebirthDispather;                                // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	double                                        M_LotteryPrintDispEndTime;                         // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         M_LotteryPrintTextList;                            // 0x02A8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_isLotteryPrintDispDrawed;                        // 0x02B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_isDebugLotteryPrintDispFlag;                     // 0x02B9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_isDebugForceRepopTimeFlag;                       // 0x02BA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BB[0x1];                                      // 0x02BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_debugForceRepopTime;                             // 0x02BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ChangeAreaWork();
	bool GetArrangeItemParam(const class FName ID, float* IntervalTime, bool* Acquired, bool* Accessed);
	bool SetAccessed(const class FName ID, const bool Flag);
	bool SetAcquired(const class FName ID, const bool Flag);
	bool SetIntervalTime(const class FName ID, const float ArrangeItemIntervaltime, float* ResultIntervalTime);
	void SetRandomArrangeParam2Actor(class AArrangeItemBase* _actor);
	bool SetRebirth(const class FName ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrangeItemManager">();
	}
	static class AArrangeItemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArrangeItemManager>();
	}
};
static_assert(alignof(AArrangeItemManager) == 0x000008, "Wrong alignment on AArrangeItemManager");
static_assert(sizeof(AArrangeItemManager) == 0x0002C0, "Wrong size on AArrangeItemManager");
static_assert(offsetof(AArrangeItemManager, M_allArrangeItemList) == 0x000248, "Member 'AArrangeItemManager::M_allArrangeItemList' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, M_allRandomArrangeItemIDInfo) == 0x000258, "Member 'AArrangeItemManager::M_allRandomArrangeItemIDInfo' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, M_timerCount) == 0x000268, "Member 'AArrangeItemManager::M_timerCount' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, OnChangeMinimapStateDelegate) == 0x000270, "Member 'AArrangeItemManager::OnChangeMinimapStateDelegate' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, OnAcquireDispather) == 0x000280, "Member 'AArrangeItemManager::OnAcquireDispather' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, OnRebirthDispather) == 0x000290, "Member 'AArrangeItemManager::OnRebirthDispather' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, M_LotteryPrintDispEndTime) == 0x0002A0, "Member 'AArrangeItemManager::M_LotteryPrintDispEndTime' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, M_LotteryPrintTextList) == 0x0002A8, "Member 'AArrangeItemManager::M_LotteryPrintTextList' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, M_isLotteryPrintDispDrawed) == 0x0002B8, "Member 'AArrangeItemManager::M_isLotteryPrintDispDrawed' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, M_isDebugLotteryPrintDispFlag) == 0x0002B9, "Member 'AArrangeItemManager::M_isDebugLotteryPrintDispFlag' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, M_isDebugForceRepopTimeFlag) == 0x0002BA, "Member 'AArrangeItemManager::M_isDebugForceRepopTimeFlag' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, M_debugForceRepopTime) == 0x0002BC, "Member 'AArrangeItemManager::M_debugForceRepopTime' has a wrong offset!");

// Class BattlePrototype.PlayerLookAtComponent
// 0x0088 (0x0148 - 0x00C0)
class UPlayerLookAtComponent final : public UActorComponent
{
public:
	float                                         LimitDegreeUp;                                     // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitDegreeDown;                                   // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitDegreeRight;                                  // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitDegreeLeft;                                   // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtFollowSpeed;                                 // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LookAtSocketName;                                  // 0x00D4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LookAroundCurve;                                   // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x48];                                      // 0x00E8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UTargetSearchComponent>  _TargetSearchComponent;                            // 0x0130(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class USkeletalMeshComponent>  _MeshComponent;                                    // 0x0138(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class URSPlayerAnimInstance>   _PlayerAnimInstance;                               // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ForceReset();
	void SetEventLookAtActor(bool bEnable, class AActor* LookAtActor);
	void SetEventLookAtLocation(bool bEnable, const struct FVector& LookAtLocation);
	void SetLookAround(bool bLookAround);
	void SetLookAtEnabled(bool bEnabled);
	void SetLookAtLocation(bool bLookLocation, const struct FVector& LookAtLocation);

	bool IsLookAtEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerLookAtComponent">();
	}
	static class UPlayerLookAtComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerLookAtComponent>();
	}
};
static_assert(alignof(UPlayerLookAtComponent) == 0x000008, "Wrong alignment on UPlayerLookAtComponent");
static_assert(sizeof(UPlayerLookAtComponent) == 0x000148, "Wrong size on UPlayerLookAtComponent");
static_assert(offsetof(UPlayerLookAtComponent, LimitDegreeUp) == 0x0000C0, "Member 'UPlayerLookAtComponent::LimitDegreeUp' has a wrong offset!");
static_assert(offsetof(UPlayerLookAtComponent, LimitDegreeDown) == 0x0000C4, "Member 'UPlayerLookAtComponent::LimitDegreeDown' has a wrong offset!");
static_assert(offsetof(UPlayerLookAtComponent, LimitDegreeRight) == 0x0000C8, "Member 'UPlayerLookAtComponent::LimitDegreeRight' has a wrong offset!");
static_assert(offsetof(UPlayerLookAtComponent, LimitDegreeLeft) == 0x0000CC, "Member 'UPlayerLookAtComponent::LimitDegreeLeft' has a wrong offset!");
static_assert(offsetof(UPlayerLookAtComponent, LookAtFollowSpeed) == 0x0000D0, "Member 'UPlayerLookAtComponent::LookAtFollowSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerLookAtComponent, LookAtSocketName) == 0x0000D4, "Member 'UPlayerLookAtComponent::LookAtSocketName' has a wrong offset!");
static_assert(offsetof(UPlayerLookAtComponent, LookAroundCurve) == 0x0000E0, "Member 'UPlayerLookAtComponent::LookAroundCurve' has a wrong offset!");
static_assert(offsetof(UPlayerLookAtComponent, _TargetSearchComponent) == 0x000130, "Member 'UPlayerLookAtComponent::_TargetSearchComponent' has a wrong offset!");
static_assert(offsetof(UPlayerLookAtComponent, _MeshComponent) == 0x000138, "Member 'UPlayerLookAtComponent::_MeshComponent' has a wrong offset!");
static_assert(offsetof(UPlayerLookAtComponent, _PlayerAnimInstance) == 0x000140, "Member 'UPlayerLookAtComponent::_PlayerAnimInstance' has a wrong offset!");

// Class BattlePrototype.ArrangeItemParticle
// 0x0028 (0x0340 - 0x0318)
class AArrangeItemParticle : public AArrangeItemBase
{
public:
	class URSParticleSystemComponentBase*         ParticleComponent;                                 // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URSParticleSystemComponentBase*         ParticleComponentSub1;                             // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URSParticleSystemComponentBase*         AcquiredParticleComponent;                         // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URSParticleSystemComponentBase*         AcquiredParticleComponentSub1;                     // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          AcquiredSeCue;                                     // 0x0338(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UParticleSystem* GetEmitterTemplate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrangeItemParticle">();
	}
	static class AArrangeItemParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArrangeItemParticle>();
	}
};
static_assert(alignof(AArrangeItemParticle) == 0x000008, "Wrong alignment on AArrangeItemParticle");
static_assert(sizeof(AArrangeItemParticle) == 0x000340, "Wrong size on AArrangeItemParticle");
static_assert(offsetof(AArrangeItemParticle, ParticleComponent) == 0x000318, "Member 'AArrangeItemParticle::ParticleComponent' has a wrong offset!");
static_assert(offsetof(AArrangeItemParticle, ParticleComponentSub1) == 0x000320, "Member 'AArrangeItemParticle::ParticleComponentSub1' has a wrong offset!");
static_assert(offsetof(AArrangeItemParticle, AcquiredParticleComponent) == 0x000328, "Member 'AArrangeItemParticle::AcquiredParticleComponent' has a wrong offset!");
static_assert(offsetof(AArrangeItemParticle, AcquiredParticleComponentSub1) == 0x000330, "Member 'AArrangeItemParticle::AcquiredParticleComponentSub1' has a wrong offset!");
static_assert(offsetof(AArrangeItemParticle, AcquiredSeCue) == 0x000338, "Member 'AArrangeItemParticle::AcquiredSeCue' has a wrong offset!");

// Class BattlePrototype.ArrangeItemParticleEvent
// 0x0000 (0x0340 - 0x0340)
class AArrangeItemParticleEvent final : public AArrangeItemParticle
{
public:
	bool DoEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrangeItemParticleEvent">();
	}
	static class AArrangeItemParticleEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArrangeItemParticleEvent>();
	}
};
static_assert(alignof(AArrangeItemParticleEvent) == 0x000008, "Wrong alignment on AArrangeItemParticleEvent");
static_assert(sizeof(AArrangeItemParticleEvent) == 0x000340, "Wrong size on AArrangeItemParticleEvent");

// Class BattlePrototype.ArrangeObject
// 0x0078 (0x02A8 - 0x0230)
class AArrangeObject : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsDoBeginPlay;                                     // 0x0238(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ID;                                                // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelID;                                           // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupID;                                           // 0x0244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   ArrangeMesh;                                       // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FirstPosition;                                     // 0x0250(0x000C)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FirstRotation;                                     // 0x025C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TempPosition;                                      // 0x0268(0x000C)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TempRotation;                                      // 0x0274(0x000C)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UFootStepComponent*                     FootStepComponent;                                 // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHitActorInfo>                  HitActorList;                                      // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitSeInterval;                                     // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaySeVelocity;                                    // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRunSeVelocity;                                 // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHitCallback(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrangeObject">();
	}
	static class AArrangeObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArrangeObject>();
	}
};
static_assert(alignof(AArrangeObject) == 0x000008, "Wrong alignment on AArrangeObject");
static_assert(sizeof(AArrangeObject) == 0x0002A8, "Wrong size on AArrangeObject");
static_assert(offsetof(AArrangeObject, IsDoBeginPlay) == 0x000238, "Member 'AArrangeObject::IsDoBeginPlay' has a wrong offset!");
static_assert(offsetof(AArrangeObject, ID) == 0x00023C, "Member 'AArrangeObject::ID' has a wrong offset!");
static_assert(offsetof(AArrangeObject, LevelID) == 0x000240, "Member 'AArrangeObject::LevelID' has a wrong offset!");
static_assert(offsetof(AArrangeObject, GroupID) == 0x000244, "Member 'AArrangeObject::GroupID' has a wrong offset!");
static_assert(offsetof(AArrangeObject, ArrangeMesh) == 0x000248, "Member 'AArrangeObject::ArrangeMesh' has a wrong offset!");
static_assert(offsetof(AArrangeObject, FirstPosition) == 0x000250, "Member 'AArrangeObject::FirstPosition' has a wrong offset!");
static_assert(offsetof(AArrangeObject, FirstRotation) == 0x00025C, "Member 'AArrangeObject::FirstRotation' has a wrong offset!");
static_assert(offsetof(AArrangeObject, TempPosition) == 0x000268, "Member 'AArrangeObject::TempPosition' has a wrong offset!");
static_assert(offsetof(AArrangeObject, TempRotation) == 0x000274, "Member 'AArrangeObject::TempRotation' has a wrong offset!");
static_assert(offsetof(AArrangeObject, FootStepComponent) == 0x000280, "Member 'AArrangeObject::FootStepComponent' has a wrong offset!");
static_assert(offsetof(AArrangeObject, HitActorList) == 0x000288, "Member 'AArrangeObject::HitActorList' has a wrong offset!");
static_assert(offsetof(AArrangeObject, HitSeInterval) == 0x000298, "Member 'AArrangeObject::HitSeInterval' has a wrong offset!");
static_assert(offsetof(AArrangeObject, PlaySeVelocity) == 0x00029C, "Member 'AArrangeObject::PlaySeVelocity' has a wrong offset!");
static_assert(offsetof(AArrangeObject, PlayRunSeVelocity) == 0x0002A0, "Member 'AArrangeObject::PlayRunSeVelocity' has a wrong offset!");

// Class BattlePrototype.LC21MapGimmickManager
// 0x0038 (0x0268 - 0x0230)
class ALC21MapGimmickManager : public ARSActorSystemBase
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     BossFloorActorClass;                               // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AMapGimmickObject*>              Objects;                                           // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBossFloorInfo>                 ObjectInfoList;                                    // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentGimmickNo;                                  // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MostLeftFloorNo;                                   // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool ChangePhase(int32 PhaseNo);
	void ClearObjectInfoList();
	bool FallLeftFloor(float OffsetY);
	bool FindAllObjectsAndInitialize();
	void GetAllFloorObjectsAndSort();
	int32 GetMostRightSideFloorNo(float Offset, int32 StartId, int32 EndId, bool CheckIsFall);
	bool RemoveAllPart();
	bool StartEventLaser();
	bool StartEventLaserCenter();
	bool StartEventLaserFar();
	bool StartEventLaserSetWall();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LC21MapGimmickManager">();
	}
	static class ALC21MapGimmickManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALC21MapGimmickManager>();
	}
};
static_assert(alignof(ALC21MapGimmickManager) == 0x000008, "Wrong alignment on ALC21MapGimmickManager");
static_assert(sizeof(ALC21MapGimmickManager) == 0x000268, "Wrong size on ALC21MapGimmickManager");
static_assert(offsetof(ALC21MapGimmickManager, BossFloorActorClass) == 0x000238, "Member 'ALC21MapGimmickManager::BossFloorActorClass' has a wrong offset!");
static_assert(offsetof(ALC21MapGimmickManager, Objects) == 0x000240, "Member 'ALC21MapGimmickManager::Objects' has a wrong offset!");
static_assert(offsetof(ALC21MapGimmickManager, ObjectInfoList) == 0x000250, "Member 'ALC21MapGimmickManager::ObjectInfoList' has a wrong offset!");
static_assert(offsetof(ALC21MapGimmickManager, CurrentGimmickNo) == 0x000260, "Member 'ALC21MapGimmickManager::CurrentGimmickNo' has a wrong offset!");
static_assert(offsetof(ALC21MapGimmickManager, MostLeftFloorNo) == 0x000264, "Member 'ALC21MapGimmickManager::MostLeftFloorNo' has a wrong offset!");

// Class BattlePrototype.UserParamManager
// 0x05E8 (0x0610 - 0x0028)
class UUserParamManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUserParam                             M_userParam;                                       // 0x0038(0x03E8)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	class UCharactersParameterManager*            M_pCharaParamManage;                               // 0x0420(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWorldmapOpenParam*                     M_worldmapOpenParamM;                              // 0x0428(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWorldmapOpenParam*                     M_worldmapOpenParamF;                              // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, int32>                      M_transObjMap;                                     // 0x0438(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 M_tradeWishList;                                   // 0x0488(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQuestParamManager*                     M_questParamManager;                               // 0x0498(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrainMessageParamManager*              M_brainMessageParamManager;                        // 0x04A0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULoadTipsParamManager*                  M_loadingTipsParamManager;                         // 0x04A8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOptionParam*                           M_optionParam;                                     // 0x04B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPurposeMessageParamManager*            M_purposeMessageParamManager;                      // 0x04B8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULibraryEnemyParam*                     M_libraryEnemyParam;                               // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULibraryCharacterParam*                 M_libraryCharaParam;                               // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUserSystemParam                       M_UserSystemParam;                                 // 0x04D0(0x0006)(Edit, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D6[0x2];                                      // 0x04D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UPresentInfoParam*                      M_presentInfoParam;                                // 0x04D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTipsCountParamManager*                 M_tipsCountParamManager;                           // 0x04E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           M_seenAjitoPatternList;                            // 0x04E8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBattleLogBuffer*                       M_battleLogBuffer;                                 // 0x04F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           M_AllAddContentsNameList;                          // 0x0500(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           M_AppliedAddContentsNameList;                      // 0x0510(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           M_NotifiedNotAppliedAddContentsNameList;           // 0x0520(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_530[0x8];                                      // 0x0530(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUserItemInfo>                  M_mapUsableItemList;                               // 0x0538(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isForceNewGameFlowFlag;                          // 0x0548(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_549[0xF];                                      // 0x0549(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           M_PurchasedAddContentNameList;                     // 0x0558(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             bondsProgressEvent;                                // 0x0568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             bondsLevelEvent;                                   // 0x0578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SasEquipExtendEvent;                               // 0x0588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SasEquipEvent;                                     // 0x0598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SasEquipStatusEvent;                               // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             WmSelectableChangeEvent;                           // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnStartBondsEpisodeEvent;                          // 0x05C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndBondsEpisodeEvent;                            // 0x05D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeNoticeUiStateDelegate;                     // 0x05E8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeNoticeUiStateRemoveDelegate;               // 0x05F8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_608[0x8];                                      // 0x0608(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBondsFValue(EPlayerID PlayerId, EPlayerID TargetID, float Value);
	void AddBondsValue(EPlayerID PlayerId, EPlayerID TargetID, int32 Value);
	void AddBrainTalkOnceCheck_InSaveData(const EBrainTalkCategory _Category, const class FName _ID);
	void AddClearLapNum();
	bool AddItemNum(const class FName& ID, const int32 Num, const bool IsUpdateMapUsableItemList_NotUsed, const bool IsDispGetLog);
	void AddLibraryEnemyFlag(const int32 ID, const ELIBRARY_FLAG Flag);
	void AddLibraryEpisodeFlag(const int32 ID, const ELIBRARY_FLAG Flag);
	void AddLibraryTerminologyFlag(const int32 ID, const ELIBRARY_FLAG Flag);
	bool AddMoney(const int32 Value);
	void AddNotifiedNotAppliedAddContentsNameList(class FName AddName);
	void AddSkillPoint(int32 Point);
	bool AddWishList(int32 Content);
	void AppendAppliedAddContentsNameList(class FName AddContentName);
	bool CheckBondsLevelUp(EPlayerID PlayerId, EPlayerID TargetID);
	bool CheckHaveItemCapacity(const class FName& ID, const int32 Num);
	bool CheckHaveItemCapacityWithRetNum(const class FName& ID, const int32 Num, ECanBeAddedItems* CanBeAdded, int32* RetNum);
	bool CheckStartTeamBondsEpisode(EPlayerID PlayerId, int32* EpisodeNo);
	bool CheckTeamBondsLevelUp(EPlayerID PlayerId, int32 ProgressNo);
	void ClearMoneyDirty();
	void ClearWorldmapOpenParamAllFromSelectSenario();
	void DeleteItemAll();
	void DeleteItemKind(const class FName& ID);
	void DeleteLibraryEnemyFlag(const int32 ID, const ELIBRARY_FLAG Flag);
	void DeleteLibraryEpisodeFlag(const int32 ID, const ELIBRARY_FLAG Flag);
	void DeleteLibraryTerminologyFlag(const int32 ID, const ELIBRARY_FLAG Flag);
	void EndBondsEpisode(bool IsCancel);
	TArray<class FName> GetAllAddContentsNameList();
	TArray<class FName> GetAppliedAddContentsNameList();
	class UBattleLogBuffer* GetBattleLogBuffer();
	float GetBondsFValue(EPlayerID PlayerId, EPlayerID TargetID);
	int32 GetBondsLevel(EPlayerID PlayerId, EPlayerID TargetID);
	int32 GetBondsMaxLevel(EPlayerID PlayerId, EPlayerID TargetID);
	int32 GetBondsProgress(EPlayerID PlayerId, EPlayerID TargetID);
	int32 GetBondsValue(EPlayerID PlayerId, EPlayerID TargetID);
	class UBrainMessageParamManager* GetBrainMessageParamManager();
	bool GetCeBank();
	bool GetEula();
	bool GetGameClear();
	EHCGameDifficulty GetGameDifficulty();
	bool GetHasPresentedItemInfoList(EPlayerID SendCharaID, EPlayerID RecvCharaID, TArray<struct FPresentInfoData>* ItemList, bool IncludeEvent);
	bool GetIsProgressBondsEpisode(EPlayerID* PlayerId, EPlayerID* TargetID);
	const TArray<struct FUserItemInfo> GetItemList();
	class ULibraryCharacterParam* GetLibraryCharaParam();
	class ULibraryEnemyParam* GetLibraryEnemyParam();
	class ULoadTipsParamManager* GetLoadTipsParamManager();
	TArray<class FName> GetNotifiedNotAppliedAddContentsNameList();
	int32 GetNpcAccessoryExtendNum(EPlayerID PlayerId);
	class UOptionParam* GetOptionParam();
	class UPresentInfoParam* GetPresentInfoParam();
	bool GetPresentItemInfoList(EPlayerID SendCharaID, EPlayerID RecvCharaID, TArray<struct FPresentInfoData>* ItemList);
	bool GetPrivacyPolicy();
	TArray<class FName> GetPurchasedAddContentNameList();
	class UPurposeMessageParamManager* GetPurposeMessageParamManager();
	class UQuestParamManager* GetQuestParamManager();
	class FName GetSelectedMapUsableItem();
	bool GetSelectNewGame();
	int32 GetSelectSaveSlot();
	int32 GetTeamBondsLevel(EPlayerID PlayerId);
	class UTipsCountParamManager* GetTipsCountParam();
	bool GetTitleProductFlag();
	bool GetTransferObject(int32 ItemId, int32* ObjectID, bool IsRemove);
	bool GetTransferObjectByName(const class FName& ItemId, int32* ObjectID, bool IsRemove);
	int32 GetWishListNum();
	class UWorldmapOpenParam* GetWorldmapOpenParam();
	bool GetZeroEpClear();
	void InitializeItemParam();
	void InitializeParam(bool IsNewGame);
	void InitializeTotalPlayTime();
	bool IsBattleFieldCheckToWorldMapSystems();
	bool IsBrainTalkOnceCheck_InSaveData_Find(const EBrainTalkCategory _Category, const class FName _ID);
	bool IsEquipSAS(E_SASKindNative Kind);
	bool IsExistInWishList(int32 Content);
	bool IsExNewGame_TakeOverBrainMap();
	bool IsExNewGame_TakeOverCharacterLevel();
	bool IsExNewGameFlow();
	bool IsForceNewGameFlowFlag();
	bool IsHaveRepairItem();
	bool IsNpcAccesoryExtend1(EPlayerID PlayerId);
	bool IsNpcAccesoryExtend2(EPlayerID PlayerId);
	bool IsSeenAjitoPattern(const class FName AjitoPatternName);
	void OnSetEventProgressID(int32 ProgressNo);
	void ReCalcSkillPoint();
	void RegisterUseMapGimmick(EMapGimmickType Type);
	void RemoveItemList(const class FName _ID);
	bool RemoveWishList(int32 Content);
	void ResetBattlefieldInfos();
	void ResetLearnedSkill(EPlayerID PlayerId);
	void ResetMapGimmickUseTimes(EMapGimmickType Type);
	void ResetMapGimmickUseTimesAll();
	void ResetTotalPlayTimeCount();
	void SetAllAddContentsNameList(const TArray<class FName>& List);
	void SetAppliedAddContentsNameList(const TArray<class FName>& List);
	void SetBattlefieldInfos(const TMap<class FString, struct FBattlefieldInfo>& Infos);
	void SetBattlefieldRandomSeed(const int32 Seed);
	void SetBondsFValue(EPlayerID PlayerId, EPlayerID TargetID, float Value);
	void SetBondsLevel(EPlayerID PlayerId, EPlayerID TargetID, int32 Level, bool AdjustExp);
	void SetBondsMaxLevel(int32 MaxLevel);
	void SetBondsProgress(EPlayerID PlayerId, EPlayerID TargetID, int32 Progress);
	void SetBondsValue(EPlayerID PlayerId, EPlayerID TargetID, int32 Value);
	void SetCeBank(bool Flag);
	void SetClearLapNum(const int32 Num);
	void SetEquipSAS(E_SASButton Button, E_SASKindNative Kind);
	void SetEula(bool Flag);
	void SetExtendEquipSAS(bool bExtend);
	void SetGameClear(bool Flag);
	void SetGameClearState(EGameClearState State);
	void SetGameDifficulty(EHCGameDifficulty Diffuculty);
	void SetIsExNewGame_TakeOverBrainMap(const bool Flag);
	void SetIsExNewGame_TakeOverCharacterLevel(const bool Flag);
	void SetIsExNewGameFlow(const bool Flag);
	void SetIsForceNewGameFlowFlag(const bool Flag);
	void SetItemKind(const class FName& ID, const int32 Num);
	void SetItemNum(const class FName& ID, const int32 Num);
	void SetLearnedSkill(EPlayerID PlayerId, EPlayerSkill SkillID, bool bLearn);
	void SetLibraryEnemyFlag(const int32 ID, const uint8 Flag);
	void SetLibraryEpisodeFlag(const int32 ID, const uint8 Flag);
	void SetLibraryTerminologyFlag(const int32 ID, const uint8 Flag);
	void SetMemberSlotInfo(const int32 Index_0, const int32 ID);
	void SetMoney(const int32 Value);
	void SetNotifiedNotAppliedAddContentsNameList(const TArray<class FName>& NameList);
	void SetNpcAccessoryExtend1(EPlayerID PlayerId);
	void SetNpcAccessoryExtend2(EPlayerID PlayerId);
	void SetPrivacyPolicy(bool Flag);
	void SetPurchasedAddContentNameList(const TArray<class FName>& List);
	void SetReceiveOrderQuestID(const int32 ID);
	void SetSASEquipStatus(E_SASKindNative Kind, ESASEquipStatus Status, bool bNotEquip);
	void SetSeenAjitoPattern(const class FName AjitoPatternName);
	void SetSelectedMapUsableItem(class FName ItemId);
	void SetSelectedScenario(const int32 Value);
	void SetSelectNewGame(bool SelectSlot);
	void SetSelectSaveSlot(int32 SelectSlot);
	void SetSkillPoint(int32 Point);
	void SetTeamBondsLevel(EPlayerID PlayerId, int32 TeamBondsLevel);
	void SetTeamBondsProgress(EPlayerID PlayerId, int32 Progress);
	void SetTitleProductFlag(bool Flag);
	bool SetTransferObject(int32 ItemId, int32 ObjectID, bool IsOverwrite);
	bool SetTransferObjectByName(const class FName& ItemId, int32 ObjectID, bool IsOverwrite);
	bool SetWishList(const TArray<int32>& WishList);
	void SetZeroEpClear(bool Flag);
	void StartBondsEpisode(EPlayerID PlayerId, EPlayerID TargetID);
	void TempDisableSkill(bool bDisable);
	bool UpdateBondsLevel(EPlayerID PlayerId, EPlayerID TargetID, bool IsSingleLvUp);
	bool UpdatePresentItemInfo(EPlayerID SendCharaID, EPlayerID RecvCharaID, class FName ItemId);
	bool UpdateTeamBondsLevel(EPlayerID PlayerId, int32 ProgressNo, bool IsSingleLvUp);
	void WorldmapCheckOpenFromProgressID(int32 ProgressId, bool CheckNearly);
	void WorldmapCheckOpenFromProgressIDAndCharaID(EPlayerID PlayerId, int32 ProgressId, bool CheckNearly);
	bool WorldmapCloseLocation(int32 LocationNo, int32 AreaNo, bool IsAreaAll);
	bool WorldmapGetOpenParam(TArray<struct FWorldmapOpenLCParam>* OpenedList);
	bool WorldmapIsAllLocationNotSelectable();
	bool WorldmapIsLocationNewOpen(int32 LocationNo, int32 AreaNo);
	bool WorldmapIsLocationNotSelectable(int32 LocationNo);
	bool WorldmapIsLocationSelectable(int32 LocationNo, int32 AreaNo);
	bool WorldmapOpenLocation(int32 LocationNo, int32 AreaNo, bool IsSelectable);
	bool WorldmapSetAllLocationNotSelectable(bool IsNotSelectable);
	bool WorldmapSetLocationNewOpen(int32 LocationNo, int32 AreaNo, bool IsNewOpen, bool IsAreaAll);
	bool WorldmapSetLocationNotSelectable(int32 LocationNo, bool IsNotSelectable);
	bool WorldmapSetLocationSelectable(int32 LocationNo, int32 AreaNo, bool IsSelectable, bool IsForce, bool IsAreaAll);
	bool WorldmapSetLocationSelectable_WithPortal(int32 LocationNo, int32 AreaNo, int32 PortalNo, bool IsSelectable, bool IsForce, bool IsAreaAll);

	TMap<class FString, struct FBattlefieldInfo> GetBattlefieldInfos() const;
	int32 GetBattlefieldRandomSeed() const;
	int32 GetClearLapNum() const;
	E_SASKindNative GetEquipSAS(E_SASButton Button) const;
	EGameClearState GetGameClearState() const;
	int32 GetItemNum(const class FName& ID) const;
	int32 GetLastAcquisitionTime(const class FName& ID) const;
	int32 GetLastShopID() const;
	int32 GetLastTradeShopID() const;
	uint8 GetLibraryEnemyFlag(const int32 ID) const;
	uint8 GetLibraryEpisodeFlag(const int32 ID) const;
	uint8 GetLibraryTerminologyFlag(const int32 ID) const;
	TMap<EMapGimmickType, int32> GetMapGimmickUseTimes() const;
	struct FUserItemInfo GetMapUsableItemListInfo(const int32 Index_0) const;
	int32 GetMapUsableItemListNextIndex(const int32 CurrentIndex) const;
	struct FUserItemInfo GetMapUsableItemListNextInfo(const int32 CurrentIndex) const;
	int32 GetMapUsableItemListNum() const;
	int32 GetMapUsableItemListPrevIndex(const int32 CurrentIndex) const;
	struct FUserItemInfo GetMapUsableItemListPrevInfo(const int32 CurrentIndex) const;
	struct FMemberSlotInfo GetMemberSlotInfo(const int32 Index_0) const;
	int32 GetMoney() const;
	bool GetMoneyDirty() const;
	int32 GetReceiveOrderQuestID() const;
	ESASEquipStatus GetSASEquipStatus(E_SASKindNative Kind) const;
	int32 GetSelectedScenario() const;
	int32 GetSkillPoint() const;
	int32 GetTeamBondsMaxLevel() const;
	int32 GetTeamBondsProgress(EPlayerID PlayerId) const;
	int32 GetTotalPlayTime(const bool IsRealData) const;
	const TArray<int32> GetWishList() const;
	bool IsExtendEquipSAS() const;
	bool IsLearnedSkill(EPlayerID PlayerId, EPlayerSkill SkillID) const;
	bool IsSASEquipAble(E_SASKindNative Kind) const;
	bool IsValidLibraryEnemyFlag(const int32 ID, const ELIBRARY_FLAG Flag) const;
	bool IsValidLibraryEpisodeFlag(const int32 ID, const ELIBRARY_FLAG Flag) const;
	bool IsValidLibraryTerminologyFlag(const int32 ID, const ELIBRARY_FLAG Flag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserParamManager">();
	}
	static class UUserParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserParamManager>();
	}
};
static_assert(alignof(UUserParamManager) == 0x000008, "Wrong alignment on UUserParamManager");
static_assert(sizeof(UUserParamManager) == 0x000610, "Wrong size on UUserParamManager");
static_assert(offsetof(UUserParamManager, M_userParam) == 0x000038, "Member 'UUserParamManager::M_userParam' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_pCharaParamManage) == 0x000420, "Member 'UUserParamManager::M_pCharaParamManage' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_worldmapOpenParamM) == 0x000428, "Member 'UUserParamManager::M_worldmapOpenParamM' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_worldmapOpenParamF) == 0x000430, "Member 'UUserParamManager::M_worldmapOpenParamF' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_transObjMap) == 0x000438, "Member 'UUserParamManager::M_transObjMap' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_tradeWishList) == 0x000488, "Member 'UUserParamManager::M_tradeWishList' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_questParamManager) == 0x000498, "Member 'UUserParamManager::M_questParamManager' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_brainMessageParamManager) == 0x0004A0, "Member 'UUserParamManager::M_brainMessageParamManager' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_loadingTipsParamManager) == 0x0004A8, "Member 'UUserParamManager::M_loadingTipsParamManager' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_optionParam) == 0x0004B0, "Member 'UUserParamManager::M_optionParam' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_purposeMessageParamManager) == 0x0004B8, "Member 'UUserParamManager::M_purposeMessageParamManager' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_libraryEnemyParam) == 0x0004C0, "Member 'UUserParamManager::M_libraryEnemyParam' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_libraryCharaParam) == 0x0004C8, "Member 'UUserParamManager::M_libraryCharaParam' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_UserSystemParam) == 0x0004D0, "Member 'UUserParamManager::M_UserSystemParam' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_presentInfoParam) == 0x0004D8, "Member 'UUserParamManager::M_presentInfoParam' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_tipsCountParamManager) == 0x0004E0, "Member 'UUserParamManager::M_tipsCountParamManager' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_seenAjitoPatternList) == 0x0004E8, "Member 'UUserParamManager::M_seenAjitoPatternList' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_battleLogBuffer) == 0x0004F8, "Member 'UUserParamManager::M_battleLogBuffer' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_AllAddContentsNameList) == 0x000500, "Member 'UUserParamManager::M_AllAddContentsNameList' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_AppliedAddContentsNameList) == 0x000510, "Member 'UUserParamManager::M_AppliedAddContentsNameList' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_NotifiedNotAppliedAddContentsNameList) == 0x000520, "Member 'UUserParamManager::M_NotifiedNotAppliedAddContentsNameList' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_mapUsableItemList) == 0x000538, "Member 'UUserParamManager::M_mapUsableItemList' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_isForceNewGameFlowFlag) == 0x000548, "Member 'UUserParamManager::M_isForceNewGameFlowFlag' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_PurchasedAddContentNameList) == 0x000558, "Member 'UUserParamManager::M_PurchasedAddContentNameList' has a wrong offset!");
static_assert(offsetof(UUserParamManager, bondsProgressEvent) == 0x000568, "Member 'UUserParamManager::bondsProgressEvent' has a wrong offset!");
static_assert(offsetof(UUserParamManager, bondsLevelEvent) == 0x000578, "Member 'UUserParamManager::bondsLevelEvent' has a wrong offset!");
static_assert(offsetof(UUserParamManager, SasEquipExtendEvent) == 0x000588, "Member 'UUserParamManager::SasEquipExtendEvent' has a wrong offset!");
static_assert(offsetof(UUserParamManager, SasEquipEvent) == 0x000598, "Member 'UUserParamManager::SasEquipEvent' has a wrong offset!");
static_assert(offsetof(UUserParamManager, SasEquipStatusEvent) == 0x0005A8, "Member 'UUserParamManager::SasEquipStatusEvent' has a wrong offset!");
static_assert(offsetof(UUserParamManager, WmSelectableChangeEvent) == 0x0005B8, "Member 'UUserParamManager::WmSelectableChangeEvent' has a wrong offset!");
static_assert(offsetof(UUserParamManager, OnStartBondsEpisodeEvent) == 0x0005C8, "Member 'UUserParamManager::OnStartBondsEpisodeEvent' has a wrong offset!");
static_assert(offsetof(UUserParamManager, OnEndBondsEpisodeEvent) == 0x0005D8, "Member 'UUserParamManager::OnEndBondsEpisodeEvent' has a wrong offset!");
static_assert(offsetof(UUserParamManager, OnChangeNoticeUiStateDelegate) == 0x0005E8, "Member 'UUserParamManager::OnChangeNoticeUiStateDelegate' has a wrong offset!");
static_assert(offsetof(UUserParamManager, OnChangeNoticeUiStateRemoveDelegate) == 0x0005F8, "Member 'UUserParamManager::OnChangeNoticeUiStateRemoveDelegate' has a wrong offset!");

// Class BattlePrototype.ArrangeObjectManager
// 0x0010 (0x0038 - 0x0028)
class UArrangeObjectManager final : public UObject
{
public:
	TArray<class AArrangeObject*>                 ArrangeObjects;                                    // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BackupFirstObjectInfo(const int32 LevelID, const int32 GroupID);
	void BackupObjectInfo(const int32 LevelID, const int32 GroupID);
	class AArrangeObject* GetArrangeObject(const int32 ID);
	void Initialize(const class UObject* WorldContextObject);
	void RegisterObject(class AArrangeObject* ArrangeObject);
	void RestoreFirstObjectInfo(const int32 LevelID, const int32 GroupID);
	void RestoreObjectInfo(const int32 LevelID, const int32 GroupID);
	void SetEnableCollision(const bool Flag, const bool bHiddenCheck);
	void SetVisible(const bool IsVisible, const int32 LevelID, const int32 GroupID);
	void UnregisterObject(class AArrangeObject* ArrangeObject);
	void UnregisterObjectAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrangeObjectManager">();
	}
	static class UArrangeObjectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArrangeObjectManager>();
	}
};
static_assert(alignof(UArrangeObjectManager) == 0x000008, "Wrong alignment on UArrangeObjectManager");
static_assert(sizeof(UArrangeObjectManager) == 0x000038, "Wrong size on UArrangeObjectManager");
static_assert(offsetof(UArrangeObjectManager, ArrangeObjects) == 0x000028, "Member 'UArrangeObjectManager::ArrangeObjects' has a wrong offset!");

// Class BattlePrototype.NpcSkeletalMeshActor
// 0x00C0 (0x02F0 - 0x0230)
class ANpcSkeletalMeshActor : public AActor
{
public:
	class UCapsuleComponent*                      CharacterCapsuleComponent;                         // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NpcMeshDataTableID;                                // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NpcMaterialDataTableID;                            // 0x023C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BPOverrideMaterialID;                              // 0x0240(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x3];                                      // 0x0241(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HideOverlapInterpolateSeconds;                     // 0x0244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ForcedLOD;                                         // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNpcSkeletalMeshComponent*              SkeletalMesh;                                      // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalBody;                                      // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalBodyLower;                                 // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalFace;                                      // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalHair;                                      // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USkeletalMeshComponent*>         SkeletalParts;                                     // 0x0278(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_storeSkeletalMeshTransform;                      // 0x0290(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FTransform                             M_storeSkeletalBodyTransform;                      // 0x02C0(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	class USkeletalMeshComponent* GetSkeletalBody();
	class USkeletalMeshComponent* GetSkeletalFace();
	class UNpcSkeletalMeshComponent* GetSkeletalMesh();
	void GetValidSkeletalMeshComponents(TArray<class USkeletalMeshComponent*>* MeshComps);
	void PresentEventEnd();
	void PresentEventStart();
	void RefreshMesh();
	void ResetMeshes(int32 MeshDataTableID, int32 MaterialDataTableID);
	void SetForcedLOD(int32 Level);
	void SetHideOverlap(bool bHide, bool bOneFrame);
	void SetInfiniteBounds(bool Enable);
	void SetLightChannnel(bool Channel0, bool Channel1, bool Channel2);
	void SetNpcTickEnabled(bool Enabled);
	void SetNpcTickInterval(float Value);
	void SetRenderLayer(uint8 NewRenderLayer);
	void SetScalarArrayParameterValue(const TArray<class FName>& ParameterNames, const TArray<float>& ParameterValues);
	void SetScalarParameterValue(class FName ParameterName, float ParameterValue);
	void SetUseShaderBoneID(bool bUse);
	void SetVector4ArrayParameterValue(const TArray<class FName>& ParameterNames, const TArray<struct FLinearColor>& ParameterValues);
	void SetVector4ParameterValue(class FName ParameterName, const struct FLinearColor& ParameterValue);
	void SetVectorParameterValue(class FName ParameterName, const struct FVector& ParameterValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcSkeletalMeshActor">();
	}
	static class ANpcSkeletalMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcSkeletalMeshActor>();
	}
};
static_assert(alignof(ANpcSkeletalMeshActor) == 0x000010, "Wrong alignment on ANpcSkeletalMeshActor");
static_assert(sizeof(ANpcSkeletalMeshActor) == 0x0002F0, "Wrong size on ANpcSkeletalMeshActor");
static_assert(offsetof(ANpcSkeletalMeshActor, CharacterCapsuleComponent) == 0x000230, "Member 'ANpcSkeletalMeshActor::CharacterCapsuleComponent' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, NpcMeshDataTableID) == 0x000238, "Member 'ANpcSkeletalMeshActor::NpcMeshDataTableID' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, NpcMaterialDataTableID) == 0x00023C, "Member 'ANpcSkeletalMeshActor::NpcMaterialDataTableID' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, BPOverrideMaterialID) == 0x000240, "Member 'ANpcSkeletalMeshActor::BPOverrideMaterialID' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, HideOverlapInterpolateSeconds) == 0x000244, "Member 'ANpcSkeletalMeshActor::HideOverlapInterpolateSeconds' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, ForcedLOD) == 0x000248, "Member 'ANpcSkeletalMeshActor::ForcedLOD' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, SkeletalMesh) == 0x000250, "Member 'ANpcSkeletalMeshActor::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, SkeletalBody) == 0x000258, "Member 'ANpcSkeletalMeshActor::SkeletalBody' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, SkeletalBodyLower) == 0x000260, "Member 'ANpcSkeletalMeshActor::SkeletalBodyLower' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, SkeletalFace) == 0x000268, "Member 'ANpcSkeletalMeshActor::SkeletalFace' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, SkeletalHair) == 0x000270, "Member 'ANpcSkeletalMeshActor::SkeletalHair' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, SkeletalParts) == 0x000278, "Member 'ANpcSkeletalMeshActor::SkeletalParts' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, M_storeSkeletalMeshTransform) == 0x000290, "Member 'ANpcSkeletalMeshActor::M_storeSkeletalMeshTransform' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, M_storeSkeletalBodyTransform) == 0x0002C0, "Member 'ANpcSkeletalMeshActor::M_storeSkeletalBodyTransform' has a wrong offset!");

// Class BattlePrototype.AssetFuncLib
// 0x0000 (0x0028 - 0x0028)
class UAssetFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FName> GetAssetAllDependencies(class FName AssetName);
	static TArray<class FName> GetAssetDependencies(class FName AssetName, bool Hard, bool Soft, bool SearchableName, bool Manage);
	static TArray<class FName> GetAssetHardDependencies(class FName AssetName);
	static TArray<class FName> GetAssetManageDependencies(class FName AssetName);
	static TArray<class FName> GetAssetPackagesDependencies(class FName AssetName);
	static TArray<class FName> GetAssetSearchableNameDependencies(class FName AssetName);
	static TArray<class FName> GetAssetSoftDependencies(class FName AssetName);
	static bool GetPackagePath(class UObject* Object, class FName* OutName);
	static class FString GetPrimaryAssetPath(const struct FPrimaryAssetId& PrimaryAssetId);
	static bool IsChapterChunkLoaded(int32 ChapterNo);
	static bool IsChunkLoaded(const int32 ChunkId, const bool IsNotExistError);
	static bool IsFullInstallPackage();
	static bool IsReadyForceMipLevelsToBeResidentByTexture(class UTexture2D* Texture);
	static void ModifyAssets(const TArray<class UObject*>& Assets);
	static class FName ObjectSoftRefToName(const TSoftObjectPtr<class UObject>& Object);
	static class FString ObjectSoftRefToString(const TSoftObjectPtr<class UObject>& Object);
	static class FString ObjectSoftRefToStringRaw(const TSoftObjectPtr<class UObject>& Object);
	static void ResetForceMipLevelsToBeResidentBySkeletalMeshComp(class USkeletalMeshComponent* SkelMeshComp);
	static void ResetForceMipLevelsToBeResidentByTexture(class UTexture2D* Texture);
	static void SetChapterChunkPriority(int32 ChapterNo);
	static void SetForceMipLevelsToBeResidentBySkeletalMeshComp(class USkeletalMeshComponent* SkelMeshComp, float Seconds, int32 CinematicLODGroupMask, bool HighProirity);
	static void SetForceMipLevelsToBeResidentByTexture(class UTexture2D* Texture, float Seconds, int32 CinematicLODGroupMask, bool HighProirity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetFuncLib">();
	}
	static class UAssetFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetFuncLib>();
	}
};
static_assert(alignof(UAssetFuncLib) == 0x000008, "Wrong alignment on UAssetFuncLib");
static_assert(sizeof(UAssetFuncLib) == 0x000028, "Wrong size on UAssetFuncLib");

// Class BattlePrototype.UIHealthControl
// 0x0060 (0x03E8 - 0x0388)
class UUIHealthControl : public UUIBase
{
public:
	uint8                                         Pad_388[0x60];                                     // 0x0388(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsUnlockPlayerChara(EPlayerID CharaID);
	void ResetFlagFirstSet();
	void SetHp(float Max, float Current);
	void SetHpDirect(float Max, float Current);
	void SetIcon(int32 Index_0, class UImage* Icon);
	void SetIcon1(class UImage* Icon, int32 Index_0);
	void SetIcon2(class UImage* Icon, int32 Index_0);
	void SetIconDraw(int32 Index_0, bool IsDraw);
	void SetIconType(int32 Type);
	void SetNotHealAnimationFlag(bool IsNotAnimation);
	void SetPlayerName(EPlayerID CharaID, class UTextBlock* Text);
	void SetProgressBar(class UImage* Base, class UImage* Override, class UImage* base_add);
	void SetTextHP(class UTextBlock* TextMaxHP, class UTextBlock* TextCurrentHP);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	int32 GetBadStateNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHealthControl">();
	}
	static class UUIHealthControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHealthControl>();
	}
};
static_assert(alignof(UUIHealthControl) == 0x000008, "Wrong alignment on UUIHealthControl");
static_assert(sizeof(UUIHealthControl) == 0x0003E8, "Wrong size on UUIHealthControl");

// Class BattlePrototype.UIVitalityPLBase
// 0x0080 (0x0468 - 0x03E8)
class UUIVitalityPLBase : public UUIHealthControl
{
public:
	uint8                                         Pad_3E8[0x30];                                     // 0x03E8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterVitalityDataAsset*            WaveDesignerDataAsset;                             // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_420[0x30];                                     // 0x0420(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GaugeWidth_;                                       // 0x0450(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_454[0x4];                                      // 0x0454(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       GaugeMaterialInstDynamics_;                        // 0x0458(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CreateDynamicGaugeMaterial();
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UImage* ImageIcon1, class UImage* ImageIcon2, class UImage* ImageIcon3, class UImage* ImageIcon4, class UImage* ImageIcon5, class UImage* ImageBarNormal, class UImage* ImageBarOverride, class UImage* ImageBarAdd, class UTextBlock* TextPlayerName, class UTextBlock* _textMaxHP, class UTextBlock* _textCurrentHP);
	void InitializeThisParam(class UImage* ImageIcon1, class UImage* ImageIcon2, class UImage* ImageIcon3, class UImage* ImageIcon4, class UImage* ImageIcon5, class UTextBlock* TextPlayerName, class UTextBlock* _textMaxHP, class UTextBlock* _textCurrentHP);
	void SetName(EPlayerID CharaID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVitalityPLBase">();
	}
	static class UUIVitalityPLBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVitalityPLBase>();
	}
};
static_assert(alignof(UUIVitalityPLBase) == 0x000008, "Wrong alignment on UUIVitalityPLBase");
static_assert(sizeof(UUIVitalityPLBase) == 0x000468, "Wrong size on UUIVitalityPLBase");
static_assert(offsetof(UUIVitalityPLBase, WaveDesignerDataAsset) == 0x000418, "Member 'UUIVitalityPLBase::WaveDesignerDataAsset' has a wrong offset!");
static_assert(offsetof(UUIVitalityPLBase, GaugeWidth_) == 0x000450, "Member 'UUIVitalityPLBase::GaugeWidth_' has a wrong offset!");
static_assert(offsetof(UUIVitalityPLBase, GaugeMaterialInstDynamics_) == 0x000458, "Member 'UUIVitalityPLBase::GaugeMaterialInstDynamics_' has a wrong offset!");

// Class BattlePrototype.UIVitalityPL02
// 0x0000 (0x0468 - 0x0468)
class UUIVitalityPL02 : public UUIVitalityPLBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVitalityPL02">();
	}
	static class UUIVitalityPL02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVitalityPL02>();
	}
};
static_assert(alignof(UUIVitalityPL02) == 0x000008, "Wrong alignment on UUIVitalityPL02");
static_assert(sizeof(UUIVitalityPL02) == 0x000468, "Wrong size on UUIVitalityPL02");

// Class BattlePrototype.AssetLoadComponent
// 0x0020 (0x00E0 - 0x00C0)
class UAssetLoadComponent : public UActorComponent
{
public:
	class USoundAtomCueSheet*                     SoundCueSheet;                                     // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystem*>                ParticleList;                                      // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetLoadComponent">();
	}
	static class UAssetLoadComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetLoadComponent>();
	}
};
static_assert(alignof(UAssetLoadComponent) == 0x000008, "Wrong alignment on UAssetLoadComponent");
static_assert(sizeof(UAssetLoadComponent) == 0x0000E0, "Wrong size on UAssetLoadComponent");
static_assert(offsetof(UAssetLoadComponent, SoundCueSheet) == 0x0000C0, "Member 'UAssetLoadComponent::SoundCueSheet' has a wrong offset!");
static_assert(offsetof(UAssetLoadComponent, ParticleList) == 0x0000C8, "Member 'UAssetLoadComponent::ParticleList' has a wrong offset!");

// Class BattlePrototype.AssetMemoryData
// 0x0028 (0x0050 - 0x0028)
class UAssetMemoryData final : public UObject
{
public:
	class FName                                   ObjectPath;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AssetName;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AssetClass;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        PhysicalSize;                                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        VirtualSize;                                       // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetMemoryData">();
	}
	static class UAssetMemoryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetMemoryData>();
	}
};
static_assert(alignof(UAssetMemoryData) == 0x000008, "Wrong alignment on UAssetMemoryData");
static_assert(sizeof(UAssetMemoryData) == 0x000050, "Wrong size on UAssetMemoryData");
static_assert(offsetof(UAssetMemoryData, ObjectPath) == 0x000028, "Member 'UAssetMemoryData::ObjectPath' has a wrong offset!");
static_assert(offsetof(UAssetMemoryData, AssetName) == 0x000030, "Member 'UAssetMemoryData::AssetName' has a wrong offset!");
static_assert(offsetof(UAssetMemoryData, AssetClass) == 0x000038, "Member 'UAssetMemoryData::AssetClass' has a wrong offset!");
static_assert(offsetof(UAssetMemoryData, PhysicalSize) == 0x000040, "Member 'UAssetMemoryData::PhysicalSize' has a wrong offset!");
static_assert(offsetof(UAssetMemoryData, VirtualSize) == 0x000048, "Member 'UAssetMemoryData::VirtualSize' has a wrong offset!");

// Class BattlePrototype.PsychicObjectBasicC
// 0x00F0 (0x0320 - 0x0230)
class APsychicObjectBasicC : public AActor
{
public:
	uint8                                         Pad_230[0x18];                                     // 0x0230(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	BattlePrototype::EPsychicObjectID             PsychicObjectIdC;                                  // 0x0248(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         PMeshComp;                                         // 0x0250(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshComponent*                         PShadowComp;                                       // 0x0258(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCpuAccessC;                                       // 0x0260(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckCpuAccessC;                                  // 0x0261(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRegisterableC;                                    // 0x0262(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActiveC;                                          // 0x0263(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInUseC;                                           // 0x0264(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTickC;                                            // 0x0265(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_266[0x2];                                      // 0x0266(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           TickReferenceList;                                 // 0x0268(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMaterialParameterEnableC;                         // 0x0278(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSimulateControlEnableC;                           // 0x0279(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSimulateControlAwakeC;                            // 0x027A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSimulateControlCheckC;                            // 0x027B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSimulateControlCheckRenderC;                      // 0x027C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27D[0x3];                                      // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SimulateControlCheckRenderRadiusSqC;               // 0x0280(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSimulateControlApplyC;                            // 0x0284(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSimulateControlBackUpC;                           // 0x0285(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRenderC;                                          // 0x0286(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSwingTypeC;                                       // 0x0287(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBrainFieldObjectC;                                // 0x0288(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUniqueObjectC;                                    // 0x0289(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTownSettingC;                                     // 0x028A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBackupSettingC;                                   // 0x028B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBackupSimualteC;                                  // 0x028C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSearchableC;                                      // 0x028D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSkipCheckRenderedC;                               // 0x028E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFixSearchPosC;                                    // 0x028F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SearchPosC;                                        // 0x0290(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSearchHeightC;                                    // 0x029C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29D[0x3];                                      // 0x029D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchHeightMinC;                                  // 0x02A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SearchHeightMaxC;                                  // 0x02A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SearchRadiusC;                                     // 0x02A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SearchSizeValueC;                                  // 0x02AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SearchPointC;                                      // 0x02B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bArrangeResetEnableC;                              // 0x02B4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B5[0xB];                                      // 0x02B5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ArrangeActorTransformC;                            // 0x02C0(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             ArrangeMeshTransformC;                             // 0x02F0(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	bool CheckDestroyDistanceC(float ChkDist);
	bool CheckPsychicObjectStillInWorld(float KillZ);
	TArray<class UMeshComponent*> GetMaterialParameterMeshList();
	class UMeshComponent* GetPsychicObjectMesh();
	class UMeshComponent* GetPsychicObjectShadow();
	bool GetUniqueObjectAttackParameter(struct FHCCollisionCommonInfo* OutCommonInto, struct FHCSkillCommonInfo* OutSkillInfo);
	class UAnimMontage* GetUniqueObjectPlayerMontage(EPsychicObjectUniqueMontageIndex MontageIndex, bool bLeft, bool bMaleHero);
	void InitializeCpuAccess();
	bool IsAllowCpuAccess();
	void ResetArrangeTransformC();
	bool SetDistanceDestroyC();
	bool SetPsychicObjectFellOutOfWorld(const class UDamageType* PDmgType);
	void SetPsychicObjectIdC(BattlePrototype::EPsychicObjectID PsyObjId);
	void SetPsychicObjectMaterialParameterEnableC(bool Flag);
	void SetPsychicObjectRegisterableC(bool Flag);
	void SetPsychicObjectSearchable(bool Flag);
	void SetPsychicObjectSearchableC(bool Flag);
	void SetPsychicObjectSearchHeight(bool bFlag, float HeightMin, float HeightMix);
	void SetPsychicObjectSearchPos(bool bFlag, const struct FVector& Pos);
	void SetPsychicObjectSearchPosC(bool bFlag, const struct FVector& Pos);
	void SetPsychicObjectSearchSkipCheckRenderedC(bool Flag);
	void SetPsychicObjectSimulateControlAwakeC(bool Flag);
	void SetPsychicObjectSimulateControlCheckC(bool Flag);
	void SetPsychicObjectSimulateControlEnableC(bool Flag);
	void SetPsychicObjectSimulateControlRenderCheckParamC(bool Flag, float Radius);
	struct FHitResult SetSceneComponentLocationRotation(class USceneComponent* SceneComp, const struct FVector& Location, const struct FRotator& Rotation, bool bSweep);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsychicObjectBasicC">();
	}
	static class APsychicObjectBasicC* GetDefaultObj()
	{
		return GetDefaultObjImpl<APsychicObjectBasicC>();
	}
};
static_assert(alignof(APsychicObjectBasicC) == 0x000010, "Wrong alignment on APsychicObjectBasicC");
static_assert(sizeof(APsychicObjectBasicC) == 0x000320, "Wrong size on APsychicObjectBasicC");
static_assert(offsetof(APsychicObjectBasicC, PsychicObjectIdC) == 0x000248, "Member 'APsychicObjectBasicC::PsychicObjectIdC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, PMeshComp) == 0x000250, "Member 'APsychicObjectBasicC::PMeshComp' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, PShadowComp) == 0x000258, "Member 'APsychicObjectBasicC::PShadowComp' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bCpuAccessC) == 0x000260, "Member 'APsychicObjectBasicC::bCpuAccessC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bCheckCpuAccessC) == 0x000261, "Member 'APsychicObjectBasicC::bCheckCpuAccessC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bRegisterableC) == 0x000262, "Member 'APsychicObjectBasicC::bRegisterableC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bActiveC) == 0x000263, "Member 'APsychicObjectBasicC::bActiveC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bInUseC) == 0x000264, "Member 'APsychicObjectBasicC::bInUseC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bTickC) == 0x000265, "Member 'APsychicObjectBasicC::bTickC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, TickReferenceList) == 0x000268, "Member 'APsychicObjectBasicC::TickReferenceList' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bMaterialParameterEnableC) == 0x000278, "Member 'APsychicObjectBasicC::bMaterialParameterEnableC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSimulateControlEnableC) == 0x000279, "Member 'APsychicObjectBasicC::bSimulateControlEnableC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSimulateControlAwakeC) == 0x00027A, "Member 'APsychicObjectBasicC::bSimulateControlAwakeC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSimulateControlCheckC) == 0x00027B, "Member 'APsychicObjectBasicC::bSimulateControlCheckC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSimulateControlCheckRenderC) == 0x00027C, "Member 'APsychicObjectBasicC::bSimulateControlCheckRenderC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, SimulateControlCheckRenderRadiusSqC) == 0x000280, "Member 'APsychicObjectBasicC::SimulateControlCheckRenderRadiusSqC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSimulateControlApplyC) == 0x000284, "Member 'APsychicObjectBasicC::bSimulateControlApplyC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSimulateControlBackUpC) == 0x000285, "Member 'APsychicObjectBasicC::bSimulateControlBackUpC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bRenderC) == 0x000286, "Member 'APsychicObjectBasicC::bRenderC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSwingTypeC) == 0x000287, "Member 'APsychicObjectBasicC::bSwingTypeC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bBrainFieldObjectC) == 0x000288, "Member 'APsychicObjectBasicC::bBrainFieldObjectC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bUniqueObjectC) == 0x000289, "Member 'APsychicObjectBasicC::bUniqueObjectC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bTownSettingC) == 0x00028A, "Member 'APsychicObjectBasicC::bTownSettingC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bBackupSettingC) == 0x00028B, "Member 'APsychicObjectBasicC::bBackupSettingC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bBackupSimualteC) == 0x00028C, "Member 'APsychicObjectBasicC::bBackupSimualteC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSearchableC) == 0x00028D, "Member 'APsychicObjectBasicC::bSearchableC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSkipCheckRenderedC) == 0x00028E, "Member 'APsychicObjectBasicC::bSkipCheckRenderedC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bFixSearchPosC) == 0x00028F, "Member 'APsychicObjectBasicC::bFixSearchPosC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, SearchPosC) == 0x000290, "Member 'APsychicObjectBasicC::SearchPosC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSearchHeightC) == 0x00029C, "Member 'APsychicObjectBasicC::bSearchHeightC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, SearchHeightMinC) == 0x0002A0, "Member 'APsychicObjectBasicC::SearchHeightMinC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, SearchHeightMaxC) == 0x0002A4, "Member 'APsychicObjectBasicC::SearchHeightMaxC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, SearchRadiusC) == 0x0002A8, "Member 'APsychicObjectBasicC::SearchRadiusC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, SearchSizeValueC) == 0x0002AC, "Member 'APsychicObjectBasicC::SearchSizeValueC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, SearchPointC) == 0x0002B0, "Member 'APsychicObjectBasicC::SearchPointC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bArrangeResetEnableC) == 0x0002B4, "Member 'APsychicObjectBasicC::bArrangeResetEnableC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, ArrangeActorTransformC) == 0x0002C0, "Member 'APsychicObjectBasicC::ArrangeActorTransformC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, ArrangeMeshTransformC) == 0x0002F0, "Member 'APsychicObjectBasicC::ArrangeMeshTransformC' has a wrong offset!");

// Class BattlePrototype.AttachEffectBackgroundVolume
// 0x0028 (0x0290 - 0x0268)
class AAttachEffectBackgroundVolume final : public AVolume
{
public:
	TArray<class AEffectBackground*>              Particles;                                         // 0x0268(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Subtract;                                          // 0x0278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Unbound;                                           // 0x0279(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A[0x16];                                     // 0x027A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorBeginOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorEndOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttachEffectBackgroundVolume">();
	}
	static class AAttachEffectBackgroundVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAttachEffectBackgroundVolume>();
	}
};
static_assert(alignof(AAttachEffectBackgroundVolume) == 0x000008, "Wrong alignment on AAttachEffectBackgroundVolume");
static_assert(sizeof(AAttachEffectBackgroundVolume) == 0x000290, "Wrong size on AAttachEffectBackgroundVolume");
static_assert(offsetof(AAttachEffectBackgroundVolume, Particles) == 0x000268, "Member 'AAttachEffectBackgroundVolume::Particles' has a wrong offset!");
static_assert(offsetof(AAttachEffectBackgroundVolume, Subtract) == 0x000278, "Member 'AAttachEffectBackgroundVolume::Subtract' has a wrong offset!");
static_assert(offsetof(AAttachEffectBackgroundVolume, Unbound) == 0x000279, "Member 'AAttachEffectBackgroundVolume::Unbound' has a wrong offset!");

// Class BattlePrototype.PlayerShadeNoiseComponent
// 0x0040 (0x0100 - 0x00C0)
class UPlayerShadeNoiseComponent final : public UActorComponent
{
public:
	float                                         CharacterMovementSpeedUpScale;                     // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CharacterRotationSpeedUpScale;                     // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMeshComponent*                         TargetMesh;                                        // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       TargetMaterials;                                   // 0x00D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x20];                                      // 0x00E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FirstSetup(class UMeshComponent* InMesh, float InCharacterMovementSpeedUpScale, float InCharacterRotationSpeedUpScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerShadeNoiseComponent">();
	}
	static class UPlayerShadeNoiseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerShadeNoiseComponent>();
	}
};
static_assert(alignof(UPlayerShadeNoiseComponent) == 0x000008, "Wrong alignment on UPlayerShadeNoiseComponent");
static_assert(sizeof(UPlayerShadeNoiseComponent) == 0x000100, "Wrong size on UPlayerShadeNoiseComponent");
static_assert(offsetof(UPlayerShadeNoiseComponent, CharacterMovementSpeedUpScale) == 0x0000C0, "Member 'UPlayerShadeNoiseComponent::CharacterMovementSpeedUpScale' has a wrong offset!");
static_assert(offsetof(UPlayerShadeNoiseComponent, CharacterRotationSpeedUpScale) == 0x0000C4, "Member 'UPlayerShadeNoiseComponent::CharacterRotationSpeedUpScale' has a wrong offset!");
static_assert(offsetof(UPlayerShadeNoiseComponent, TargetMesh) == 0x0000C8, "Member 'UPlayerShadeNoiseComponent::TargetMesh' has a wrong offset!");
static_assert(offsetof(UPlayerShadeNoiseComponent, TargetMaterials) == 0x0000D0, "Member 'UPlayerShadeNoiseComponent::TargetMaterials' has a wrong offset!");

// Class BattlePrototype.AttackComponentBase
// 0x0030 (0x00F0 - 0x00C0)
class UAttackComponentBase : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerAnimControllerComponent*         _animCon;                                          // 0x00D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x18];                                      // 0x00D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAttackComponentBase* FindAttackComponentBySASVisionActor(class AActor* Actor, TSubclassOf<class AActor> ActorClass);
	static class UAttackComponentBase* FindAttackingComponent(class AActor* Actor);

	void AddComboCount();
	bool CheckStartAttack(float DeltaTime);
	bool ClearInput();
	void ClearInputAll();
	void DestroySASVisionActor();
	void DisappearSASVisionActor();
	bool InputButtonByCombo(bool bPressed, bool bComboFirst);
	bool IsAttackCombo();
	void OnChangeAnimKind(EPlayerAnimKind NewKind, EPlayerAnimKind OldKind);
	bool OnChangeAttacking(bool bAttacking);
	bool OnCustomAttackTimingNotified(const class FString& CustomName);
	bool OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	bool OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void SetAttacking(bool bAttacking, bool bAddComboCount);
	void SetAttackInputKind(ERSAttackInputKind Kind);
	void SpawnSASVisionActor(TSubclassOf<class AActor> ActorClass, class FName LocationTagName, bool bFollow);

	class UAttackInputComponent* GetAttackInputComponent() const;
	ERSAttackInputKind GetAttackInputKind() const;
	ERSAttackInputKind GetBranchComboAttackInputKind() const;
	int32 GetBranchComboCount() const;
	class UPlayerAnimControllerComponent* GetOwnerAnimCon() const;
	bool IsAttacking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackComponentBase">();
	}
	static class UAttackComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackComponentBase>();
	}
};
static_assert(alignof(UAttackComponentBase) == 0x000008, "Wrong alignment on UAttackComponentBase");
static_assert(sizeof(UAttackComponentBase) == 0x0000F0, "Wrong size on UAttackComponentBase");
static_assert(offsetof(UAttackComponentBase, _animCon) == 0x0000D0, "Member 'UAttackComponentBase::_animCon' has a wrong offset!");

// Class BattlePrototype.AttackInputComponent
// 0x2DE8 (0x2EA8 - 0x00C0)
class UAttackInputComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnComboInputEnd;                                   // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangePsychicComboLevel;                         // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeFlyingPsychicComboLevel;                   // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x2DA0];                                    // 0x00F0(0x2DA0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAttackComponentBase*>           _inputAttackComponentList;                         // 0x2E90(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EA0[0x8];                                     // 0x2EA0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddComboCount(ERSAttackInputKind Kind, ERSAttackInputKind branchKind, int32 branchComboCount);
	void AddComboPattern(class FName PatternName, ERSAttackInputKind InputKind, const TArray<class UAttackComponentBase*>& AttackComps, float ComboInterval, int32 MaxUseCount);
	void AddPsychicComboCount();
	void BeginComboInterval();
	void ChangeComboPattern(class FName PatternName);
	void CheckStartAttack(float DeltaTime);
	void ClearComboPattern(class FName PatternName);
	void ClearInputAll();
	void ClearPsychicComboCount();
	void ClearUseCount();
	void DebugSetComboDisp(bool bDisp);
	class UAttackComponentBase* FindAttackingComponent(ERSAttackInputKind Kind);
	TArray<class UAttackComponentBase*> GetInputAttackComponentList();
	int32 GetPsychicComboCount();
	int32 GetRemainUseCount(ERSAttackInputKind Kind);
	void InputAttackByPC(ERSAttackInputKind InputKind, bool bPressed);
	bool IsAttackedFlyingCombo();
	bool IsAttacking();
	bool IsAttackingByKind(ERSAttackInputKind Kind);
	bool IsCheckStartAttack(ERSAttackInputKind AttackKind);
	bool IsComboInterval(ERSAttackInputKind Kind, bool bCheckWaitFlag);
	bool IsDisableCombo(ERSAttackInputKind Kind);
	bool IsRegisterCombo(ERSAttackInputKind Kind);
	void OnAttackComponentChangeAttacking(class UAttackComponentBase* AttackComp, bool bAttacking);
	void OverwriteComboCount(int32 ComboCount);
	void RegisterCurrentAttackComponent(class UAttackComponentBase* AttackComp);
	void ResetCombo();
	void ResetComboByInputKind(ERSAttackInputKind Kind);
	void ResetFlyingCombo();
	void ResetPsychicComboLevel();
	void SetAttackedFlyingCombo();
	void SetComboAttackInputKind(ERSAttackInputKind Kind);
	void SetDisableCombo(ERSAttackInputKind Kind, bool bDisable);
	void SetFlyingPsychicComboLevel(int32 PsychicComboLevel);
	void SetPsychicComboLevel(int32 PsychicComboLevel);
	void UnregisterCurrentAttackComponent(class UAttackComponentBase* AttackComp);

	ERSAttackInputKind GetComboAttackInputKind() const;
	int32 GetComboCount() const;
	int32 GetComboCountByInputKind(ERSAttackInputKind Kind) const;
	class FName GetComboPattern() const;
	int32 GetFlyingPsychicComboLevel() const;
	int32 GetFlyingPsychicComboLevelMax() const;
	int32 GetPsychicComboLevel() const;
	int32 GetPsychicComboLevelMax() const;
	bool IsWaitPsychicCombo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackInputComponent">();
	}
	static class UAttackInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackInputComponent>();
	}
};
static_assert(alignof(UAttackInputComponent) == 0x000008, "Wrong alignment on UAttackInputComponent");
static_assert(sizeof(UAttackInputComponent) == 0x002EA8, "Wrong size on UAttackInputComponent");
static_assert(offsetof(UAttackInputComponent, OnComboInputEnd) == 0x0000C0, "Member 'UAttackInputComponent::OnComboInputEnd' has a wrong offset!");
static_assert(offsetof(UAttackInputComponent, OnChangePsychicComboLevel) == 0x0000D0, "Member 'UAttackInputComponent::OnChangePsychicComboLevel' has a wrong offset!");
static_assert(offsetof(UAttackInputComponent, OnChangeFlyingPsychicComboLevel) == 0x0000E0, "Member 'UAttackInputComponent::OnChangeFlyingPsychicComboLevel' has a wrong offset!");
static_assert(offsetof(UAttackInputComponent, _inputAttackComponentList) == 0x002E90, "Member 'UAttackInputComponent::_inputAttackComponentList' has a wrong offset!");

// Class BattlePrototype.AttackPropertyMediatorComponent
// 0x0050 (0x0110 - 0x00C0)
class UAttackPropertyMediatorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x50];                                      // 0x00C0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAttackPropertyMediatorComponent* FindAttackPropertyMediator(class AActor* Actor);
	static class UAttackPropertyMediatorComponent* GetAttackPropertyMediator(class AActor* Actor);

	void ClearAttackRate(const class FName& ClaimantName);
	void SetAttackRate(const class FName& ClaimantName, float AttackRate);

	float CalcTotalAttackRate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackPropertyMediatorComponent">();
	}
	static class UAttackPropertyMediatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackPropertyMediatorComponent>();
	}
};
static_assert(alignof(UAttackPropertyMediatorComponent) == 0x000008, "Wrong alignment on UAttackPropertyMediatorComponent");
static_assert(sizeof(UAttackPropertyMediatorComponent) == 0x000110, "Wrong size on UAttackPropertyMediatorComponent");

// Class BattlePrototype.LibraryEnemyDBAsset
// 0x0050 (0x0078 - 0x0028)
class ULibraryEnemyDBAsset final : public UObject
{
public:
	TMap<class FName, struct FLibraryEnemyDBCell> DBMap;                                             // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	void Convert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LibraryEnemyDBAsset">();
	}
	static class ULibraryEnemyDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULibraryEnemyDBAsset>();
	}
};
static_assert(alignof(ULibraryEnemyDBAsset) == 0x000008, "Wrong alignment on ULibraryEnemyDBAsset");
static_assert(sizeof(ULibraryEnemyDBAsset) == 0x000078, "Wrong size on ULibraryEnemyDBAsset");
static_assert(offsetof(ULibraryEnemyDBAsset, DBMap) == 0x000028, "Member 'ULibraryEnemyDBAsset::DBMap' has a wrong offset!");

// Class BattlePrototype.XGameStreamingManager
// 0x0018 (0x0050 - 0x0038)
class UXGameStreamingManager final : public URSTickableManagerBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URSGameInstance*                        _gameInstance;                                     // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEventPauseFlag(bool Flag);
	void SetFixedLayout(ETouchControlLayout Layout, float Sec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"XGameStreamingManager">();
	}
	static class UXGameStreamingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UXGameStreamingManager>();
	}
};
static_assert(alignof(UXGameStreamingManager) == 0x000008, "Wrong alignment on UXGameStreamingManager");
static_assert(sizeof(UXGameStreamingManager) == 0x000050, "Wrong size on UXGameStreamingManager");
static_assert(offsetof(UXGameStreamingManager, _gameInstance) == 0x000040, "Member 'UXGameStreamingManager::_gameInstance' has a wrong offset!");

// Class BattlePrototype.AutoAimComponent
// 0x0070 (0x0130 - 0x00C0)
class UAutoAimComponent final : public UActorComponent
{
public:
	float                                         _aimSpeed;                                         // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimSpeedInternalLock;                             // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxAimAngle;                                      // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInternalLock;                                   // 0x00CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isToCamera;                                       // 0x00CD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isToBrainCrash;                                   // 0x00CE(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CF[0x1];                                       // 0x00CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _offsetDegree;                                     // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDirectionOfRotation                          _directionOfRotation;                              // 0x00D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _frontDegree;                                      // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isToWeakPoint;                                    // 0x00DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DD[0x53];                                      // 0x00DD(0x0053)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAutoAimComponent* GetAutoAimComponentFromActor(class AActor* Actor);

	void BeginAutoAim(class UObject* Notify, float AimSpeed, float MaxAimAngle, bool IsInternalLock, bool IsToCamera, class AActor* brainCrashActor, class UMeshComponent* SocketRotateMesh, class FName SocketName, float OffsetDegree, EDirectionOfRotation DirectionOfRotation, float FrontDegree, float AimSpeedInternalLock, bool FindAimTargetWhenNoTarget, bool IsDetectTargetChange, bool IsToWeakPoint);
	void BeginAutoAimLocation(class UObject* Notify, float AimSpeed, float MaxAimAngle, const struct FVector& AimLocation, class UMeshComponent* SocketRotateMesh, class FName SocketName, float OffsetDegree, EDirectionOfRotation DirectionOfRotation, float FrontDegree);
	void EndAutoAim(class UObject* Notify);
	void LockLocation(bool bLock, const struct FVector& LockLocation_0);
	void PauseAutoAim(bool bPause);
	float UpdateFromDirectionOfRotation(float Rot, float Sign);
	void UpdateRotateAim(float DeltaSeconds);

	bool IsBindOwnerTick() const;
	bool IsLockLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoAimComponent">();
	}
	static class UAutoAimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoAimComponent>();
	}
};
static_assert(alignof(UAutoAimComponent) == 0x000008, "Wrong alignment on UAutoAimComponent");
static_assert(sizeof(UAutoAimComponent) == 0x000130, "Wrong size on UAutoAimComponent");
static_assert(offsetof(UAutoAimComponent, _aimSpeed) == 0x0000C0, "Member 'UAutoAimComponent::_aimSpeed' has a wrong offset!");
static_assert(offsetof(UAutoAimComponent, _aimSpeedInternalLock) == 0x0000C4, "Member 'UAutoAimComponent::_aimSpeedInternalLock' has a wrong offset!");
static_assert(offsetof(UAutoAimComponent, _maxAimAngle) == 0x0000C8, "Member 'UAutoAimComponent::_maxAimAngle' has a wrong offset!");
static_assert(offsetof(UAutoAimComponent, _isInternalLock) == 0x0000CC, "Member 'UAutoAimComponent::_isInternalLock' has a wrong offset!");
static_assert(offsetof(UAutoAimComponent, _isToCamera) == 0x0000CD, "Member 'UAutoAimComponent::_isToCamera' has a wrong offset!");
static_assert(offsetof(UAutoAimComponent, _isToBrainCrash) == 0x0000CE, "Member 'UAutoAimComponent::_isToBrainCrash' has a wrong offset!");
static_assert(offsetof(UAutoAimComponent, _offsetDegree) == 0x0000D0, "Member 'UAutoAimComponent::_offsetDegree' has a wrong offset!");
static_assert(offsetof(UAutoAimComponent, _directionOfRotation) == 0x0000D4, "Member 'UAutoAimComponent::_directionOfRotation' has a wrong offset!");
static_assert(offsetof(UAutoAimComponent, _frontDegree) == 0x0000D8, "Member 'UAutoAimComponent::_frontDegree' has a wrong offset!");
static_assert(offsetof(UAutoAimComponent, _isToWeakPoint) == 0x0000DC, "Member 'UAutoAimComponent::_isToWeakPoint' has a wrong offset!");

// Class BattlePrototype.HitCheckReceiverComponent
// 0x0030 (0x00F0 - 0x00C0)
class UHitCheckReceiverComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             DispatchHitAttack;                                 // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchHitDirectAttack;                           // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchHitDamage;                                 // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UHitCheckReceiverComponent* GetHitCheckReceiverComponentFromActor(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitCheckReceiverComponent">();
	}
	static class UHitCheckReceiverComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitCheckReceiverComponent>();
	}
};
static_assert(alignof(UHitCheckReceiverComponent) == 0x000008, "Wrong alignment on UHitCheckReceiverComponent");
static_assert(sizeof(UHitCheckReceiverComponent) == 0x0000F0, "Wrong size on UHitCheckReceiverComponent");
static_assert(offsetof(UHitCheckReceiverComponent, DispatchHitAttack) == 0x0000C0, "Member 'UHitCheckReceiverComponent::DispatchHitAttack' has a wrong offset!");
static_assert(offsetof(UHitCheckReceiverComponent, DispatchHitDirectAttack) == 0x0000D0, "Member 'UHitCheckReceiverComponent::DispatchHitDirectAttack' has a wrong offset!");
static_assert(offsetof(UHitCheckReceiverComponent, DispatchHitDamage) == 0x0000E0, "Member 'UHitCheckReceiverComponent::DispatchHitDamage' has a wrong offset!");

// Class BattlePrototype.AutoRecoverComponent
// 0x0018 (0x00D8 - 0x00C0)
class UAutoRecoverComponent final : public UActorComponent
{
public:
	float                                         _HPRecoverStartSec;                                // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _HPRecoverSpeed;                                   // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _autoRecoverHPFraction;                            // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _PPRecoverStartSec;                                // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _autoRecoverFullPPSec;                             // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _autoRecoverPPFraction;                            // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ProcessAutoRecoverHP(float DelataTime, bool EnableRecover);
	void ProcessAutoRecoverPP(float DelataTime, bool EnableRecover);
	void Setup(float HpRecoverSpeed, float HpRecoverStartSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoRecoverComponent">();
	}
	static class UAutoRecoverComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoRecoverComponent>();
	}
};
static_assert(alignof(UAutoRecoverComponent) == 0x000008, "Wrong alignment on UAutoRecoverComponent");
static_assert(sizeof(UAutoRecoverComponent) == 0x0000D8, "Wrong size on UAutoRecoverComponent");
static_assert(offsetof(UAutoRecoverComponent, _HPRecoverStartSec) == 0x0000C0, "Member 'UAutoRecoverComponent::_HPRecoverStartSec' has a wrong offset!");
static_assert(offsetof(UAutoRecoverComponent, _HPRecoverSpeed) == 0x0000C4, "Member 'UAutoRecoverComponent::_HPRecoverSpeed' has a wrong offset!");
static_assert(offsetof(UAutoRecoverComponent, _autoRecoverHPFraction) == 0x0000C8, "Member 'UAutoRecoverComponent::_autoRecoverHPFraction' has a wrong offset!");
static_assert(offsetof(UAutoRecoverComponent, _PPRecoverStartSec) == 0x0000CC, "Member 'UAutoRecoverComponent::_PPRecoverStartSec' has a wrong offset!");
static_assert(offsetof(UAutoRecoverComponent, _autoRecoverFullPPSec) == 0x0000D0, "Member 'UAutoRecoverComponent::_autoRecoverFullPPSec' has a wrong offset!");
static_assert(offsetof(UAutoRecoverComponent, _autoRecoverPPFraction) == 0x0000D4, "Member 'UAutoRecoverComponent::_autoRecoverPPFraction' has a wrong offset!");

// Class BattlePrototype.WakeUpEventForPostureBase
// 0x0050 (0x0280 - 0x0230)
class AWakeUpEventForPostureBase final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsDoBeginPlay;                                     // 0x0238(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          EventBoxComponent;                                 // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ScenarioFlagRowName;                               // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInnerRange;                                      // 0x0250(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EventStartWaitTime;                                // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Direction;                                         // 0x0258(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DirectionAcceptRange;                              // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveAcceptRange;                                   // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ConditionEnableElapsedTime;                        // 0x026C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool DoEvent();
	void Setup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WakeUpEventForPostureBase">();
	}
	static class AWakeUpEventForPostureBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWakeUpEventForPostureBase>();
	}
};
static_assert(alignof(AWakeUpEventForPostureBase) == 0x000008, "Wrong alignment on AWakeUpEventForPostureBase");
static_assert(sizeof(AWakeUpEventForPostureBase) == 0x000280, "Wrong size on AWakeUpEventForPostureBase");
static_assert(offsetof(AWakeUpEventForPostureBase, IsDoBeginPlay) == 0x000238, "Member 'AWakeUpEventForPostureBase::IsDoBeginPlay' has a wrong offset!");
static_assert(offsetof(AWakeUpEventForPostureBase, EventBoxComponent) == 0x000240, "Member 'AWakeUpEventForPostureBase::EventBoxComponent' has a wrong offset!");
static_assert(offsetof(AWakeUpEventForPostureBase, ScenarioFlagRowName) == 0x000248, "Member 'AWakeUpEventForPostureBase::ScenarioFlagRowName' has a wrong offset!");
static_assert(offsetof(AWakeUpEventForPostureBase, IsInnerRange) == 0x000250, "Member 'AWakeUpEventForPostureBase::IsInnerRange' has a wrong offset!");
static_assert(offsetof(AWakeUpEventForPostureBase, EventStartWaitTime) == 0x000254, "Member 'AWakeUpEventForPostureBase::EventStartWaitTime' has a wrong offset!");
static_assert(offsetof(AWakeUpEventForPostureBase, Direction) == 0x000258, "Member 'AWakeUpEventForPostureBase::Direction' has a wrong offset!");
static_assert(offsetof(AWakeUpEventForPostureBase, DirectionAcceptRange) == 0x000264, "Member 'AWakeUpEventForPostureBase::DirectionAcceptRange' has a wrong offset!");
static_assert(offsetof(AWakeUpEventForPostureBase, MoveAcceptRange) == 0x000268, "Member 'AWakeUpEventForPostureBase::MoveAcceptRange' has a wrong offset!");
static_assert(offsetof(AWakeUpEventForPostureBase, ConditionEnableElapsedTime) == 0x00026C, "Member 'AWakeUpEventForPostureBase::ConditionEnableElapsedTime' has a wrong offset!");

// Class BattlePrototype.BattleCharacterDebugInterface
// 0x0000 (0x0028 - 0x0028)
class IBattleCharacterDebugInterface final : public IInterface
{
public:
	bool IsDebugInvincible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCharacterDebugInterface">();
	}
	static class IBattleCharacterDebugInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBattleCharacterDebugInterface>();
	}
};
static_assert(alignof(IBattleCharacterDebugInterface) == 0x000008, "Wrong alignment on IBattleCharacterDebugInterface");
static_assert(sizeof(IBattleCharacterDebugInterface) == 0x000028, "Wrong size on IBattleCharacterDebugInterface");

// Class BattlePrototype.BattleCharacterHudInterface
// 0x0000 (0x0028 - 0x0028)
class IBattleCharacterHudInterface final : public IInterface
{
public:
	bool BrainCrashUnlock();
	int32 GetWeakNumber();
	bool SetEmphasisCrashGauge(bool bEmphasisCrashGauge);

	void GetCrashChanceCursorPoint(struct FVector* Point) const;
	void GetHpGaugePoint(struct FVector* Point) const;
	void GetTargetCursorPoint(struct FVector* Point) const;
	bool IsEmphasisCrashGauge() const;
	void IsHpGaugeAlwaysMax(bool* bAlwaysMax) const;
	void IsInvisibleHPGauge(bool* bInvisible) const;
	bool IsInvisibleMiniMap() const;
	void IsSpawnWait(bool* bSpawnWait) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCharacterHudInterface">();
	}
	static class IBattleCharacterHudInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBattleCharacterHudInterface>();
	}
};
static_assert(alignof(IBattleCharacterHudInterface) == 0x000008, "Wrong alignment on IBattleCharacterHudInterface");
static_assert(sizeof(IBattleCharacterHudInterface) == 0x000028, "Wrong size on IBattleCharacterHudInterface");

// Class BattlePrototype.NpcTownPeopleBase
// 0x00B0 (0x03A0 - 0x02F0)
class ANpcTownPeopleBase : public ANpcSkeletalMeshActor
{
public:
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAnimInstance>              AnimClass;                                         // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENpcAnimationKind                             FirstAnimationKind;                                // 0x0300(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLookAtPlayer;                                    // 0x0301(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_302[0x6];                                      // 0x0302(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             IconOffsetDataTable;                               // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNpcIconOffsetInfo>             IconOffsetDataInfos;                               // 0x0310(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCullingMode;                                     // 0x0320(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseTick;                                         // 0x0321(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_322[0x42];                                     // 0x0322(0x0042)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class URSNpcAnimInstance>      AnimationBP;                                       // 0x0364(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36C[0x34];                                     // 0x036C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckCulling();
	float GetHeadHeight();
	void SetCulling(bool Culling);
	void SetLookAtPlayer(bool IsLookAt);
	void SetupGround();

	class UActorComponent* GetLookAtComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcTownPeopleBase">();
	}
	static class ANpcTownPeopleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcTownPeopleBase>();
	}
};
static_assert(alignof(ANpcTownPeopleBase) == 0x000010, "Wrong alignment on ANpcTownPeopleBase");
static_assert(sizeof(ANpcTownPeopleBase) == 0x0003A0, "Wrong size on ANpcTownPeopleBase");
static_assert(offsetof(ANpcTownPeopleBase, AnimClass) == 0x0002F8, "Member 'ANpcTownPeopleBase::AnimClass' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleBase, FirstAnimationKind) == 0x000300, "Member 'ANpcTownPeopleBase::FirstAnimationKind' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleBase, IsLookAtPlayer) == 0x000301, "Member 'ANpcTownPeopleBase::IsLookAtPlayer' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleBase, IconOffsetDataTable) == 0x000308, "Member 'ANpcTownPeopleBase::IconOffsetDataTable' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleBase, IconOffsetDataInfos) == 0x000310, "Member 'ANpcTownPeopleBase::IconOffsetDataInfos' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleBase, IsCullingMode) == 0x000320, "Member 'ANpcTownPeopleBase::IsCullingMode' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleBase, IsUseTick) == 0x000321, "Member 'ANpcTownPeopleBase::IsUseTick' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleBase, AnimationBP) == 0x000364, "Member 'ANpcTownPeopleBase::AnimationBP' has a wrong offset!");

// Class BattlePrototype.NpcTownPeopleMob
// 0x0000 (0x03A0 - 0x03A0)
class ANpcTownPeopleMob : public ANpcTownPeopleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcTownPeopleMob">();
	}
	static class ANpcTownPeopleMob* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcTownPeopleMob>();
	}
};
static_assert(alignof(ANpcTownPeopleMob) == 0x000010, "Wrong alignment on ANpcTownPeopleMob");
static_assert(sizeof(ANpcTownPeopleMob) == 0x0003A0, "Wrong size on ANpcTownPeopleMob");

// Class BattlePrototype.BattleCharacterInterface
// 0x0000 (0x0028 - 0x0028)
class IBattleCharacterInterface final : public IInterface
{
public:
	bool AddScarFromHitDamageInfoInterface(class AActor* Actor, const struct FHitDamageInfo& HitDamageInfo);
	float CalcUniqueDamage(const struct FHCHitResult& HitResult, float BaseDamage);
	bool CheckEmphasisCrashGauge(const struct FHCHitResult& HitResult);
	void DisEnableNoDeadTutorial();
	void EndNoDeadNoCrashChanceEvent();
	bool EventStartForceEndBadStatus();
	struct FVector GetAutoAimTargetLocation();
	void GetCameraStabilizeParameter(float* DistLockHz, float* DistRestoreHz, float* DistLockVt, float* DistRestoreVt);
	ECharacterHitPriority GetCharacterHitPriorityInterface();
	struct FVector GetDamageReactionDirInterface(const struct FHCHitResult& HitResult);
	struct FVector GetLookAtTargetLocation();
	bool IsCounterWaitInterface();
	bool IsDisableAtomCuePlayInterface();
	bool IsEnableSlashEffectInterface(const struct FHCHitResult& HitResult);
	bool IsHitWeakChangeDefaultEffectInterface();
	bool IsSuperArmorInterface();
	bool RestartBehaviorTree(bool bTickEnable);
	bool SetActorAllTickEnabled(bool bEnabled);
	bool SetBehaviorTreeTickEnable(bool bEnable);
	bool SetCounterInterface();
	bool SetHiddenCharacterAttachment(bool NewHidden);
	void SetInfinityCrashChance(bool bEnable);
	void SetInvalidDamageInterface(bool bInvalidDamage, class FName ClaimantName, int32 Param);
	void SetNoCrashChanceByUseGuts(bool bEnable);
	void SetNoCrashChanceEvent(bool NoCrashChanceEvent);
	void SetNoDeadEvent(bool NoDeadEvent);
	void SetUseGuts(bool bUse);
	bool ShakeCameraInDamageInterface(const struct FHCHitResult& HitResult);
	bool StopBehaviorTree(bool bTickDisable);
	bool VibrationControllerInDamageInterface(const struct FHCHitResult& HitResult);

	EAssassinAttackHit GetAssasinAttackHitType() const;
	int32 GetCharaKind() const;
	struct FVector GetWeakTargetPointInterface(const struct FVector& AttackerPos) const;
	bool IsAbsoluteVisibilityTrace() const;
	bool IsAttackerTargetSelf(const struct FHCHitResult& HitResult) const;
	bool IsAttractSelfInterface() const;
	bool IsCrashMaxWithGuts() const;
	bool IsDeadBrainCrashOnly() const;
	bool IsDeadChaseAttackOnly() const;
	bool IsDeadLaunchAttackOnly() const;
	bool IsDeadPhysicsAttackOnly() const;
	bool IsDeadPsychicObjComboOnly() const;
	bool IsDeadPsychicObjOnly() const;
	bool IsEnableReactionCoefficientInterface(float* OutReactionSRate, float* OutReactionLRate, float* OutDownRate, float* OutCrashRate) const;
	bool IsEventCondition() const;
	bool IsInfinityCrashChance() const;
	bool IsNoCrashChanceByUseGuts() const;
	bool IsNoCrashChanceEvent() const;
	bool IsNoDeadEvent() const;
	bool IsNoDeadTutorial() const;
	bool IsNotAbleBrainCrashTarget() const;
	bool IsUniqueNoDead() const;
	bool IsUseGuts() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCharacterInterface">();
	}
	static class IBattleCharacterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBattleCharacterInterface>();
	}
};
static_assert(alignof(IBattleCharacterInterface) == 0x000008, "Wrong alignment on IBattleCharacterInterface");
static_assert(sizeof(IBattleCharacterInterface) == 0x000028, "Wrong size on IBattleCharacterInterface");

// Class BattlePrototype.PreventDamageMotionComponent
// 0x0028 (0x00E8 - 0x00C0)
class UPreventDamageMotionComponent final : public UActorComponent
{
public:
	int32                                         _maxGuardValue;                                    // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _guardRecoverStartSec;                             // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _recoverGuardPerSec;                               // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _guardBreakMinSec;                                 // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _guardBreakMaxSec;                                 // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _guardValue;                                       // 0x00D4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _guardReduceCount;                                 // 0x00D8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _guardBreakCount;                                  // 0x00DC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _guardBreakStartTime;                              // 0x00E0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReduceGuard(int32 ReducedValue);
	void ResetGuardValue();

	float GetGuardValue() const;
	bool IsGuardBreak() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreventDamageMotionComponent">();
	}
	static class UPreventDamageMotionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPreventDamageMotionComponent>();
	}
};
static_assert(alignof(UPreventDamageMotionComponent) == 0x000008, "Wrong alignment on UPreventDamageMotionComponent");
static_assert(sizeof(UPreventDamageMotionComponent) == 0x0000E8, "Wrong size on UPreventDamageMotionComponent");
static_assert(offsetof(UPreventDamageMotionComponent, _maxGuardValue) == 0x0000C0, "Member 'UPreventDamageMotionComponent::_maxGuardValue' has a wrong offset!");
static_assert(offsetof(UPreventDamageMotionComponent, _guardRecoverStartSec) == 0x0000C4, "Member 'UPreventDamageMotionComponent::_guardRecoverStartSec' has a wrong offset!");
static_assert(offsetof(UPreventDamageMotionComponent, _recoverGuardPerSec) == 0x0000C8, "Member 'UPreventDamageMotionComponent::_recoverGuardPerSec' has a wrong offset!");
static_assert(offsetof(UPreventDamageMotionComponent, _guardBreakMinSec) == 0x0000CC, "Member 'UPreventDamageMotionComponent::_guardBreakMinSec' has a wrong offset!");
static_assert(offsetof(UPreventDamageMotionComponent, _guardBreakMaxSec) == 0x0000D0, "Member 'UPreventDamageMotionComponent::_guardBreakMaxSec' has a wrong offset!");
static_assert(offsetof(UPreventDamageMotionComponent, _guardValue) == 0x0000D4, "Member 'UPreventDamageMotionComponent::_guardValue' has a wrong offset!");
static_assert(offsetof(UPreventDamageMotionComponent, _guardReduceCount) == 0x0000D8, "Member 'UPreventDamageMotionComponent::_guardReduceCount' has a wrong offset!");
static_assert(offsetof(UPreventDamageMotionComponent, _guardBreakCount) == 0x0000DC, "Member 'UPreventDamageMotionComponent::_guardBreakCount' has a wrong offset!");
static_assert(offsetof(UPreventDamageMotionComponent, _guardBreakStartTime) == 0x0000E0, "Member 'UPreventDamageMotionComponent::_guardBreakStartTime' has a wrong offset!");

// Class BattlePrototype.BattleEnemyInterface
// 0x0000 (0x0028 - 0x0028)
class IBattleEnemyInterface final : public IInterface
{
public:
	bool BrainCrashLock_Native();
	bool CallDead_Native();
	bool CallFuncDamageDownEnd_Native();
	bool CallFuncDamageDownLoop_Native();
	bool CallFuncDamageDownStart_Native();
	bool CameraAttentionEnd_Native(class UCurveFloat* FovCurveOut);
	bool CheckNpcDrive_Native(ENpcDriveCheckType CheckType, class AActor* EnemyActor);
	bool CheckSASHologramAttack_Native(ESASHologramAttackTiming Timing, class ARSCharacterBase* RequestCharacter);
	bool DamageFloatEnd_Native();
	bool DamageMotionEnd_Native(float DeltaTime);
	bool DeadStart_Native();
	bool DisableFitGroundTmp_Native();
	bool DropFlyingEnemy_Native(class AActor* Enemy);
	bool EnableAllWeak_Native(bool bEnable);
	bool EnableFitGroundTmp_Native();
	bool EndDamageFloating_Native();
	bool EnemyEndEvDitherNative(bool bDisp);
	bool EnemyStartEvDitherNative(bool bDisp, float DitherTime);
	bool EnemyUpdateEvDitherNative(float DeltaSec);
	bool EntryBrainCrashAccess_Native(class ARSCharacterBase* Character);
	void FlyDown_Native(bool* IsEnd);
	void GetCurrentActionTime_Native(float* ActionTime);
	EEnemyTribe GetEnemyTribe();
	bool GetFailedFall_Native();
	bool GetFall_Native();
	void GetHitObjectType_Native(TArray<EObjectTypeQuery>* ObjectType);
	void GetLostData_Native(float* LostMoveTimeMin, float* LostMoveTimeMax, float* LostMoveRotationRate, float* SpeedScale, bool* IsNoMoveAnim);
	class USearchingComponent* GetSearchingComponent_Native();
	void IsBrainCrashMiss_Native(bool* IsMiss);
	bool IsCheckLookScrollTick(const struct FVector& Start, const struct FVector& End);
	bool IsCheckSameCompareGroundLoaction();
	bool IsEnemyDamageDown_CallFromCPP();
	void IsEnemyLandingCheck_Native(bool* bHit);
	bool IsEnemyStateAttack_CallFromCPP();
	bool IsFlyEnemyCheck_Native();
	void IsIgnoreLandingCheck_Native(bool* bIgnoreLandingCheck);
	void IsMotionEnd_Native(bool* ReturnValue);
	bool IsPossibleTargetAttack_CallFromCPP(class AActor* Actor);
	bool KickCrashChanceLoopEffect_Native();
	void LaunchDown_Native(bool* IsEnd);
	bool LeaveBrainCrashAccess_Native(class ARSCharacterBase* Character);
	void OnEndAnimDieIF(bool* bDummy);
	bool OnEndCrashChance_Native();
	bool OutputLogCrashChanceEnd_Native();
	void ReceivedNotifyAnimEnd_Native(bool* Received);
	bool ResetAction_Native();
	bool ResetCore_Native(class AActor* Enemy, bool RemoveCore);
	bool ResetStateReceivedExecuteAi_Native();
	bool RestoreWeakEmissive_Native(const class FString& WeakSlotName);
	bool RestoreWeakState_Native();
	bool SafeDestroy_Native(class AActor* Actor);
	bool SetDamageCollisionDisable_Native(const class FName& ClaimantName);
	bool SetDownTimer_Native(float NewTime);
	bool SetEnemyConsiderDownDead(bool bEnable);
	bool SetHp_Native(int32 HP);
	bool SetIdleMove_Native(bool IsIdle);
	bool SetIsBrainAccess_Native(bool NewIsBrainAccess);
	bool SetIsLandCheck_Native(bool NewIsLandCheck);
	bool SetIsLaunchDown_Native(bool NewIsLaunchDown);
	bool SetIsMoveAnim_Native(bool NewIsMoveAnim);
	bool SetLanding_Native(bool bLanding);
	bool SetReserveAction_Native(uint8 Action, float Param00, float Param01);
	bool SetTickEnableMeshOnly(bool bMeshOnly);
	bool SetUseWaitNoInterpolation_Native(bool Use);
	bool SetWeakEmissiveOff_Native(const class FString& WeakSlotName);
	bool StartDamageFloating_Native();
	void StartFallIfFlyingIF(bool* bDummy);
	bool StartReactionDilation_CallFromCPP(uint8 ReactionKind, bool bAddDamage);
	bool StartVanish_Native(float VanishSec, float StartVanish, float EndVanish);
	bool StopCrashChanceLoopEffect_Native();
	bool StoreWeakState_Native();
	bool SwitchDispCore_Native(bool DisplayOn);
	void UpdateDamageAnim_Native(bool* DamageEnd, bool* DamageDownEnd);
	bool UpdateFall_Native();
	bool UpdateMoveMaxSpeed();
	void UpdateOutRangeFade_Native(float ToTargetLenge, bool ForceDisp);

	class UCapsuleComponent* GetCapsuleComponent_Native() const;
	class AActor* GetCurrentTarget() const;
	struct FVector GetDamageHitDirectionIF() const;
	bool GetDebugEnemyDownInfinity_Native() const;
	float GetDownTimer_Native() const;
	EnemyMoveAnimKind GetDownUpMoveAnimKind_Native() const;
	class UEnemyAiComponentBase* GetEnemyAiComponent() const;
	class UEnemyAnimControllerComponent* GetEnemyAnimControllerComponent() const;
	class UEnemyScriptComponent* GetEnemyScriptComponent() const;
	class UHateTargetComponent* GetHateTarget_Native() const;
	bool GetIsJumpEnd() const;
	bool GetIsLandCheck() const;
	void GetLostActionInfoList_Native(TArray<struct FEmLostActionInfo>* LostActionInfo) const;
	bool GetNewDamageFloating_Native() const;
	bool GetPressDownLoop_Native() const;
	class AActor* GetTargetCharacter_Native() const;
	struct FVector GetTopHeightLocation() const;
	float GetUniqueTickEnableRange() const;
	bool IsBossEnemy_CallFromCPP() const;
	bool IsBrainSuccess_Native() const;
	bool IsCheckHeightChangeTick() const;
	bool IsCheckLookTargetTick(const struct FVector& Start, const struct FVector& End) const;
	bool IsDamageMotionEnd_Native() const;
	bool IsDisableDownMotionInterface() const;
	bool IsDisableUroAction_Interface() const;
	bool IsEnemyConsiderDownDead() const;
	bool IsEnemyFalling_Interface() const;
	bool IsEnemySpawn_Interface() const;
	bool IsExecLowProcess() const;
	bool IsInvincible_Native() const;
	bool IsLaunchDown_Native() const;
	bool IsNotFindPlayer_CallFromCPP() const;
	bool IsPressDown_Native() const;
	bool IsReflectContainer() const;
	bool IsSpawned() const;
	bool IsSuspendFollowAttackInterface() const;
	bool IsTickDisableCondition() const;
	bool IsUniqueAroundEffectPause() const;
	bool IsUpdateEnemySpawn() const;
	bool IsUpdateEnemyTickEnable() const;
	bool IsWeakUiDamageHit_CallFromCPP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleEnemyInterface">();
	}
	static class IBattleEnemyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBattleEnemyInterface>();
	}
};
static_assert(alignof(IBattleEnemyInterface) == 0x000008, "Wrong alignment on IBattleEnemyInterface");
static_assert(sizeof(IBattleEnemyInterface) == 0x000028, "Wrong size on IBattleEnemyInterface");

// Class BattlePrototype.IntroTutorialManager
// 0x0050 (0x0280 - 0x0230)
class AIntroTutorialManager : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnSuccessInput;                                    // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_240[0x20];                                     // 0x0240(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USoundAtomCue*>                  SEArray;                                           // 0x0260(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BeginIntroTutorial();
	void DisplaySuccess();
	void EndDispCurrentMiniTips(bool ForceStop);
	void EndDispMiniTips(EHelpTutorial TutorialID, bool ForceStop);
	bool EndIntroTutorial();
	bool EndTutorial();
	void OnTutorialSuccess_Attack();
	void OnTutorialSuccess_ChangeLockon();
	void OnTutorialSuccess_Dash();
	void OnTutorialSuccess_Dodge();
	void OnTutorialSuccess_Jump();
	void OnTutorialSuccess_LaunchAttack();
	void OnTutorialSuccess_Lockon();
	void OnTutorialSuccess_Psychic();
	void OnTutorialSuccess_PsychicCombo();
	void OnTutorialSuccess_SpecialAttack();
	void OnTutorialSuccess_StepInAttack();
	bool RemoveEnemysNoDead(int32 GroupID, int32 SubGroupID);
	bool RestrictPlayerAttack(bool IsOn);
	bool RestrictPlayerLaunchAttack(bool IsOn);
	bool RestrictPlayerPsychic(bool IsOn);
	bool RestrictPlayerSpecialAttack(bool IsOn);
	bool SetTutrialPKGaugeRecovery(bool IsOn);
	void StartDispMiniTips(EHelpTutorial TutorialID, class FName GuideID, float MinDispTime);
	bool StartTutorial(EIntroTutorialType Type);
	void StopDispMiniTipsAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IntroTutorialManager">();
	}
	static class AIntroTutorialManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIntroTutorialManager>();
	}
};
static_assert(alignof(AIntroTutorialManager) == 0x000008, "Wrong alignment on AIntroTutorialManager");
static_assert(sizeof(AIntroTutorialManager) == 0x000280, "Wrong size on AIntroTutorialManager");
static_assert(offsetof(AIntroTutorialManager, OnSuccessInput) == 0x000230, "Member 'AIntroTutorialManager::OnSuccessInput' has a wrong offset!");
static_assert(offsetof(AIntroTutorialManager, SEArray) == 0x000260, "Member 'AIntroTutorialManager::SEArray' has a wrong offset!");

// Class BattlePrototype.BattleManager
// 0x00D0 (0x0300 - 0x0230)
class ABattleManager : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARSCharacterBase*>               _battleActorList;                                  // 0x0238(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _ForceBattleList;                                  // 0x0250(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BATTLEFIELD_SPEEDRUN_TIME;                         // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BATTLEFIELD_HORDE_ENEMY_NUM;                       // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActorBattleEndLogData>         _BattleLogDataList;                                // 0x0270(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         OneFrameHitEffectMax;                              // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitEffectPoolNum_Other;                            // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitEffectPoolNum_Npc;                              // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitEffectPoolNum_Enemy;                            // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitEffectPoolNum_PlayerDamage;                     // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitEffectPoolNum_Player;                           // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitEffectPoolNum_Special;                          // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPoolHitEffectData>             _HitEffectPool_Other;                              // 0x02A0(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPoolHitEffectData>             _HitEffectPool_Npc;                                // 0x02B0(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPoolHitEffectData>             _HitEffectPool_Enemy;                              // 0x02C0(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPoolHitEffectData>             _HitEffectPool_PlayerDamage;                       // 0x02D0(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPoolHitEffectData>             _HitEffectPool_Player;                             // 0x02E0(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPoolHitEffectData>             _HitEffectPool_Special;                            // 0x02F0(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddBattleActor(class ARSCharacterBase* Actor);
	void BeginRecordBattleLog(bool bBattleField);
	void ClearBattleActor();
	void EndRecordBattleLog(bool bBattleField);
	void ForceEndRecordBattleLog();
	class UBattleSettingComponent* GetBattleSetting();
	class UBattleSituationComponent* GetSituation();
	bool PlayBrainTalkStealthLost();
	void PoolHitEffectData(class AActor* HitActor, const struct FHCHitResult& HitResult, bool bNoLimit);
	void RemoveBattleActor(class ARSCharacterBase* Actor, EReasonBattleEnd Reason);
	void SetBattleMode(bool bBattle);
	void SetForceBattle(bool bForce, class FName ClaimantName);
	void StartTutorialOperation(class FName HelpTutoID, float DelaySec);

	bool CheckBattleLog_StealthLost() const;
	const TArray<class ARSCharacterBase*> GetBattleActorList() const;
	bool IsBattleMode() const;
	bool IsForceBattle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleManager">();
	}
	static class ABattleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleManager>();
	}
};
static_assert(alignof(ABattleManager) == 0x000008, "Wrong alignment on ABattleManager");
static_assert(sizeof(ABattleManager) == 0x000300, "Wrong size on ABattleManager");
static_assert(offsetof(ABattleManager, _battleActorList) == 0x000238, "Member 'ABattleManager::_battleActorList' has a wrong offset!");
static_assert(offsetof(ABattleManager, _ForceBattleList) == 0x000250, "Member 'ABattleManager::_ForceBattleList' has a wrong offset!");
static_assert(offsetof(ABattleManager, BATTLEFIELD_SPEEDRUN_TIME) == 0x000260, "Member 'ABattleManager::BATTLEFIELD_SPEEDRUN_TIME' has a wrong offset!");
static_assert(offsetof(ABattleManager, BATTLEFIELD_HORDE_ENEMY_NUM) == 0x000264, "Member 'ABattleManager::BATTLEFIELD_HORDE_ENEMY_NUM' has a wrong offset!");
static_assert(offsetof(ABattleManager, _BattleLogDataList) == 0x000270, "Member 'ABattleManager::_BattleLogDataList' has a wrong offset!");
static_assert(offsetof(ABattleManager, OneFrameHitEffectMax) == 0x000280, "Member 'ABattleManager::OneFrameHitEffectMax' has a wrong offset!");
static_assert(offsetof(ABattleManager, HitEffectPoolNum_Other) == 0x000284, "Member 'ABattleManager::HitEffectPoolNum_Other' has a wrong offset!");
static_assert(offsetof(ABattleManager, HitEffectPoolNum_Npc) == 0x000288, "Member 'ABattleManager::HitEffectPoolNum_Npc' has a wrong offset!");
static_assert(offsetof(ABattleManager, HitEffectPoolNum_Enemy) == 0x00028C, "Member 'ABattleManager::HitEffectPoolNum_Enemy' has a wrong offset!");
static_assert(offsetof(ABattleManager, HitEffectPoolNum_PlayerDamage) == 0x000290, "Member 'ABattleManager::HitEffectPoolNum_PlayerDamage' has a wrong offset!");
static_assert(offsetof(ABattleManager, HitEffectPoolNum_Player) == 0x000294, "Member 'ABattleManager::HitEffectPoolNum_Player' has a wrong offset!");
static_assert(offsetof(ABattleManager, HitEffectPoolNum_Special) == 0x000298, "Member 'ABattleManager::HitEffectPoolNum_Special' has a wrong offset!");
static_assert(offsetof(ABattleManager, _HitEffectPool_Other) == 0x0002A0, "Member 'ABattleManager::_HitEffectPool_Other' has a wrong offset!");
static_assert(offsetof(ABattleManager, _HitEffectPool_Npc) == 0x0002B0, "Member 'ABattleManager::_HitEffectPool_Npc' has a wrong offset!");
static_assert(offsetof(ABattleManager, _HitEffectPool_Enemy) == 0x0002C0, "Member 'ABattleManager::_HitEffectPool_Enemy' has a wrong offset!");
static_assert(offsetof(ABattleManager, _HitEffectPool_PlayerDamage) == 0x0002D0, "Member 'ABattleManager::_HitEffectPool_PlayerDamage' has a wrong offset!");
static_assert(offsetof(ABattleManager, _HitEffectPool_Player) == 0x0002E0, "Member 'ABattleManager::_HitEffectPool_Player' has a wrong offset!");
static_assert(offsetof(ABattleManager, _HitEffectPool_Special) == 0x0002F0, "Member 'ABattleManager::_HitEffectPool_Special' has a wrong offset!");

// Class BattlePrototype.BattlePrototypeUtility
// 0x0000 (0x0028 - 0x0028)
class UBattlePrototypeUtility final : public UObject
{
public:
	static void DrawDebugPrintString(class UObject* CallingObj, const class FString& InString, float ScreenX, float ScreenY, class AActor* TargetActor, const struct FLinearColor& TextColor, float Scale);
	static const struct FIntPoint GetAppBaseResolution();
	static void GetCallStack(class FString* Output);
	static void GetCallStackBP(class FString* Output);
	static int32 GetDebugBadState();
	static int32 GetMasterReleaseVersion();
	static bool IsDebugAreaSceneSelectable();
	static bool IsDebugBrainCrashOpend();
	static bool IsDebugDirectPause();
	static bool IsDebugDrawAI();
	static bool IsDebugDrawAttackCollision();
	static bool IsDebugDrawNonLockonTargetSearch();
	static bool IsDebugDrawPrintString();
	static bool IsDebugDrawTargetSearch();
	static bool IsDebugEnemyDamagePartHitPrint();
	static bool IsDebugEnemyDrawData();
	static bool IsDebugEnemyInvincible();
	static bool IsDebugEnemyParameter();
	static bool IsDebugParticleSpawnDisable();
	static bool IsDebugPlayerInvincible();
	static bool IsDebugSASBetaEnable();
	static bool IsDebugSASInfinity();
	static bool IsDebugSoundSpawnDisable();
	static bool IsEnableUserReview202005EOM();
	static bool IsMasterReleaseVersion();
	static bool IsNotSaveLoadDebugingParameter();
	static void SetDebugAreaSceneSelectable(bool Flag);
	static void SetNotSaveLoadDebugingParameter(bool Flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlePrototypeUtility">();
	}
	static class UBattlePrototypeUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattlePrototypeUtility>();
	}
};
static_assert(alignof(UBattlePrototypeUtility) == 0x000008, "Wrong alignment on UBattlePrototypeUtility");
static_assert(sizeof(UBattlePrototypeUtility) == 0x000028, "Wrong size on UBattlePrototypeUtility");

// Class BattlePrototype.BattleSettingComponent
// 0x0018 (0x00D8 - 0x00C0)
class UBattleSettingComponent : public UActorComponent
{
public:
	float                                         AttackExPsychicRateForArmor;                       // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         EnemyLockOnMax;                                    // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         EnemyAttackActionMax;                              // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WinceAccumulationStopSeconds;                      // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         KnockBackAccumulationStopSeconds;                  // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DownAccumulationStopSeconds;                       // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetAttackExPsychicRateForArmor();
	void SetAttackExPsychicRateForArmor(float Value);

	float GetDownAccumationStopSeconds() const;
	int32 GetEnemyAttackActionMax() const;
	int32 GetEnemyLockOnMax() const;
	float GetKnockBackAccumationStopSeconds() const;
	float GetWinceAccumationStopSeconds() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleSettingComponent">();
	}
	static class UBattleSettingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleSettingComponent>();
	}
};
static_assert(alignof(UBattleSettingComponent) == 0x000008, "Wrong alignment on UBattleSettingComponent");
static_assert(sizeof(UBattleSettingComponent) == 0x0000D8, "Wrong size on UBattleSettingComponent");
static_assert(offsetof(UBattleSettingComponent, AttackExPsychicRateForArmor) == 0x0000C0, "Member 'UBattleSettingComponent::AttackExPsychicRateForArmor' has a wrong offset!");
static_assert(offsetof(UBattleSettingComponent, EnemyLockOnMax) == 0x0000C4, "Member 'UBattleSettingComponent::EnemyLockOnMax' has a wrong offset!");
static_assert(offsetof(UBattleSettingComponent, EnemyAttackActionMax) == 0x0000C8, "Member 'UBattleSettingComponent::EnemyAttackActionMax' has a wrong offset!");
static_assert(offsetof(UBattleSettingComponent, WinceAccumulationStopSeconds) == 0x0000CC, "Member 'UBattleSettingComponent::WinceAccumulationStopSeconds' has a wrong offset!");
static_assert(offsetof(UBattleSettingComponent, KnockBackAccumulationStopSeconds) == 0x0000D0, "Member 'UBattleSettingComponent::KnockBackAccumulationStopSeconds' has a wrong offset!");
static_assert(offsetof(UBattleSettingComponent, DownAccumulationStopSeconds) == 0x0000D4, "Member 'UBattleSettingComponent::DownAccumulationStopSeconds' has a wrong offset!");

// Class BattlePrototype.OnlineTestPlayerState
// 0x0008 (0x0338 - 0x0330)
class AOnlineTestPlayerState final : public APlayerState
{
public:
	struct FOnlineTestData                        TestData;                                          // 0x0330(0x0008)(BlueprintVisible, Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)

public:
	void OnRep_SetTestData();
	void SetData(const struct FOnlineTestData& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineTestPlayerState">();
	}
	static class AOnlineTestPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOnlineTestPlayerState>();
	}
};
static_assert(alignof(AOnlineTestPlayerState) == 0x000008, "Wrong alignment on AOnlineTestPlayerState");
static_assert(sizeof(AOnlineTestPlayerState) == 0x000338, "Wrong size on AOnlineTestPlayerState");
static_assert(offsetof(AOnlineTestPlayerState, TestData) == 0x000330, "Member 'AOnlineTestPlayerState::TestData' has a wrong offset!");

// Class BattlePrototype.DriveRendererParameter
// 0x0050 (0x0080 - 0x0030)
class UDriveRendererParameter final : public UDataAsset
{
public:
	struct FLinearColor                           BgEdgeColorInner;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BgEdgeColorOuter;                                  // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BgEdgeColorShift;                                  // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BgEdgeLength;                                      // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BgEdgeLengthMin;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BgEdgeSmooth;                                      // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BgEdgeEdgeThresholdNormal;                         // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BgEdgeEdgeThresholdLuminance;                      // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VignetteIntensity;                                 // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VignetteRange;                                     // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTime;                                    // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleOnPPStartDelay;                              // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleOffPPStartDelay;                             // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DriveRendererParameter">();
	}
	static class UDriveRendererParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDriveRendererParameter>();
	}
};
static_assert(alignof(UDriveRendererParameter) == 0x000008, "Wrong alignment on UDriveRendererParameter");
static_assert(sizeof(UDriveRendererParameter) == 0x000080, "Wrong size on UDriveRendererParameter");
static_assert(offsetof(UDriveRendererParameter, BgEdgeColorInner) == 0x000030, "Member 'UDriveRendererParameter::BgEdgeColorInner' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, BgEdgeColorOuter) == 0x000040, "Member 'UDriveRendererParameter::BgEdgeColorOuter' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, BgEdgeColorShift) == 0x000050, "Member 'UDriveRendererParameter::BgEdgeColorShift' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, BgEdgeLength) == 0x000054, "Member 'UDriveRendererParameter::BgEdgeLength' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, BgEdgeLengthMin) == 0x000058, "Member 'UDriveRendererParameter::BgEdgeLengthMin' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, BgEdgeSmooth) == 0x00005C, "Member 'UDriveRendererParameter::BgEdgeSmooth' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, BgEdgeEdgeThresholdNormal) == 0x000060, "Member 'UDriveRendererParameter::BgEdgeEdgeThresholdNormal' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, BgEdgeEdgeThresholdLuminance) == 0x000064, "Member 'UDriveRendererParameter::BgEdgeEdgeThresholdLuminance' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, VignetteIntensity) == 0x000068, "Member 'UDriveRendererParameter::VignetteIntensity' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, VignetteRange) == 0x00006C, "Member 'UDriveRendererParameter::VignetteRange' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, TransitionTime) == 0x000070, "Member 'UDriveRendererParameter::TransitionTime' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, BattleOnPPStartDelay) == 0x000074, "Member 'UDriveRendererParameter::BattleOnPPStartDelay' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, BattleOffPPStartDelay) == 0x000078, "Member 'UDriveRendererParameter::BattleOffPPStartDelay' has a wrong offset!");

// Class BattlePrototype.BattleSituationComponent
// 0x0038 (0x00F8 - 0x00C0)
class UBattleSituationComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnChangeSituation;                                 // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         IgnoreChangeSituationRemainTimer;                  // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NormalSituationRemainTimer;                        // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IgnoreChangeSituationTime;                         // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChangeSituationTime;                               // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBattleSituationType                          SituationType;                                     // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x17];                                      // 0x00E1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeSituation(EBattleSituationType Type);
	void GetSituationParameter(EBattleSituationActionType ActionType, float* RemainTime, int32* Priority);
	void OnAction(const struct FActionParameter& Parameter);

	EBattleSituationType GetSituation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleSituationComponent">();
	}
	static class UBattleSituationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleSituationComponent>();
	}
};
static_assert(alignof(UBattleSituationComponent) == 0x000008, "Wrong alignment on UBattleSituationComponent");
static_assert(sizeof(UBattleSituationComponent) == 0x0000F8, "Wrong size on UBattleSituationComponent");
static_assert(offsetof(UBattleSituationComponent, OnChangeSituation) == 0x0000C0, "Member 'UBattleSituationComponent::OnChangeSituation' has a wrong offset!");
static_assert(offsetof(UBattleSituationComponent, IgnoreChangeSituationRemainTimer) == 0x0000D0, "Member 'UBattleSituationComponent::IgnoreChangeSituationRemainTimer' has a wrong offset!");
static_assert(offsetof(UBattleSituationComponent, NormalSituationRemainTimer) == 0x0000D4, "Member 'UBattleSituationComponent::NormalSituationRemainTimer' has a wrong offset!");
static_assert(offsetof(UBattleSituationComponent, IgnoreChangeSituationTime) == 0x0000D8, "Member 'UBattleSituationComponent::IgnoreChangeSituationTime' has a wrong offset!");
static_assert(offsetof(UBattleSituationComponent, ChangeSituationTime) == 0x0000DC, "Member 'UBattleSituationComponent::ChangeSituationTime' has a wrong offset!");
static_assert(offsetof(UBattleSituationComponent, SituationType) == 0x0000E0, "Member 'UBattleSituationComponent::SituationType' has a wrong offset!");

// Class BattlePrototype.NpcDataParam
// 0x0010 (0x0040 - 0x0030)
class UNpcDataParam final : public UDataAsset
{
public:
	float                                         HeadLookAtClamp;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadLookAtFollowSpeed;                             // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NotTurnAngle;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcDataParam">();
	}
	static class UNpcDataParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNpcDataParam>();
	}
};
static_assert(alignof(UNpcDataParam) == 0x000008, "Wrong alignment on UNpcDataParam");
static_assert(sizeof(UNpcDataParam) == 0x000040, "Wrong size on UNpcDataParam");
static_assert(offsetof(UNpcDataParam, HeadLookAtClamp) == 0x000030, "Member 'UNpcDataParam::HeadLookAtClamp' has a wrong offset!");
static_assert(offsetof(UNpcDataParam, HeadLookAtFollowSpeed) == 0x000034, "Member 'UNpcDataParam::HeadLookAtFollowSpeed' has a wrong offset!");
static_assert(offsetof(UNpcDataParam, NotTurnAngle) == 0x000038, "Member 'UNpcDataParam::NotTurnAngle' has a wrong offset!");

// Class BattlePrototype.BlendableVolume
// 0x0020 (0x0288 - 0x0268)
class ABlendableVolume : public AVolume
{
public:
	uint8                                         Pad_268[0xC];                                      // 0x0268(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Priority;                                          // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendRadius;                                       // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendWeight;                                       // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnabled : 1;                                      // 0x0280(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUnbound : 1;                                      // 0x0280(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlendableVolume">();
	}
	static class ABlendableVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlendableVolume>();
	}
};
static_assert(alignof(ABlendableVolume) == 0x000008, "Wrong alignment on ABlendableVolume");
static_assert(sizeof(ABlendableVolume) == 0x000288, "Wrong size on ABlendableVolume");
static_assert(offsetof(ABlendableVolume, Priority) == 0x000274, "Member 'ABlendableVolume::Priority' has a wrong offset!");
static_assert(offsetof(ABlendableVolume, BlendRadius) == 0x000278, "Member 'ABlendableVolume::BlendRadius' has a wrong offset!");
static_assert(offsetof(ABlendableVolume, BlendWeight) == 0x00027C, "Member 'ABlendableVolume::BlendWeight' has a wrong offset!");

// Class BattlePrototype.BlownAwayComponent
// 0x0018 (0x00D8 - 0x00C0)
class UBlownAwayComponent final : public UActorComponent
{
public:
	bool                                          _isBlowOnDamage;                                   // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _guardBlowPowerRate;                               // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBlownAwayComponent* GetBlownAwayComponentFromActor(class AActor* Actor);

	void AddDamageBlowImpulse(const struct FHCHitResult& HitResult, bool IsGuard);
	void SetIsBlowOnDamage(bool blowEnable);

	struct FVector GetBlowImpulse(const class AActor* AttackActor, const struct FRotator& blowAngle, float blowPower) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlownAwayComponent">();
	}
	static class UBlownAwayComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlownAwayComponent>();
	}
};
static_assert(alignof(UBlownAwayComponent) == 0x000008, "Wrong alignment on UBlownAwayComponent");
static_assert(sizeof(UBlownAwayComponent) == 0x0000D8, "Wrong size on UBlownAwayComponent");
static_assert(offsetof(UBlownAwayComponent, _isBlowOnDamage) == 0x0000C0, "Member 'UBlownAwayComponent::_isBlowOnDamage' has a wrong offset!");
static_assert(offsetof(UBlownAwayComponent, _guardBlowPowerRate) == 0x0000C4, "Member 'UBlownAwayComponent::_guardBlowPowerRate' has a wrong offset!");

// Class BattlePrototype.PlayerInterface
// 0x0000 (0x0028 - 0x0028)
class IPlayerInterface final : public IInterface
{
public:
	bool AimEndAI_CallFromCPP();
	bool AimStartAI_CallFromCPP();
	float BeforeTakeDamage(float DamageValue, const struct FHCHitResult& HitResult);
	void BeginControlPsychicObject(class AActor** TargetActor);
	bool CanBattleAction_CallFromCPP(EPlayerAIBattleThinkTypeCPP ThinkType);
	bool CheckAIPsychicObject_CallFromCPP(bool bCapture, bool bAttack);
	bool CheckAutoCounter_CallFromCPP();
	bool CheckEventMovePos_CallFromCPP();
	bool CheckFriendCoverDamage(float DamageValue);
	void CheckHologramAttack(ESASHologramAttackTiming Timing, class ARSCharacterBase* RequestCharacter);
	bool CheckJumpCount();
	bool CheckRareArrangeItemBySAS();
	bool ClearBattleParticle(class FName ClaimantName, bool bForceClear);
	bool CloseBrainField(bool bCrash);
	void EndControlPsychicObject(class AActor** TargetActor);
	bool EndEventWait_CallFromCPP();
	void EquipAccessory(EPlayerAccessory Index_0, int32 AccessoryId);
	void EquipAttachment(EPlayerAttachment Index_0, int32 AttachmentId);
	void EquipCostume(int32 CostumeId);
	void EquipWeapon(int32 WeaponId);
	bool ForceEndSAS_Telepo();
	bool ForceWarp_CallFromCPP(const struct FTransform& Transform, float IdleRestoreDelay);
	class AActor* GetBattleTargetActor_CallFromCPP();
	EPlayerBrainFieldDanger GetBrainFieldDangerLV();
	EPlayerActionKind GetCurrentActionStateInterface();
	void GetCurrentSASGaugeRate(E_SASButton SASButton, float* SASGaugeRate);
	void GetEventMovePosActor_CallFromCPP(class AActor** OutActor, float* OutRadius);
	float GetMaxSpeedScale_CallFromCPP();
	void GetSAS_MaxActiveSeconds(E_SASKindNative SasKind, float* ActivationSeconds);
	void GetSASActiveSeconds(E_SASButton SASButton, float* RemainingSec);
	bool GetSASEffectFixParam(E_SASKindNative InKind, TArray<struct F_SASParamNative>* OutFixParam);
	void GetSASRecastAndActiveGaugeRate(E_SASButton SASButton, float* SASGaugeRate, bool* IsActive);
	bool InputAI_Attack_CallFromCPP(bool bPressed);
	bool InputAI_Dodge_CallFromCPP(bool bPressed);
	bool InputAI_Jump_CallFromCPP(bool bPressed);
	bool InputAI_LeftStick_CallFromCPP(float X, float Y);
	bool InputAI_Psychic_CallFromCPP(bool bPressed);
	bool InputAI_UseItem_CallFromCPP(bool bPressed);
	bool IsAbleOverwriteENPCBrainField();
	bool IsActionStatusAI_CallFromCPP(EPlayerActionStatus Status);
	bool IsActiveSAS_Accelerator();
	bool IsActiveSAS_Copy();
	bool IsActiveSAS_Electric();
	bool IsActiveSAS_Fire();
	bool IsActiveSAS_Metal();
	bool IsActiveSAS_Psychic();
	bool IsActiveSAS_SeeThrough();
	bool IsActiveSAS_Stealth();
	bool IsActiveSAS_Telepo();
	bool IsAIMoveMode_CallFromCPP(EPlayerAIMoveModeCPP MoveModeCPP);
	bool IsAIPlayer();
	bool IsBattleActionStartAI_CallFromCPP();
	bool IsBattleThink_CallFromCPP(EPlayerAIBattleThinkTypeCPP Type);
	bool IsBattleThinkParam_CallFromCPP(EPlayerAIBattleThinkParamCPP Param);
	bool IsEnableActionCounter_CallFromCPP();
	bool IsEnableBackStepAttack();
	bool IsEnableCheckActionIcon();
	bool IsEnableSASCoverDamageFromPlayerID(EPlayerID CoverPlayerID);
	bool IsEnableSASEffectHologram(EPlayerID PlayerId);
	bool IsEnableSASHologramAttack(ESASHologramAttackTiming Timing);
	bool IsEnableSasSelectSlow();
	bool IsEnemyPlayer_CallFromCPP();
	bool IsIgnoreStealthVelocity();
	bool IsInputAI_Psychic_CallFromCPP();
	bool IsInputAI_UseItem_CallFromCPP();
	bool IsInputOverwriteENPCBrainField();
	bool IsPlayerStatusAI_CallFromCPP(EPlayerCommonStatus Status);
	bool IsPsychicAble_CallFromCPP();
	bool IsReactionChance_CallFromCPP();
	bool IsSelfRecovery_CallFromCPP();
	bool IsSpecialDown_CallFromCPP(float* OutSpDownWince);
	bool IsUniqueConditionTransition_CallFromCPP(int32 UniqueNo);
	bool IsUniqueEffectiveSas_CallFromCPP(class AActor* InAttackActor, float* OutWinceRate, float* OutKnockBackRate, float* OutDownRate, float* OutCrashRate);
	bool IsUseAbleCombinationVision(E_SASKindNative InKind);
	bool IsUseAbleSASRecastGauge(E_SASKindNative SasKind);
	bool IsUseItemThink_CallFromCPP();
	bool NextBattleThink_CallFromCPP();
	bool NotifyResetBehaviorTree_CallFromCPP();
	bool OnAnimNotifyEnableAction();
	bool OnAnimNotifyEnableAttack();
	bool OnAnimNotifyEnablePsychic();
	bool OnChangeBattleThink_CallFromCPP(EPlayerAIBattleThinkTypeCPP Next, EPlayerAIBattleThinkTypeCPP Prev);
	bool OpenBrainField();
	ERSAttackInputKind OverwriteAttackInputKindAI_CallFromCPP(EPlayerAIBattleThinkTypeCPP Think, ERSAttackInputKind Kind);
	bool ResetAnimLeftStickPower();
	bool ResetBattleThink_CallFromCPP();
	bool ResetCoverDamagePlayer_CallFromCPP();
	bool RestartBattleAI_CallFromCPP();
	bool RestoreMaxSpeed_CallFromCPP(const class FName& ClaimantName);
	bool ScaleMaxSpeed_CallFromCPP(float Scale, class FName ClaimantName);
	bool SearchAIPsychicObject_CallFromCPP();
	bool SetAIMoveStick_CallFromCPP(bool bMoveStick);
	void SetAIOrder(EPlayerAIOrder Plan);
	bool SetBattleParticleType(EPlayerBattleParticleType Type);
	bool SetEnableInputStick_CallFromCPP(bool bEnable);
	bool SetEventEndDown(bool bFront);
	bool SetEventMove_CallFromCPP(const TArray<struct FVector>& Pos_list_in, const TArray<float>& Radius_list_in, bool Walk, bool bAfterWait);
	bool SetEventWait_CallFromCPP();
	void SetEyeControlEnable(bool bEnable, class FName ClaimantName);
	void SetEyeControlParameter(float Horizontal, float Vertical);
	bool SetForceLockTargetSelf_CallFromCPP();
	bool SetMaterialScalarParameterOther(class FName ParamName, float Value);
	bool SetMoveMode_CallFromCPP(EPlayerAIMoveModeCPP MoveModeCPP);
	bool SetMoveStickBack_CallFromCPP(bool bBack);
	ERSPartyPlayerKind SetPartyPlayerKind(ERSPartyPlayerKind Kind);
	bool SetPlayerCamera(class ACameraActor* PCameraActor, bool bPitch, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	bool SetPlayerInputRestriction_CallFromCPP(EPlayerInputRestrictionType Type, bool bRistriction);
	bool SetReserveCoverDamage_CallFromCPP(bool Flag);
	bool SetSasStealth_CallFromCPP(bool Stealth_on_in, bool Hero_order_in, bool Check_delay, bool Check_ignore, bool No_sas_cancel_in);
	bool SetStealthReactionInterval_CallFromCPP();
	bool SpawnBattleParticle(class FName ClaimantName);
	struct FPlayerInfo UpdateMenuParameter(const struct FPlayerInfo& CurrentParameter);
	void UpdateParameter(const struct FCharactersParameterTable& Table);

	int32 GetAttackCountAI_CallFromCPP() const;
	struct FVector GetControlPlayerDist_CallFromCPP() const;
	EPlayerID GetCoverDamagePlayerID_CallFromCPP() const;
	void GetCurrentTargetActorInterface(class AActor** TargetActor) const;
	class AActor* GetMovePosActor_CallFromCPP() const;
	ERSPartyPlayerKind GetPartyPlayerKind() const;
	void GetPlayerAccessoryEffect_CallFromCPP(EEffecacyType EffectType, bool* bOutEquip, float* OutParam) const;
	EPlayerID GetPlayerID() const;
	void GetSASKindforButton(E_SASButton SASButton, E_SASKindNative* SasKind) const;
	void GetTargetBossInterface(class AActor** LockBoss) const;
	void IsActiveSAS_ForButton(E_SASButton SASButton, bool* IsSAS) const;
	bool IsAttackAble_CallFromCPP() const;
	void IsCanSAS_Use(E_SASButton SASButton, bool* IsSASUse) const;
	bool IsControlAI_CallFromCPP() const;
	bool IsDamageCollisionInvincible_CallFromCPP() const;
	bool IsDodgeAble_CallFromCPP() const;
	bool IsDying_CallFromCPP() const;
	bool IsEnableActionDodge_CallFromCPP() const;
	bool IsEnableActionJump_CallFromCPP() const;
	bool IsEnableBrainCrash_Native() const;
	bool IsEnemyForceWait_CallFromCPP() const;
	bool IsEventMove_CallFromCPP() const;
	bool IsEventMoveEnd_CallFromCPP() const;
	bool IsEventWait_CallFromCPP() const;
	bool IsInputAI_Attack_CallFromCPP() const;
	bool IsInputAI_Dodge_CallFromCPP() const;
	bool IsInputAI_Jump_CallFromCPP() const;
	void IsInputSAS(E_SASButton SASButton, bool* IsInputSAS_0) const;
	bool IsJumpAble_CallFromCPP() const;
	void IsLockTargetInterface(bool* IsLockTarget) const;
	bool IsLockTargetLostInterface() const;
	bool IsMetalMode_CallFromCPP() const;
	bool IsMoveAble_CallFromCPP() const;
	bool IsOnReadySAS() const;
	bool IsPlayerSuperArmor_CallFromCPP() const;
	bool IsResetBehaviorTree_CallFromCPP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInterface">();
	}
	static class IPlayerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerInterface>();
	}
};
static_assert(alignof(IPlayerInterface) == 0x000008, "Wrong alignment on IPlayerInterface");
static_assert(sizeof(IPlayerInterface) == 0x000028, "Wrong size on IPlayerInterface");

// Class BattlePrototype.BrainCrashFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UBrainCrashFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void EditorSetBCSequenceSettingsFromJSONString(class UDataTable* DataTable, const class FString& JsonString);
	static int32 GetBCSafePointAllowAllRotation();
	static int32 GetBCSafePointAllowRotationBit(const struct FBrainCrashSafePoint& SafePoint, int32 EnemyIndex);
	static struct FTransform GetBCSafePointBoxTransform(const struct FVector& Location, const struct FBrainCrashSequenceSettingsData& SeqenceSetting, float RotationYaw, float HeightFloating, float Scale);
	static struct FTransform GetBCSafePointCylinderTransform(const struct FVector& Location, const struct FBrainCrashSequenceSettingsData& SeqenceSetting, float HeightFloating, float Scale);
	static bool IsBCSafePointAllowAllRotation(int32 RotationBit);
	static void SearchBCSafePoint(bool* HitNearLocation, struct FTransform* NearLocationTransform, float* NearLocationLength, bool* HitNearAngle, struct FTransform* NearAngleTransform, float* NearAngleLength, float* NearAngleAngle, const struct FBrainCrashSafePoint& SafePoints, class UBrainCrashParam* Param, int32 RotationAngle, int32 EnemyIndex, const struct FVector& Location, const struct FVector& SequencerCenterLocation, float TargetRawDir, float TargetNormalizedDir);
	static void SearchBCSafePointList(bool* HitNearLocation, struct FTransform* NearLocationTransform, float* NearLocationLength, bool* HitNearAngle, struct FTransform* NearAngleTransform, float* NearAngleLength, const TArray<struct FBrainCrashSafePoint>& SafePoints, const TArray<class USplineMeshComponent*>& BattleFieldMeshComps, class UBrainCrashParam* Param, const struct FBrainCrashSequenceSettings& SequencerSetting, int32 RotationAngle, int32 EnemyIndex, const struct FVector& Location, const struct FVector& SequencerCenterLocation, float TargetRawDir, float TargetNormalizedDir);
	static void SetBCSafePointAllowRotationBit(struct FBrainCrashSafePoint& RefSafePoint, int32 EnemyIndex, int32 AllowRotateBit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainCrashFunctionLibrary">();
	}
	static class UBrainCrashFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrainCrashFunctionLibrary>();
	}
};
static_assert(alignof(UBrainCrashFunctionLibrary) == 0x000008, "Wrong alignment on UBrainCrashFunctionLibrary");
static_assert(sizeof(UBrainCrashFunctionLibrary) == 0x000028, "Wrong size on UBrainCrashFunctionLibrary");

// Class BattlePrototype.JumpAreaBase
// 0x0040 (0x0278 - 0x0238)
class AJumpAreaBase : public ATriggerBox
{
public:
	int32                                         LocationNo;                                        // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaNo;                                            // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PortalNo;                                          // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSelectNextAreaFunction;                         // 0x0244(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_245[0x3];                                      // 0x0245(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LocationNoJumpTo;                                  // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaNoJumpTo;                                      // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PortalNoJumpTo;                                    // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartPortalNameJumpTo;                             // 0x0254(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOpenWorldMap;                                    // 0x025C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25D[0x3];                                      // 0x025D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ToDetailSubAreaName;                               // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAreaInfoTweakCondition>        Conditions;                                        // 0x0268(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool IsAcceptableJumpArea();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JumpAreaBase">();
	}
	static class AJumpAreaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJumpAreaBase>();
	}
};
static_assert(alignof(AJumpAreaBase) == 0x000008, "Wrong alignment on AJumpAreaBase");
static_assert(sizeof(AJumpAreaBase) == 0x000278, "Wrong size on AJumpAreaBase");
static_assert(offsetof(AJumpAreaBase, LocationNo) == 0x000238, "Member 'AJumpAreaBase::LocationNo' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, AreaNo) == 0x00023C, "Member 'AJumpAreaBase::AreaNo' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, PortalNo) == 0x000240, "Member 'AJumpAreaBase::PortalNo' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, UseSelectNextAreaFunction) == 0x000244, "Member 'AJumpAreaBase::UseSelectNextAreaFunction' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, LocationNoJumpTo) == 0x000248, "Member 'AJumpAreaBase::LocationNoJumpTo' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, AreaNoJumpTo) == 0x00024C, "Member 'AJumpAreaBase::AreaNoJumpTo' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, PortalNoJumpTo) == 0x000250, "Member 'AJumpAreaBase::PortalNoJumpTo' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, StartPortalNameJumpTo) == 0x000254, "Member 'AJumpAreaBase::StartPortalNameJumpTo' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, IsOpenWorldMap) == 0x00025C, "Member 'AJumpAreaBase::IsOpenWorldMap' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, ToDetailSubAreaName) == 0x000260, "Member 'AJumpAreaBase::ToDetailSubAreaName' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, Conditions) == 0x000268, "Member 'AJumpAreaBase::Conditions' has a wrong offset!");

// Class BattlePrototype.BrainCrashManager
// 0x00D0 (0x0300 - 0x0230)
class ABrainCrashManager : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEmptyTriggerTransform;                            // 0x0238(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LastTriggerTransform;                              // 0x0240(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x90];                                     // 0x0270(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckUseCutin();
	int32 GetSafePointGroupPlayerID(class UBrainCrashLocationSettings* LocationSettings);
	TArray<struct FBrainCrashSafePoint> GetSafePointGroupPoints(class UBrainCrashLocationSettings* LocationSettings);
	TArray<struct FBrainCrashSafePoint> GetSafePointGroupPointsFromID(class UBrainCrashLocationSettings* LocationSettings, int32 SafePointID);
	TArray<struct FBrainCrashSafePoint> GetSafePointGroupPointsFromUnbound(class UBrainCrashLocationSettings* LocationSettings);
	bool GetTriggerTransform(struct FTransform* TriggerTransform);
	class ABrainCrashSettingVolume* GetTriggerTransformVolume();
	bool SearchUniqueFinishEnemyLocation(struct FTransform& OutEnmeyTransform, const struct FTransform& SeqeuncerEnemyTransform, const struct FTransform& SeqeuncerPlayerTransform, const struct FTransform& PlayerTransform, const TArray<struct FVector>& CollisionCheckOffset, int32 CollisionCheckRadius, const TArray<EObjectTypeQuery>& CollisionObjectTypes, EDrawDebugTrace CollisionDebugType);
	void SetupSafePointGroup(class UBrainCrashLocationSettings* LocationSettings, bool ForceUpdate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainCrashManager">();
	}
	static class ABrainCrashManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrainCrashManager>();
	}
};
static_assert(alignof(ABrainCrashManager) == 0x000010, "Wrong alignment on ABrainCrashManager");
static_assert(sizeof(ABrainCrashManager) == 0x000300, "Wrong size on ABrainCrashManager");
static_assert(offsetof(ABrainCrashManager, bEmptyTriggerTransform) == 0x000238, "Member 'ABrainCrashManager::bEmptyTriggerTransform' has a wrong offset!");
static_assert(offsetof(ABrainCrashManager, LastTriggerTransform) == 0x000240, "Member 'ABrainCrashManager::LastTriggerTransform' has a wrong offset!");

// Class BattlePrototype.BrainCrashParam
// 0x0040 (0x0070 - 0x0030)
class UBrainCrashParam final : public UDataAsset
{
public:
	float                                         CameraInterpStartTime;                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      CameraInterpStartFunc;                             // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraInterpStartEaseExp;                          // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraInterpFinishTime;                            // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      CameraInterpFinishFunc;                            // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraInterpFinishEaseExp;                         // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DitherHiddenSeconds;                               // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafePointPriorityAngleLength;                      // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafePointPriorityAngle;                            // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafePointLimitLength;                              // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafePointLimitAngle;                               // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafePointLimitHeight;                              // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GeneralDamageSeconds;                              // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GeneralDamageMaxIntervalSeconds;                   // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniqueWaitSecdons;                                 // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainCrashParam">();
	}
	static class UBrainCrashParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrainCrashParam>();
	}
};
static_assert(alignof(UBrainCrashParam) == 0x000008, "Wrong alignment on UBrainCrashParam");
static_assert(sizeof(UBrainCrashParam) == 0x000070, "Wrong size on UBrainCrashParam");
static_assert(offsetof(UBrainCrashParam, CameraInterpStartTime) == 0x000030, "Member 'UBrainCrashParam::CameraInterpStartTime' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, CameraInterpStartFunc) == 0x000034, "Member 'UBrainCrashParam::CameraInterpStartFunc' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, CameraInterpStartEaseExp) == 0x000038, "Member 'UBrainCrashParam::CameraInterpStartEaseExp' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, CameraInterpFinishTime) == 0x00003C, "Member 'UBrainCrashParam::CameraInterpFinishTime' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, CameraInterpFinishFunc) == 0x000040, "Member 'UBrainCrashParam::CameraInterpFinishFunc' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, CameraInterpFinishEaseExp) == 0x000044, "Member 'UBrainCrashParam::CameraInterpFinishEaseExp' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, DitherHiddenSeconds) == 0x000048, "Member 'UBrainCrashParam::DitherHiddenSeconds' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, SafePointPriorityAngleLength) == 0x00004C, "Member 'UBrainCrashParam::SafePointPriorityAngleLength' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, SafePointPriorityAngle) == 0x000050, "Member 'UBrainCrashParam::SafePointPriorityAngle' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, SafePointLimitLength) == 0x000054, "Member 'UBrainCrashParam::SafePointLimitLength' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, SafePointLimitAngle) == 0x000058, "Member 'UBrainCrashParam::SafePointLimitAngle' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, SafePointLimitHeight) == 0x00005C, "Member 'UBrainCrashParam::SafePointLimitHeight' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, GeneralDamageSeconds) == 0x000060, "Member 'UBrainCrashParam::GeneralDamageSeconds' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, GeneralDamageMaxIntervalSeconds) == 0x000064, "Member 'UBrainCrashParam::GeneralDamageMaxIntervalSeconds' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, UniqueWaitSecdons) == 0x000068, "Member 'UBrainCrashParam::UniqueWaitSecdons' has a wrong offset!");

// Class BattlePrototype.BrainCrashLocationSettings
// 0x0010 (0x0040 - 0x0030)
class UBrainCrashLocationSettings final : public UDataAsset
{
public:
	TArray<struct FBrainCrashSafePoint>           SafePoints;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainCrashLocationSettings">();
	}
	static class UBrainCrashLocationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrainCrashLocationSettings>();
	}
};
static_assert(alignof(UBrainCrashLocationSettings) == 0x000008, "Wrong alignment on UBrainCrashLocationSettings");
static_assert(sizeof(UBrainCrashLocationSettings) == 0x000040, "Wrong size on UBrainCrashLocationSettings");
static_assert(offsetof(UBrainCrashLocationSettings, SafePoints) == 0x000030, "Member 'UBrainCrashLocationSettings::SafePoints' has a wrong offset!");

// Class BattlePrototype.PauseUtility
// 0x0000 (0x0028 - 0x0028)
class UPauseUtility final : public UObject
{
public:
	static void DumpRedActorPauseSettings(const class UObject* WorldContextObject);
	static void GetRedPaused(const class UObject* WorldContextObject, int32* ReturnValue);
	static void SetRedPaused(const class UObject* WorldContextObject, int32 PauseFlag, bool bPaused);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PauseUtility">();
	}
	static class UPauseUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPauseUtility>();
	}
};
static_assert(alignof(UPauseUtility) == 0x000008, "Wrong alignment on UPauseUtility");
static_assert(sizeof(UPauseUtility) == 0x000028, "Wrong size on UPauseUtility");

// Class BattlePrototype.GameDifficultyDefine
// 0x0010 (0x00D0 - 0x00C0)
class UGameDifficultyDefine final : public UActorComponent
{
public:
	float                                         M_addMag;                                          // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         M_difficultyMag;                                   // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         M_defaultMag;                                      // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool DifficultyMagCalc();
	float GetDefaultMag();
	float GetDifficultyMag();
	void SetAddMag(float _addMag);
	void SetDefaultMag(float _defaultMag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDifficultyDefine">();
	}
	static class UGameDifficultyDefine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDifficultyDefine>();
	}
};
static_assert(alignof(UGameDifficultyDefine) == 0x000008, "Wrong alignment on UGameDifficultyDefine");
static_assert(sizeof(UGameDifficultyDefine) == 0x0000D0, "Wrong size on UGameDifficultyDefine");
static_assert(offsetof(UGameDifficultyDefine, M_addMag) == 0x0000C0, "Member 'UGameDifficultyDefine::M_addMag' has a wrong offset!");
static_assert(offsetof(UGameDifficultyDefine, M_difficultyMag) == 0x0000C4, "Member 'UGameDifficultyDefine::M_difficultyMag' has a wrong offset!");
static_assert(offsetof(UGameDifficultyDefine, M_defaultMag) == 0x0000C8, "Member 'UGameDifficultyDefine::M_defaultMag' has a wrong offset!");

// Class BattlePrototype.BrainCrashPointGroupVolume
// 0x0020 (0x0288 - 0x0268)
class ABrainCrashPointGroupVolume final : public AVolume
{
public:
	int32                                         GroupID;                                           // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0270(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnbound;                                          // 0x0271(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_272[0x16];                                     // 0x0272(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorBeginOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorEndOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainCrashPointGroupVolume">();
	}
	static class ABrainCrashPointGroupVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrainCrashPointGroupVolume>();
	}
};
static_assert(alignof(ABrainCrashPointGroupVolume) == 0x000008, "Wrong alignment on ABrainCrashPointGroupVolume");
static_assert(sizeof(ABrainCrashPointGroupVolume) == 0x000288, "Wrong size on ABrainCrashPointGroupVolume");
static_assert(offsetof(ABrainCrashPointGroupVolume, GroupID) == 0x000268, "Member 'ABrainCrashPointGroupVolume::GroupID' has a wrong offset!");
static_assert(offsetof(ABrainCrashPointGroupVolume, Priority) == 0x00026C, "Member 'ABrainCrashPointGroupVolume::Priority' has a wrong offset!");
static_assert(offsetof(ABrainCrashPointGroupVolume, bEnabled) == 0x000270, "Member 'ABrainCrashPointGroupVolume::bEnabled' has a wrong offset!");
static_assert(offsetof(ABrainCrashPointGroupVolume, bUnbound) == 0x000271, "Member 'ABrainCrashPointGroupVolume::bUnbound' has a wrong offset!");

// Class BattlePrototype.UIConfigSelect2
// 0x0168 (0x04F0 - 0x0388)
class UUIConfigSelect2 : public UUIBase
{
public:
	uint8                                         Pad_388[0x168];                                    // 0x0388(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeIndex(int32 Index_0, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimEnable, class UWidgetAnimation* AnimEnableIn, class UWidgetAnimation* AnimEnableOut, class UTextBlock* TextIndex);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextTitle);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigSelect2">();
	}
	static class UUIConfigSelect2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigSelect2>();
	}
};
static_assert(alignof(UUIConfigSelect2) == 0x000008, "Wrong alignment on UUIConfigSelect2");
static_assert(sizeof(UUIConfigSelect2) == 0x0004F0, "Wrong size on UUIConfigSelect2");

// Class BattlePrototype.BrainCrashSafePointConfigVolume
// 0x0008 (0x0270 - 0x0268)
class ABrainCrashSafePointConfigVolume final : public AVolume
{
public:
	bool                                          bDisableMakePoint;                                 // 0x0268(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainCrashSafePointConfigVolume">();
	}
	static class ABrainCrashSafePointConfigVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrainCrashSafePointConfigVolume>();
	}
};
static_assert(alignof(ABrainCrashSafePointConfigVolume) == 0x000008, "Wrong alignment on ABrainCrashSafePointConfigVolume");
static_assert(sizeof(ABrainCrashSafePointConfigVolume) == 0x000270, "Wrong size on ABrainCrashSafePointConfigVolume");
static_assert(offsetof(ABrainCrashSafePointConfigVolume, bDisableMakePoint) == 0x000268, "Member 'ABrainCrashSafePointConfigVolume::bDisableMakePoint' has a wrong offset!");

// Class BattlePrototype.BrainCrashSettingVolume
// 0x0048 (0x02B0 - 0x0268)
class ABrainCrashSettingVolume final : public AVolume
{
public:
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TriggerTransform;                                  // 0x0270(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x02A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnbound;                                          // 0x02A5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A6[0xA];                                      // 0x02A6(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FitGroundTriggerTransform();

	struct FTransform GetTriggerTransformWS() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainCrashSettingVolume">();
	}
	static class ABrainCrashSettingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrainCrashSettingVolume>();
	}
};
static_assert(alignof(ABrainCrashSettingVolume) == 0x000010, "Wrong alignment on ABrainCrashSettingVolume");
static_assert(sizeof(ABrainCrashSettingVolume) == 0x0002B0, "Wrong size on ABrainCrashSettingVolume");
static_assert(offsetof(ABrainCrashSettingVolume, TriggerTransform) == 0x000270, "Member 'ABrainCrashSettingVolume::TriggerTransform' has a wrong offset!");
static_assert(offsetof(ABrainCrashSettingVolume, Priority) == 0x0002A0, "Member 'ABrainCrashSettingVolume::Priority' has a wrong offset!");
static_assert(offsetof(ABrainCrashSettingVolume, bEnabled) == 0x0002A4, "Member 'ABrainCrashSettingVolume::bEnabled' has a wrong offset!");
static_assert(offsetof(ABrainCrashSettingVolume, bUnbound) == 0x0002A5, "Member 'ABrainCrashSettingVolume::bUnbound' has a wrong offset!");

// Class BattlePrototype.DebuggingItemScrResGroup
// 0x0000 (0x02D0 - 0x02D0)
class ADebuggingItemScrResGroup final : public ADebuggingItemGroup
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemScrResGroup">();
	}
	static class ADebuggingItemScrResGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemScrResGroup>();
	}
};
static_assert(alignof(ADebuggingItemScrResGroup) == 0x000008, "Wrong alignment on ADebuggingItemScrResGroup");
static_assert(sizeof(ADebuggingItemScrResGroup) == 0x0002D0, "Wrong size on ADebuggingItemScrResGroup");

// Class BattlePrototype.UIGeneralChoice
// 0x01A0 (0x0528 - 0x0388)
class UUIGeneralChoice : public UUIBase
{
public:
	uint8                                         Pad_388[0x1A0];                                    // 0x0388(0x01A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeIndex(int32 Index_0, class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UREDTextBlock* TextIndex);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextMain, class UVerticalBox* IndexListParent, class UImage* ImageGhost, class UImage* ImagepgBlack);
	void Notice_start1(const class FString& TextMain, const class FString& TextIndex);
	void Notice_start2(const class FString& TextMain, int32 DefaultIndex, const class FString& TextIndex1, const class FString& TextIndex2);
	void Start1(const class FString& TextMain, const class FString& TextIndex, bool Cancelable, int32 CancelIndex, bool IsFade);
	void Start2(const class FString& TextMain, int32 DefaultIndex, const class FString& TextIndex1, const class FString& TextIndex2, bool Cancelable, int32 CancelIndex, bool IsFade);
	void Start3(const class FString& TextMain, int32 DefaultIndex, const class FString& TextIndex1, const class FString& TextIndex2, const class FString& TextIndex3, bool Cancelable, int32 CancelIndex, bool IsFade);
	void Start4(const class FString& TextMain, int32 DefaultIndex, const class FString& TextIndex1, const class FString& TextIndex2, const class FString& TextIndex3, const class FString& TextIndex4, bool Cancelable, int32 CancelIndex, bool IsFade);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	int32 GetResult() const;
	bool IsCancel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGeneralChoice">();
	}
	static class UUIGeneralChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGeneralChoice>();
	}
};
static_assert(alignof(UUIGeneralChoice) == 0x000008, "Wrong alignment on UUIGeneralChoice");
static_assert(sizeof(UUIGeneralChoice) == 0x000528, "Wrong size on UUIGeneralChoice");

// Class BattlePrototype.BrainFieldEnemyLocation
// 0x0008 (0x0238 - 0x0230)
class ABrainFieldEnemyLocation final : public AActor
{
public:
	int32                                         LocationNo;                                        // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainFieldEnemyLocation">();
	}
	static class ABrainFieldEnemyLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrainFieldEnemyLocation>();
	}
};
static_assert(alignof(ABrainFieldEnemyLocation) == 0x000008, "Wrong alignment on ABrainFieldEnemyLocation");
static_assert(sizeof(ABrainFieldEnemyLocation) == 0x000238, "Wrong size on ABrainFieldEnemyLocation");
static_assert(offsetof(ABrainFieldEnemyLocation, LocationNo) == 0x000230, "Member 'ABrainFieldEnemyLocation::LocationNo' has a wrong offset!");

// Class BattlePrototype.EnemyDropData
// 0x0008 (0x0030 - 0x0028)
class UEnemyDropData final : public UObject
{
public:
	class UDataTable*                             RefEnemyDropTable;                                 // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool GetEnemyDropData(struct FEnemyDropDataCell* EnemyDropData, class FName ID);
	bool GetEnemyDropDataFromIndex(struct FEnemyDropDataCell* EnemyDropData, int32 Index_0);
	class FName GetIdFromIndex(int32 Index_0);
	bool LoadEnemyDropDataTable(const class FString& EnemyDropTablePath);

	bool IsValidResource() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyDropData">();
	}
	static class UEnemyDropData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyDropData>();
	}
};
static_assert(alignof(UEnemyDropData) == 0x000008, "Wrong alignment on UEnemyDropData");
static_assert(sizeof(UEnemyDropData) == 0x000030, "Wrong size on UEnemyDropData");
static_assert(offsetof(UEnemyDropData, RefEnemyDropTable) == 0x000028, "Member 'UEnemyDropData::RefEnemyDropTable' has a wrong offset!");

// Class BattlePrototype.BrainFieldEnemyLocationWave
// 0x0008 (0x0238 - 0x0230)
class ABrainFieldEnemyLocationWave final : public AActor
{
public:
	int32                                         LocationNo;                                        // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LongAway;                                          // 0x0234(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235[0x3];                                      // 0x0235(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainFieldEnemyLocationWave">();
	}
	static class ABrainFieldEnemyLocationWave* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrainFieldEnemyLocationWave>();
	}
};
static_assert(alignof(ABrainFieldEnemyLocationWave) == 0x000008, "Wrong alignment on ABrainFieldEnemyLocationWave");
static_assert(sizeof(ABrainFieldEnemyLocationWave) == 0x000238, "Wrong size on ABrainFieldEnemyLocationWave");
static_assert(offsetof(ABrainFieldEnemyLocationWave, LocationNo) == 0x000230, "Member 'ABrainFieldEnemyLocationWave::LocationNo' has a wrong offset!");
static_assert(offsetof(ABrainFieldEnemyLocationWave, LongAway) == 0x000234, "Member 'ABrainFieldEnemyLocationWave::LongAway' has a wrong offset!");

// Class BattlePrototype.PhantomBase
// 0x0020 (0x0650 - 0x0630)
class APhantomBase final : public AASCharacter
{
public:
	class UTeamComponent*                         Team;                                              // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHitCheckComponent*                     HitCheck;                                          // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHitCheckReceiverComponent*             HitCheckReceiver;                                  // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDynamicMaterialControllerComponent*    DynamicMaterialController;                         // 0x0640(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_648[0x8];                                      // 0x0648(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool OnCustomAttackTimingNotified(class FName CustomName);
	void RecvOnEndMaterialFade(class FName ParameterName);
	void RecvOnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void StartMaterialFade(bool bFadeIn, float FadeSec);
	void StartPhantom(class UAnimMontage* Montage, float FadeInSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhantomBase">();
	}
	static class APhantomBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APhantomBase>();
	}
};
static_assert(alignof(APhantomBase) == 0x000010, "Wrong alignment on APhantomBase");
static_assert(sizeof(APhantomBase) == 0x000650, "Wrong size on APhantomBase");
static_assert(offsetof(APhantomBase, Team) == 0x000628, "Member 'APhantomBase::Team' has a wrong offset!");
static_assert(offsetof(APhantomBase, HitCheck) == 0x000630, "Member 'APhantomBase::HitCheck' has a wrong offset!");
static_assert(offsetof(APhantomBase, HitCheckReceiver) == 0x000638, "Member 'APhantomBase::HitCheckReceiver' has a wrong offset!");
static_assert(offsetof(APhantomBase, DynamicMaterialController) == 0x000640, "Member 'APhantomBase::DynamicMaterialController' has a wrong offset!");

// Class BattlePrototype.UIEnemyListIndex
// 0x0040 (0x03C8 - 0x0388)
class UUIEnemyListIndex : public UUIBase
{
public:
	uint8                                         Pad_388[0x40];                                     // 0x0388(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UImage* ImageNewIcon, class UTextBlock* TextName);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEnemyListIndex">();
	}
	static class UUIEnemyListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEnemyListIndex>();
	}
};
static_assert(alignof(UUIEnemyListIndex) == 0x000008, "Wrong alignment on UUIEnemyListIndex");
static_assert(sizeof(UUIEnemyListIndex) == 0x0003C8, "Wrong size on UUIEnemyListIndex");

// Class BattlePrototype.BrainFieldManager
// 0x0970 (0x0BA0 - 0x0230)
class ABrainFieldManager : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxTrainEnemy;                                     // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugCollisionMode;                                // 0x023C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D[0x953];                                    // 0x023D(0x0953)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             M_EDBrainFieldBattleEndNativeEvent;                // 0x0B90(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	void Broadcast_EDBrainFieldBattleEndNativeEvent(EBrainFieldEndType EndType);
	void CalcJumpBrainFieldTransformEnemy(TArray<struct FTransform>* OutTransforms, const TArray<class AActor*>& Enemies, const TArray<struct FTransform>& NormalFieldTransforms, const TArray<bool>& IsWaves, const struct FVector& NormalFieldPlayerLocation);
	void CalcJumpBrainFieldTransformEnemyCustomCollision(TArray<struct FTransform>* OutTransforms, const TArray<class AActor*>& Enemies, const TArray<struct FTransform>& NormalFieldTransforms, const struct FVector& CustomCollisionPlayerLocation, float BrainFieldPlayerHeight);
	void CalcJumpBrainFieldTransformEnemyCustomCollision2(TArray<struct FTransform>* OutTransforms, const TArray<class AActor*>& Enemies, const struct FBrainFieldSettingsLocation& LocationSetting, float BrainFieldPlayerHeight, bool UserPlayer, class AActor* UserActor);
	void DebugCheckEnemyWaveTransformNativeCollision(const struct FTransform& PlayerTransform, struct FTransform* EnemyTransform, bool* ValidIndex, bool* UseCollision, int32 Index_0, bool LongAway);
	TArray<class AActor*> GetBrainFieldActors(class ULevelStreaming* Level);
	bool GetEnemyLocationWave(struct FTransform* EnemyTransform, int32 Index_0, bool LongAway);
	bool GetEnemyLocationWaveFromNo(struct FTransform* EnemyTransform, int32 LocationNo);
	int32 GetEnemyLocationWaveNum(bool LongAway);
	bool GetLocationSettings(const TArray<class AActor*>& TrainEnemyList, struct FBrainFieldSettingsLocation* OutSettings);
	void GetNormalLevelActorListNative(const struct FBrainFieldNormalLevelActorListInput& Inputs, TArray<class AActor*>* NormalLevelActors, TArray<class AActor*>* Characters, TArray<class AActor*>* Weapons, TArray<class AActor*>* PsychicObjects, TArray<class AActor*>* PsychicGrabs, TArray<class AActor*>* EffectBackround, TArray<class AActor*>* EffectBackroundMother);
	bool GetUserIsPlayer();
	bool InBranField_FromNative();
	bool IsInvokeBrainField_FromNative();
	bool IsPerformanceSequencer_FromNative();
	void IsValidEventCommandTypeAtBrainField(EEventTriggerCheckType EventCommandType, bool CheckBrainTalkEvent, bool* IsValid);
	void SelectJumpBrainFieldTrainEnemy(TArray<class AActor*>* TrainList, TArray<class AActor*>* NoTrainList, const TArray<class AActor*>& TargetEnemyListBattleField, const TArray<class AActor*>& TargetEnemyListBattleFieldWave, const TArray<class AActor*>& TargetEnemyListNormal, const struct FVector& NormalFieldPlayerLocation);
	void SetupEnemyWaveTransformNative(const TArray<class ARSCharacterBase*>& Enemies, const TArray<struct FBrainFieldWaveEnemyFlag>& EnemyFlags, const struct FTransform& PlayerTransform);
	void VisibleNormalActorsNative(bool IsVisible, int32 ObjectNum, int32& VisibleSplitIndex, const TArray<class AActor*>& ActorList, TArray<struct FBrainFieldRestoreFlag>& SettingFlags);

	bool GetEnemyLocation(struct FTransform* EnemyTransform, int32 Index_0) const;
	int32 GetEnemyLocationNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainFieldManager">();
	}
	static class ABrainFieldManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrainFieldManager>();
	}
};
static_assert(alignof(ABrainFieldManager) == 0x000008, "Wrong alignment on ABrainFieldManager");
static_assert(sizeof(ABrainFieldManager) == 0x000BA0, "Wrong size on ABrainFieldManager");
static_assert(offsetof(ABrainFieldManager, MaxTrainEnemy) == 0x000238, "Member 'ABrainFieldManager::MaxTrainEnemy' has a wrong offset!");
static_assert(offsetof(ABrainFieldManager, DebugCollisionMode) == 0x00023C, "Member 'ABrainFieldManager::DebugCollisionMode' has a wrong offset!");
static_assert(offsetof(ABrainFieldManager, M_EDBrainFieldBattleEndNativeEvent) == 0x000B90, "Member 'ABrainFieldManager::M_EDBrainFieldBattleEndNativeEvent' has a wrong offset!");

// Class BattlePrototype.BrainFieldSettingsActor
// 0x0230 (0x0460 - 0x0230)
class ABrainFieldSettingsActor final : public AActor
{
public:
	struct FBrainFieldSettings                    Settings;                                          // 0x0230(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bUseCollisionLocationOrigin;                       // 0x0258(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultPlayerStartLeftRight;                   // 0x0259(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25A[0x6];                                      // 0x025A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PlayerStartMain;                                   // 0x0260(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             PlayerStartLeft;                                   // 0x0290(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             PlayerStartRight;                                  // 0x02C0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnemyRelativeJump;                                // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0xF];                                      // 0x02F1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             EnemyStart01;                                      // 0x0300(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             EnemyStart02;                                      // 0x0330(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             EnemyStart03;                                      // 0x0360(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             EnemyStart04;                                      // 0x0390(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseRestoreTransform;                              // 0x03C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C1[0xF];                                      // 0x03C1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PlayerRestoreMain;                                 // 0x03D0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             PlayerRestoreLeft;                                 // 0x0400(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             PlayerRestoreRight;                                // 0x0430(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainFieldSettingsActor">();
	}
	static class ABrainFieldSettingsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrainFieldSettingsActor>();
	}
};
static_assert(alignof(ABrainFieldSettingsActor) == 0x000010, "Wrong alignment on ABrainFieldSettingsActor");
static_assert(sizeof(ABrainFieldSettingsActor) == 0x000460, "Wrong size on ABrainFieldSettingsActor");
static_assert(offsetof(ABrainFieldSettingsActor, Settings) == 0x000230, "Member 'ABrainFieldSettingsActor::Settings' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, bUseCollisionLocationOrigin) == 0x000258, "Member 'ABrainFieldSettingsActor::bUseCollisionLocationOrigin' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, bUseDefaultPlayerStartLeftRight) == 0x000259, "Member 'ABrainFieldSettingsActor::bUseDefaultPlayerStartLeftRight' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, PlayerStartMain) == 0x000260, "Member 'ABrainFieldSettingsActor::PlayerStartMain' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, PlayerStartLeft) == 0x000290, "Member 'ABrainFieldSettingsActor::PlayerStartLeft' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, PlayerStartRight) == 0x0002C0, "Member 'ABrainFieldSettingsActor::PlayerStartRight' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, bEnemyRelativeJump) == 0x0002F0, "Member 'ABrainFieldSettingsActor::bEnemyRelativeJump' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, EnemyStart01) == 0x000300, "Member 'ABrainFieldSettingsActor::EnemyStart01' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, EnemyStart02) == 0x000330, "Member 'ABrainFieldSettingsActor::EnemyStart02' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, EnemyStart03) == 0x000360, "Member 'ABrainFieldSettingsActor::EnemyStart03' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, EnemyStart04) == 0x000390, "Member 'ABrainFieldSettingsActor::EnemyStart04' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, bUseRestoreTransform) == 0x0003C0, "Member 'ABrainFieldSettingsActor::bUseRestoreTransform' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, PlayerRestoreMain) == 0x0003D0, "Member 'ABrainFieldSettingsActor::PlayerRestoreMain' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, PlayerRestoreLeft) == 0x000400, "Member 'ABrainFieldSettingsActor::PlayerRestoreLeft' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, PlayerRestoreRight) == 0x000430, "Member 'ABrainFieldSettingsActor::PlayerRestoreRight' has a wrong offset!");

// Class BattlePrototype.EnemyAiVariableComponent
// 0x0000 (0x00C0 - 0x00C0)
class UEnemyAiVariableComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyAiVariableComponent">();
	}
	static class UEnemyAiVariableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyAiVariableComponent>();
	}
};
static_assert(alignof(UEnemyAiVariableComponent) == 0x000008, "Wrong alignment on UEnemyAiVariableComponent");
static_assert(sizeof(UEnemyAiVariableComponent) == 0x0000C0, "Wrong size on UEnemyAiVariableComponent");

// Class BattlePrototype.UIConfigKeyboardMouseListIndex
// 0x00D8 (0x0460 - 0x0388)
class UUIConfigKeyboardMouseListIndex : public UUIBase
{
public:
	uint8                                         Pad_388[0xD8];                                     // 0x0388(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeMouseHit(class UREDOverlay* Pg_set_2, class UREDOverlay* Pg_set_3);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect_L, class UWidgetAnimation* AnimSelect_L_in, class UWidgetAnimation* AnimSelect_L_out, class UWidgetAnimation* AnimDecision_L, class UWidgetAnimation* AnimSelect_L2, class UWidgetAnimation* AnimCancel_L2, class UWidgetAnimation* AnimSelect_R, class UWidgetAnimation* AnimSelect_R_in, class UWidgetAnimation* AnimSelect_R_out, class UWidgetAnimation* AnimDecision_R, class UWidgetAnimation* AnimSelect_R2, class UWidgetAnimation* AnimCancel_R2, class UWidgetAnimation* AnimChange_L_R, class UWidgetAnimation* AnimChange_R_L, class UTextBlock* TextTitle);
	void InitializeThisFixed(class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimSelect2, class UWidgetAnimation* AnimSelect2_in, class UWidgetAnimation* AnimSelect2_out, class UTextBlock* TextTitle2, class UOverlay* OverlayFrameSet1, class UOverlay* OverlayFrameSet2);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigKeyboardMouseListIndex">();
	}
	static class UUIConfigKeyboardMouseListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigKeyboardMouseListIndex>();
	}
};
static_assert(alignof(UUIConfigKeyboardMouseListIndex) == 0x000008, "Wrong alignment on UUIConfigKeyboardMouseListIndex");
static_assert(sizeof(UUIConfigKeyboardMouseListIndex) == 0x000460, "Wrong size on UUIConfigKeyboardMouseListIndex");

// Class BattlePrototype.BrainMessageData
// 0x0008 (0x0030 - 0x0028)
class UBrainMessageData final : public UObject
{
public:
	class UBrainMessageDBAsset*                   brainMessageDataAsset_;                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	int32 GetAllThreadNum();
	class UBrainMessageDBAsset* GetBrainMessageDataAsset();
	struct FBrainMessageDBDataCell GetBrainMessageDataCellFromAsset(class FName RowName, bool* IsFound);
	bool LoadDataAsset(const class FString& DtPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainMessageData">();
	}
	static class UBrainMessageData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrainMessageData>();
	}
};
static_assert(alignof(UBrainMessageData) == 0x000008, "Wrong alignment on UBrainMessageData");
static_assert(sizeof(UBrainMessageData) == 0x000030, "Wrong size on UBrainMessageData");
static_assert(offsetof(UBrainMessageData, brainMessageDataAsset_) == 0x000028, "Member 'UBrainMessageData::brainMessageDataAsset_' has a wrong offset!");

// Class BattlePrototype.GimmickTriggerVolume
// 0x0028 (0x0290 - 0x0268)
class AGimmickTriggerVolume : public AVolume
{
public:
	class AMapGimmickObject*                      TargetMapGimmick;                                  // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMapGimmickManager*                     MapGimmickManager;                                 // 0x0270(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapGimmickPlayerPlace                        PositionToGimmick;                                 // 0x0278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOverlapAllPlayer;                                // 0x0279(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOverlapPartner;                                  // 0x027A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapGimmickFinishDir                          FinishAnimationDir;                                // 0x027B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UpdateIconOnly;                                    // 0x027C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseLimitIcon;                                    // 0x027D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E[0x2];                                      // 0x027E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           _TimerHandle;                                      // 0x0280(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DelayCollisionOn();
	void OnActorBeginOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorEndOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorHitFunc(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

	bool IsInPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickTriggerVolume">();
	}
	static class AGimmickTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickTriggerVolume>();
	}
};
static_assert(alignof(AGimmickTriggerVolume) == 0x000008, "Wrong alignment on AGimmickTriggerVolume");
static_assert(sizeof(AGimmickTriggerVolume) == 0x000290, "Wrong size on AGimmickTriggerVolume");
static_assert(offsetof(AGimmickTriggerVolume, TargetMapGimmick) == 0x000268, "Member 'AGimmickTriggerVolume::TargetMapGimmick' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerVolume, MapGimmickManager) == 0x000270, "Member 'AGimmickTriggerVolume::MapGimmickManager' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerVolume, PositionToGimmick) == 0x000278, "Member 'AGimmickTriggerVolume::PositionToGimmick' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerVolume, IsOverlapAllPlayer) == 0x000279, "Member 'AGimmickTriggerVolume::IsOverlapAllPlayer' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerVolume, IsOverlapPartner) == 0x00027A, "Member 'AGimmickTriggerVolume::IsOverlapPartner' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerVolume, FinishAnimationDir) == 0x00027B, "Member 'AGimmickTriggerVolume::FinishAnimationDir' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerVolume, UpdateIconOnly) == 0x00027C, "Member 'AGimmickTriggerVolume::UpdateIconOnly' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerVolume, IsUseLimitIcon) == 0x00027D, "Member 'AGimmickTriggerVolume::IsUseLimitIcon' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerVolume, _TimerHandle) == 0x000280, "Member 'AGimmickTriggerVolume::_TimerHandle' has a wrong offset!");

// Class BattlePrototype.BrainMessageDBAsset
// 0x0050 (0x0078 - 0x0028)
class UBrainMessageDBAsset final : public UObject
{
public:
	TMap<class FName, struct FBrainMessageDBDataCell> brainMessageDBMap_;                                // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	void Convert();
	void ConvertArray(struct FBrainMessageContentData* bMesData, const struct FBrainMessageRowDataCell& RowCell);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainMessageDBAsset">();
	}
	static class UBrainMessageDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrainMessageDBAsset>();
	}
};
static_assert(alignof(UBrainMessageDBAsset) == 0x000008, "Wrong alignment on UBrainMessageDBAsset");
static_assert(sizeof(UBrainMessageDBAsset) == 0x000078, "Wrong size on UBrainMessageDBAsset");
static_assert(offsetof(UBrainMessageDBAsset, brainMessageDBMap_) == 0x000028, "Member 'UBrainMessageDBAsset::brainMessageDBMap_' has a wrong offset!");

// Class BattlePrototype.UIDiscover
// 0x00B0 (0x0438 - 0x0388)
class UUIDiscover : public UUIBase
{
public:
	class AActor*                                 M_EmActor;                                         // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_EmPosData;                                       // 0x0390(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39C[0x9C];                                     // 0x039C(0x009C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceClose();
	void ForceCloseDead();
	void ForceVisible(bool Flag);
	int32 GetDiscoverIndex();
	void InitializeAnime(class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_discover, class UWidgetAnimation* In_discover, class UWidgetAnimation* Out_discover, class UWidgetAnimation* Default_undiscover, class UWidgetAnimation* In_undiscover, class UWidgetAnimation* Out_undiscover, class UWidgetAnimation* Default_undiscoverOver, class UWidgetAnimation* Out_undiscoverOver);
	void InitializeData(class UOverlay* FrameData);
	void SetDiscoverIcon(EDiscoverIconType Type);
	void SetDiscoverIndex(int32 Index_0);
	void SetMaxTimer(float Timer);
	void Start(EDiscoverType Type, class AActor* EmActor);
	void UpdatePosDiscover();
	void UpdateStateDiscover(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDiscover">();
	}
	static class UUIDiscover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDiscover>();
	}
};
static_assert(alignof(UUIDiscover) == 0x000008, "Wrong alignment on UUIDiscover");
static_assert(sizeof(UUIDiscover) == 0x000438, "Wrong size on UUIDiscover");
static_assert(offsetof(UUIDiscover, M_EmActor) == 0x000388, "Member 'UUIDiscover::M_EmActor' has a wrong offset!");
static_assert(offsetof(UUIDiscover, M_EmPosData) == 0x000390, "Member 'UUIDiscover::M_EmPosData' has a wrong offset!");

// Class BattlePrototype.BrainMessageParamManager
// 0x0068 (0x0090 - 0x0028)
class UBrainMessageParamManager final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnChangeNoticeUiStateDelegate;                     // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class URSGameInstance*                        GameInst_;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBrainMessageData*                      brainMessageData_;                                 // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALevelManager*                          LevelManager_;                                     // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FThreadData>                    ThreadDatas_;                                      // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x28];                                      // 0x0060(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseDebugReplyTime_DEBUG;                          // 0x0088(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugReplyTime_DEBUG;                              // 0x008C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddMessageIgnorConditions(const int32 TargetThread, const int32 MessageNum);
	void AllOpenMessageIgnorConditionsAndLock(const int32 TargetThread);
	bool CheckAppropriateThreadFromTitleID(class FName TitleID, EPlayerID MainPlayerID);
	void CheckMessageConditions(int32 ThreadNum, int32 MessageNum, bool IsReply, const bool IsNoticeEnable);
	void FinishWork(class URSGameInstance* GameInst);
	int32 GetAlreadyEmergenceNum(int32 ThreadNum);
	int32 GetAlreadyLookNum(int32 ThreadNum);
	const TArray<int32> GetEmergenceMessageNum(int32 ThreadNum);
	bool GetIsOpenThread(int32 ThreadNum);
	int32 GetNextMessageNum(int32 ThreadNum);
	void GetSortedIndexArray(EBrainMesSortType SortType, TArray<int32>* SortedIndexArray);
	int32 GetThreadNumFromThreadID(class FName ThreadID);
	bool GetTiedBondsEPID(int32 ThreadNum, int32 MessageNum, class FString* bondsBPReference);
	void InitAtExNewGame(EPlayerID MainPlayerID);
	void InitData(class URSGameInstance* GameInst);
	bool IsActiveThreadTimer(int32 ThreadNum);
	bool IsBanToReply(int32 ThreadNum, int32 MessageNum);
	bool IsReadyToReply(int32 ThreadNum, int32 MessageNum, bool IgnoreCommonTimming);
	void ResumeThreadTimer();
	void SetAlreadyEmergenceNum(int32 ThreadNum, int32 LookNum);
	void SetAlreadyLookNum(int32 ThreadNum, int32 LookNum);
	void SetIsOpenThred(int32 ThreadNum, bool IsOpen);
	void SetStopUpdatingMessageFlag(bool bStop);
	void StopThreadTimer();
	void UpdateMessageIndication(int32 ThreadNum, int32 MessageNum, bool IsReply, const bool IsNoticeEnable);
	void UpdateMessageIndication_Bind();
	void UpdateMessageIndication_BindInner(int32 ThreadNum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainMessageParamManager">();
	}
	static class UBrainMessageParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrainMessageParamManager>();
	}
};
static_assert(alignof(UBrainMessageParamManager) == 0x000008, "Wrong alignment on UBrainMessageParamManager");
static_assert(sizeof(UBrainMessageParamManager) == 0x000090, "Wrong size on UBrainMessageParamManager");
static_assert(offsetof(UBrainMessageParamManager, OnChangeNoticeUiStateDelegate) == 0x000028, "Member 'UBrainMessageParamManager::OnChangeNoticeUiStateDelegate' has a wrong offset!");
static_assert(offsetof(UBrainMessageParamManager, GameInst_) == 0x000038, "Member 'UBrainMessageParamManager::GameInst_' has a wrong offset!");
static_assert(offsetof(UBrainMessageParamManager, brainMessageData_) == 0x000040, "Member 'UBrainMessageParamManager::brainMessageData_' has a wrong offset!");
static_assert(offsetof(UBrainMessageParamManager, LevelManager_) == 0x000048, "Member 'UBrainMessageParamManager::LevelManager_' has a wrong offset!");
static_assert(offsetof(UBrainMessageParamManager, ThreadDatas_) == 0x000050, "Member 'UBrainMessageParamManager::ThreadDatas_' has a wrong offset!");
static_assert(offsetof(UBrainMessageParamManager, bUseDebugReplyTime_DEBUG) == 0x000088, "Member 'UBrainMessageParamManager::bUseDebugReplyTime_DEBUG' has a wrong offset!");
static_assert(offsetof(UBrainMessageParamManager, DebugReplyTime_DEBUG) == 0x00008C, "Member 'UBrainMessageParamManager::DebugReplyTime_DEBUG' has a wrong offset!");

// Class BattlePrototype.BrainTalkBattleManager
// 0x0980 (0x09A8 - 0x0028)
class UBrainTalkBattleManager final : public UObject
{
public:
	class URSGameInstance*                        _gameInstance;                                     // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSystemBrainTalkManageStructParam> M_BrainTalkSystemConditionManageList;              // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSystemBrainTalkManageStructParam> M_BrainTalkEnemyConditionManageList;               // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSystemBrainTalkManageStructParam> M_BrainTalkTutorialConditionManageList;            // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSystemBrainTalkManageStructParam> M_BrainTalkGimmickConditionManageList;             // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkOnceCheck_Category           M_BrainTalkOnceCheck;                              // 0x0070(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_WataruHarukaExistenceProgressID> M_BrainTalkBt_WataruHarukaNoExistenceProgressIDList; // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_InvalidProgressID> M_BrainTalkBt_InvalidProgressIDList;               // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkCh_InvalidProgressID> M_BrainTalkCh_InvalidProgressIDList;               // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<EBrainTalkChGroup>                     M_BrainTalkCharacterGroup;                         // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_Hp30p>             M_BrainTalkBt_Hp30pList;                           // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_Hp30pList_Param;                     // 0x00D0(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillByEn>          M_BrainTalkBt_KillByEnList;                        // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillByEnList_Param;                  // 0x00F0(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_BrainCrashByEn>    M_BrainTalkBt_BrainCrashByEnList;                  // 0x0100(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_BrainCrashByEnList_Param;            // 0x0110(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_BadStateByEn>      M_BrainTalkBt_BadStateByEnList;                    // 0x0120(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_BadStateByEnList_Param;              // 0x0130(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_BadStateForEn>     M_BrainTalkBt_BadStateForEnList;                   // 0x0140(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_BadStateForEnList_Param;             // 0x0150(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_Recovery>          M_BrainTalkBt_RecoveryList;                        // 0x0160(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_RecoveryList_Param;                  // 0x0170(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_Revival>           M_BrainTalkBt_RevivalList;                         // 0x0180(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_RevivalList_Param;                   // 0x0190(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_BFActivate>        M_BrainTalkBt_BFActivateList;                      // 0x01A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_BFActivateList_Param;                // 0x01B0(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_SasCombo>          M_BrainTalkBt_SasComboList;                        // 0x01C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_SasComboList_Param;                  // 0x01D0(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_PsychicCombo>      M_BrainTalkBt_PsychicComboList;                    // 0x01E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_PsychicComboList_Param;              // 0x01F0(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DriveActive>       M_BrainTalkBt_DriveActiveList;                     // 0x0200(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DriveActiveList_Param;               // 0x0210(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_HiKizunaEffect>    M_BrainTalkBt_HiKizunaEffectList;                  // 0x0220(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_HiKizunaEffectList_Param;            // 0x0230(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_TouchBFWall>       M_BrainTalkBt_TouchBFWallList;                     // 0x0240(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_TouchBFWallList_Param;               // 0x0250(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_NearCC>            M_BrainTalkBt_NearCCList;                          // 0x0260(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_NearCCList_Param;                    // 0x0270(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_BattleEscape>      M_BrainTalkBt_BattleEscapeList;                    // 0x0280(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_BattleEscapeList_Param;              // 0x0290(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KizunaLvUp>        M_BrainTalkBt_KizunaLvUpList;                      // 0x02A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KizunaLvUpList_Param;                // 0x02B0(0x0010)(NativeAccessSpecifierPrivate)
	EBrainTalkKizunaLvUpFlow                      M_KizunaLvUpFlow;                                  // 0x02C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_KizunaLvUpReplayTime;                            // 0x02C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<EPlayerID>                             M_KizunaLvUpReplayPlayerList;                      // 0x02C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DamageTakeOver>    M_BrainTalkBt_DamageTakeOverList;                  // 0x02D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DamageTakeOverList_Param;            // 0x02E8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_LvUp>              M_BrainTalkBt_LvUpList;                            // 0x02F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_LvUpList_Param;                      // 0x0308(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DeadInarow>        M_BrainTalkBt_DeadInarowList;                      // 0x0318(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DeadInarowList_Param;                // 0x0328(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_SallyTimes>        M_BrainTalkBt_SallyTimesList;                      // 0x0338(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_SallyTimesList_Param;                // 0x0348(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_NoSallyTimes>      M_BrainTalkBt_NoSallyTimesList;                    // 0x0358(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_NoSallyTimesList_Param;              // 0x0368(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_JumpOff>           M_BrainTalkBt_JumpOffList;                         // 0x0378(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_JumpOffList_Param;                   // 0x0388(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_PLChangeAttachment> M_BrainTalkBt_PLChangeAttachmentList;              // 0x0398(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_PLChangeAttachmentList_Param;        // 0x03A8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_PLDead>            M_BrainTalkBt_PLDeadList;                          // 0x03B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_PLDeadList_Param;                    // 0x03C8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillEnRest>        M_BrainTalkBt_KillEnRestList;                      // 0x03D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillEnRestList_Param;                // 0x03E8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillAllEnForPT>    M_BrainTalkBt_KillAllEnForPTList;                  // 0x03F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillAllEnForPTList_Param;            // 0x0408(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillAllEnForPL>    M_BrainTalkBt_KillAllEnForPLList;                  // 0x0418(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillAllEnForPLList_Param;            // 0x0428(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillAllEnShortTime> M_BrainTalkBt_KillAllEnShortTimeList;              // 0x0438(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillAllEnShortTimeList_Param;        // 0x0448(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillAllEnStrEn>    M_BrainTalkBt_KillAllEnStrEnList;                  // 0x0458(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillAllEnStrEnList_Param;            // 0x0468(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillAllEnManyEn>   M_BrainTalkBt_KillAllEnManyEnList;                 // 0x0478(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillAllEnManyEnList_Param;           // 0x0488(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillAllEnManyWeakEn> M_BrainTalkBt_KillAllEnManyWeakEnList;             // 0x0498(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillAllEnManyWeakEnList_Param;       // 0x04A8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillEnStrategy>    M_BrainTalkBt_KillEnStrategyList;                  // 0x04B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillEnStrategyList_Param;            // 0x04C8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DiscStrEn>         M_BrainTalkBt_DiscStrEnList;                       // 0x04D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DiscStrEnList_Param;                 // 0x04E8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DestroyShell>      M_BrainTalkBt_DestroyShellList;                    // 0x04F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DestroyShellList_Param;              // 0x0508(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_EnemyDown>         M_BrainTalkBt_EnemyDownList;                       // 0x0518(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_EnemyDownList_Param;                 // 0x0528(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DiscEn>            M_BrainTalkBt_DiscEnList;                          // 0x0538(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DiscEnList_Param;                    // 0x0548(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DispCrashTrg>      M_BrainTalkBt_DispCrashTrgList;                    // 0x0558(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DispCrashTrgList_Param;              // 0x0568(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillEnemyBC>       M_BrainTalkBt_KillEnemyBCList;                     // 0x0578(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillEnemyBCList_Param;               // 0x0588(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_EnBerserkSign>     M_BrainTalkBt_EnBerserkSignList;                   // 0x0598(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_EnBerserkSignList_Param;             // 0x05A8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_EnBerserk>         M_BrainTalkBt_EnBerserkList;                       // 0x05B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_EnBerserkList_Param;                 // 0x05C8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_AttackEnShell>     M_BrainTalkBt_AttackEnShellList;                   // 0x05D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_AttackEnShellList_Param;             // 0x05E8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_AttackEnWeak>      M_BrainTalkBt_AttackEnWeakList;                    // 0x05F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_AttackEnWeakList_Param;              // 0x0608(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_FirstStrike>       M_BrainTalkBt_FirstStrikeList;                     // 0x0618(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_FirstStrikeList_Param;               // 0x0628(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_OilEnAtkFire>      M_BrainTalkBt_OilEnAtkFireList;                    // 0x0638(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_OilEnAtkFireList_Param;              // 0x0648(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_WaterEnAtkElectric> M_BrainTalkBt_WaterEnAtkElectricList;              // 0x0658(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_WaterEnAtkElectricList_Param;        // 0x0668(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DiscStealth>       M_BrainTalkBt_DiscStealthList;                     // 0x0678(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DiscStealthList_Param;               // 0x0688(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DiscSasValidEn>    M_BrainTalkBt_DiscSasValidEnList;                  // 0x0698(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DiscSasValidEnList_Param;            // 0x06A8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_StealthLosePL>     M_BrainTalkBt_StealthLosePLList;                   // 0x06B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_StealthLosePLList_Param;             // 0x06C8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_SasNoUse>          M_BrainTalkBt_SasNoUseList;                        // 0x06D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_SasNoUseList_Param;                  // 0x06E8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_SasContinuity>     M_BrainTalkBt_SasContinuityList;                   // 0x06F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_SasContinuityList_Param;             // 0x0708(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_SasHoloPossible>   M_BrainTalkBt_SasHoloPossibleList;                 // 0x0718(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_SasHoloPossibleList_Param;           // 0x0728(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_SasHoloPursuit>    M_BrainTalkBt_SasHoloPursuitList;                  // 0x0738(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_SasHoloPursuitList_Param;            // 0x0748(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_GetItem>           M_BrainTalkBt_GetItemList;                         // 0x0758(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_GetItemList_Param;                   // 0x0768(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_EnemyDrop>         M_BrainTalkBt_EnemyDropList;                       // 0x0778(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_EnemyDropList_Param;                 // 0x0788(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_UnopenedTreasure>  M_BrainTalkBt_UnopenedTreasureList;                // 0x0798(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_UnopenedTreasureList_Param;          // 0x07A8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_GatherPoint>       M_BrainTalkBt_GatherPointList;                     // 0x07B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_GatherPointList_Param;               // 0x07C8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_RecoveryItemZero>  M_BrainTalkBt_RecoveryItemZeroList;                // 0x07D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_RecoveryItemZeroList_Param;          // 0x07E8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DiscQuestEnemy>    M_BrainTalkBt_DiscQuestEnemyList;                  // 0x07F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DiscQuestEnemyList_Param;            // 0x0808(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_ClearQuest>        M_BrainTalkBt_ClearQuestList;                      // 0x0818(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_ClearQuestList_Param;                // 0x0828(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_BirthKizunaEp>     M_BrainTalkBt_BirthKizunaEpList;                   // 0x0838(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<EPlayerID>                             M_BrainTalkBt_BirthKizunaEp_FadePlayList;          // 0x0848(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_BirthKizunaEpList_Param;             // 0x0858(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillQuestTgtEn>    M_BrainTalkBt_KillQuestTgtEnList;                  // 0x0868(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillQuestTgtEnList_Param;            // 0x0878(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_GetQuestTgtItem>   M_BrainTalkBt_GetQuestTgtItemList;                 // 0x0888(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_GetQuestTgtItemList_Param;           // 0x0898(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_PTChangeAttachment> M_BrainTalkBt_PTChangeAttachmentList;              // 0x08A8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_PTChangeAttachmentList_Param;        // 0x08B8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DriveGaugeMax>     M_BrainTalkBt_DriveGaugeMaxList;                   // 0x08C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DriveGaugeMaxList_Param;             // 0x08D8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_EquipStrongestWeapon> M_BrainTalkBt_EquipStrongestWeaponList;            // 0x08E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_EquipStrongestWeaponList_Param;      // 0x08F8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_WaitingVoice>      M_BrainTalkBt_WaitingVoiceList;                    // 0x0908(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_WaitingVoiceList_Param;              // 0x0918(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_RecoveryHpToPL>    M_BrainTalkBt_RecoveryHpToPLList;                  // 0x0928(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_RecoveryHpToPLList_Param;            // 0x0938(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_RecoveryAbToPL>    M_BrainTalkBt_RecoveryAbToPLList;                  // 0x0948(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_RecoveryAbToPLList_Param;            // 0x0958(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkEm_ConditionParam>    M_BrainTalkEm_ConditionParamList;                  // 0x0968(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkTutorial_ConditionParam> M_BrainTalkTutorial_ConditionParamList;            // 0x0978(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkGimmick_ConditionParam> M_BrainTalkGimmick_ConditionParamList;             // 0x0988(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_998[0x10];                                     // 0x0998(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainTalkBattleManager">();
	}
	static class UBrainTalkBattleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrainTalkBattleManager>();
	}
};
static_assert(alignof(UBrainTalkBattleManager) == 0x000008, "Wrong alignment on UBrainTalkBattleManager");
static_assert(sizeof(UBrainTalkBattleManager) == 0x0009A8, "Wrong size on UBrainTalkBattleManager");
static_assert(offsetof(UBrainTalkBattleManager, _gameInstance) == 0x000028, "Member 'UBrainTalkBattleManager::_gameInstance' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkSystemConditionManageList) == 0x000030, "Member 'UBrainTalkBattleManager::M_BrainTalkSystemConditionManageList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkEnemyConditionManageList) == 0x000040, "Member 'UBrainTalkBattleManager::M_BrainTalkEnemyConditionManageList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkTutorialConditionManageList) == 0x000050, "Member 'UBrainTalkBattleManager::M_BrainTalkTutorialConditionManageList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkGimmickConditionManageList) == 0x000060, "Member 'UBrainTalkBattleManager::M_BrainTalkGimmickConditionManageList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkOnceCheck) == 0x000070, "Member 'UBrainTalkBattleManager::M_BrainTalkOnceCheck' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_WataruHarukaNoExistenceProgressIDList) == 0x000080, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_WataruHarukaNoExistenceProgressIDList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_InvalidProgressIDList) == 0x000090, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_InvalidProgressIDList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkCh_InvalidProgressIDList) == 0x0000A0, "Member 'UBrainTalkBattleManager::M_BrainTalkCh_InvalidProgressIDList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkCharacterGroup) == 0x0000B0, "Member 'UBrainTalkBattleManager::M_BrainTalkCharacterGroup' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_Hp30pList) == 0x0000C0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_Hp30pList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_Hp30pList_Param) == 0x0000D0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_Hp30pList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillByEnList) == 0x0000E0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillByEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillByEnList_Param) == 0x0000F0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillByEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BrainCrashByEnList) == 0x000100, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BrainCrashByEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BrainCrashByEnList_Param) == 0x000110, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BrainCrashByEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BadStateByEnList) == 0x000120, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BadStateByEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BadStateByEnList_Param) == 0x000130, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BadStateByEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BadStateForEnList) == 0x000140, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BadStateForEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BadStateForEnList_Param) == 0x000150, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BadStateForEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RecoveryList) == 0x000160, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RecoveryList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RecoveryList_Param) == 0x000170, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RecoveryList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RevivalList) == 0x000180, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RevivalList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RevivalList_Param) == 0x000190, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RevivalList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BFActivateList) == 0x0001A0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BFActivateList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BFActivateList_Param) == 0x0001B0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BFActivateList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasComboList) == 0x0001C0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasComboList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasComboList_Param) == 0x0001D0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasComboList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_PsychicComboList) == 0x0001E0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_PsychicComboList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_PsychicComboList_Param) == 0x0001F0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_PsychicComboList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DriveActiveList) == 0x000200, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DriveActiveList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DriveActiveList_Param) == 0x000210, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DriveActiveList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_HiKizunaEffectList) == 0x000220, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_HiKizunaEffectList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_HiKizunaEffectList_Param) == 0x000230, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_HiKizunaEffectList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_TouchBFWallList) == 0x000240, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_TouchBFWallList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_TouchBFWallList_Param) == 0x000250, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_TouchBFWallList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_NearCCList) == 0x000260, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_NearCCList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_NearCCList_Param) == 0x000270, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_NearCCList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BattleEscapeList) == 0x000280, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BattleEscapeList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BattleEscapeList_Param) == 0x000290, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BattleEscapeList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KizunaLvUpList) == 0x0002A0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KizunaLvUpList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KizunaLvUpList_Param) == 0x0002B0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KizunaLvUpList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_KizunaLvUpFlow) == 0x0002C0, "Member 'UBrainTalkBattleManager::M_KizunaLvUpFlow' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_KizunaLvUpReplayTime) == 0x0002C4, "Member 'UBrainTalkBattleManager::M_KizunaLvUpReplayTime' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_KizunaLvUpReplayPlayerList) == 0x0002C8, "Member 'UBrainTalkBattleManager::M_KizunaLvUpReplayPlayerList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DamageTakeOverList) == 0x0002D8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DamageTakeOverList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DamageTakeOverList_Param) == 0x0002E8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DamageTakeOverList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_LvUpList) == 0x0002F8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_LvUpList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_LvUpList_Param) == 0x000308, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_LvUpList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DeadInarowList) == 0x000318, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DeadInarowList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DeadInarowList_Param) == 0x000328, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DeadInarowList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SallyTimesList) == 0x000338, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SallyTimesList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SallyTimesList_Param) == 0x000348, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SallyTimesList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_NoSallyTimesList) == 0x000358, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_NoSallyTimesList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_NoSallyTimesList_Param) == 0x000368, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_NoSallyTimesList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_JumpOffList) == 0x000378, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_JumpOffList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_JumpOffList_Param) == 0x000388, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_JumpOffList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_PLChangeAttachmentList) == 0x000398, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_PLChangeAttachmentList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_PLChangeAttachmentList_Param) == 0x0003A8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_PLChangeAttachmentList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_PLDeadList) == 0x0003B8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_PLDeadList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_PLDeadList_Param) == 0x0003C8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_PLDeadList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillEnRestList) == 0x0003D8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillEnRestList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillEnRestList_Param) == 0x0003E8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillEnRestList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnForPTList) == 0x0003F8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnForPTList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnForPTList_Param) == 0x000408, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnForPTList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnForPLList) == 0x000418, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnForPLList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnForPLList_Param) == 0x000428, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnForPLList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnShortTimeList) == 0x000438, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnShortTimeList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnShortTimeList_Param) == 0x000448, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnShortTimeList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnStrEnList) == 0x000458, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnStrEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnStrEnList_Param) == 0x000468, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnStrEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnManyEnList) == 0x000478, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnManyEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnManyEnList_Param) == 0x000488, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnManyEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnManyWeakEnList) == 0x000498, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnManyWeakEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnManyWeakEnList_Param) == 0x0004A8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnManyWeakEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillEnStrategyList) == 0x0004B8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillEnStrategyList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillEnStrategyList_Param) == 0x0004C8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillEnStrategyList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscStrEnList) == 0x0004D8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscStrEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscStrEnList_Param) == 0x0004E8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscStrEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DestroyShellList) == 0x0004F8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DestroyShellList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DestroyShellList_Param) == 0x000508, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DestroyShellList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EnemyDownList) == 0x000518, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EnemyDownList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EnemyDownList_Param) == 0x000528, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EnemyDownList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscEnList) == 0x000538, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscEnList_Param) == 0x000548, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DispCrashTrgList) == 0x000558, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DispCrashTrgList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DispCrashTrgList_Param) == 0x000568, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DispCrashTrgList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillEnemyBCList) == 0x000578, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillEnemyBCList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillEnemyBCList_Param) == 0x000588, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillEnemyBCList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EnBerserkSignList) == 0x000598, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EnBerserkSignList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EnBerserkSignList_Param) == 0x0005A8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EnBerserkSignList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EnBerserkList) == 0x0005B8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EnBerserkList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EnBerserkList_Param) == 0x0005C8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EnBerserkList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_AttackEnShellList) == 0x0005D8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_AttackEnShellList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_AttackEnShellList_Param) == 0x0005E8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_AttackEnShellList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_AttackEnWeakList) == 0x0005F8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_AttackEnWeakList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_AttackEnWeakList_Param) == 0x000608, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_AttackEnWeakList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_FirstStrikeList) == 0x000618, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_FirstStrikeList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_FirstStrikeList_Param) == 0x000628, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_FirstStrikeList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_OilEnAtkFireList) == 0x000638, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_OilEnAtkFireList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_OilEnAtkFireList_Param) == 0x000648, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_OilEnAtkFireList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_WaterEnAtkElectricList) == 0x000658, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_WaterEnAtkElectricList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_WaterEnAtkElectricList_Param) == 0x000668, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_WaterEnAtkElectricList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscStealthList) == 0x000678, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscStealthList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscStealthList_Param) == 0x000688, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscStealthList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscSasValidEnList) == 0x000698, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscSasValidEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscSasValidEnList_Param) == 0x0006A8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscSasValidEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_StealthLosePLList) == 0x0006B8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_StealthLosePLList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_StealthLosePLList_Param) == 0x0006C8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_StealthLosePLList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasNoUseList) == 0x0006D8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasNoUseList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasNoUseList_Param) == 0x0006E8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasNoUseList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasContinuityList) == 0x0006F8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasContinuityList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasContinuityList_Param) == 0x000708, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasContinuityList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasHoloPossibleList) == 0x000718, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasHoloPossibleList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasHoloPossibleList_Param) == 0x000728, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasHoloPossibleList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasHoloPursuitList) == 0x000738, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasHoloPursuitList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasHoloPursuitList_Param) == 0x000748, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasHoloPursuitList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GetItemList) == 0x000758, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GetItemList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GetItemList_Param) == 0x000768, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GetItemList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EnemyDropList) == 0x000778, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EnemyDropList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EnemyDropList_Param) == 0x000788, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EnemyDropList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_UnopenedTreasureList) == 0x000798, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_UnopenedTreasureList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_UnopenedTreasureList_Param) == 0x0007A8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_UnopenedTreasureList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GatherPointList) == 0x0007B8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GatherPointList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GatherPointList_Param) == 0x0007C8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GatherPointList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RecoveryItemZeroList) == 0x0007D8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RecoveryItemZeroList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RecoveryItemZeroList_Param) == 0x0007E8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RecoveryItemZeroList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscQuestEnemyList) == 0x0007F8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscQuestEnemyList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscQuestEnemyList_Param) == 0x000808, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscQuestEnemyList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_ClearQuestList) == 0x000818, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_ClearQuestList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_ClearQuestList_Param) == 0x000828, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_ClearQuestList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BirthKizunaEpList) == 0x000838, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BirthKizunaEpList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BirthKizunaEp_FadePlayList) == 0x000848, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BirthKizunaEp_FadePlayList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BirthKizunaEpList_Param) == 0x000858, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BirthKizunaEpList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillQuestTgtEnList) == 0x000868, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillQuestTgtEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillQuestTgtEnList_Param) == 0x000878, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillQuestTgtEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GetQuestTgtItemList) == 0x000888, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GetQuestTgtItemList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GetQuestTgtItemList_Param) == 0x000898, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GetQuestTgtItemList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_PTChangeAttachmentList) == 0x0008A8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_PTChangeAttachmentList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_PTChangeAttachmentList_Param) == 0x0008B8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_PTChangeAttachmentList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DriveGaugeMaxList) == 0x0008C8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DriveGaugeMaxList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DriveGaugeMaxList_Param) == 0x0008D8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DriveGaugeMaxList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EquipStrongestWeaponList) == 0x0008E8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EquipStrongestWeaponList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EquipStrongestWeaponList_Param) == 0x0008F8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EquipStrongestWeaponList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_WaitingVoiceList) == 0x000908, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_WaitingVoiceList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_WaitingVoiceList_Param) == 0x000918, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_WaitingVoiceList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RecoveryHpToPLList) == 0x000928, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RecoveryHpToPLList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RecoveryHpToPLList_Param) == 0x000938, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RecoveryHpToPLList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RecoveryAbToPLList) == 0x000948, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RecoveryAbToPLList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RecoveryAbToPLList_Param) == 0x000958, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RecoveryAbToPLList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkEm_ConditionParamList) == 0x000968, "Member 'UBrainTalkBattleManager::M_BrainTalkEm_ConditionParamList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkTutorial_ConditionParamList) == 0x000978, "Member 'UBrainTalkBattleManager::M_BrainTalkTutorial_ConditionParamList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkGimmick_ConditionParamList) == 0x000988, "Member 'UBrainTalkBattleManager::M_BrainTalkGimmick_ConditionParamList' has a wrong offset!");

// Class BattlePrototype.DebugPrintComponent
// 0x0010 (0x00D0 - 0x00C0)
class UDebugPrintComponent final : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DrawHUD();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugPrintComponent">();
	}
	static class UDebugPrintComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugPrintComponent>();
	}
};
static_assert(alignof(UDebugPrintComponent) == 0x000008, "Wrong alignment on UDebugPrintComponent");
static_assert(sizeof(UDebugPrintComponent) == 0x0000D0, "Wrong size on UDebugPrintComponent");

// Class BattlePrototype.UIItemListIndex
// 0x00C8 (0x0450 - 0x0388)
class UUIItemListIndex : public UUIBase
{
public:
	struct FLinearColor                           ColorNumHave;                                      // 0x0388(0x0010)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ColorMaxNumHave;                                   // 0x0398(0x0010)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0xA8];                                     // 0x03A8(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeOverlay(class UREDOverlay* ListLset, class UREDOverlay* ListRset);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelectL, class UWidgetAnimation* AnimSelectInL, class UBorder* borderHaveL, class UWidgetAnimation* AnimSelectR, class UWidgetAnimation* AnimSelectInR, class UBorder* borderHaveR, class UWidgetAnimation* AnimChangeR, class UWidgetAnimation* AnimChangeL, class UImage* ImageNewIconL, class UTextBlock* TextItemNameL, class UTextBlock* TextNumHaveL, class UOverlay* OverlayR, class UImage* ImageNewIconR, class UTextBlock* TextItemNameR, class UTextBlock* TextNumHaveR);
	bool SetItemInfoL(const class FName& ItemId, int32 ItemIndex);
	bool SetItemInfoR(const class FName& ItemId, int32 ItemIndex);
	void UpdateStateThis();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemListIndex">();
	}
	static class UUIItemListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemListIndex>();
	}
};
static_assert(alignof(UUIItemListIndex) == 0x000008, "Wrong alignment on UUIItemListIndex");
static_assert(sizeof(UUIItemListIndex) == 0x000450, "Wrong size on UUIItemListIndex");
static_assert(offsetof(UUIItemListIndex, ColorNumHave) == 0x000388, "Member 'UUIItemListIndex::ColorNumHave' has a wrong offset!");
static_assert(offsetof(UUIItemListIndex, ColorMaxNumHave) == 0x000398, "Member 'UUIItemListIndex::ColorMaxNumHave' has a wrong offset!");

// Class BattlePrototype.BrainTalkManager
// 0x00A8 (0x02D8 - 0x0230)
class ABrainTalkManager : public ARSActorSystemBase
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URSGameInstance*                        _gameInstance;                                     // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrainTalkBattleManager*                M_pBrainTalkBattleManager;                         // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalk_CategoryDatatable>   M_BrainTalkMasterDataQueCategoryDatatableList;     // 0x0258(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkMasterData>           M_BrainTalkMasterDataQueList;                      // 0x0268(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_StrongestWeaponIdList;                           // 0x0280(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isUpdateEquipIdList;                             // 0x0290(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerInfo>                    M_OpenMenuWindowEquipIdList;                       // 0x0298(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_dataTable;                                       // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkPriority                            M_Priority;                                        // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_ReferenceIndex;                                  // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_massageWaitTime;                                 // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_isPauseBrainTalk;                                // 0x02BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_isFinishBrainTalk;                               // 0x02BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_isNoStopBrainTalk;                               // 0x02BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF[0x1];                                      // 0x02BF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBrainTalkBt_PlayInfo>          M_BrainTalkBt_PlayReqList;                         // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_isStartTalkEventPauseBT;                         // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_isStartTalkEventKeepPlayingBT;                   // 0x02D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_DebbugBrainTalkAllInvalidFlag;                   // 0x02D2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_DebbugBrainTalkBTInvalidFlag;                    // 0x02D3(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_DebugDispBrainTalkLogFlag;                       // 0x02D4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D5[0x3];                                      // 0x02D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBrainTalkMasterDataQueList(const struct FBrainTalkMasterData& Data, const struct FBrainTalk_CategoryDatatable& CategoryDatatable);
	void BPFL_PauseBrainTalkAtEndTalkEventAfter();
	void BPFL_PauseBrainTalkAtStartTalkEventBefore();
	bool BrainTalkBt_AttackEnShell();
	bool BrainTalkBt_AttackEnWeak();
	bool BrainTalkBt_BadStateByEn(const EPlayerID BadStateMember, const EHCSkillAttribute BadState);
	bool BrainTalkBt_BadStateForEn(const EPlayerID BadStateMember, const EHCSkillAttribute BadState);
	bool BrainTalkBt_BattleEscape();
	bool BrainTalkBt_BFActivate();
	bool BrainTalkBt_BirthKizunaEp(const EPlayerID EpCharacter);
	bool BrainTalkBt_BrainCrashByEn();
	bool BrainTalkBt_ClearQuest();
	bool BrainTalkBt_DamageTakeOver(const EPlayerID TakeOverCharacter);
	bool BrainTalkBt_DeadInarow(const int32 DeadNum);
	bool BrainTalkBt_DestroyShell();
	bool BrainTalkBt_DiscEn();
	bool BrainTalkBt_DiscQuestEnemy();
	bool BrainTalkBt_DiscSasValidEn(E_SASKindNative SasEffect);
	bool BrainTalkBt_DiscStealth();
	bool BrainTalkBt_DiscStrEn();
	bool BrainTalkBt_DispCrashTrg();
	bool BrainTalkBt_DriveActive();
	bool BrainTalkBt_DriveGaugeMax();
	bool BrainTalkBt_EnBerserk();
	bool BrainTalkBt_EnBerserkSign();
	bool BrainTalkBt_EnemyDown(const EPlayerID DownCharacter);
	bool BrainTalkBt_EnemyDrop(const EItemRarity Rarity);
	bool BrainTalkBt_EquipStrongestWeapon(const EPlayerID EquiCharacter);
	bool BrainTalkBt_FirstStrike();
	bool BrainTalkBt_GatherPoint();
	bool BrainTalkBt_GetItem(const EItemRarity Rarity);
	bool BrainTalkBt_GetQuestTgtItem();
	bool BrainTalkBt_HiKizunaEffect(const EPlayerID HologramPlayerID);
	bool BrainTalkBt_Hp30p();
	bool BrainTalkBt_JumpOff();
	bool BrainTalkBt_KillAllEnForPL();
	bool BrainTalkBt_KillAllEnForPT(const EPlayerID KillCharacter);
	bool BrainTalkBt_KillAllEnManyEn(const EPlayerID KillCharacter);
	bool BrainTalkBt_KillAllEnManyWeakEn(const EPlayerID KillCharacter);
	bool BrainTalkBt_KillAllEnShortTime(const EPlayerID KillCharacter);
	bool BrainTalkBt_KillAllEnStrEn(const EPlayerID KillCharacter);
	bool BrainTalkBt_KillByEn();
	bool BrainTalkBt_KillEnemyBC();
	bool BrainTalkBt_KillEnRest(const EPlayerID KillCharacter);
	bool BrainTalkBt_KillEnStrategy();
	bool BrainTalkBt_KillQuestTgtEn();
	bool BrainTalkBt_KizunaLvUp(const EPlayerID KizunaLvUpCharacter, const bool IsRetry);
	bool BrainTalkBt_LvUp(const EPlayerID LvUpCharacter);
	bool BrainTalkBt_NearCC();
	bool BrainTalkBt_NoSallyTimes(const EPlayerID TargetCharacter, const int32 NoSallyMinutes, const int32 BeforeBTMinutes);
	bool BrainTalkBt_OilEnAtkFire();
	bool BrainTalkBt_PLChangeAttachment();
	bool BrainTalkBt_PLDead();
	bool BrainTalkBt_PsychicCombo(const int32 ComboNum);
	bool BrainTalkBt_PTChangeAttachment(const EPlayerID ChangeAttachmentCharacter);
	bool BrainTalkBt_Recovery(const EPlayerID RecoveryTo);
	bool BrainTalkBt_RecoveryAbToPL(const EPlayerID RecoveryFrom);
	bool BrainTalkBt_RecoveryHpToPL(const EPlayerID RecoveryFrom);
	bool BrainTalkBt_RecoveryItemZero();
	bool BrainTalkBt_Revival(const EPlayerID RevivalFrom, const EPlayerID RevivalTo);
	bool BrainTalkBt_SallyTimes(const EPlayerID TargetCharacter, const int32 SallyMinutes, const int32 BeforeBTMinutes);
	bool BrainTalkBt_SasCombo(const int32 ComboNum);
	bool BrainTalkBt_SasContinuity(E_SASKindNative SasEffect, const int32 Num);
	bool BrainTalkBt_SasHoloPossible(const EPlayerID HoloCharacter);
	bool BrainTalkBt_SasHoloPursuit(const EPlayerID HoloCharacter);
	bool BrainTalkBt_SasNoUse(const EPlayerID TargetCharacter, E_SASKindNative SasEffect, const int32 LastSasProgressTime, const int32 LastSasBTProgressTime);
	bool BrainTalkBt_StealthLosePL();
	bool BrainTalkBt_TouchBFWall();
	bool BrainTalkBt_UnopenedTreasure();
	bool BrainTalkBt_WaitingVoice(const EPlayerID WaitCharacter);
	bool BrainTalkBt_WaterEnAtkElectric();
	bool BrainTalkEm_ch0100_01();
	bool BrainTalkEm_ch0100_02();
	bool BrainTalkEm_ch0200_01();
	bool BrainTalkEm_ch0200_02();
	bool BrainTalkEm_ConfusionCharge_ConfusionAttack();
	bool BrainTalkEm_ElectricCharge_ElectricAttack();
	bool BrainTalkEm_ElectricCharge_WaterMember();
	bool BrainTalkEm_em0120_01();
	bool BrainTalkEm_em0210_01();
	bool BrainTalkEm_em0300_01();
	bool BrainTalkEm_em0300_02();
	bool BrainTalkEm_em0300_03();
	bool BrainTalkEm_em0300_04();
	bool BrainTalkEm_em0310_01();
	bool BrainTalkEm_em0310_02();
	bool BrainTalkEm_em0310_03();
	bool BrainTalkEm_em0310_04();
	bool BrainTalkEm_em0320_01();
	bool BrainTalkEm_em0320_02();
	bool BrainTalkEm_em0330_01();
	bool BrainTalkEm_em0330_02();
	bool BrainTalkEm_em0330_03();
	bool BrainTalkEm_em0500_01();
	bool BrainTalkEm_em0620_01();
	bool BrainTalkEm_em0700_01();
	bool BrainTalkEm_em0800_01();
	bool BrainTalkEm_em0820_01();
	bool BrainTalkEm_em0830_01();
	bool BrainTalkEm_em1010_01();
	bool BrainTalkEm_em1020_01();
	bool BrainTalkEm_em1100_01();
	bool BrainTalkEm_em1120_01();
	bool BrainTalkEm_em1200_01();
	bool BrainTalkEm_em1200_02();
	bool BrainTalkEm_em1200_03();
	bool BrainTalkEm_em1210_01();
	bool BrainTalkEm_em1210_02();
	bool BrainTalkEm_em1210_03();
	bool BrainTalkEm_em1210_04();
	bool BrainTalkEm_em1210_05();
	bool BrainTalkEm_em1300_01();
	bool BrainTalkEm_em1300_02();
	bool BrainTalkEm_em1300_03();
	bool BrainTalkEm_em1400_01();
	bool BrainTalkEm_em1410_01();
	bool BrainTalkEm_em1410_02();
	bool BrainTalkEm_em1410_03();
	bool BrainTalkEm_em1410_04();
	bool BrainTalkEm_em1410_05();
	bool BrainTalkEm_em1420_01();
	bool BrainTalkEm_em1420_02();
	bool BrainTalkEm_em1420_03();
	bool BrainTalkEm_em1420_04();
	bool BrainTalkEm_em1430_01();
	bool BrainTalkEm_em1430_02();
	bool BrainTalkEm_em8000_01();
	bool BrainTalkEm_em8000_02();
	bool BrainTalkEm_em8000_03();
	bool BrainTalkEm_em8000_04();
	bool BrainTalkEm_em8000_05();
	bool BrainTalkEm_em8000_06();
	bool BrainTalkEm_em8200_01();
	bool BrainTalkEm_em8200_02();
	bool BrainTalkEm_em8200_03();
	bool BrainTalkEm_em8200_04();
	bool BrainTalkEm_em8200_05();
	bool BrainTalkEm_em8200_07();
	bool BrainTalkEm_em8200_08();
	bool BrainTalkEm_em8300_01();
	bool BrainTalkEm_em8300_02();
	bool BrainTalkEm_em8300_03();
	bool BrainTalkEm_em8300_04();
	bool BrainTalkEm_em8300_05();
	bool BrainTalkEm_em8300_06();
	bool BrainTalkEm_FlameCharge_FlameAttack();
	bool BrainTalkEm_FlameCharge_OilMember();
	bool BrainTalkEm_np1100_01();
	bool BrainTalkEm_np1100_02();
	bool BrainTalkEm_np1100_03();
	bool BrainTalkEm_np1100_04();
	bool BrainTalkEm_np1100_05();
	bool BrainTalkEm_np1100_06();
	bool BrainTalkEm_OilCharge_OilAttack();
	bool BrainTalkEm_WaterCharge_WaterAttack();
	void BrainTalkLoadWork();
	bool BrainTalkMapGimmick(EBrainTalkGimmickCondition Type, const class FString& ConditionLabel);
	bool BrainTalkTuto_tutorial_f_F();
	bool BrainTalkTuto_tutorial_f_G();
	bool BrainTalkTuto_tutorial_f_H();
	bool BrainTalkTuto_tutorial_f_I();
	bool BrainTalkTuto_tutorial_f_J();
	bool BrainTalkTuto_tutorial_m_F();
	bool BrainTalkTuto_tutorial_m_G();
	bool BrainTalkTuto_tutorial_m_H();
	bool BrainTalkTuto_tutorial_m_I();
	bool BrainTalkTuto_tutorial_m_J();
	void CallbackFinishBrainTalk();
	bool CheckEquipChangeBrainTalk();
	void ClearBrainTalkMasterDataQueList();
	void CloseBrainTalkUI();
	int32 GetBrainTalkMapGimmickWaitTime(EBrainTalkGimmickCondition Type, const class FString& ConditionLabel);
	TArray<struct FBrainTalkMasterData> GetBrainTalkMasterDataQueList();
	struct FMessageDataCell GetBrainTalkMessage(const class FString& MessageID);
	bool GetBrainTalkParam(class FName BrainTalkID, EBrainTalkCategory Category, float* OccurRate, bool* IsOnce);
	class UDataTable* GetCategoryDataTable(EBrainTalkCategory Category);
	bool GetCategoryDataTableRow(EBrainTalkCategory Category, class FName BrainTalkID, struct FBrainTalkMasterData* RowData);
	class UDataTable* GetDataTable();
	bool GetDebugDispBrainTalkLogFlag();
	float GetMassageWaitTime();
	EBrainTalkPriority GetPriority();
	EBrainTalkPriorityCheckResult GetPriorityCheck(EBrainTalkPriority PlayReqPriority);
	int32 GetReferenceIndex();
	void InitializeStrongestWeaponIdList();
	bool IsDoEventCheck();
	bool IsEnableCheck(const bool IsPlaySuppressionCheck, const bool IsPlayerHPCheck);
	bool IsFindBrainTalkOnceCheck_LoadReset(const EBrainTalkCategory _Category, const class FName _ID);
	bool IsFinishBrainTalk();
	bool IsFinishLoad();
	bool IsGameOverCheck();
	bool IsLowerPriority();
	bool IsNoStopBrainTalk();
	bool IsStartTalkEventKeepPlayingBT();
	bool IsStartTalkEventPauseBT();
	bool IsSysInvalidProgressIDCheck(EBrainTalkBtGroup Group);
	bool IsTimingEnableCheck();
	void LoadBrainTalkDatatable(const struct FBrainTalkMasterData& BrainTalkData);
	void OpenBrainTalkUI(const int32 CharacterId, const int32 ExpressionID, const class FString& MessageID, const float DrawSecond);
	void PauseBrainTalk(const bool IsPause);
	void PlaySystemBrainTalk(EBrainTalkSystemType Type, const int32 Index_0, EPlayerID Player1);
	void SetDebbugBrainTalkAllInvalidFlag(const bool Flag);
	void SetDebbugBrainTalkBTInvalidFlag(const bool Flag);
	void SetDebugDispBrainTalkLogFlag(const bool Flag);
	void SetIsFinishBrainTalk(const bool Flag);
	void SetIsNoStopBrainTalk(const bool Flag);
	void SetIsStartTalkEventKeepPlayingBT(const bool Flag);
	void SetIsStartTalkEventPauseBT(const bool Flag);
	void SetMassageWaitTime(const float Sec);
	void SetNewRowBrainTalk(const float WaitTime);
	void SetOpenMenuWindowEquipWeaponIdList();
	void SetReferenceIndex(const int32 Num);
	void SetStrongestWeaponId(EPlayerID Player, int32 ID);
	void StartBrainTalk();
	void StartBrainTalk_FromNative(const struct FBrainTalkMasterData& BrainTalkData, const struct FBrainTalk_CategoryDatatable& CategoryDatatable);
	void StartBrainTalk_FromNative2(class FName BrainTalkID, EBrainTalkCategory Category);
	void StopBrainTalk();
	void StopBrainTalk_BPFL_FromNative();
	void StopBrainTalkVoice();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainTalkManager">();
	}
	static class ABrainTalkManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrainTalkManager>();
	}
};
static_assert(alignof(ABrainTalkManager) == 0x000008, "Wrong alignment on ABrainTalkManager");
static_assert(sizeof(ABrainTalkManager) == 0x0002D8, "Wrong size on ABrainTalkManager");
static_assert(offsetof(ABrainTalkManager, _gameInstance) == 0x000238, "Member 'ABrainTalkManager::_gameInstance' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_pBrainTalkBattleManager) == 0x000250, "Member 'ABrainTalkManager::M_pBrainTalkBattleManager' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_BrainTalkMasterDataQueCategoryDatatableList) == 0x000258, "Member 'ABrainTalkManager::M_BrainTalkMasterDataQueCategoryDatatableList' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_BrainTalkMasterDataQueList) == 0x000268, "Member 'ABrainTalkManager::M_BrainTalkMasterDataQueList' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_StrongestWeaponIdList) == 0x000280, "Member 'ABrainTalkManager::M_StrongestWeaponIdList' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_isUpdateEquipIdList) == 0x000290, "Member 'ABrainTalkManager::M_isUpdateEquipIdList' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_OpenMenuWindowEquipIdList) == 0x000298, "Member 'ABrainTalkManager::M_OpenMenuWindowEquipIdList' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_dataTable) == 0x0002A8, "Member 'ABrainTalkManager::M_dataTable' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_Priority) == 0x0002B0, "Member 'ABrainTalkManager::M_Priority' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_ReferenceIndex) == 0x0002B4, "Member 'ABrainTalkManager::M_ReferenceIndex' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_massageWaitTime) == 0x0002B8, "Member 'ABrainTalkManager::M_massageWaitTime' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_isPauseBrainTalk) == 0x0002BC, "Member 'ABrainTalkManager::M_isPauseBrainTalk' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_isFinishBrainTalk) == 0x0002BD, "Member 'ABrainTalkManager::M_isFinishBrainTalk' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_isNoStopBrainTalk) == 0x0002BE, "Member 'ABrainTalkManager::M_isNoStopBrainTalk' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_BrainTalkBt_PlayReqList) == 0x0002C0, "Member 'ABrainTalkManager::M_BrainTalkBt_PlayReqList' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_isStartTalkEventPauseBT) == 0x0002D0, "Member 'ABrainTalkManager::M_isStartTalkEventPauseBT' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_isStartTalkEventKeepPlayingBT) == 0x0002D1, "Member 'ABrainTalkManager::M_isStartTalkEventKeepPlayingBT' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_DebbugBrainTalkAllInvalidFlag) == 0x0002D2, "Member 'ABrainTalkManager::M_DebbugBrainTalkAllInvalidFlag' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_DebbugBrainTalkBTInvalidFlag) == 0x0002D3, "Member 'ABrainTalkManager::M_DebbugBrainTalkBTInvalidFlag' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_DebugDispBrainTalkLogFlag) == 0x0002D4, "Member 'ABrainTalkManager::M_DebugDispBrainTalkLogFlag' has a wrong offset!");

// Class BattlePrototype.DamagePropertyMediatorComponent
// 0x0160 (0x0220 - 0x00C0)
class UDamagePropertyMediatorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x140];                                     // 0x00C0(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPrimitiveComponent*>            _damagePrimitives;                                 // 0x0200(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_210[0x10];                                     // 0x0210(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDamagePropertyMediatorComponent* GetDamagePropertyMediatorComponentFromActor(class AActor* Actor);

	void ClearBlowRate(const class FName& ClaimantName);
	void ClearDamageCollisionDisable(const class FName& ClaimantName);
	void ClearDamageRate(const class FName& ClaimantName);
	void ClearHitZeroEffectSE(const class FName& ClaimantName);
	ECollisionEnabled GetCacheCollisionType(int32 Index_0);
	int32 GetCacheCollisionTypeIndex(class UPrimitiveComponent* PPrimitive);
	int32 GetCacheCollisionTypeNum();
	void SetBlowRate(const class FName& ClaimantName, float BlowRate);
	void SetCacheCollisionType(int32 Index_0, ECollisionEnabled Type);
	void SetDamageCollisionDisable(const class FName& ClaimantName);
	void SetDamageRate(const class FName& ClaimantName, float DamageRate);
	void SetHitZeroEffectSE(const class FName& ClaimantName, const struct FHitZeroEffectAndSE& EffectSE);

	float CalcTotalBlowRate() const;
	float CalcTotalDamageRate() const;
	struct FHitZeroEffectAndSE GetTotalHitZeroEffectSE() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamagePropertyMediatorComponent">();
	}
	static class UDamagePropertyMediatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamagePropertyMediatorComponent>();
	}
};
static_assert(alignof(UDamagePropertyMediatorComponent) == 0x000008, "Wrong alignment on UDamagePropertyMediatorComponent");
static_assert(sizeof(UDamagePropertyMediatorComponent) == 0x000220, "Wrong size on UDamagePropertyMediatorComponent");
static_assert(offsetof(UDamagePropertyMediatorComponent, _damagePrimitives) == 0x000200, "Member 'UDamagePropertyMediatorComponent::_damagePrimitives' has a wrong offset!");

// Class BattlePrototype.BSPBlockBase
// 0x0008 (0x0238 - 0x0230)
class ABSPBlockBase final : public ARSActorSystemBase
{
public:
	class UBrushComponent*                        BrushComponent;                                    // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSPBlockBase">();
	}
	static class ABSPBlockBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABSPBlockBase>();
	}
};
static_assert(alignof(ABSPBlockBase) == 0x000008, "Wrong alignment on ABSPBlockBase");
static_assert(sizeof(ABSPBlockBase) == 0x000238, "Wrong size on ABSPBlockBase");
static_assert(offsetof(ABSPBlockBase, BrushComponent) == 0x000230, "Member 'ABSPBlockBase::BrushComponent' has a wrong offset!");

// Class BattlePrototype.BSPBlockVolume
// 0x0058 (0x0310 - 0x02B8)
class ABSPBlockVolume final : public AAudioVolume
{
public:
	FMulticastInlineDelegateProperty_             OnBSPVolumeBeginOverlap;                           // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBSPVolumeEndOverlap;                             // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBSPVolumeHit;                                    // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class ABSPPortalBase*>                 Portals;                                           // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurSoundAttenuationRate;                           // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetSoundAttenuationRate;                        // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundSettingInterporateSpeed;                      // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalDistanceFromPlayer;                           // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpdateID;                                          // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorBeginOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorEndOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorHitFunc(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void PrepareUpdateSoundAttenuation();
	void ResetAttenuation();
	void SetDistanceFromPlayer(float Distance);
	void UpdateSoundAttenuation(float DeltaSeconds);

	bool IsInVolume(const struct FVector& Point, float SphereRadius) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSPBlockVolume">();
	}
	static class ABSPBlockVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABSPBlockVolume>();
	}
};
static_assert(alignof(ABSPBlockVolume) == 0x000008, "Wrong alignment on ABSPBlockVolume");
static_assert(sizeof(ABSPBlockVolume) == 0x000310, "Wrong size on ABSPBlockVolume");
static_assert(offsetof(ABSPBlockVolume, OnBSPVolumeBeginOverlap) == 0x0002B8, "Member 'ABSPBlockVolume::OnBSPVolumeBeginOverlap' has a wrong offset!");
static_assert(offsetof(ABSPBlockVolume, OnBSPVolumeEndOverlap) == 0x0002C8, "Member 'ABSPBlockVolume::OnBSPVolumeEndOverlap' has a wrong offset!");
static_assert(offsetof(ABSPBlockVolume, OnBSPVolumeHit) == 0x0002D8, "Member 'ABSPBlockVolume::OnBSPVolumeHit' has a wrong offset!");
static_assert(offsetof(ABSPBlockVolume, Portals) == 0x0002E8, "Member 'ABSPBlockVolume::Portals' has a wrong offset!");
static_assert(offsetof(ABSPBlockVolume, CurSoundAttenuationRate) == 0x0002F8, "Member 'ABSPBlockVolume::CurSoundAttenuationRate' has a wrong offset!");
static_assert(offsetof(ABSPBlockVolume, TargetSoundAttenuationRate) == 0x0002FC, "Member 'ABSPBlockVolume::TargetSoundAttenuationRate' has a wrong offset!");
static_assert(offsetof(ABSPBlockVolume, SoundSettingInterporateSpeed) == 0x000300, "Member 'ABSPBlockVolume::SoundSettingInterporateSpeed' has a wrong offset!");
static_assert(offsetof(ABSPBlockVolume, TotalDistanceFromPlayer) == 0x000304, "Member 'ABSPBlockVolume::TotalDistanceFromPlayer' has a wrong offset!");
static_assert(offsetof(ABSPBlockVolume, UpdateID) == 0x000308, "Member 'ABSPBlockVolume::UpdateID' has a wrong offset!");

// Class BattlePrototype.EnemyDeadMoveComponentBase
// 0x0050 (0x0110 - 0x00C0)
class UEnemyDeadMoveComponentBase : public UActorComponent
{
public:
	class ARSCharacterBase*                       MOwnerEnemy;                                       // 0x00C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x48];                                      // 0x00C8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Start_Native(float BlendExp, float MoveLength, EEasingFunc Function, float MoveSeconds, const struct FVector& DamageDir);
	void Update_Native(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyDeadMoveComponentBase">();
	}
	static class UEnemyDeadMoveComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyDeadMoveComponentBase>();
	}
};
static_assert(alignof(UEnemyDeadMoveComponentBase) == 0x000008, "Wrong alignment on UEnemyDeadMoveComponentBase");
static_assert(sizeof(UEnemyDeadMoveComponentBase) == 0x000110, "Wrong size on UEnemyDeadMoveComponentBase");
static_assert(offsetof(UEnemyDeadMoveComponentBase, MOwnerEnemy) == 0x0000C0, "Member 'UEnemyDeadMoveComponentBase::MOwnerEnemy' has a wrong offset!");

// Class BattlePrototype.UICrushBonus
// 0x0030 (0x03B8 - 0x0388)
class UUICrushBonus final : public UUIBase
{
public:
	uint8                                         Pad_388[0x30];                                     // 0x0388(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextNumber);
	void SetBonus(int32 bonus);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICrushBonus">();
	}
	static class UUICrushBonus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICrushBonus>();
	}
};
static_assert(alignof(UUICrushBonus) == 0x000008, "Wrong alignment on UUICrushBonus");
static_assert(sizeof(UUICrushBonus) == 0x0003B8, "Wrong size on UUICrushBonus");

// Class BattlePrototype.BSPManager
// 0x0038 (0x0268 - 0x0230)
class ABSPManager : public ARSActorSystemBase
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnBlockBeginOverlap;                               // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlockEndOverlap;                                 // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlockHit;                                        // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void CalcBSPAttenuationFirstFromPlayer_Native(class ABSPBlockVolume* PFromBSPVolume, const TArray<class ABSPPortalBase*>& Portals, const struct FVector& BasePos, const int32 BlockUpdateID, const float MaxSoundDistance);
	void GetSoundAttenuationRate_Call(const struct FVector& Pos, float* AttenuationRate);
	void GetSoundAttenuationRate_Native(const TArray<class ABSPBlockVolume*>& AreaBlocks, const struct FVector& Pos, bool IsPlayerInBlock, float* AttenuationRate, class ABSPBlockVolume** bLock);
	class ABSPBlockVolume* IsPosInAnyBlock_Native(const TArray<class ABSPBlockVolume*>& AreaBlocks, const struct FVector& Pos);
	void OnBlockBeginOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnBlockEndOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnBlockHitFunc(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void UpdateAllAtomBSPAttenuation_Native();
	void UpdateBSPAttenuation_Native(const float DeltaSeconds, const bool IsPlayerInBlock, const TArray<class ABSPBlockVolume*>& AreaBlocks, const TArray<class ABSPBlockVolume*>& BlockWithPlayer, const int32 BlockUpdateID, const float MaxSoundDistance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSPManager">();
	}
	static class ABSPManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABSPManager>();
	}
};
static_assert(alignof(ABSPManager) == 0x000008, "Wrong alignment on ABSPManager");
static_assert(sizeof(ABSPManager) == 0x000268, "Wrong size on ABSPManager");
static_assert(offsetof(ABSPManager, OnBlockBeginOverlap) == 0x000238, "Member 'ABSPManager::OnBlockBeginOverlap' has a wrong offset!");
static_assert(offsetof(ABSPManager, OnBlockEndOverlap) == 0x000248, "Member 'ABSPManager::OnBlockEndOverlap' has a wrong offset!");
static_assert(offsetof(ABSPManager, OnBlockHit) == 0x000258, "Member 'ABSPManager::OnBlockHit' has a wrong offset!");

// Class BattlePrototype.HitBitComponent
// 0x0020 (0x00E0 - 0x00C0)
class UHitBitComponent final : public UActorComponent
{
public:
	bool                                          _bAutoInitHitBit;                                  // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EHitBitKind>                           _initHitBitKinds;                                  // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 CalcAttackHitBit(const struct FHCCollisionCommonInfo& CommonInfo);
	static int32 CalcDamageHitBit(class AActor* Actor);

	bool IsHit(int32 HitBit) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitBitComponent">();
	}
	static class UHitBitComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitBitComponent>();
	}
};
static_assert(alignof(UHitBitComponent) == 0x000008, "Wrong alignment on UHitBitComponent");
static_assert(sizeof(UHitBitComponent) == 0x0000E0, "Wrong size on UHitBitComponent");
static_assert(offsetof(UHitBitComponent, _bAutoInitHitBit) == 0x0000C0, "Member 'UHitBitComponent::_bAutoInitHitBit' has a wrong offset!");
static_assert(offsetof(UHitBitComponent, _initHitBitKinds) == 0x0000C8, "Member 'UHitBitComponent::_initHitBitKinds' has a wrong offset!");

// Class BattlePrototype.BSPPortalBase
// 0x0028 (0x0258 - 0x0230)
class ABSPPortalBase : public ARSActorSystemBase
{
public:
	TArray<class ABSPBlockVolume*>                NearVolumes;                                       // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttenuationBaseRate;                               // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceAttenuationRate;                           // 0x0244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalDistanceFromPlayer;                           // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenRate;                                          // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpdateID;                                          // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddNearVolume(class ABSPBlockVolume* BlockVolume);
	void CheckAndSetUpdateID(int32 ID, bool* IsFirstTime);
	void SetDistanceFromPlayer(float Distance);

	float GetTotalAttenuationRate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSPPortalBase">();
	}
	static class ABSPPortalBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABSPPortalBase>();
	}
};
static_assert(alignof(ABSPPortalBase) == 0x000008, "Wrong alignment on ABSPPortalBase");
static_assert(sizeof(ABSPPortalBase) == 0x000258, "Wrong size on ABSPPortalBase");
static_assert(offsetof(ABSPPortalBase, NearVolumes) == 0x000230, "Member 'ABSPPortalBase::NearVolumes' has a wrong offset!");
static_assert(offsetof(ABSPPortalBase, AttenuationBaseRate) == 0x000240, "Member 'ABSPPortalBase::AttenuationBaseRate' has a wrong offset!");
static_assert(offsetof(ABSPPortalBase, DistanceAttenuationRate) == 0x000244, "Member 'ABSPPortalBase::DistanceAttenuationRate' has a wrong offset!");
static_assert(offsetof(ABSPPortalBase, TotalDistanceFromPlayer) == 0x000248, "Member 'ABSPPortalBase::TotalDistanceFromPlayer' has a wrong offset!");
static_assert(offsetof(ABSPPortalBase, OpenRate) == 0x00024C, "Member 'ABSPPortalBase::OpenRate' has a wrong offset!");
static_assert(offsetof(ABSPPortalBase, UpdateID) == 0x000250, "Member 'ABSPPortalBase::UpdateID' has a wrong offset!");

// Class BattlePrototype.UIItemPartyStatus
// 0x0058 (0x03E0 - 0x0388)
class UUIItemPartyStatus : public UUIBase
{
public:
	uint8                                         Pad_388[0x58];                                     // 0x0388(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeIcons(class UUIItemPartyStatusIcon* UiIcon1, class UUIItemPartyStatusIcon* UiIcon2, class UUIItemPartyStatusIcon* UiIcon3, class UUIItemPartyStatusIcon* UiIcon4, class UUIItemPartyStatusIcon* UiIcon5, class UUIItemPartyStatusIcon* UiIcon6, class UUIItemPartyStatusIcon* UiIcon7, class UUIItemPartyStatusIcon* UiIcon8, class UUIItemPartyStatusIcon* UiIcon9, class UUIItemPartyStatusIcon* UiIcon10);
	void InitializeThis(class UWidgetAnimation* AnimDefault);
	void UpdatePartyStatus(const class FName& ItemId);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemPartyStatus">();
	}
	static class UUIItemPartyStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemPartyStatus>();
	}
};
static_assert(alignof(UUIItemPartyStatus) == 0x000008, "Wrong alignment on UUIItemPartyStatus");
static_assert(sizeof(UUIItemPartyStatus) == 0x0003E0, "Wrong size on UUIItemPartyStatus");

// Class BattlePrototype.BTDecoratorEnemyBase
// 0x0040 (0x00A8 - 0x0068)
class UBTDecoratorEnemyBase : public UBTDecorator
{
public:
	class AAIController*                          _AIOwner;                                          // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _ActorOwner;                                       // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnemyScriptComponent*                  _EnemyScript;                                      // 0x0078(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           ObservedKeyNames;                                  // 0x0080(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCheckConditionOnlyBlackBoardChanges : 1;          // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsObservingBB : 1;                                // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecoratorEnemyBase">();
	}
	static class UBTDecoratorEnemyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecoratorEnemyBase>();
	}
};
static_assert(alignof(UBTDecoratorEnemyBase) == 0x000008, "Wrong alignment on UBTDecoratorEnemyBase");
static_assert(sizeof(UBTDecoratorEnemyBase) == 0x0000A8, "Wrong size on UBTDecoratorEnemyBase");
static_assert(offsetof(UBTDecoratorEnemyBase, _AIOwner) == 0x000068, "Member 'UBTDecoratorEnemyBase::_AIOwner' has a wrong offset!");
static_assert(offsetof(UBTDecoratorEnemyBase, _ActorOwner) == 0x000070, "Member 'UBTDecoratorEnemyBase::_ActorOwner' has a wrong offset!");
static_assert(offsetof(UBTDecoratorEnemyBase, _EnemyScript) == 0x000078, "Member 'UBTDecoratorEnemyBase::_EnemyScript' has a wrong offset!");
static_assert(offsetof(UBTDecoratorEnemyBase, ObservedKeyNames) == 0x000080, "Member 'UBTDecoratorEnemyBase::ObservedKeyNames' has a wrong offset!");

// Class BattlePrototype.BTD_DistanceAngleCheck_Native
// 0x0030 (0x00D8 - 0x00A8)
class UBTD_DistanceAngleCheck_Native final : public UBTDecoratorEnemyBase
{
public:
	struct FBlackboardKeySelector                 Target;                                            // 0x00A8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_DistanceAngleCheck_Native">();
	}
	static class UBTD_DistanceAngleCheck_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_DistanceAngleCheck_Native>();
	}
};
static_assert(alignof(UBTD_DistanceAngleCheck_Native) == 0x000008, "Wrong alignment on UBTD_DistanceAngleCheck_Native");
static_assert(sizeof(UBTD_DistanceAngleCheck_Native) == 0x0000D8, "Wrong size on UBTD_DistanceAngleCheck_Native");
static_assert(offsetof(UBTD_DistanceAngleCheck_Native, Target) == 0x0000A8, "Member 'UBTD_DistanceAngleCheck_Native::Target' has a wrong offset!");
static_assert(offsetof(UBTD_DistanceAngleCheck_Native, Distance) == 0x0000D0, "Member 'UBTD_DistanceAngleCheck_Native::Distance' has a wrong offset!");
static_assert(offsetof(UBTD_DistanceAngleCheck_Native, Angle) == 0x0000D4, "Member 'UBTD_DistanceAngleCheck_Native::Angle' has a wrong offset!");

// Class BattlePrototype.EnemyManager
// 0x02A8 (0x04D8 - 0x0230)
class AEnemyManager : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 MTickEnableTargetDroneActor;                       // 0x0238(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMeshComponent>          MTickEnableTargetDroneMesh;                        // 0x0240(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsStealthSeeFlag;                                // 0x0248(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 SelectParamDistList;                               // 0x0250(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 SelectParamDistPointList;                          // 0x0260(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 SelectParamAngleList;                              // 0x0270(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 SelectParamAnglePointList;                         // 0x0280(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x58];                                     // 0x0290(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnEnemyListNative;                                 // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class ARSCharacterBase*>               EnemyList;                                         // 0x02F8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FEnemyListInfo>      EnemyListByLevel;                                  // 0x0308(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         EnemyBossList;                                     // 0x0358(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FEnemyListInfo>      EnemyBossListByLevel;                              // 0x0368(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TArray<class ARSCharacterBase*>               BrainCrashCandidateList;                           // 0x03B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        _enemyIgnoreDamageFlag;                            // 0x03C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3CC[0x5];                                      // 0x03CC(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          RestrictSelfDead;                                  // 0x03D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D2[0x2];                                      // 0x03D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RestrictSelfDeadTimer;                             // 0x03D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FEnemyRepopLevelInfo> EnemyRepopLevelInfoList;                           // 0x03D8(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<class FName, bool>                       MUniqueBrainCrashPlayedList;                       // 0x0428(0x0050)(Edit, NativeAccessSpecifierPrivate)
	uint32                                        MUpdateEnemyCount;                                 // 0x0478(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        MEnemyCountMax;                                    // 0x047C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ARSCharacterBase*>               MMovingList;                                       // 0x0480(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         EnemyMovingCount;                                  // 0x0490(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_494[0x4];                                      // 0x0494(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARSCharacterBase*>               BrainCrashTargetList;                              // 0x0498(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ARSCharacterBase*>               CurrentTargetList;                                 // 0x04A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExecBrainCrash;                                   // 0x04B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLastEnableBc;                                     // 0x04B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDisplayCursor;                                  // 0x04BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4BB[0x5];                                      // 0x04BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARSCharacterBase*>               MNeedCheckCutList;                                 // 0x04C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MCanPlayCutScene;                                  // 0x04D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D1[0x7];                                      // 0x04D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBrainCrashCandidate(class ARSCharacterBase* AddChara);
	void AddEnemyBossList(class AActor* AddEnemy);
	void AddEnemyList(class ARSCharacterBase* AddEnemy);
	void AddEnemyRepopLevelInfoList(class FName Name_0, const struct FEnemyRepopLevelInfo& EnemyRepopLevelInfo);
	void AddMovingList(class ARSCharacterBase* AddCharacter);
	void AllEnemyTickStop();
	bool CanUpdateEnemyNative();
	bool CheckRepopCharaInListNative(class FName CharaUniqueId, int32 GroupID);
	void ClearEnemyRepopLevelInfoList();
	void DisableEnemyIgnoreDamage(ECharacterIgnoreDamage SetFlag);
	void DisableEnemyIgnoreDamageAll();
	void EnableEnemyIgnoreDamage(ECharacterIgnoreDamage SetFlag);
	void EnableEnemyIgnoreDamageAll();
	bool EnableUniqueBrainCrashPlayedList(class FName Name_0);
	void EntryRepopNative(float RepopTimeBase, float Range, float Probability, const class FString& ClassBpPath, const struct FVector& InitPos, float MoveArea, class FName LevelName, int32 Group, int32 SubGroup, class FName UniqueId, class FName Level, int32 DropId, class ARSCharacterBase* RepopTarget);
	bool FindEnemyRepopLevelInfoList(class FName Name_0, struct FEnemyRepopLevelInfo* EnemyRepopLevelInfo);
	void GetActorLevelAreaID(const class AActor* Actor, int32* LocationId, int32* AreaId);
	class FName GetActorLevelName(const class AActor* Actor);
	TArray<class ARSCharacterBase*> GetBrainCrashCandidateList();
	bool GetCanPlayCutSceneFromNative();
	TArray<class AActor*> GetEnemyBossList();
	TArray<class AActor*> GetEnemyBossListByLevelName(const class FName LevelName);
	int32 GetEnemyBossNumByLevelName(const class FName LevelName);
	class UClass* GetEnemyClass(const class FString& Path);
	TArray<class ARSCharacterBase*> GetEnemyList();
	TArray<class AActor*> GetEnemyListByLevelName(const class FName LevelName);
	TArray<class ARSCharacterBase*> GetEnemyListRef();
	int32 GetEnemyNumByLevelName(const class FName LevelName);
	TMap<class FName, struct FEnemyRepopLevelInfo> GetEnemyRepopLevelInfoList();
	class AActor* GetTickEnableTargetActor();
	struct FVector GetTickEnableTargetLocation();
	TMap<class FName, bool> GetUniqueBrainCrashPlayedList();
	void IncrementUpdateEnemyNative();
	int32 IsEntryBrainCrashCandidate(class ARSCharacterBase* FindChara);
	bool IsStealthSeeFlagNative();
	bool IsUniqueBrainCrashPlayed(class FName Name_0);
	bool MakeEnemyRepopLevelInfoList(const TMap<class FName, struct FEnemyRepopLevelInfo>& _srcList);
	bool MakeUniqueBrainCrashPlayedList(const TMap<class FName, bool>& SrcList);
	bool PreUpdateEnemyTickEnable(class AActor* Enemy, class AActor* Player, float OutRange);
	void RegisterNeedCheckCutActor(class ARSCharacterBase* _registerActor);
	void RemoveEnemyRepopLevelInfoList(class FName Name_0);
	bool RepopCheckInsideCameraNative(const struct FVector& MyPos);
	bool RepopSpawn_FromNative(const struct FEnemyRepopInfo& EnemyRepopInfo, int32 Group, int32 SubGroup);
	bool RepopUpdateNative(class FName NowLocationName, bool IsInScene, float DeltaSeconds);
	void ResetUniqueBrainCrashPlayedList();
	void ResetUpdateEnemyNative();
	class ARSCharacterBase* SelectBrainCrashCharacter_Native();
	bool SetBrainCrashHUDTarget_Window(class ARSCharacterBase* TargetChara, bool EnablePlayer);
	void SetEnemyIgnoreDamageFlag(int32 Flags_0);
	void SetMaxMovingCount(int32 Count);
	void SetRepopExtendInfoToActor(const struct FEnemyRepopExtendInfo& EnemyRepopExtendInfo, bool& IsIgnoreRestrictAttackOther, bool& IsIgnoreAllowance, bool& IsNoCheckCaptureArea, bool& IsChangeSearchAngle, float& ChangeSearchAngle, bool& IsAlwayChangeSearchAngle, bool& IsChangeSearchRange, float& ChangeSearchRange, bool& IsAlwayChangeSearchRange, bool& IsChangeSensingAngle, float& ChangeSensingAngle, bool& IsAlwaySensingAngle, bool& IsChangeCaptureArea, float& ChangeCaptureArea, bool& IsAlwayCaptureArea);
	void SetRepopExtendInfoToList(struct FEnemyRepopExtendInfo& EnemyRepopExtendInfo, bool IsIgnoreRestrictAttackOther, bool IsIgnoreAllowance, bool IsNoCheckCaptureArea, bool IsChangeSearchAngle, float ChangeSearchAngle, bool IsAlwayChangeSearchAngle, bool IsChangeSearchRange, float ChangeSearchRange, bool IsAlwayChangeSearchRange, bool IsChangeSensingAngle, float ChangeSensingAngle, bool IsAlwaySensingAngle, bool IsChangeCaptureArea, float ChangeCaptureArea, bool IsAlwayCaptureArea);
	bool SetRepopExtendInList_FromNative(struct FEnemyRepopExtendInfo& EnemyRepopExtendInfo, class ARSCharacterBase* RepopTarget);
	void SetRestrictSelfDead(bool _RestrictSelfDead, float _RestrictTime);
	void SetSelectParameter(const TArray<float>& DistList, const TArray<int32>& DistPointList, const TArray<float>& AngleList, const TArray<int32>& AnglePointList);
	void SetSpawnWaitDelay(class ARSCharacterBase* Chara, float DelayTime);
	void SetTickEnableTargetDroneActor(class AActor* DroneActor);
	void SetTickEnableTargetDroneMesh(class UMeshComponent* DroneMesh);
	void StopEnemyAll_FromNative();
	void SubBrainCrashCandidate(class ARSCharacterBase* SubChara);
	void SubEnemyBossList(class AActor* SubEnemy);
	void SubEnemyList(class ARSCharacterBase* SubEnemy);
	void SubMovingList(class ARSCharacterBase* SubCharacter);
	void UnregisterNeedCheckCutActor(class ARSCharacterBase* _unregisterActor);
	void UpdateBrainCrashTarget_Native();
	void UpdateCheckCut();
	void UpdateEnemyTickEnable(class AActor* Enemy, class AActor* Player, float Range, float Height, float OutRange);
	void UpdateOutRangeFade(float OutRange);
	void UpdateRestrictSelfDead(float _DeltaSec);
	class ARSCharacterBase* UsableBrainCrashLockTarget_Native(class ARSCharacterBase* Player);

	int32 CalcBrainCrashScore(float* OutDist, float* OutAngle, const class ARSCharacterBase* ChkChara, const struct FVector& ChkPos, const struct FVector& ChkDir, float LongestDist) const;
	int32 CalcRelationScore(const struct FVector& CameraPos, const struct FVector& CameraDir, const struct FVector& CheckPos, float PossibleBrainCrashRange) const;
	bool CanAddMovingList(const class ARSCharacterBase* NewCharacter) const;
	bool CanPlayCutSceneEnemy() const;
	int32 GetBrainCrashCandidateNum() const;
	int32 GetEnemyIgnoreDamageFlag() const;
	int32 GetEnemyNum() const;
	bool IsEnemyIgnoreDamage(ECharacterIgnoreDamage CheckFlag) const;
	bool IsRestrictSelfDead() const;
	TArray<class ARSCharacterBase*> SelectBrainCrashMultiTarget(const struct FVector& ChkPos, const struct FVector& ChkDir) const;
	class ARSCharacterBase* SelectBrainCrashTarget(const struct FVector& ChkPos, const struct FVector& ChkDir) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyManager">();
	}
	static class AEnemyManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyManager>();
	}
};
static_assert(alignof(AEnemyManager) == 0x000008, "Wrong alignment on AEnemyManager");
static_assert(sizeof(AEnemyManager) == 0x0004D8, "Wrong size on AEnemyManager");
static_assert(offsetof(AEnemyManager, MTickEnableTargetDroneActor) == 0x000238, "Member 'AEnemyManager::MTickEnableTargetDroneActor' has a wrong offset!");
static_assert(offsetof(AEnemyManager, MTickEnableTargetDroneMesh) == 0x000240, "Member 'AEnemyManager::MTickEnableTargetDroneMesh' has a wrong offset!");
static_assert(offsetof(AEnemyManager, MbIsStealthSeeFlag) == 0x000248, "Member 'AEnemyManager::MbIsStealthSeeFlag' has a wrong offset!");
static_assert(offsetof(AEnemyManager, SelectParamDistList) == 0x000250, "Member 'AEnemyManager::SelectParamDistList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, SelectParamDistPointList) == 0x000260, "Member 'AEnemyManager::SelectParamDistPointList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, SelectParamAngleList) == 0x000270, "Member 'AEnemyManager::SelectParamAngleList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, SelectParamAnglePointList) == 0x000280, "Member 'AEnemyManager::SelectParamAnglePointList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, OnEnemyListNative) == 0x0002E8, "Member 'AEnemyManager::OnEnemyListNative' has a wrong offset!");
static_assert(offsetof(AEnemyManager, EnemyList) == 0x0002F8, "Member 'AEnemyManager::EnemyList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, EnemyListByLevel) == 0x000308, "Member 'AEnemyManager::EnemyListByLevel' has a wrong offset!");
static_assert(offsetof(AEnemyManager, EnemyBossList) == 0x000358, "Member 'AEnemyManager::EnemyBossList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, EnemyBossListByLevel) == 0x000368, "Member 'AEnemyManager::EnemyBossListByLevel' has a wrong offset!");
static_assert(offsetof(AEnemyManager, BrainCrashCandidateList) == 0x0003B8, "Member 'AEnemyManager::BrainCrashCandidateList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, _enemyIgnoreDamageFlag) == 0x0003C8, "Member 'AEnemyManager::_enemyIgnoreDamageFlag' has a wrong offset!");
static_assert(offsetof(AEnemyManager, RestrictSelfDead) == 0x0003D1, "Member 'AEnemyManager::RestrictSelfDead' has a wrong offset!");
static_assert(offsetof(AEnemyManager, RestrictSelfDeadTimer) == 0x0003D4, "Member 'AEnemyManager::RestrictSelfDeadTimer' has a wrong offset!");
static_assert(offsetof(AEnemyManager, EnemyRepopLevelInfoList) == 0x0003D8, "Member 'AEnemyManager::EnemyRepopLevelInfoList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, MUniqueBrainCrashPlayedList) == 0x000428, "Member 'AEnemyManager::MUniqueBrainCrashPlayedList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, MUpdateEnemyCount) == 0x000478, "Member 'AEnemyManager::MUpdateEnemyCount' has a wrong offset!");
static_assert(offsetof(AEnemyManager, MEnemyCountMax) == 0x00047C, "Member 'AEnemyManager::MEnemyCountMax' has a wrong offset!");
static_assert(offsetof(AEnemyManager, MMovingList) == 0x000480, "Member 'AEnemyManager::MMovingList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, EnemyMovingCount) == 0x000490, "Member 'AEnemyManager::EnemyMovingCount' has a wrong offset!");
static_assert(offsetof(AEnemyManager, BrainCrashTargetList) == 0x000498, "Member 'AEnemyManager::BrainCrashTargetList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, CurrentTargetList) == 0x0004A8, "Member 'AEnemyManager::CurrentTargetList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, bExecBrainCrash) == 0x0004B8, "Member 'AEnemyManager::bExecBrainCrash' has a wrong offset!");
static_assert(offsetof(AEnemyManager, bLastEnableBc) == 0x0004B9, "Member 'AEnemyManager::bLastEnableBc' has a wrong offset!");
static_assert(offsetof(AEnemyManager, bIsDisplayCursor) == 0x0004BA, "Member 'AEnemyManager::bIsDisplayCursor' has a wrong offset!");
static_assert(offsetof(AEnemyManager, MNeedCheckCutList) == 0x0004C0, "Member 'AEnemyManager::MNeedCheckCutList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, MCanPlayCutScene) == 0x0004D0, "Member 'AEnemyManager::MCanPlayCutScene' has a wrong offset!");

// Class BattlePrototype.UISASMenuControl
// 0x0018 (0x03A0 - 0x0388)
class UUISASMenuControl : public UUIBase
{
public:
	uint8                                         Pad_388[0x18];                                     // 0x0388(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BgSetVisible(bool IsVisible_0, float Speed);
	void BgUpdate(float DeltaSeconds);
	void GetSasKey(ESasKeyType Type, class FName* KeyName, class FName* KeyName2);
	void SetBg(class UImage* PImage);

	bool BgIsUpdate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISASMenuControl">();
	}
	static class UUISASMenuControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISASMenuControl>();
	}
};
static_assert(alignof(UUISASMenuControl) == 0x000008, "Wrong alignment on UUISASMenuControl");
static_assert(sizeof(UUISASMenuControl) == 0x0003A0, "Wrong size on UUISASMenuControl");

// Class BattlePrototype.BTD_Enemy_EnableActionTimer_Native
// 0x0028 (0x00D0 - 0x00A8)
class UBTD_Enemy_EnableActionTimer_Native final : public UBTDecoratorEnemyBase
{
public:
	struct FBlackboardKeySelector                 ActionTimerKey;                                    // 0x00A8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_EnableActionTimer_Native">();
	}
	static class UBTD_Enemy_EnableActionTimer_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_EnableActionTimer_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_EnableActionTimer_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_EnableActionTimer_Native");
static_assert(sizeof(UBTD_Enemy_EnableActionTimer_Native) == 0x0000D0, "Wrong size on UBTD_Enemy_EnableActionTimer_Native");
static_assert(offsetof(UBTD_Enemy_EnableActionTimer_Native, ActionTimerKey) == 0x0000A8, "Member 'UBTD_Enemy_EnableActionTimer_Native::ActionTimerKey' has a wrong offset!");

// Class BattlePrototype.EnemyWeaponBase
// 0x0108 (0x0338 - 0x0230)
class AEnemyWeaponBase : public AActor
{
public:
	uint8                                         Pad_230[0x38];                                     // 0x0230(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MTotalDeltaSeconds;                                // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbEnableSweep;                                     // 0x026C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbNotLineCheck;                                    // 0x026D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26E[0x2];                                      // 0x026E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MOldLocation;                                      // 0x0270(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MTargetLocation;                                   // 0x027C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetDistance;                                   // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetDistanceCheck;                              // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnemyWeaponMoveKind                          MMoveKind;                                         // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x3];                                      // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MLifeTimer;                                        // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MInitLocation;                                     // 0x0298(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAdjustAngle;                                      // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MMaxCorrectAngleZ;                                 // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAdjustFloorAngle;                                 // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MLimitAngleUp;                                     // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MLimitAngleDown;                                   // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MLimitAngleLR;                                     // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAdjustAngleDistanceMax;                           // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAdjustAngleDistanceMin;                           // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MLimitDistanceAdjustAngleUp;                       // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MLimitDistanceAdjustAngleDown;                     // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbNewCorrectDir;                                   // 0x02CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MWeaponActiveNative;                               // 0x02CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MIsCurveTargetMove;                                // 0x02CE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CF[0x1];                                      // 0x02CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MCurveTargetMoveSpeed;                             // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MCurveTargetMove;                                  // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsHitCurveTargetMove;                             // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x3];                                      // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MCommonMoveDir;                                    // 0x02E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MCommonMoveSpeed;                                  // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MCommonMoveGravity;                                // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MProjectileGravityScale;                           // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsAnyHit;                                         // 0x02FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbNotUseAttackCollision;                           // 0x02FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbHitPhysics;                                      // 0x02FE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FF[0x1];                                      // 0x02FF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MPhysicsHalfHeightScale;                           // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MPhysicsRadiusScale;                               // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MPhysicsCollisionHitLocation;                      // 0x0308(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbDisableHitPhysics;                               // 0x0314(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_315[0x3];                                      // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               MPhysicsRotationOffset;                            // 0x0318(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          MbDisableUpdatePhysics;                            // 0x0324(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsFloatObjectExist;                              // 0x0325(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbDisablePhysicsCollision;                         // 0x0326(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_327[0x11];                                     // 0x0327(0x0011)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddIgnoreJustDodgeNative();
	void AttackCollisionEndNative(bool IsVisible);
	struct FVector CorrectBulletDirectionNative(const struct FVector& FireLocation, const struct FVector& TargetLocation, const struct FVector& FireForwardVector, float AbsoluteAngleZ, float MaxAngleZ, float Speed);
	void EndCurveTargetMove_FromNative(float Sec);
	void EndHomingNative();
	void EndPhysicsCollisionNative();
	class UPrimitiveComponent* GetAttackCollisionPrimitiveNative(bool* IsSphere);
	class AActor* GetAttackOwnerTargetCharaNative();
	class UHitCheckComponent* GetHitCheckComponent_FromNative();
	struct FVector GetLocationTwoFrameAgo();
	float GetTargetDistanceNative();
	bool HitAfterCurveMoveTarget_FromNative(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HitCurveMoveTargetNative(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HitPhysicsCollisionNative(const struct FVector& HitLocation);
	void InitCommonMoveNative(const struct FVector& InitPos, const struct FVector& MoveDir, float MoveSpeed, bool NoTargetMove);
	void InitCommonMovewithGravityNative(const struct FVector& InitPos, const struct FVector& MoveDir, float MoveSpeed, float Gravity, bool NoTargetMove);
	void InitializeNative(class UProjectileMovementComponent* ProjectileMovement, class UHitCheckComponent* HitCheck, class USphereComponent* AttackCollision, class UCapsuleComponent* AttackCollisionCapsule, class URSParticleSystemComponentBase* RSParticleSystem, class USkeletalMeshComponent* BulletMesh, class UCapsuleComponent* PhysicsCollision);
	void InitializePhysicsCollisionNative();
	void InitPreviousLocations(const struct FVector& InitLocation);
	bool IsHitFloorNative(const struct FVector& Normal);
	void IsHitLineCheckNative(const struct FVector& StartLocation, const struct FVector& EndLocation, bool* IsAnyHit, struct FHitResult* HitResult);
	bool ProjectileHitProcess_FromNative(bool IsHitPlayer, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ProjectileHitProcessNative(bool IsHitPlayer, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SetCurveTargetMoveInitNative();
	void SetTargetMoveEffectRotationNative();
	void SetWeaponActiveNative(bool Active);
	bool SetWeaponVisibilityNative(bool IsVisible);
	void StartPhysicsCollisionNative();
	void UpdateAddIgnoreJustDodgeNative(float DeltaTime, float& IgnoreJustDodgeTimer);
	void UpdateCommonMoveNative(float DeltaTime);
	void UpdateCurveTargetMoveNative(float DeltaTime);
	bool UpdateLifeTimeNative(bool InterceptReserve, float DeltaTime, float& LifeTime);
	void UpdatePhysicsCollisionNative(float DeltaTime);
	void UpdatePreviousLocations();
	void UpdateTargetNative(bool BreakLostTarget, class AActor* Target, class AActor* AttackOwner, float& LifeTime);

	bool IsWeaponActiveNative() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyWeaponBase">();
	}
	static class AEnemyWeaponBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyWeaponBase>();
	}
};
static_assert(alignof(AEnemyWeaponBase) == 0x000008, "Wrong alignment on AEnemyWeaponBase");
static_assert(sizeof(AEnemyWeaponBase) == 0x000338, "Wrong size on AEnemyWeaponBase");
static_assert(offsetof(AEnemyWeaponBase, MTotalDeltaSeconds) == 0x000268, "Member 'AEnemyWeaponBase::MTotalDeltaSeconds' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MbEnableSweep) == 0x00026C, "Member 'AEnemyWeaponBase::MbEnableSweep' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MbNotLineCheck) == 0x00026D, "Member 'AEnemyWeaponBase::MbNotLineCheck' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MOldLocation) == 0x000270, "Member 'AEnemyWeaponBase::MOldLocation' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MTargetLocation) == 0x00027C, "Member 'AEnemyWeaponBase::MTargetLocation' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MTargetDistance) == 0x000288, "Member 'AEnemyWeaponBase::MTargetDistance' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MTargetDistanceCheck) == 0x00028C, "Member 'AEnemyWeaponBase::MTargetDistanceCheck' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MMoveKind) == 0x000290, "Member 'AEnemyWeaponBase::MMoveKind' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MLifeTimer) == 0x000294, "Member 'AEnemyWeaponBase::MLifeTimer' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MInitLocation) == 0x000298, "Member 'AEnemyWeaponBase::MInitLocation' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MAdjustAngle) == 0x0002A4, "Member 'AEnemyWeaponBase::MAdjustAngle' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MMaxCorrectAngleZ) == 0x0002A8, "Member 'AEnemyWeaponBase::MMaxCorrectAngleZ' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MAdjustFloorAngle) == 0x0002AC, "Member 'AEnemyWeaponBase::MAdjustFloorAngle' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MLimitAngleUp) == 0x0002B0, "Member 'AEnemyWeaponBase::MLimitAngleUp' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MLimitAngleDown) == 0x0002B4, "Member 'AEnemyWeaponBase::MLimitAngleDown' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MLimitAngleLR) == 0x0002B8, "Member 'AEnemyWeaponBase::MLimitAngleLR' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MAdjustAngleDistanceMax) == 0x0002BC, "Member 'AEnemyWeaponBase::MAdjustAngleDistanceMax' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MAdjustAngleDistanceMin) == 0x0002C0, "Member 'AEnemyWeaponBase::MAdjustAngleDistanceMin' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MLimitDistanceAdjustAngleUp) == 0x0002C4, "Member 'AEnemyWeaponBase::MLimitDistanceAdjustAngleUp' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MLimitDistanceAdjustAngleDown) == 0x0002C8, "Member 'AEnemyWeaponBase::MLimitDistanceAdjustAngleDown' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MbNewCorrectDir) == 0x0002CC, "Member 'AEnemyWeaponBase::MbNewCorrectDir' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MWeaponActiveNative) == 0x0002CD, "Member 'AEnemyWeaponBase::MWeaponActiveNative' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MIsCurveTargetMove) == 0x0002CE, "Member 'AEnemyWeaponBase::MIsCurveTargetMove' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MCurveTargetMoveSpeed) == 0x0002D0, "Member 'AEnemyWeaponBase::MCurveTargetMoveSpeed' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MCurveTargetMove) == 0x0002D8, "Member 'AEnemyWeaponBase::MCurveTargetMove' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MIsHitCurveTargetMove) == 0x0002E0, "Member 'AEnemyWeaponBase::MIsHitCurveTargetMove' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MCommonMoveDir) == 0x0002E4, "Member 'AEnemyWeaponBase::MCommonMoveDir' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MCommonMoveSpeed) == 0x0002F0, "Member 'AEnemyWeaponBase::MCommonMoveSpeed' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MCommonMoveGravity) == 0x0002F4, "Member 'AEnemyWeaponBase::MCommonMoveGravity' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MProjectileGravityScale) == 0x0002F8, "Member 'AEnemyWeaponBase::MProjectileGravityScale' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MIsAnyHit) == 0x0002FC, "Member 'AEnemyWeaponBase::MIsAnyHit' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MbNotUseAttackCollision) == 0x0002FD, "Member 'AEnemyWeaponBase::MbNotUseAttackCollision' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MbHitPhysics) == 0x0002FE, "Member 'AEnemyWeaponBase::MbHitPhysics' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MPhysicsHalfHeightScale) == 0x000300, "Member 'AEnemyWeaponBase::MPhysicsHalfHeightScale' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MPhysicsRadiusScale) == 0x000304, "Member 'AEnemyWeaponBase::MPhysicsRadiusScale' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MPhysicsCollisionHitLocation) == 0x000308, "Member 'AEnemyWeaponBase::MPhysicsCollisionHitLocation' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MbDisableHitPhysics) == 0x000314, "Member 'AEnemyWeaponBase::MbDisableHitPhysics' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MPhysicsRotationOffset) == 0x000318, "Member 'AEnemyWeaponBase::MPhysicsRotationOffset' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MbDisableUpdatePhysics) == 0x000324, "Member 'AEnemyWeaponBase::MbDisableUpdatePhysics' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MbIsFloatObjectExist) == 0x000325, "Member 'AEnemyWeaponBase::MbIsFloatObjectExist' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MbDisablePhysicsCollision) == 0x000326, "Member 'AEnemyWeaponBase::MbDisablePhysicsCollision' has a wrong offset!");

// Class BattlePrototype.BTD_Enemy_EnableLostAction_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_Enemy_EnableLostAction_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_EnableLostAction_Native">();
	}
	static class UBTD_Enemy_EnableLostAction_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_EnableLostAction_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_EnableLostAction_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_EnableLostAction_Native");
static_assert(sizeof(UBTD_Enemy_EnableLostAction_Native) == 0x0000A8, "Wrong size on UBTD_Enemy_EnableLostAction_Native");

// Class BattlePrototype.UIShopGetSubListIndex
// 0x0048 (0x03D0 - 0x0388)
class UUIShopGetSubListIndex : public UUIBase
{
public:
	uint8                                         Pad_388[0x48];                                     // 0x0388(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDefaultMax, class UTextBlock* TextItemName, class UImage* ImageCross, class UTextBlock* TextGetNum, class UOverlay* OverlayNumSet, class UTextBlock* TextNumSum, class UTextBlock* TextNumSlash, class UTextBlock* TextNumMax);
	void SetBondsIcon();
	void SetItemIcon(const class FName& ItemId);
	void SetQuestIcon();
	void UpdateStateThis(int32 State, int32 SubState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopGetSubListIndex">();
	}
	static class UUIShopGetSubListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopGetSubListIndex>();
	}
};
static_assert(alignof(UUIShopGetSubListIndex) == 0x000008, "Wrong alignment on UUIShopGetSubListIndex");
static_assert(sizeof(UUIShopGetSubListIndex) == 0x0003D0, "Wrong size on UUIShopGetSubListIndex");

// Class BattlePrototype.BTD_Enemy_FormType_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_Enemy_FormType_Native final : public UBTDecoratorEnemyBase
{
public:
	EEnemyFormType                                FormType;                                          // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_FormType_Native">();
	}
	static class UBTD_Enemy_FormType_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_FormType_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_FormType_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_FormType_Native");
static_assert(sizeof(UBTD_Enemy_FormType_Native) == 0x0000B0, "Wrong size on UBTD_Enemy_FormType_Native");
static_assert(offsetof(UBTD_Enemy_FormType_Native, FormType) == 0x0000A8, "Member 'UBTD_Enemy_FormType_Native::FormType' has a wrong offset!");

// Class BattlePrototype.BTD_Enemy_IsAlive_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_Enemy_IsAlive_Native final : public UBTDecoratorEnemyBase
{
public:
	EnemyAliveAnimKind                            EnemyAliveAnimKind;                                // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsAlive_Native">();
	}
	static class UBTD_Enemy_IsAlive_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsAlive_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsAlive_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsAlive_Native");
static_assert(sizeof(UBTD_Enemy_IsAlive_Native) == 0x0000B0, "Wrong size on UBTD_Enemy_IsAlive_Native");
static_assert(offsetof(UBTD_Enemy_IsAlive_Native, EnemyAliveAnimKind) == 0x0000A8, "Member 'UBTD_Enemy_IsAlive_Native::EnemyAliveAnimKind' has a wrong offset!");

// Class BattlePrototype.UIBrainMessage
// 0x0020 (0x03A8 - 0x0388)
class UUIBrainMessage : public UUIBase
{
public:
	bool                                          M_FlagReplyBondsEpisode;                           // 0x0388(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_FlagReplyTest;                                   // 0x0389(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_FlagReplyClose;                                  // 0x038A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_FlagMouseInput;                                  // 0x038B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0x1C];                                     // 0x038C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ClearCurrentNewFlagNative(int32 Index_0, class UUserWidget* Widget);
	void InitializeList(class UREDScrollBox* ScrollBox, class UREDScrollBox* ScrollboxMessage);
	bool InitListMessageNative(int32 Index_0);
	bool IsUpdateBrainThreadMouseFocus(int32* CursorIndex);
	void ListFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void PlayMessageScrollSE();
	void ResetDefaultThread();
	void ResetReplyBondsEpisodeFlag();
	void SetDefaultThread(class FName ThreadID);
	void SetFlagEnableClose(bool IsPlay);
	void SetOldScrollOffset(float Offset);
	void StopMessageScrollSE();
	void UpdateBrainMessageMouseFocus();
	bool UpdateBrainMessageMouseSE();
	bool UpdateThreadTitleNative(int32 Index_0);

	bool GetFlagEnableClose() const;
	bool IsReplyBondsEpisode() const;
	bool IsReplyClose() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBrainMessage">();
	}
	static class UUIBrainMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBrainMessage>();
	}
};
static_assert(alignof(UUIBrainMessage) == 0x000008, "Wrong alignment on UUIBrainMessage");
static_assert(sizeof(UUIBrainMessage) == 0x0003A8, "Wrong size on UUIBrainMessage");
static_assert(offsetof(UUIBrainMessage, M_FlagReplyBondsEpisode) == 0x000388, "Member 'UUIBrainMessage::M_FlagReplyBondsEpisode' has a wrong offset!");
static_assert(offsetof(UUIBrainMessage, M_FlagReplyTest) == 0x000389, "Member 'UUIBrainMessage::M_FlagReplyTest' has a wrong offset!");
static_assert(offsetof(UUIBrainMessage, M_FlagReplyClose) == 0x00038A, "Member 'UUIBrainMessage::M_FlagReplyClose' has a wrong offset!");
static_assert(offsetof(UUIBrainMessage, M_FlagMouseInput) == 0x00038B, "Member 'UUIBrainMessage::M_FlagMouseInput' has a wrong offset!");

// Class BattlePrototype.BTD_Enemy_IsBadStatus_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_Enemy_IsBadStatus_Native final : public UBTDecoratorEnemyBase
{
public:
	EHCBadState                                   BadStatus;                                         // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsBadStatus_Native">();
	}
	static class UBTD_Enemy_IsBadStatus_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsBadStatus_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsBadStatus_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsBadStatus_Native");
static_assert(sizeof(UBTD_Enemy_IsBadStatus_Native) == 0x0000B0, "Wrong size on UBTD_Enemy_IsBadStatus_Native");
static_assert(offsetof(UBTD_Enemy_IsBadStatus_Native, BadStatus) == 0x0000A8, "Member 'UBTD_Enemy_IsBadStatus_Native::BadStatus' has a wrong offset!");

// Class BattlePrototype.DebuggingItemStringArray
// 0x0040 (0x0308 - 0x02C8)
class ADebuggingItemStringArray : public ADebuggingItemBase
{
public:
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnComboBoxSettingChanged;                          // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class FText>                           StringArray;                                       // 0x02E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Index_0;                                           // 0x02F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0xC];                                      // 0x02FC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKeyLeftFunc(const class ADebuggingItemBase* InItem, bool IsRepeat, int32 InSpeed);
	void OnKeyRightFunc(const class ADebuggingItemBase* InItem, bool IsRepeat, int32 InSpeed);
	void SetComboBoxSetting(const TArray<class FText>& InStringArray);
	void SetStringIndex(int32 InIndex);

	int32 GetIndexByString(const class FText& SearchString) const;
	const class FText GetString() const;
	int32 GetStringIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemStringArray">();
	}
	static class ADebuggingItemStringArray* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemStringArray>();
	}
};
static_assert(alignof(ADebuggingItemStringArray) == 0x000008, "Wrong alignment on ADebuggingItemStringArray");
static_assert(sizeof(ADebuggingItemStringArray) == 0x000308, "Wrong size on ADebuggingItemStringArray");
static_assert(offsetof(ADebuggingItemStringArray, OnChanged) == 0x0002C8, "Member 'ADebuggingItemStringArray::OnChanged' has a wrong offset!");
static_assert(offsetof(ADebuggingItemStringArray, OnComboBoxSettingChanged) == 0x0002D8, "Member 'ADebuggingItemStringArray::OnComboBoxSettingChanged' has a wrong offset!");
static_assert(offsetof(ADebuggingItemStringArray, StringArray) == 0x0002E8, "Member 'ADebuggingItemStringArray::StringArray' has a wrong offset!");
static_assert(offsetof(ADebuggingItemStringArray, Index_0) == 0x0002F8, "Member 'ADebuggingItemStringArray::Index_0' has a wrong offset!");

// Class BattlePrototype.DebuggingItemScrSetting
// 0x0008 (0x0310 - 0x0308)
class ADebuggingItemScrSetting : public ADebuggingItemStringArray
{
public:
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemScrSetting">();
	}
	static class ADebuggingItemScrSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemScrSetting>();
	}
};
static_assert(alignof(ADebuggingItemScrSetting) == 0x000008, "Wrong alignment on ADebuggingItemScrSetting");
static_assert(sizeof(ADebuggingItemScrSetting) == 0x000310, "Wrong size on ADebuggingItemScrSetting");

// Class BattlePrototype.DebuggingItemScrModeChange
// 0x0000 (0x0310 - 0x0310)
class ADebuggingItemScrModeChange final : public ADebuggingItemScrSetting
{
public:
	void OnChangeValue(const class ADebuggingItemStringArray* InItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemScrModeChange">();
	}
	static class ADebuggingItemScrModeChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemScrModeChange>();
	}
};
static_assert(alignof(ADebuggingItemScrModeChange) == 0x000008, "Wrong alignment on ADebuggingItemScrModeChange");
static_assert(sizeof(ADebuggingItemScrModeChange) == 0x000310, "Wrong size on ADebuggingItemScrModeChange");

// Class BattlePrototype.BTD_Enemy_IsBattle_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_Enemy_IsBattle_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsBattle_Native">();
	}
	static class UBTD_Enemy_IsBattle_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsBattle_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsBattle_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsBattle_Native");
static_assert(sizeof(UBTD_Enemy_IsBattle_Native) == 0x0000A8, "Wrong size on UBTD_Enemy_IsBattle_Native");

// Class BattlePrototype.UILog
// 0x0388 (0x0710 - 0x0388)
class UUILog : public UUIBase
{
public:
	uint8                                         Pad_388[0x388];                                    // 0x0388(0x0388)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddLogMessage(const class FString& LogMessage);
	void AddLogMessageSE(const class FString& LogMessage, EUI_SE Se);
	void InitializeThis(class UWidgetAnimation* AnimIn1, class UWidgetAnimation* AnimIn2, class UWidgetAnimation* AnimIn3, class UWidgetAnimation* AnimIn4, class UWidgetAnimation* AnimIn5, class UWidgetAnimation* AnimIn6, class UWidgetAnimation* AnimIn7, class UWidgetAnimation* AnimDefault1, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimDefault3, class UWidgetAnimation* AnimDefault4, class UWidgetAnimation* AnimDefault5, class UWidgetAnimation* AnimDefault6, class UUILogParts* Log1, class UUILogParts* Log2, class UUILogParts* Log3, class UUILogParts* Log4, class UUILogParts* Log5, class UUILogParts* Log6, class UUILogParts* Log7);
	void SetDrawTime(float Time);
	void SetWaitTime(float Time);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	float GetDrawTime() const;
	float GetWaitTime() const;
	bool IsEmpty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILog">();
	}
	static class UUILog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILog>();
	}
};
static_assert(alignof(UUILog) == 0x000008, "Wrong alignment on UUILog");
static_assert(sizeof(UUILog) == 0x000710, "Wrong size on UUILog");

// Class BattlePrototype.BTD_Enemy_IsCanFlyModeChange_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_Enemy_IsCanFlyModeChange_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsCanFlyModeChange_Native">();
	}
	static class UBTD_Enemy_IsCanFlyModeChange_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsCanFlyModeChange_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsCanFlyModeChange_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsCanFlyModeChange_Native");
static_assert(sizeof(UBTD_Enemy_IsCanFlyModeChange_Native) == 0x0000A8, "Wrong size on UBTD_Enemy_IsCanFlyModeChange_Native");

// Class BattlePrototype.BTD_Enemy_IsDead_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_Enemy_IsDead_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsDead_Native">();
	}
	static class UBTD_Enemy_IsDead_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsDead_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsDead_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsDead_Native");
static_assert(sizeof(UBTD_Enemy_IsDead_Native) == 0x0000A8, "Wrong size on UBTD_Enemy_IsDead_Native");

// Class BattlePrototype.DeadStateMediatorComponent
// 0x0028 (0x00E8 - 0x00C0)
class UDeadStateMediatorComponent final : public UActorComponent
{
public:
	float                                         _deadStartTime;                                    // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _deadKeepSec;                                      // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _disableAutoRevive;                                // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnRevive;                                          // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsAbleDead();
	void SetDisableAutoRevibeAfterDead();
	void StartDead();
	bool TryStartDead();
	void UpdateDead();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeadStateMediatorComponent">();
	}
	static class UDeadStateMediatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeadStateMediatorComponent>();
	}
};
static_assert(alignof(UDeadStateMediatorComponent) == 0x000008, "Wrong alignment on UDeadStateMediatorComponent");
static_assert(sizeof(UDeadStateMediatorComponent) == 0x0000E8, "Wrong size on UDeadStateMediatorComponent");
static_assert(offsetof(UDeadStateMediatorComponent, _deadStartTime) == 0x0000C0, "Member 'UDeadStateMediatorComponent::_deadStartTime' has a wrong offset!");
static_assert(offsetof(UDeadStateMediatorComponent, _deadKeepSec) == 0x0000C4, "Member 'UDeadStateMediatorComponent::_deadKeepSec' has a wrong offset!");
static_assert(offsetof(UDeadStateMediatorComponent, _disableAutoRevive) == 0x0000C8, "Member 'UDeadStateMediatorComponent::_disableAutoRevive' has a wrong offset!");
static_assert(offsetof(UDeadStateMediatorComponent, OnRevive) == 0x0000D0, "Member 'UDeadStateMediatorComponent::OnRevive' has a wrong offset!");

// Class BattlePrototype.UIShopGetContents
// 0x00B8 (0x0440 - 0x0388)
class UUIShopGetContents : public UUIBase
{
public:
	struct FVector2D                              ListElementSizeMain;                               // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSizeMain;                                // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClassMain;                                // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUIShopGetSubListIndex>     M_pSubItemClass;                                   // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x40];                                     // 0x03A8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIShopGetSubListIndex*>         M_uiSubItemList;                                   // 0x03E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x38];                                     // 0x03F8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class URSSaveGame*                            M_pSaveSystem;                                     // 0x0430(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pSaveLoadSystemParamManager;                     // 0x0438(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializeFromShop(class UUIShop* UIShop, class UUIShopChoice* UiChoice);
	void InitializeThis(class UREDScrollBox* ScrollBoxMain, class UREDScrollBoxSimple* ScrollBoxSub, class UUIShopGetSubListIndex* UiSubListIndex, class UTextBlock* TextListTitle, class UImage* ImageSubBaseLine, class USpacer* SpacerDescription);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUpdateElement(int32 Index_0, class UUserWidget* Widget);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopGetContents">();
	}
	static class UUIShopGetContents* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopGetContents>();
	}
};
static_assert(alignof(UUIShopGetContents) == 0x000008, "Wrong alignment on UUIShopGetContents");
static_assert(sizeof(UUIShopGetContents) == 0x000440, "Wrong size on UUIShopGetContents");
static_assert(offsetof(UUIShopGetContents, ListElementSizeMain) == 0x000388, "Member 'UUIShopGetContents::ListElementSizeMain' has a wrong offset!");
static_assert(offsetof(UUIShopGetContents, ListOffsetSizeMain) == 0x000390, "Member 'UUIShopGetContents::ListOffsetSizeMain' has a wrong offset!");
static_assert(offsetof(UUIShopGetContents, ListIndexClassMain) == 0x000398, "Member 'UUIShopGetContents::ListIndexClassMain' has a wrong offset!");
static_assert(offsetof(UUIShopGetContents, M_pSubItemClass) == 0x0003A0, "Member 'UUIShopGetContents::M_pSubItemClass' has a wrong offset!");
static_assert(offsetof(UUIShopGetContents, M_uiSubItemList) == 0x0003E8, "Member 'UUIShopGetContents::M_uiSubItemList' has a wrong offset!");
static_assert(offsetof(UUIShopGetContents, M_pSaveSystem) == 0x000430, "Member 'UUIShopGetContents::M_pSaveSystem' has a wrong offset!");
static_assert(offsetof(UUIShopGetContents, M_pSaveLoadSystemParamManager) == 0x000438, "Member 'UUIShopGetContents::M_pSaveLoadSystemParamManager' has a wrong offset!");

// Class BattlePrototype.BTD_Enemy_IsEnableWander_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_Enemy_IsEnableWander_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsEnableWander_Native">();
	}
	static class UBTD_Enemy_IsEnableWander_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsEnableWander_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsEnableWander_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsEnableWander_Native");
static_assert(sizeof(UBTD_Enemy_IsEnableWander_Native) == 0x0000A8, "Wrong size on UBTD_Enemy_IsEnableWander_Native");

// Class BattlePrototype.DebuggingItemScrResInnerChange
// 0x0008 (0x0308 - 0x0300)
class ADebuggingItemScrResInnerChange final : public ADebuggingItemInt
{
public:
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeValue(const class ADebuggingItemInt* InItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemScrResInnerChange">();
	}
	static class ADebuggingItemScrResInnerChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemScrResInnerChange>();
	}
};
static_assert(alignof(ADebuggingItemScrResInnerChange) == 0x000008, "Wrong alignment on ADebuggingItemScrResInnerChange");
static_assert(sizeof(ADebuggingItemScrResInnerChange) == 0x000308, "Wrong size on ADebuggingItemScrResInnerChange");

// Class BattlePrototype.BTD_Enemy_IsForceBreak_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_Enemy_IsForceBreak_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsForceBreak_Native">();
	}
	static class UBTD_Enemy_IsForceBreak_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsForceBreak_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsForceBreak_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsForceBreak_Native");
static_assert(sizeof(UBTD_Enemy_IsForceBreak_Native) == 0x0000A8, "Wrong size on UBTD_Enemy_IsForceBreak_Native");

// Class BattlePrototype.UIItemTradeMaterialListIndex
// 0x0070 (0x03F8 - 0x0388)
class UUIItemTradeMaterialListIndex : public UUIBase
{
public:
	uint8                                         Pad_388[0x70];                                     // 0x0388(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDefaultMax, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectMax, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectInMax, class UWidgetAnimation* AnimDefaultLack, class UWidgetAnimation* AnimSelectLack, class UWidgetAnimation* AnimSelectInLack, class UTextBlock* TextItemName, class UTextBlock* TextNumHave, class UTextBlock* TextNumNeed);
	bool SetItemInfo(const class FName& ItemId, int32 NeedNum, bool IsLackMaterial);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemTradeMaterialListIndex">();
	}
	static class UUIItemTradeMaterialListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemTradeMaterialListIndex>();
	}
};
static_assert(alignof(UUIItemTradeMaterialListIndex) == 0x000008, "Wrong alignment on UUIItemTradeMaterialListIndex");
static_assert(sizeof(UUIItemTradeMaterialListIndex) == 0x0003F8, "Wrong size on UUIItemTradeMaterialListIndex");

// Class BattlePrototype.BTD_Enemy_IsNotWallHit_Native
// 0x0010 (0x00B8 - 0x00A8)
class UBTD_Enemy_IsNotWallHit_Native final : public UBTDecoratorEnemyBase
{
public:
	float                                         _tmpDistance;                                      // 0x00A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameTimer                             _tmpGameTimer;                                     // 0x00AC(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsNotWallHit_Native">();
	}
	static class UBTD_Enemy_IsNotWallHit_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsNotWallHit_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsNotWallHit_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsNotWallHit_Native");
static_assert(sizeof(UBTD_Enemy_IsNotWallHit_Native) == 0x0000B8, "Wrong size on UBTD_Enemy_IsNotWallHit_Native");
static_assert(offsetof(UBTD_Enemy_IsNotWallHit_Native, _tmpDistance) == 0x0000A8, "Member 'UBTD_Enemy_IsNotWallHit_Native::_tmpDistance' has a wrong offset!");
static_assert(offsetof(UBTD_Enemy_IsNotWallHit_Native, _tmpGameTimer) == 0x0000AC, "Member 'UBTD_Enemy_IsNotWallHit_Native::_tmpGameTimer' has a wrong offset!");

// Class BattlePrototype.BTD_Enemy_IsRandom_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_Enemy_IsRandom_Native final : public UBTDecoratorEnemyBase
{
public:
	int32                                         Num;                                               // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsRandom_Native">();
	}
	static class UBTD_Enemy_IsRandom_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsRandom_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsRandom_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsRandom_Native");
static_assert(sizeof(UBTD_Enemy_IsRandom_Native) == 0x0000B0, "Wrong size on UBTD_Enemy_IsRandom_Native");
static_assert(offsetof(UBTD_Enemy_IsRandom_Native, Num) == 0x0000A8, "Member 'UBTD_Enemy_IsRandom_Native::Num' has a wrong offset!");

// Class BattlePrototype.BTD_Enemy_IsSpawnNow_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_Enemy_IsSpawnNow_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsSpawnNow_Native">();
	}
	static class UBTD_Enemy_IsSpawnNow_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsSpawnNow_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsSpawnNow_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsSpawnNow_Native");
static_assert(sizeof(UBTD_Enemy_IsSpawnNow_Native) == 0x0000A8, "Wrong size on UBTD_Enemy_IsSpawnNow_Native");

// Class BattlePrototype.OutgameDebuggingManager
// 0x00C8 (0x02F8 - 0x0230)
class AOutgameDebuggingManager final : public AActor
{
public:
	uint8                                         Pad_230[0x20];                                     // 0x0230(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnReadyDebugging;                                  // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EOutgameDebuggingPage                         Page;                                              // 0x0260(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x4F];                                     // 0x0261(0x004F)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            DebuggingWidget;                                   // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UDebuggingWidget*>               DebuggingTreeWidget;                               // 0x02B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOutgameDebuggingStartupObject*         StartupObject;                                     // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x4];                                      // 0x02D0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugAutoInputDelayTime;                           // 0x02D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDispRevision;                                // 0x02D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x1F];                                     // 0x02D9(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AOutgameDebuggingManager* GetDebuggingManagerInstance(const class UObject* WorldContextObject);

	void BeginPageAjito();
	void BeginPageBattle();
	void BeginPageEnemy();
	void BeginPageEvent();
	void BeginPageParty();
	void BeginPagePlayer();
	void BeginPageRender();
	void BeginPageScene();
	void BeginPageSound();
	void BeginPageSystem();
	void BeginPageUI();
	void Dump();
	void EndPageAjito();
	void EndPageBattle();
	void EndPageEnemy();
	void EndPageEvent();
	void EndPageParty();
	void EndPagePlayer();
	void EndPageRender();
	void EndPageScene();
	void EndPageSound();
	void EndPageSystem();
	void EndPageUI();
	void ExportDebuggingItemText();
	void FinishWindow();
	class FString GetDebuggingText(const class FString& Key);
	class FString GetRevisionString();
	void LoadDebuggingParameter(bool IsBroadcast);
	void RegisterChild(EOutgameDebuggingPage InPage, class ADebuggingItemBase* InItem);
	void ResetDebuggingParameter();
	void SaveDebuggingParameter();
	class ADebuggingItemBase* SearchItem(EOutgameDebuggingPage InPage, const class FText& InHashName, bool InIgnoreCase);
	void SetDebugDispRevisions(bool IsDisp);
	void SetPage(EOutgameDebuggingPage InPage);
	void StartWindow();
	void TickPageAjito(float DeltaSeconds);
	void TickPageBattle(float DeltaSeconds);
	void TickPageEnemy(float DeltaSeconds);
	void TickPageEvent(float DeltaSeconds);
	void TickPageParty(float DeltaSeconds);
	void TickPagePlayer(float DeltaSeconds);
	void TickPageRender(float DeltaSeconds);
	void TickPageScene(float DeltaSeconds);
	void TickPageSound(float DeltaSeconds);
	void TickPageSystem(float DeltaSeconds);
	void TickPageUI(float DeltaSeconds);
	void UnregisterChildFromHashName(EOutgameDebuggingPage InPage, const class FText& InHashName);
	void UnregisterChildFromItem(EOutgameDebuggingPage InPage, class ADebuggingItemBase* InItem);

	bool DebugIsDispRevisions() const;
	bool IsReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutgameDebuggingManager">();
	}
	static class AOutgameDebuggingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOutgameDebuggingManager>();
	}
};
static_assert(alignof(AOutgameDebuggingManager) == 0x000008, "Wrong alignment on AOutgameDebuggingManager");
static_assert(sizeof(AOutgameDebuggingManager) == 0x0002F8, "Wrong size on AOutgameDebuggingManager");
static_assert(offsetof(AOutgameDebuggingManager, OnReadyDebugging) == 0x000250, "Member 'AOutgameDebuggingManager::OnReadyDebugging' has a wrong offset!");
static_assert(offsetof(AOutgameDebuggingManager, Page) == 0x000260, "Member 'AOutgameDebuggingManager::Page' has a wrong offset!");
static_assert(offsetof(AOutgameDebuggingManager, DebuggingWidget) == 0x0002B0, "Member 'AOutgameDebuggingManager::DebuggingWidget' has a wrong offset!");
static_assert(offsetof(AOutgameDebuggingManager, DebuggingTreeWidget) == 0x0002B8, "Member 'AOutgameDebuggingManager::DebuggingTreeWidget' has a wrong offset!");
static_assert(offsetof(AOutgameDebuggingManager, StartupObject) == 0x0002C8, "Member 'AOutgameDebuggingManager::StartupObject' has a wrong offset!");
static_assert(offsetof(AOutgameDebuggingManager, DebugAutoInputDelayTime) == 0x0002D4, "Member 'AOutgameDebuggingManager::DebugAutoInputDelayTime' has a wrong offset!");
static_assert(offsetof(AOutgameDebuggingManager, bDebugDispRevision) == 0x0002D8, "Member 'AOutgameDebuggingManager::bDebugDispRevision' has a wrong offset!");

// Class BattlePrototype.BTD_Enemy_IsSpawnState_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_Enemy_IsSpawnState_Native final : public UBTDecoratorEnemyBase
{
public:
	Enum_EnemySpawnStateNative                    State;                                             // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsSpawnState_Native">();
	}
	static class UBTD_Enemy_IsSpawnState_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsSpawnState_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsSpawnState_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsSpawnState_Native");
static_assert(sizeof(UBTD_Enemy_IsSpawnState_Native) == 0x0000B0, "Wrong size on UBTD_Enemy_IsSpawnState_Native");
static_assert(offsetof(UBTD_Enemy_IsSpawnState_Native, State) == 0x0000A8, "Member 'UBTD_Enemy_IsSpawnState_Native::State' has a wrong offset!");

// Class BattlePrototype.PostProcessOverraySystem
// 0x0000 (0x0230 - 0x0230)
class APostProcessOverraySystem : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessOverraySystem">();
	}
	static class APostProcessOverraySystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<APostProcessOverraySystem>();
	}
};
static_assert(alignof(APostProcessOverraySystem) == 0x000008, "Wrong alignment on APostProcessOverraySystem");
static_assert(sizeof(APostProcessOverraySystem) == 0x000230, "Wrong size on APostProcessOverraySystem");

// Class BattlePrototype.BTD_Enemy_IsTickEnable_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_Enemy_IsTickEnable_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsTickEnable_Native">();
	}
	static class UBTD_Enemy_IsTickEnable_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsTickEnable_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsTickEnable_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsTickEnable_Native");
static_assert(sizeof(UBTD_Enemy_IsTickEnable_Native) == 0x0000A8, "Wrong size on UBTD_Enemy_IsTickEnable_Native");

// Class BattlePrototype.BTD_Enemy_IsWander_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_Enemy_IsWander_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsWander_Native">();
	}
	static class UBTD_Enemy_IsWander_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsWander_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsWander_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsWander_Native");
static_assert(sizeof(UBTD_Enemy_IsWander_Native) == 0x0000A8, "Wrong size on UBTD_Enemy_IsWander_Native");

// Class BattlePrototype.UIItemTrade
// 0xDC20 (0xDFA8 - 0x0388)
class UUIItemTrade : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0xDC08];                                   // 0x03A0(0xDC08)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseWishList();
	void InitializeFromShop(class UUIShop* UIShop, class UUIShopItemDetails* UiItemDetail, class UUIShopChoice* UiChoice, class UUIShopPartyStatus* UiPartyStatus);
	void InitializeFromWishList(class UUIWishList* UIWishList, class UUIShopItemDetails* UiItemDetail, class UUIShopPartyStatus* UiPartyStatus);
	void InitializeThis(class UREDScrollBox* ScrollBox, class UUIItemTradeListIndex* UiListIndexBase, class UTextBlock* TextIndexItem, class UTextBlock* TextIndexHaveNum, class UUIItemTradeMaterialListIndex* UiMaterialListIndex1, class UUIItemTradeMaterialListIndex* UiMaterialListIndex2, class UUIItemTradeMaterialListIndex* UiMaterialListIndex3, class UTextBlock* TextMaterialName, class UTextBlock* TextMaterialHaveNum, class UTextBlock* TextMaterialNeedNum);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUpdateElement(int32 Index_0, class UUserWidget* Widget);
	void Start(int32 TradeShopId);
	void StartWishList();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemTrade">();
	}
	static class UUIItemTrade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemTrade>();
	}
};
static_assert(alignof(UUIItemTrade) == 0x000008, "Wrong alignment on UUIItemTrade");
static_assert(sizeof(UUIItemTrade) == 0x00DFA8, "Wrong size on UUIItemTrade");
static_assert(offsetof(UUIItemTrade, ListElementSize) == 0x000388, "Member 'UUIItemTrade::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUIItemTrade, ListOffsetSize) == 0x000390, "Member 'UUIItemTrade::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUIItemTrade, ListIndexClass) == 0x000398, "Member 'UUIItemTrade::ListIndexClass' has a wrong offset!");

// Class BattlePrototype.BTD_IsEnemyBattleStart_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_IsEnemyBattleStart_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsEnemyBattleStart_Native">();
	}
	static class UBTD_IsEnemyBattleStart_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsEnemyBattleStart_Native>();
	}
};
static_assert(alignof(UBTD_IsEnemyBattleStart_Native) == 0x000008, "Wrong alignment on UBTD_IsEnemyBattleStart_Native");
static_assert(sizeof(UBTD_IsEnemyBattleStart_Native) == 0x0000A8, "Wrong size on UBTD_IsEnemyBattleStart_Native");

// Class BattlePrototype.DebuggingManager
// 0x0168 (0x0398 - 0x0230)
class ADebuggingManager final : public AActor
{
public:
	uint8                                         Pad_230[0x20];                                     // 0x0230(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnReadyDebugging;                                  // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EDebuggingPage                                Page;                                              // 0x0260(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x4F];                                     // 0x0261(0x004F)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            DebuggingWidget;                                   // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UDebuggingWidget*>               DebuggingTreeWidget;                               // 0x02B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDebuggingStartupObject*                StartupObject;                                     // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x18];                                     // 0x02D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ADebuggingItemStringArray*              M_pDebugTimeSaveDataComboBox;                      // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugDriveDrawCrashBonusAll;                      // 0x02F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugAutoInput;                                   // 0x02F1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugAutoEvent;                                   // 0x02F2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintSequencerFrame;                         // 0x02F3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugAutoInputDelayTime;                           // 0x02F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPlayerOneBrainCrash;                         // 0x02F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9[0x3];                                      // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalTownPeopleCrowdNum;                           // 0x02FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveTownPeopleCrowdNum;                          // 0x0300(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalTownPeopleNum;                                // 0x0304(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveTownPeopleNum;                               // 0x0308(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADebuggingItemInGameAchievementGroup> AchievementGroup;                                  // 0x030C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADebuggingItemFlagManagerGroup> CharaLibFlagGroup;                                 // 0x0314(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADebuggingItemFlagManagerGroup> EnemyLibFlagGroup;                                 // 0x031C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADebuggingItemClearGetterGroup> ClearGetterGroup;                                  // 0x0324(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ATrialParamDebugGroup>   TrialParamGroup;                                   // 0x032C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugEnemyInstantBadCondition;                    // 0x0334(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyOneKill;                                // 0x0335(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyOneBreakArmor;                          // 0x0336(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyBrainCrashAccess;                       // 0x0337(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyForceWait;                              // 0x0338(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyNoReaction;                             // 0x0339(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyDrawEyeRay;                             // 0x033A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnableEnemyHpRateDamage;                     // 0x033B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebugEnemyHPRateDamage;                            // 0x033C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DebugEnemyNoAttack;                                // 0x0340(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyAllowanceIgnoreOutOfScreen;             // 0x0341(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyAllowanceIgnoreRestrictAttackOther;     // 0x0342(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyRepopNoTime;                            // 0x0343(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyRepopNoRange;                           // 0x0344(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugStopUpdateEnemyTickEnable;                   // 0x0345(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugForceEnableUpdateEnemyTickEnable;            // 0x0346(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyDispRepopSettingData;                   // 0x0347(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyDispTickControlInfo;                    // 0x0348(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDebugEnemyDispSettingInfo;                      // 0x0349(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDebugEnemyDispGroupInfo;                        // 0x034A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyDispNavMeshFlag;                        // 0x034B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDisablePlanarReflection;                     // 0x034C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDispRevision;                                // 0x034D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDamageCalcLog;                               // 0x034E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugCrushDamageCalcLog;                          // 0x034F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugHasBrokenAllBattlefield;                     // 0x0350(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisplayLogEventAssetLoad;                         // 0x0351(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_352[0x6];                                      // 0x0352(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         DebugLoggerString;                                 // 0x0358(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 DebugLoggerTime;                                   // 0x0368(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_378[0x18];                                     // 0x0378(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugNpcNoBattle;                                 // 0x0390(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     DebugControlNonePlayerID;                          // 0x0391(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawNpcInputStick;                           // 0x0392(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_393[0x5];                                      // 0x0393(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ADebuggingManager* GetDebuggingManagerInstance(const class UObject* WorldContextObject);

	void AddDebugLogger(const class FString& String, float DrawSeconds);
	void BeginPageAjito();
	void BeginPageBattle();
	void BeginPageEnemy();
	void BeginPageEvent();
	void BeginPageParty();
	void BeginPagePlayer();
	void BeginPageRender();
	void BeginPageScene();
	void BeginPageSound();
	void BeginPageSystem();
	void BeginPageUI();
	bool DebugCreateEnemy(const struct FVector& Location);
	void DebugEnemyDispNavMesh();
	void DebugInputPause();
	void DebugInputStepFrame();
	int32 DebugSelectNextCreateEnemy(int32 AddValue);
	int32 DebugSelectPrevCreateEnemy(int32 SubValue);
	void DebugUpdateDisablePlanarReflection();
	void DrawDebugLogger(float DeltaSeconds);
	void Dump();
	void EndPageAjito();
	void EndPageBattle();
	void EndPageEnemy();
	void EndPageEvent();
	void EndPageParty();
	void EndPagePlayer();
	void EndPageRender();
	void EndPageScene();
	void EndPageSound();
	void EndPageSystem();
	void EndPageUI();
	void ExportDebuggingItemText();
	void FinishWindow();
	class FString GetDamageCalcLog();
	class FString GetDebuggingText(const class FString& Key, bool IsReferenceJp);
	class FString GetRevisionString();
	bool IsDisplayLogEventAssetLoad();
	void LoadDebuggingParameter(bool IsBroadcast);
	void RegisterChild(EDebuggingPage InPage, class ADebuggingItemBase* InItem);
	void ResetDebuggingParameter();
	void SaveDebuggingParameter();
	class ADebuggingItemBase* SearchItem(EDebuggingPage InPage, const class FText& InHashName, bool InIgnoreCase);
	void SetDebugControlNonePlayerID(EPlayerID ID);
	void SetDebugDisablePlanarReflection(bool IsDisable);
	void SetDebugDispRevisions(bool IsDisp);
	void SetDebugDrawNpcInputStick(bool Value);
	void SetDebuggingSelectStrings(const TArray<class FName>& AreaSelectLabels, const TArray<class FString>& AreaSelectStrings, const TArray<class FName>& ScenarioSelectLabels, const TArray<class FString>& ScenerioSelectStrings, const TArray<class FName>& SevedataSelectLabels, const TArray<class FString>& SavedataSelectStrings);
	void SetDebugHasBrokenAllBattlefield(bool AllBroken);
	void SetDebugNpcNoBattle(bool bEnable);
	void SetPage(EDebuggingPage InPage);
	void StartWindow();
	void TickPageAjito(float DeltaSeconds);
	void TickPageBattle(float DeltaSeconds);
	void TickPageEnemy(float DeltaSeconds);
	void TickPageEvent(float DeltaSeconds);
	void TickPageParty(float DeltaSeconds);
	void TickPagePlayer(float DeltaSeconds);
	void TickPageRender(float DeltaSeconds);
	void TickPageScene(float DeltaSeconds);
	void TickPageSound(float DeltaSeconds);
	void TickPageSystem(float DeltaSeconds);
	void TickPageUI(float DeltaSeconds);
	void UnregisterChildFromHashName(EDebuggingPage InPage, const class FText& InHashName);
	void UnregisterChildFromItem(EDebuggingPage InPage, class ADebuggingItemBase* InItem);

	class FName DebugGetCreateEnemyName() const;
	bool DebugIsDisablePlanarReflection() const;
	bool DebugIsDispRevisions() const;
	EPlayerID GetDebugControlNonePlayerID() const;
	bool GetDebugDrawNpcInputStick() const;
	float GetDebugEnemyHpRateDamage() const;
	int32 GetDebugLotteryParamIndex() const;
	bool IsDebugCrushDamageCalcLog() const;
	bool IsDebugDamageCalcLog() const;
	bool IsDebugEnableEnemyHpRateDamage() const;
	bool IsDebugEnemyAllowanceIgnoreOutOfScreen() const;
	bool IsDebugEnemyAllowanceIgnoreRestrictAttackOther() const;
	bool IsDebugEnemyBlow() const;
	bool IsDebugEnemyBrainCrashAccess() const;
	bool IsDebugEnemyDispGroupInfo() const;
	bool IsDebugEnemyDispRepopSettingData() const;
	bool IsDebugEnemyDispSettingInfo() const;
	bool IsDebugEnemyDispTickControlInfo() const;
	bool IsDebugEnemyDrawEyeRay() const;
	bool IsDebugEnemyForceWait() const;
	bool IsDebugEnemyInstantBadCondition() const;
	bool IsDebugEnemyKnockBack() const;
	bool IsDebugEnemyNoAttack() const;
	bool IsDebugEnemyNoReaction() const;
	bool IsDebugEnemyOneBreakArmor() const;
	bool IsDebugEnemyOneKill() const;
	bool IsDebugEnemyRepopNoRange() const;
	bool IsDebugEnemyRepopNoTime() const;
	bool IsDebugEnemyWince() const;
	bool IsDebugForceEnableUpdateEnemyTickEnable() const;
	bool IsDebugHasBrokenAllBattlefield() const;
	bool IsDebugNpcNoBattle() const;
	bool IsDebugStopUpdateEnemyTickEnable() const;
	bool IsEnableDebugLotteryParam() const;
	bool IsEnableDebugPauseInput() const;
	bool IsOpenWindow() const;
	bool IsReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingManager">();
	}
	static class ADebuggingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingManager>();
	}
};
static_assert(alignof(ADebuggingManager) == 0x000008, "Wrong alignment on ADebuggingManager");
static_assert(sizeof(ADebuggingManager) == 0x000398, "Wrong size on ADebuggingManager");
static_assert(offsetof(ADebuggingManager, OnReadyDebugging) == 0x000250, "Member 'ADebuggingManager::OnReadyDebugging' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, Page) == 0x000260, "Member 'ADebuggingManager::Page' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, DebuggingWidget) == 0x0002B0, "Member 'ADebuggingManager::DebuggingWidget' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, DebuggingTreeWidget) == 0x0002B8, "Member 'ADebuggingManager::DebuggingTreeWidget' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, StartupObject) == 0x0002C8, "Member 'ADebuggingManager::StartupObject' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, M_pDebugTimeSaveDataComboBox) == 0x0002E8, "Member 'ADebuggingManager::M_pDebugTimeSaveDataComboBox' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugDriveDrawCrashBonusAll) == 0x0002F0, "Member 'ADebuggingManager::bDebugDriveDrawCrashBonusAll' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugAutoInput) == 0x0002F1, "Member 'ADebuggingManager::bDebugAutoInput' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugAutoEvent) == 0x0002F2, "Member 'ADebuggingManager::bDebugAutoEvent' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugPrintSequencerFrame) == 0x0002F3, "Member 'ADebuggingManager::bDebugPrintSequencerFrame' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, DebugAutoInputDelayTime) == 0x0002F4, "Member 'ADebuggingManager::DebugAutoInputDelayTime' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugPlayerOneBrainCrash) == 0x0002F8, "Member 'ADebuggingManager::bDebugPlayerOneBrainCrash' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, TotalTownPeopleCrowdNum) == 0x0002FC, "Member 'ADebuggingManager::TotalTownPeopleCrowdNum' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, ActiveTownPeopleCrowdNum) == 0x000300, "Member 'ADebuggingManager::ActiveTownPeopleCrowdNum' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, TotalTownPeopleNum) == 0x000304, "Member 'ADebuggingManager::TotalTownPeopleNum' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, ActiveTownPeopleNum) == 0x000308, "Member 'ADebuggingManager::ActiveTownPeopleNum' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, AchievementGroup) == 0x00030C, "Member 'ADebuggingManager::AchievementGroup' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, CharaLibFlagGroup) == 0x000314, "Member 'ADebuggingManager::CharaLibFlagGroup' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, EnemyLibFlagGroup) == 0x00031C, "Member 'ADebuggingManager::EnemyLibFlagGroup' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, ClearGetterGroup) == 0x000324, "Member 'ADebuggingManager::ClearGetterGroup' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, TrialParamGroup) == 0x00032C, "Member 'ADebuggingManager::TrialParamGroup' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyInstantBadCondition) == 0x000334, "Member 'ADebuggingManager::bDebugEnemyInstantBadCondition' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyOneKill) == 0x000335, "Member 'ADebuggingManager::bDebugEnemyOneKill' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyOneBreakArmor) == 0x000336, "Member 'ADebuggingManager::bDebugEnemyOneBreakArmor' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyBrainCrashAccess) == 0x000337, "Member 'ADebuggingManager::bDebugEnemyBrainCrashAccess' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyForceWait) == 0x000338, "Member 'ADebuggingManager::bDebugEnemyForceWait' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyNoReaction) == 0x000339, "Member 'ADebuggingManager::bDebugEnemyNoReaction' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyDrawEyeRay) == 0x00033A, "Member 'ADebuggingManager::bDebugEnemyDrawEyeRay' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnableEnemyHpRateDamage) == 0x00033B, "Member 'ADebuggingManager::bDebugEnableEnemyHpRateDamage' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, DebugEnemyHPRateDamage) == 0x00033C, "Member 'ADebuggingManager::DebugEnemyHPRateDamage' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, DebugEnemyNoAttack) == 0x000340, "Member 'ADebuggingManager::DebugEnemyNoAttack' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyAllowanceIgnoreOutOfScreen) == 0x000341, "Member 'ADebuggingManager::bDebugEnemyAllowanceIgnoreOutOfScreen' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyAllowanceIgnoreRestrictAttackOther) == 0x000342, "Member 'ADebuggingManager::bDebugEnemyAllowanceIgnoreRestrictAttackOther' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyRepopNoTime) == 0x000343, "Member 'ADebuggingManager::bDebugEnemyRepopNoTime' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyRepopNoRange) == 0x000344, "Member 'ADebuggingManager::bDebugEnemyRepopNoRange' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugStopUpdateEnemyTickEnable) == 0x000345, "Member 'ADebuggingManager::bDebugStopUpdateEnemyTickEnable' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugForceEnableUpdateEnemyTickEnable) == 0x000346, "Member 'ADebuggingManager::bDebugForceEnableUpdateEnemyTickEnable' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyDispRepopSettingData) == 0x000347, "Member 'ADebuggingManager::bDebugEnemyDispRepopSettingData' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyDispTickControlInfo) == 0x000348, "Member 'ADebuggingManager::bDebugEnemyDispTickControlInfo' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bIsDebugEnemyDispSettingInfo) == 0x000349, "Member 'ADebuggingManager::bIsDebugEnemyDispSettingInfo' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bIsDebugEnemyDispGroupInfo) == 0x00034A, "Member 'ADebuggingManager::bIsDebugEnemyDispGroupInfo' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyDispNavMeshFlag) == 0x00034B, "Member 'ADebuggingManager::bDebugEnemyDispNavMeshFlag' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugDisablePlanarReflection) == 0x00034C, "Member 'ADebuggingManager::bDebugDisablePlanarReflection' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugDispRevision) == 0x00034D, "Member 'ADebuggingManager::bDebugDispRevision' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugDamageCalcLog) == 0x00034E, "Member 'ADebuggingManager::bDebugDamageCalcLog' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugCrushDamageCalcLog) == 0x00034F, "Member 'ADebuggingManager::bDebugCrushDamageCalcLog' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugHasBrokenAllBattlefield) == 0x000350, "Member 'ADebuggingManager::bDebugHasBrokenAllBattlefield' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDisplayLogEventAssetLoad) == 0x000351, "Member 'ADebuggingManager::bDisplayLogEventAssetLoad' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, DebugLoggerString) == 0x000358, "Member 'ADebuggingManager::DebugLoggerString' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, DebugLoggerTime) == 0x000368, "Member 'ADebuggingManager::DebugLoggerTime' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugNpcNoBattle) == 0x000390, "Member 'ADebuggingManager::bDebugNpcNoBattle' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, DebugControlNonePlayerID) == 0x000391, "Member 'ADebuggingManager::DebugControlNonePlayerID' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugDrawNpcInputStick) == 0x000392, "Member 'ADebuggingManager::bDebugDrawNpcInputStick' has a wrong offset!");

// Class BattlePrototype.BTD_IsEnemyDamageAnimKind_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_IsEnemyDamageAnimKind_Native final : public UBTDecoratorEnemyBase
{
public:
	EnemyDamageAnimKind                           DamageKind;                                        // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsEnemyDamageAnimKind_Native">();
	}
	static class UBTD_IsEnemyDamageAnimKind_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsEnemyDamageAnimKind_Native>();
	}
};
static_assert(alignof(UBTD_IsEnemyDamageAnimKind_Native) == 0x000008, "Wrong alignment on UBTD_IsEnemyDamageAnimKind_Native");
static_assert(sizeof(UBTD_IsEnemyDamageAnimKind_Native) == 0x0000B0, "Wrong size on UBTD_IsEnemyDamageAnimKind_Native");
static_assert(offsetof(UBTD_IsEnemyDamageAnimKind_Native, DamageKind) == 0x0000A8, "Member 'UBTD_IsEnemyDamageAnimKind_Native::DamageKind' has a wrong offset!");

// Class BattlePrototype.UIMainContentsSubTab
// 0x0050 (0x03D8 - 0x0388)
class UUIMainContentsSubTab : public UUIBase
{
public:
	uint8                                         Pad_388[0x50];                                     // 0x0388(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimUnselect, class UREDTextBlock* TextCategory);
	void SetSelect(bool IsSelect);
	void SetTitle(const class FText& Text);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMainContentsSubTab">();
	}
	static class UUIMainContentsSubTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMainContentsSubTab>();
	}
};
static_assert(alignof(UUIMainContentsSubTab) == 0x000008, "Wrong alignment on UUIMainContentsSubTab");
static_assert(sizeof(UUIMainContentsSubTab) == 0x0003D8, "Wrong size on UUIMainContentsSubTab");

// Class BattlePrototype.BTD_IsEnemyDamageDownAnimKind_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_IsEnemyDamageDownAnimKind_Native final : public UBTDecoratorEnemyBase
{
public:
	EnemyDamageDownAnimKind                       DamageDownKind;                                    // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsEnemyDamageDownAnimKind_Native">();
	}
	static class UBTD_IsEnemyDamageDownAnimKind_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsEnemyDamageDownAnimKind_Native>();
	}
};
static_assert(alignof(UBTD_IsEnemyDamageDownAnimKind_Native) == 0x000008, "Wrong alignment on UBTD_IsEnemyDamageDownAnimKind_Native");
static_assert(sizeof(UBTD_IsEnemyDamageDownAnimKind_Native) == 0x0000B0, "Wrong size on UBTD_IsEnemyDamageDownAnimKind_Native");
static_assert(offsetof(UBTD_IsEnemyDamageDownAnimKind_Native, DamageDownKind) == 0x0000A8, "Member 'UBTD_IsEnemyDamageDownAnimKind_Native::DamageDownKind' has a wrong offset!");

// Class BattlePrototype.BTD_IsEnemyDamageStopAnimKind_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_IsEnemyDamageStopAnimKind_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsEnemyDamageStopAnimKind_Native">();
	}
	static class UBTD_IsEnemyDamageStopAnimKind_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsEnemyDamageStopAnimKind_Native>();
	}
};
static_assert(alignof(UBTD_IsEnemyDamageStopAnimKind_Native) == 0x000008, "Wrong alignment on UBTD_IsEnemyDamageStopAnimKind_Native");
static_assert(sizeof(UBTD_IsEnemyDamageStopAnimKind_Native) == 0x0000A8, "Wrong size on UBTD_IsEnemyDamageStopAnimKind_Native");

// Class BattlePrototype.EnemyFixParamComponentBase
// 0x0068 (0x0128 - 0x00C0)
class UEnemyFixParamComponentBase : public UActorComponent
{
public:
	float                                         MChangeCrashHighRate;                              // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MCrashDamageTime;                                  // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MLaunchLMotionScale;                               // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MReactionSWeakCorrectionValue;                     // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MReactionLWeakCorrectionValue;                     // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDownWeakCorrectionValue;                          // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MCrashWeakCorrectionValue;                         // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MRouteReactionSBonus;                              // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MRouteReactionLBonus;                              // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MRouteDownBonus;                                   // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDownCrashBonus;                                   // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MBCChancePlayRate;                                 // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDetectIcon_FindSeconds;                           // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MSensingHeight;                                    // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MEnableMoveHeight;                                 // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAIActionHeight;                                   // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTickPriority_RangeTop;                            // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTickPriority_RangeMiddle;                         // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTickPriority_HeightTop;                           // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTickPriority_IntervalTop;                         // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTickPriority_LimitTop;                            // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTickPriority_IntervalMiddle;                      // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTickPriority_LimitMiddle;                         // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTickPriority_IntervalBottom;                      // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTickPriority_LimitBottom;                         // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyFixParamComponentBase">();
	}
	static class UEnemyFixParamComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyFixParamComponentBase>();
	}
};
static_assert(alignof(UEnemyFixParamComponentBase) == 0x000008, "Wrong alignment on UEnemyFixParamComponentBase");
static_assert(sizeof(UEnemyFixParamComponentBase) == 0x000128, "Wrong size on UEnemyFixParamComponentBase");
static_assert(offsetof(UEnemyFixParamComponentBase, MChangeCrashHighRate) == 0x0000C0, "Member 'UEnemyFixParamComponentBase::MChangeCrashHighRate' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MCrashDamageTime) == 0x0000C4, "Member 'UEnemyFixParamComponentBase::MCrashDamageTime' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MLaunchLMotionScale) == 0x0000C8, "Member 'UEnemyFixParamComponentBase::MLaunchLMotionScale' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MReactionSWeakCorrectionValue) == 0x0000CC, "Member 'UEnemyFixParamComponentBase::MReactionSWeakCorrectionValue' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MReactionLWeakCorrectionValue) == 0x0000D0, "Member 'UEnemyFixParamComponentBase::MReactionLWeakCorrectionValue' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MDownWeakCorrectionValue) == 0x0000D4, "Member 'UEnemyFixParamComponentBase::MDownWeakCorrectionValue' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MCrashWeakCorrectionValue) == 0x0000D8, "Member 'UEnemyFixParamComponentBase::MCrashWeakCorrectionValue' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MRouteReactionSBonus) == 0x0000DC, "Member 'UEnemyFixParamComponentBase::MRouteReactionSBonus' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MRouteReactionLBonus) == 0x0000E0, "Member 'UEnemyFixParamComponentBase::MRouteReactionLBonus' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MRouteDownBonus) == 0x0000E4, "Member 'UEnemyFixParamComponentBase::MRouteDownBonus' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MDownCrashBonus) == 0x0000E8, "Member 'UEnemyFixParamComponentBase::MDownCrashBonus' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MBCChancePlayRate) == 0x0000EC, "Member 'UEnemyFixParamComponentBase::MBCChancePlayRate' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MDetectIcon_FindSeconds) == 0x0000F0, "Member 'UEnemyFixParamComponentBase::MDetectIcon_FindSeconds' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MSensingHeight) == 0x0000F4, "Member 'UEnemyFixParamComponentBase::MSensingHeight' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MEnableMoveHeight) == 0x0000F8, "Member 'UEnemyFixParamComponentBase::MEnableMoveHeight' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MAIActionHeight) == 0x0000FC, "Member 'UEnemyFixParamComponentBase::MAIActionHeight' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MTickPriority_RangeTop) == 0x000100, "Member 'UEnemyFixParamComponentBase::MTickPriority_RangeTop' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MTickPriority_RangeMiddle) == 0x000104, "Member 'UEnemyFixParamComponentBase::MTickPriority_RangeMiddle' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MTickPriority_HeightTop) == 0x000108, "Member 'UEnemyFixParamComponentBase::MTickPriority_HeightTop' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MTickPriority_IntervalTop) == 0x00010C, "Member 'UEnemyFixParamComponentBase::MTickPriority_IntervalTop' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MTickPriority_LimitTop) == 0x000110, "Member 'UEnemyFixParamComponentBase::MTickPriority_LimitTop' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MTickPriority_IntervalMiddle) == 0x000114, "Member 'UEnemyFixParamComponentBase::MTickPriority_IntervalMiddle' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MTickPriority_LimitMiddle) == 0x000118, "Member 'UEnemyFixParamComponentBase::MTickPriority_LimitMiddle' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MTickPriority_IntervalBottom) == 0x00011C, "Member 'UEnemyFixParamComponentBase::MTickPriority_IntervalBottom' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MTickPriority_LimitBottom) == 0x000120, "Member 'UEnemyFixParamComponentBase::MTickPriority_LimitBottom' has a wrong offset!");

// Class BattlePrototype.BTD_IsEnemyKind_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_IsEnemyKind_Native final : public UBTDecoratorEnemyBase
{
public:
	EnemyKind                                     _EnemyKind;                                        // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsEnemyKind_Native">();
	}
	static class UBTD_IsEnemyKind_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsEnemyKind_Native>();
	}
};
static_assert(alignof(UBTD_IsEnemyKind_Native) == 0x000008, "Wrong alignment on UBTD_IsEnemyKind_Native");
static_assert(sizeof(UBTD_IsEnemyKind_Native) == 0x0000B0, "Wrong size on UBTD_IsEnemyKind_Native");
static_assert(offsetof(UBTD_IsEnemyKind_Native, _EnemyKind) == 0x0000A8, "Member 'UBTD_IsEnemyKind_Native::_EnemyKind' has a wrong offset!");

// Class BattlePrototype.ActivityManager
// 0x00D8 (0x0100 - 0x0028)
class UActivityManager final : public UObject
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             ProgressIDTable_Yuito;                             // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             ProgressIDTable_Kasane;                            // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x70];                                      // 0x0090(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndBondsEpisodeActivity(EPlayerID PlayerId, EPlayerID TargetID, int32 ProgressId, EGameActivityOutcome Outcome);
	void EndMainEpisodeActivity(EPlayerID PlayerId, int32 ProgressId, EGameActivityOutcome Outcome);
	void ResumeBondsEpisodeActivity(EPlayerID PlayerId, EPlayerID TargetID, int32 ProgressId);
	void ResumeMainEpisodeActivity(EPlayerID PlayerId, int32 ProgressId);
	void SetDebugDrawFlag(bool IsDraw, EDebugGameActivityDisplayFlag Type);
	void SetDisableFlag(EGameActivityDisableFlag Type, bool IsDisable);
	void StartMainEpisodeActivity(EPlayerID PlayerId, int32 ProgressId);
	void StartNewGame(EPlayerID PlayerId, int32 ProgressId);
	void Update();
	void UpdateBondsEpisodeActivity(EPlayerID PlayerId, EPlayerID TargetID, int32 ProgressId);
	void UpdateMainEpisodeActivity(EPlayerID PlayerId, int32 beforeProgressID, int32 NextProgressID);
	void WaitUntilComplete();

	EPlayerID GetMainCharacter(int32 SelectedScenario) const;
	bool IsDisableFlag(EGameActivityDisableFlag Type) const;
	bool IsExistBondsEpisodeActivity(EPlayerID PlayerId, int32 ProgressId) const;
	bool IsExsistDebugDrawFlag(EDebugGameActivityDisplayFlag Type) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivityManager">();
	}
	static class UActivityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivityManager>();
	}
};
static_assert(alignof(UActivityManager) == 0x000008, "Wrong alignment on UActivityManager");
static_assert(sizeof(UActivityManager) == 0x000100, "Wrong size on UActivityManager");
static_assert(offsetof(UActivityManager, ProgressIDTable_Yuito) == 0x000080, "Member 'UActivityManager::ProgressIDTable_Yuito' has a wrong offset!");
static_assert(offsetof(UActivityManager, ProgressIDTable_Kasane) == 0x000088, "Member 'UActivityManager::ProgressIDTable_Kasane' has a wrong offset!");

// Class BattlePrototype.DelegatableActor
// 0x0000 (0x0230 - 0x0230)
class ADelegatableActor final : public AActor
{
public:
	void OnPostEditChange();
	void OnPostEditMove();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelegatableActor">();
	}
	static class ADelegatableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelegatableActor>();
	}
};
static_assert(alignof(ADelegatableActor) == 0x000008, "Wrong alignment on ADelegatableActor");
static_assert(sizeof(ADelegatableActor) == 0x000230, "Wrong size on ADelegatableActor");

// Class BattlePrototype.BTD_IsEnemyStopAnimKind_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_IsEnemyStopAnimKind_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsEnemyStopAnimKind_Native">();
	}
	static class UBTD_IsEnemyStopAnimKind_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsEnemyStopAnimKind_Native>();
	}
};
static_assert(alignof(UBTD_IsEnemyStopAnimKind_Native) == 0x000008, "Wrong alignment on UBTD_IsEnemyStopAnimKind_Native");
static_assert(sizeof(UBTD_IsEnemyStopAnimKind_Native) == 0x0000A8, "Wrong size on UBTD_IsEnemyStopAnimKind_Native");

// Class BattlePrototype.NpcSequencerActor
// 0x0030 (0x0320 - 0x02F0)
class ANpcSequencerActor final : public ANpcSkeletalMeshActor
{
public:
	class UBoxComponent*                          BoundBoxComponent;                                 // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       BoundCollisionHead;                                // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       BoundCollisionHandLeft;                            // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       BoundCollisionHandRight;                           // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       BoundCollisionFootLeft;                            // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       BoundCollisionFootRight;                           // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcSequencerActor">();
	}
	static class ANpcSequencerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcSequencerActor>();
	}
};
static_assert(alignof(ANpcSequencerActor) == 0x000010, "Wrong alignment on ANpcSequencerActor");
static_assert(sizeof(ANpcSequencerActor) == 0x000320, "Wrong size on ANpcSequencerActor");
static_assert(offsetof(ANpcSequencerActor, BoundBoxComponent) == 0x0002F0, "Member 'ANpcSequencerActor::BoundBoxComponent' has a wrong offset!");
static_assert(offsetof(ANpcSequencerActor, BoundCollisionHead) == 0x0002F8, "Member 'ANpcSequencerActor::BoundCollisionHead' has a wrong offset!");
static_assert(offsetof(ANpcSequencerActor, BoundCollisionHandLeft) == 0x000300, "Member 'ANpcSequencerActor::BoundCollisionHandLeft' has a wrong offset!");
static_assert(offsetof(ANpcSequencerActor, BoundCollisionHandRight) == 0x000308, "Member 'ANpcSequencerActor::BoundCollisionHandRight' has a wrong offset!");
static_assert(offsetof(ANpcSequencerActor, BoundCollisionFootLeft) == 0x000310, "Member 'ANpcSequencerActor::BoundCollisionFootLeft' has a wrong offset!");
static_assert(offsetof(ANpcSequencerActor, BoundCollisionFootRight) == 0x000318, "Member 'ANpcSequencerActor::BoundCollisionFootRight' has a wrong offset!");

// Class BattlePrototype.BTD_IsEnemyTargetNearRange_Native
// 0x0030 (0x00D8 - 0x00A8)
class UBTD_IsEnemyTargetNearRange_Native final : public UBTDecoratorEnemyBase
{
public:
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NearRange;                                         // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInRange;                                         // 0x00D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsEnemyTargetNearRange_Native">();
	}
	static class UBTD_IsEnemyTargetNearRange_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsEnemyTargetNearRange_Native>();
	}
};
static_assert(alignof(UBTD_IsEnemyTargetNearRange_Native) == 0x000008, "Wrong alignment on UBTD_IsEnemyTargetNearRange_Native");
static_assert(sizeof(UBTD_IsEnemyTargetNearRange_Native) == 0x0000D8, "Wrong size on UBTD_IsEnemyTargetNearRange_Native");
static_assert(offsetof(UBTD_IsEnemyTargetNearRange_Native, NearRange) == 0x0000D0, "Member 'UBTD_IsEnemyTargetNearRange_Native::NearRange' has a wrong offset!");
static_assert(offsetof(UBTD_IsEnemyTargetNearRange_Native, IsInRange) == 0x0000D4, "Member 'UBTD_IsEnemyTargetNearRange_Native::IsInRange' has a wrong offset!");

// Class BattlePrototype.BTD_IsEnemyWait_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_IsEnemyWait_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsEnemyWait_Native">();
	}
	static class UBTD_IsEnemyWait_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsEnemyWait_Native>();
	}
};
static_assert(alignof(UBTD_IsEnemyWait_Native) == 0x000008, "Wrong alignment on UBTD_IsEnemyWait_Native");
static_assert(sizeof(UBTD_IsEnemyWait_Native) == 0x0000A8, "Wrong size on UBTD_IsEnemyWait_Native");

// Class BattlePrototype.UIMain3DManager
// 0x0030 (0x0260 - 0x0230)
class AUIMain3DManager : public AActor
{
public:
	class UDataTable*                             SceneDataTable;                                    // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PlayerDataTable;                                   // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PlayerEquipGeneralDataTable;                       // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             BGCameraDataTable;                                 // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x10];                                     // 0x0250(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetBGCameraSetting(struct FUIMain3DBGCameraSetting* Setting);
	bool GetEquipSetting(class UDataTable* DataTable, EUIMain3DEquipCameraID CameraID, struct FUIMain3DCharacterEquipSetting* Setting);
	bool GetPlayerSetting(int32 PlayerUniqueID, struct FUIMain3DCharacterPlayerSetting* Setting);
	bool GetSceneSetting(EUIMain3DCharacterSceneID SceneID, struct FUIMain3DCharacterSceneSetting* Setting);
	bool IsTexturesThatUsedAtMeshLoaded(class UMeshComponent* MeshComp);
	void LoadTextureRelationEquip(class UMeshComponent* MeshComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMain3DManager">();
	}
	static class AUIMain3DManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIMain3DManager>();
	}
};
static_assert(alignof(AUIMain3DManager) == 0x000008, "Wrong alignment on AUIMain3DManager");
static_assert(sizeof(AUIMain3DManager) == 0x000260, "Wrong size on AUIMain3DManager");
static_assert(offsetof(AUIMain3DManager, SceneDataTable) == 0x000230, "Member 'AUIMain3DManager::SceneDataTable' has a wrong offset!");
static_assert(offsetof(AUIMain3DManager, PlayerDataTable) == 0x000238, "Member 'AUIMain3DManager::PlayerDataTable' has a wrong offset!");
static_assert(offsetof(AUIMain3DManager, PlayerEquipGeneralDataTable) == 0x000240, "Member 'AUIMain3DManager::PlayerEquipGeneralDataTable' has a wrong offset!");
static_assert(offsetof(AUIMain3DManager, BGCameraDataTable) == 0x000248, "Member 'AUIMain3DManager::BGCameraDataTable' has a wrong offset!");

// Class BattlePrototype.BTD_IsFlyEnemy_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_IsFlyEnemy_Native final : public UBTDecoratorEnemyBase
{
public:
	bool                                          bIsFlying;                                         // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsFlyEnemy_Native">();
	}
	static class UBTD_IsFlyEnemy_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsFlyEnemy_Native>();
	}
};
static_assert(alignof(UBTD_IsFlyEnemy_Native) == 0x000008, "Wrong alignment on UBTD_IsFlyEnemy_Native");
static_assert(sizeof(UBTD_IsFlyEnemy_Native) == 0x0000B0, "Wrong size on UBTD_IsFlyEnemy_Native");
static_assert(offsetof(UBTD_IsFlyEnemy_Native, bIsFlying) == 0x0000A8, "Member 'UBTD_IsFlyEnemy_Native::bIsFlying' has a wrong offset!");

// Class BattlePrototype.DebugInfoScreenBase
// 0x0098 (0x02C8 - 0x0230)
class ADebugInfoScreenBase : public AActor
{
public:
	TArray<struct FDebugInfoScreenData>           DataList;                                          // 0x0230(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_240[0x20];                                     // 0x0240(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            RenderWidget;                                      // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTextBlock*>                     TextWidgetList;                                    // 0x0268(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278[0x50];                                     // 0x0278(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugInfoScreenBase">();
	}
	static class ADebugInfoScreenBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugInfoScreenBase>();
	}
};
static_assert(alignof(ADebugInfoScreenBase) == 0x000008, "Wrong alignment on ADebugInfoScreenBase");
static_assert(sizeof(ADebugInfoScreenBase) == 0x0002C8, "Wrong size on ADebugInfoScreenBase");
static_assert(offsetof(ADebugInfoScreenBase, DataList) == 0x000230, "Member 'ADebugInfoScreenBase::DataList' has a wrong offset!");
static_assert(offsetof(ADebugInfoScreenBase, RenderWidget) == 0x000260, "Member 'ADebugInfoScreenBase::RenderWidget' has a wrong offset!");
static_assert(offsetof(ADebugInfoScreenBase, TextWidgetList) == 0x000268, "Member 'ADebugInfoScreenBase::TextWidgetList' has a wrong offset!");

// Class BattlePrototype.BTD_IsFlyType_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_IsFlyType_Native final : public UBTDecoratorEnemyBase
{
public:
	bool                                          bIsFlying;                                         // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsFlyType_Native">();
	}
	static class UBTD_IsFlyType_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsFlyType_Native>();
	}
};
static_assert(alignof(UBTD_IsFlyType_Native) == 0x000008, "Wrong alignment on UBTD_IsFlyType_Native");
static_assert(sizeof(UBTD_IsFlyType_Native) == 0x0000B0, "Wrong size on UBTD_IsFlyType_Native");
static_assert(offsetof(UBTD_IsFlyType_Native, bIsFlying) == 0x0000A8, "Member 'UBTD_IsFlyType_Native::bIsFlying' has a wrong offset!");

// Class BattlePrototype.UICharaPresentWindow
// 0x00F0 (0x0478 - 0x0388)
class UUICharaPresentWindow : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ColorNumNormal;                                    // 0x03A0(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ColorNumMax;                                       // 0x03B0(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0xB8];                                     // 0x03C0(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UREDScrollBox* ScrollBox, class UUICharaPresentListIndex* ChildListIndex, class UImage* ImagePresent, class UTextBlock* TextTitleBar, class UTextBlock* TextCharaName, class UBorder* borderBondLevelNum, class UTextBlock* TextBondLevelNum, class UTextBlock* TextItemName, class UBorder* borderCurrentNum, class UTextBlock* TextCurrentNum, class UTextBlock* TextSlash, class UTextBlock* TextMaxNum, class UUIGuide* ChildGuide);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUpdateElement(int32 Index_0, class UUserWidget* Widget);
	bool SetFaceIcon(EPlayerID CharacterId);
	bool SetFavorabilityIcon(EItemFavorability Favorability);
	bool SetItemInfo(const class FName& ItemId);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICharaPresentWindow">();
	}
	static class UUICharaPresentWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICharaPresentWindow>();
	}
};
static_assert(alignof(UUICharaPresentWindow) == 0x000008, "Wrong alignment on UUICharaPresentWindow");
static_assert(sizeof(UUICharaPresentWindow) == 0x000478, "Wrong size on UUICharaPresentWindow");
static_assert(offsetof(UUICharaPresentWindow, ListElementSize) == 0x000388, "Member 'UUICharaPresentWindow::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUICharaPresentWindow, ListOffsetSize) == 0x000390, "Member 'UUICharaPresentWindow::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUICharaPresentWindow, ListIndexClass) == 0x000398, "Member 'UUICharaPresentWindow::ListIndexClass' has a wrong offset!");
static_assert(offsetof(UUICharaPresentWindow, ColorNumNormal) == 0x0003A0, "Member 'UUICharaPresentWindow::ColorNumNormal' has a wrong offset!");
static_assert(offsetof(UUICharaPresentWindow, ColorNumMax) == 0x0003B0, "Member 'UUICharaPresentWindow::ColorNumMax' has a wrong offset!");

// Class BattlePrototype.BTD_IsInitLayout_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_IsInitLayout_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsInitLayout_Native">();
	}
	static class UBTD_IsInitLayout_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsInitLayout_Native>();
	}
};
static_assert(alignof(UBTD_IsInitLayout_Native) == 0x000008, "Wrong alignment on UBTD_IsInitLayout_Native");
static_assert(sizeof(UBTD_IsInitLayout_Native) == 0x0000A8, "Wrong size on UBTD_IsInitLayout_Native");

// Class BattlePrototype.BTD_IsMoveAnim_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_IsMoveAnim_Native final : public UBTDecoratorEnemyBase
{
public:
	EnemyMoveAnimKind                             _MoveAnimKind;                                     // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsMoveAnim_Native">();
	}
	static class UBTD_IsMoveAnim_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsMoveAnim_Native>();
	}
};
static_assert(alignof(UBTD_IsMoveAnim_Native) == 0x000008, "Wrong alignment on UBTD_IsMoveAnim_Native");
static_assert(sizeof(UBTD_IsMoveAnim_Native) == 0x0000B0, "Wrong size on UBTD_IsMoveAnim_Native");
static_assert(offsetof(UBTD_IsMoveAnim_Native, _MoveAnimKind) == 0x0000A8, "Member 'UBTD_IsMoveAnim_Native::_MoveAnimKind' has a wrong offset!");

// Class BattlePrototype.DatabaseManager
// 0x0278 (0x02A0 - 0x0028)
class UDatabaseManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemData*                              ItemData;                                          // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTextDatabaseData>              TextList;                                          // 0x0038(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, class UMessageData*>      MessageList;                                       // 0x0048(0x0050)(Protected, NativeAccessSpecifierProtected)
	class UEnemyDropData*                         EnemyDropData;                                     // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTradeItemData*                         TradeItemData;                                     // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQuestData*                             QuestData;                                         // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrainMessageData*                      BrainMessageData;                                  // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULoadTipsData*                          LoadTipsData;                                      // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULibraryEnemyData*                      LibraryEnemyData;                                  // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULibraryCharaData*                      LibraryCharaData;                                  // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHelpTutorialData*                      HelpTutorialData;                                  // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDetailedMapData*                       DetailedMapData;                                   // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             SpeakerData;                                       // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShowDestinationData*                   ShowDestinationData;                               // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPresentData*                           PresentData;                                       // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWorldmapBatchOpenData*                 WorldmapBatchOpenData;                             // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FItemFavorabilityParamDataCell> ItemFavorabilityParam;                             // 0x0100(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBondsLevelupData*                      BondsLevelupData;                                  // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTeamBondsLevelupData*                  TeamBondsLevelupData;                              // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FActionIconSupportParam>        ActionIconSupportParamList;                        // 0x0120(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBrainTalkDataBase                     M_BrainTalkDatabase;                               // 0x0130(0x0120)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x28];                                     // 0x0250(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPlayerID>                             M_CharaSortListM;                                  // 0x0278(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EPlayerID>                             M_CharaSortListF;                                  // 0x0288(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BT_BrainTalkAsyncLoadExec();
	void BT_BrainTalkAsyncLoadStart();
	void BT_BrainTalkLoadWork();
	void BT_LoadCategoryDatatable();
	class UMessageData* FindMessageData(const class FString& TableName);
	class UBrainMessageData* GetBrainMessageData();
	class UDetailedMapData* GetDetailedMapData();
	class UEnemyDropData* GetEnemyDropData();
	class UHelpTutorialData* GetHelpTutorialData();
	class UItemData* GetItemData();
	class FString GetItemDataDescription(class FName ID);
	class FString GetItemDataName(class FName ID);
	float GetItemFavorabilityParam(EItemFavorability Favorability, bool IsFirstTime);
	class ULibraryCharaData* GetLibraryCharaData();
	class ULibraryEnemyData* GetLibraryEnemyData();
	class ULoadTipsData* GetLoadTipsData();
	bool GetMessageData(struct FMessageDataCell* MessageDataCell, const class FString& TableName, const class FString& ID);
	const TArray<EPlayerID> GetPlayerSortList(EPlayerID MainID);
	class UPresentData* GetPresentData();
	class UQuestData* GetQuestData();
	class UShowDestinationData* GetShowDestinationData();
	void GetSpeakerData(class FName RowName, struct FMessageDataCell* SpeakerData_0);
	class FString GetText(ETextType TextType, class FName ID);
	class UTradeItemData* GetTradeItemData();
	class FString GetWhoSpeak(const class FString& DisplayName);
	void Initialize();
	bool IsFinishBrainTalkLoad();
	bool LoadAndAppendMessageFromPath(const class FString& TableName, const class FString& FilePath);
	bool LoadMessage(const class FString& TableName, class UDataTable* DataTable);
	bool LoadMessageFromDataTable(const class FString& TableName, class UDataTable* DataTable);
	bool LoadMessageFromPath(const class FString& TableName, const class FString& FilePath);
	bool LoadResidentMessageData();
	bool LoadTextFromPath(ETextType TextType, const class FString& FilePath);
	void PreLoadAllVoiceLast(const class FString& TableName);
	bool UnloadMessage(const class FString& TableName);
	void UnloadMessageAll();
	bool UnloadText(ETextType TextType);
	void UnloadTextAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatabaseManager">();
	}
	static class UDatabaseManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatabaseManager>();
	}
};
static_assert(alignof(UDatabaseManager) == 0x000010, "Wrong alignment on UDatabaseManager");
static_assert(sizeof(UDatabaseManager) == 0x0002A0, "Wrong size on UDatabaseManager");
static_assert(offsetof(UDatabaseManager, ItemData) == 0x000030, "Member 'UDatabaseManager::ItemData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, TextList) == 0x000038, "Member 'UDatabaseManager::TextList' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, MessageList) == 0x000048, "Member 'UDatabaseManager::MessageList' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, EnemyDropData) == 0x000098, "Member 'UDatabaseManager::EnemyDropData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, TradeItemData) == 0x0000A0, "Member 'UDatabaseManager::TradeItemData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, QuestData) == 0x0000A8, "Member 'UDatabaseManager::QuestData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, BrainMessageData) == 0x0000B0, "Member 'UDatabaseManager::BrainMessageData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, LoadTipsData) == 0x0000B8, "Member 'UDatabaseManager::LoadTipsData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, LibraryEnemyData) == 0x0000C0, "Member 'UDatabaseManager::LibraryEnemyData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, LibraryCharaData) == 0x0000C8, "Member 'UDatabaseManager::LibraryCharaData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, HelpTutorialData) == 0x0000D0, "Member 'UDatabaseManager::HelpTutorialData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, DetailedMapData) == 0x0000D8, "Member 'UDatabaseManager::DetailedMapData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, SpeakerData) == 0x0000E0, "Member 'UDatabaseManager::SpeakerData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, ShowDestinationData) == 0x0000E8, "Member 'UDatabaseManager::ShowDestinationData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, PresentData) == 0x0000F0, "Member 'UDatabaseManager::PresentData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, WorldmapBatchOpenData) == 0x0000F8, "Member 'UDatabaseManager::WorldmapBatchOpenData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, ItemFavorabilityParam) == 0x000100, "Member 'UDatabaseManager::ItemFavorabilityParam' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, BondsLevelupData) == 0x000110, "Member 'UDatabaseManager::BondsLevelupData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, TeamBondsLevelupData) == 0x000118, "Member 'UDatabaseManager::TeamBondsLevelupData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, ActionIconSupportParamList) == 0x000120, "Member 'UDatabaseManager::ActionIconSupportParamList' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, M_BrainTalkDatabase) == 0x000130, "Member 'UDatabaseManager::M_BrainTalkDatabase' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, M_CharaSortListM) == 0x000278, "Member 'UDatabaseManager::M_CharaSortListM' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, M_CharaSortListF) == 0x000288, "Member 'UDatabaseManager::M_CharaSortListF' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerBase
// 0x0038 (0x00A0 - 0x0068)
class UBTDecorator_RSPlayerBase : public UBTDecorator
{
public:
	class AAIController*                          _AIOwner;                                          // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerScriptComponent*                 _PlayerScript;                                     // 0x0070(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           ObservedKeyNames;                                  // 0x0078(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCheckConditionOnlyBlackBoardChanges : 1;          // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsObservingBB : 1;                                // 0x0098(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerBase">();
	}
	static class UBTDecorator_RSPlayerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerBase>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerBase) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerBase");
static_assert(sizeof(UBTDecorator_RSPlayerBase) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerBase");
static_assert(offsetof(UBTDecorator_RSPlayerBase, _AIOwner) == 0x000068, "Member 'UBTDecorator_RSPlayerBase::_AIOwner' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RSPlayerBase, _PlayerScript) == 0x000070, "Member 'UBTDecorator_RSPlayerBase::_PlayerScript' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RSPlayerBase, ObservedKeyNames) == 0x000078, "Member 'UBTDecorator_RSPlayerBase::ObservedKeyNames' has a wrong offset!");

// Class BattlePrototype.EasyNavNode
// 0x0008 (0x0238 - 0x0230)
class AEasyNavNode final : public AActor
{
public:
	class UBoxComponent*                          BoxComponent;                                      // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EasyNavNode">();
	}
	static class AEasyNavNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEasyNavNode>();
	}
};
static_assert(alignof(AEasyNavNode) == 0x000008, "Wrong alignment on AEasyNavNode");
static_assert(sizeof(AEasyNavNode) == 0x000238, "Wrong size on AEasyNavNode");
static_assert(offsetof(AEasyNavNode, BoxComponent) == 0x000230, "Member 'AEasyNavNode::BoxComponent' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerCheckDistanceToPlayer
// 0x0008 (0x00A8 - 0x00A0)
class UBTDecorator_RSPlayerCheckDistanceToPlayer final : public UBTDecorator_RSPlayerBase
{
public:
	float                                         Distance;                                          // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerCheckDistanceToPlayer">();
	}
	static class UBTDecorator_RSPlayerCheckDistanceToPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerCheckDistanceToPlayer>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerCheckDistanceToPlayer) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerCheckDistanceToPlayer");
static_assert(sizeof(UBTDecorator_RSPlayerCheckDistanceToPlayer) == 0x0000A8, "Wrong size on UBTDecorator_RSPlayerCheckDistanceToPlayer");
static_assert(offsetof(UBTDecorator_RSPlayerCheckDistanceToPlayer, Distance) == 0x0000A0, "Member 'UBTDecorator_RSPlayerCheckDistanceToPlayer::Distance' has a wrong offset!");

// Class BattlePrototype.OnlineTestDestroySession
// 0x0048 (0x0078 - 0x0030)
class UOnlineTestDestroySession final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOnlineTestDestroySession* OnlineTestDestroySession(class UObject* WorldContextObject, class APlayerController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineTestDestroySession">();
	}
	static class UOnlineTestDestroySession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineTestDestroySession>();
	}
};
static_assert(alignof(UOnlineTestDestroySession) == 0x000008, "Wrong alignment on UOnlineTestDestroySession");
static_assert(sizeof(UOnlineTestDestroySession) == 0x000078, "Wrong size on UOnlineTestDestroySession");
static_assert(offsetof(UOnlineTestDestroySession, OnSuccess) == 0x000030, "Member 'UOnlineTestDestroySession::OnSuccess' has a wrong offset!");
static_assert(offsetof(UOnlineTestDestroySession, OnFailure) == 0x000040, "Member 'UOnlineTestDestroySession::OnFailure' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsAssist
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsAssist final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsAssist">();
	}
	static class UBTDecorator_RSPlayerIsAssist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsAssist>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsAssist) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsAssist");
static_assert(sizeof(UBTDecorator_RSPlayerIsAssist) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsAssist");

// Class BattlePrototype.BTDecorator_RSPlayerIsAttackAble
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsAttackAble final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsAttackAble">();
	}
	static class UBTDecorator_RSPlayerIsAttackAble* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsAttackAble>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsAttackAble) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsAttackAble");
static_assert(sizeof(UBTDecorator_RSPlayerIsAttackAble) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsAttackAble");

// Class BattlePrototype.UICharaName
// 0x0040 (0x03C8 - 0x0388)
class UUICharaName : public UUIBase
{
public:
	float                                         DrawSecond;                                        // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0x3C];                                     // 0x038C(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextCharaName, class UTextBlock* TextCharaName2);
	void Start(const class FString& CharaID);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICharaName">();
	}
	static class UUICharaName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICharaName>();
	}
};
static_assert(alignof(UUICharaName) == 0x000008, "Wrong alignment on UUICharaName");
static_assert(sizeof(UUICharaName) == 0x0003C8, "Wrong size on UUICharaName");
static_assert(offsetof(UUICharaName, DrawSecond) == 0x000388, "Member 'UUICharaName::DrawSecond' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsBattleMode
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsBattleMode final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsBattleMode">();
	}
	static class UBTDecorator_RSPlayerIsBattleMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsBattleMode>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsBattleMode) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsBattleMode");
static_assert(sizeof(UBTDecorator_RSPlayerIsBattleMode) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsBattleMode");

// Class BattlePrototype.FootStepComponent
// 0x0028 (0x00E8 - 0x00C0)
class UFootStepComponent final : public UActorComponent
{
public:
	class FName                                   EffectTableId;                                     // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoundTableId;                                      // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterPhysicalSurfaceActionEffectResource* EffectActionResCache;                              // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterPhysicalSurfaceActionSoundResource* SoundActionResCache;                               // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBeginPlayLoadAsset;                              // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayEffect(const EGamePhysicalSurfaceType PhysicsType, const ECharacterPhysicalActionType ActionType, const struct FTransform& Transform, class AActor* Creator);
	void PlayEffectByName(const EGamePhysicalSurfaceType PhysicsType, class FName ActionType, const struct FTransform& Transform, class AActor* Creator);
	void PlaySound(const EGamePhysicalSurfaceType PhysicsType, const ECharacterPhysicalActionType ActionType, const struct FVector& Location, const struct FRotator& Rotation, class AActor* Creator);
	void PlaySoundByName(const EGamePhysicalSurfaceType PhysicsType, class FName ActionType, const struct FVector& Location, const struct FRotator& Rotation, class AActor* Creator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootStepComponent">();
	}
	static class UFootStepComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootStepComponent>();
	}
};
static_assert(alignof(UFootStepComponent) == 0x000008, "Wrong alignment on UFootStepComponent");
static_assert(sizeof(UFootStepComponent) == 0x0000E8, "Wrong size on UFootStepComponent");
static_assert(offsetof(UFootStepComponent, EffectTableId) == 0x0000C0, "Member 'UFootStepComponent::EffectTableId' has a wrong offset!");
static_assert(offsetof(UFootStepComponent, SoundTableId) == 0x0000C8, "Member 'UFootStepComponent::SoundTableId' has a wrong offset!");
static_assert(offsetof(UFootStepComponent, EffectActionResCache) == 0x0000D0, "Member 'UFootStepComponent::EffectActionResCache' has a wrong offset!");
static_assert(offsetof(UFootStepComponent, SoundActionResCache) == 0x0000D8, "Member 'UFootStepComponent::SoundActionResCache' has a wrong offset!");
static_assert(offsetof(UFootStepComponent, IsBeginPlayLoadAsset) == 0x0000E0, "Member 'UFootStepComponent::IsBeginPlayLoadAsset' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsBattleThink
// 0x0008 (0x00A8 - 0x00A0)
class UBTDecorator_RSPlayerIsBattleThink final : public UBTDecorator_RSPlayerBase
{
public:
	EPlayerAIBattleThinkTypeCPP                   ThinkTypeCPP;                                      // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsBattleThink">();
	}
	static class UBTDecorator_RSPlayerIsBattleThink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsBattleThink>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsBattleThink) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsBattleThink");
static_assert(sizeof(UBTDecorator_RSPlayerIsBattleThink) == 0x0000A8, "Wrong size on UBTDecorator_RSPlayerIsBattleThink");
static_assert(offsetof(UBTDecorator_RSPlayerIsBattleThink, ThinkTypeCPP) == 0x0000A0, "Member 'UBTDecorator_RSPlayerIsBattleThink::ThinkTypeCPP' has a wrong offset!");

// Class BattlePrototype.UIConfigController
// 0x0178 (0x0500 - 0x0388)
class UUIConfigController : public UUIBase
{
public:
	float                                         LineHeight;                                        // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0x174];                                    // 0x038C(0x0174)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UREDScrollBoxSimple* ScrollBox, class UUIConfigControllerSelectMulti* IndexAttack, class UUIConfigControllerSelectMulti* IndexJump, class UUIConfigControllerSelectMulti* IndexStep_Dash, class UUIConfigControllerSelectMulti* IndexSpecialAttack, class UUIConfigControllerSelectMulti* IndexSAS_Menu_OpenClose, class UUIConfigControllerSelectMulti* IndexCV_Menu_OpenClose, class UUIConfigControllerSelectMulti* IndexPsychokinesis_Low, class UUIConfigControllerSelectMulti* IndexPsychokinesis_High, class UUIConfigControllerSelectMulti* IndexAutoTargetSwitching, class UUIConfigControllerSelectMulti* IndexSAS_CV_PageSwitch, class UUIConfigControllerSelect* IndexMoveFront, class UUIConfigControllerSelect* IndexMoveBack, class UUIConfigControllerSelect* IndexMoveLeft, class UUIConfigControllerSelect* IndexMoveRight, class UUIConfigControllerSelect* IndexAction, class UUIConfigControllerSelect* IndexAction2, class UUIConfigControllerSelect* IndexPsychicField, class UUIConfigControllerSelect* IndexAssaultVision, class UUIConfigControllerSelect* IndexExecuteBrainDrive, class UUIConfigControllerSelect* IndexCameraUp, class UUIConfigControllerSelect* IndexCameraDown, class UUIConfigControllerSelect* IndexCameraLeft, class UUIConfigControllerSelect* IndexCameraRight, class UUIConfigControllerSelect* IndexLockOn, class UUIConfigControllerSelect* IndexExecuteSAS1, class UUIConfigControllerSelect* IndexExecuteSAS2, class UUIConfigControllerSelect* IndexExecuteSAS3, class UUIConfigControllerSelect* IndexExecuteSAS4, class UUIConfigControllerSelect* IndexStopSAS, class UUIConfigControllerSelect* IndexExecuteCV1, class UUIConfigControllerSelect* IndexExecuteCV2, class UUIConfigControllerSelect* IndexExecuteCV3, class UUIConfigControllerSelect* IndexExecuteCV4, class UUIConfigControllerSelect* IndexItemSelectL, class UUIConfigControllerSelect* IndexItemSelectR, class UUIConfigControllerSelect* IndexUseItem, class UUIConfigControllerSelect* IndexCampMenu, class UUIConfigControllerSelect* IndexDetailMap, class UUIConfigControllerSelect* IndexWorldMap, class UUIConfigControllerSelect* IndexBrainMessage);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigController">();
	}
	static class UUIConfigController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigController>();
	}
};
static_assert(alignof(UUIConfigController) == 0x000008, "Wrong alignment on UUIConfigController");
static_assert(sizeof(UUIConfigController) == 0x000500, "Wrong size on UUIConfigController");
static_assert(offsetof(UUIConfigController, LineHeight) == 0x000388, "Member 'UUIConfigController::LineHeight' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsBattleThinkParam
// 0x0008 (0x00A8 - 0x00A0)
class UBTDecorator_RSPlayerIsBattleThinkParam final : public UBTDecorator_RSPlayerBase
{
public:
	EPlayerAIBattleThinkParamCPP                  ThinkParamCPP;                                     // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsBattleThinkParam">();
	}
	static class UBTDecorator_RSPlayerIsBattleThinkParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsBattleThinkParam>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsBattleThinkParam) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsBattleThinkParam");
static_assert(sizeof(UBTDecorator_RSPlayerIsBattleThinkParam) == 0x0000A8, "Wrong size on UBTDecorator_RSPlayerIsBattleThinkParam");
static_assert(offsetof(UBTDecorator_RSPlayerIsBattleThinkParam, ThinkParamCPP) == 0x0000A0, "Member 'UBTDecorator_RSPlayerIsBattleThinkParam::ThinkParamCPP' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsBrainField
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsBrainField final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsBrainField">();
	}
	static class UBTDecorator_RSPlayerIsBrainField* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsBrainField>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsBrainField) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsBrainField");
static_assert(sizeof(UBTDecorator_RSPlayerIsBrainField) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsBrainField");

// Class BattlePrototype.DebuggingItemImage
// 0x0048 (0x0310 - 0x02C8)
class ADebuggingItemImage final : public ADebuggingItemBase
{
public:
	FMulticastInlineDelegateProperty_             OnChangedImage;                                    // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangedIndex;                                    // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTexture*                               Image;                                             // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FText>                           StringArray;                                       // 0x02F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Index_0;                                           // 0x0300(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_304[0xC];                                      // 0x0304(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKeyLeftFunc(const class ADebuggingItemBase* InItem, bool IsRepeat, int32 InSpeed);
	void OnKeyRightFunc(const class ADebuggingItemBase* InItem, bool IsRepeat, int32 InSpeed);
	void SetImage(class UTexture* Texture);
	void SetStringIndex(int32 InIndex);

	int32 GetStringIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemImage">();
	}
	static class ADebuggingItemImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemImage>();
	}
};
static_assert(alignof(ADebuggingItemImage) == 0x000008, "Wrong alignment on ADebuggingItemImage");
static_assert(sizeof(ADebuggingItemImage) == 0x000310, "Wrong size on ADebuggingItemImage");
static_assert(offsetof(ADebuggingItemImage, OnChangedImage) == 0x0002C8, "Member 'ADebuggingItemImage::OnChangedImage' has a wrong offset!");
static_assert(offsetof(ADebuggingItemImage, OnChangedIndex) == 0x0002D8, "Member 'ADebuggingItemImage::OnChangedIndex' has a wrong offset!");
static_assert(offsetof(ADebuggingItemImage, Image) == 0x0002E8, "Member 'ADebuggingItemImage::Image' has a wrong offset!");
static_assert(offsetof(ADebuggingItemImage, StringArray) == 0x0002F0, "Member 'ADebuggingItemImage::StringArray' has a wrong offset!");
static_assert(offsetof(ADebuggingItemImage, Index_0) == 0x000300, "Member 'ADebuggingItemImage::Index_0' has a wrong offset!");

// Class BattlePrototype.UIEnemyDropItem
// 0x0010 (0x0398 - 0x0388)
class UUIEnemyDropItem : public UUIBase
{
public:
	uint8                                         Pad_388[0x10];                                     // 0x0388(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UImage* ImageIcon, class UTextBlock* TextName);
	void SetInfoBP(int32 ItemIconId, EItemRarity ItemRariy);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEnemyDropItem">();
	}
	static class UUIEnemyDropItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEnemyDropItem>();
	}
};
static_assert(alignof(UUIEnemyDropItem) == 0x000008, "Wrong alignment on UUIEnemyDropItem");
static_assert(sizeof(UUIEnemyDropItem) == 0x000398, "Wrong size on UUIEnemyDropItem");

// Class BattlePrototype.BTDecorator_RSPlayerIsDamage
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsDamage final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsDamage">();
	}
	static class UBTDecorator_RSPlayerIsDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsDamage>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsDamage) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsDamage");
static_assert(sizeof(UBTDecorator_RSPlayerIsDamage) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsDamage");

// Class BattlePrototype.EnemyAroundEffectComponentBase
// 0x0070 (0x0130 - 0x00C0)
class UEnemyAroundEffectComponentBase : public UActorComponent
{
public:
	bool                                          MbUseEffect;                                       // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MCommonRate;                                       // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAttachRate;                                       // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URSParticleSystemComponentBase*         MEffectHandle;                                     // 0x00D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbVisible;                                         // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MVertSurfaceParameterName;                         // 0x00DC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MVertSurfaceParameterCommonRateName;               // 0x00E4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MVertSurfaceParameterAttachRateName;               // 0x00EC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MUseMultiEmitter;                                  // 0x00F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           VertSurfaceParameterCommonRateNameList;            // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           EmitterNameList;                                   // 0x0108(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  EmitterEnableList;                                 // 0x0118(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFadeDeitherValue;                                 // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MDelayFadeDeitherFlag;                             // 0x012C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DelaySetFadeDeitherValue();
	bool EndAroundWeakEffect_Native(int32 EmitterIndex);
	int32 GetEmitterLastIndex();
	void HiddenEffect_Native(bool NewHidden);
	void Initialize(bool UseEffect, float CommonRate, float AttachRate, bool Visible);
	bool IsDisableAllEmitter();
	bool IsEnableAllEmitter();
	bool IsUseEffect_Native();
	bool IsUseMultiEmitter();
	bool IsVisible_Native();
	bool IsVisibleEffect_Native(int32 EmitterIndex);
	void RegisterCameraDitherParticleHandle_FromNative(class AActor* Owner, class URSParticleSystemComponentBase* AroundWeakEffect);
	void SetEffectParam_Native(float NewCommonRate, float NewAttachRate);
	void SetEffectParameter();
	void SetFadeDeitherValue(float DeitherValue);
	void SetVisibleEffect_Native(bool Visible);
	class URSParticleSystemComponentBase* SpawnEmitter_FromNative(class USkeletalMeshComponent* TargetMesh);
	bool StartAroundWeakEffect_Native(int32 EmitterIndex);
	void UnregisterCameraDitherParticleHandle_FromNative(class AActor* Owner, class URSParticleSystemComponentBase* EffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyAroundEffectComponentBase">();
	}
	static class UEnemyAroundEffectComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyAroundEffectComponentBase>();
	}
};
static_assert(alignof(UEnemyAroundEffectComponentBase) == 0x000008, "Wrong alignment on UEnemyAroundEffectComponentBase");
static_assert(sizeof(UEnemyAroundEffectComponentBase) == 0x000130, "Wrong size on UEnemyAroundEffectComponentBase");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MbUseEffect) == 0x0000C0, "Member 'UEnemyAroundEffectComponentBase::MbUseEffect' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MCommonRate) == 0x0000C4, "Member 'UEnemyAroundEffectComponentBase::MCommonRate' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MAttachRate) == 0x0000C8, "Member 'UEnemyAroundEffectComponentBase::MAttachRate' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MEffectHandle) == 0x0000D0, "Member 'UEnemyAroundEffectComponentBase::MEffectHandle' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MbVisible) == 0x0000D8, "Member 'UEnemyAroundEffectComponentBase::MbVisible' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MVertSurfaceParameterName) == 0x0000DC, "Member 'UEnemyAroundEffectComponentBase::MVertSurfaceParameterName' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MVertSurfaceParameterCommonRateName) == 0x0000E4, "Member 'UEnemyAroundEffectComponentBase::MVertSurfaceParameterCommonRateName' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MVertSurfaceParameterAttachRateName) == 0x0000EC, "Member 'UEnemyAroundEffectComponentBase::MVertSurfaceParameterAttachRateName' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MUseMultiEmitter) == 0x0000F4, "Member 'UEnemyAroundEffectComponentBase::MUseMultiEmitter' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, VertSurfaceParameterCommonRateNameList) == 0x0000F8, "Member 'UEnemyAroundEffectComponentBase::VertSurfaceParameterCommonRateNameList' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, EmitterNameList) == 0x000108, "Member 'UEnemyAroundEffectComponentBase::EmitterNameList' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, EmitterEnableList) == 0x000118, "Member 'UEnemyAroundEffectComponentBase::EmitterEnableList' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MFadeDeitherValue) == 0x000128, "Member 'UEnemyAroundEffectComponentBase::MFadeDeitherValue' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MDelayFadeDeitherFlag) == 0x00012C, "Member 'UEnemyAroundEffectComponentBase::MDelayFadeDeitherFlag' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsDead
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsDead final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsDead">();
	}
	static class UBTDecorator_RSPlayerIsDead* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsDead>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsDead) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsDead");
static_assert(sizeof(UBTDecorator_RSPlayerIsDead) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsDead");

// Class BattlePrototype.OptimizeSwitchMaterialLibrary
// 0x0000 (0x0028 - 0x0028)
class UOptimizeSwitchMaterialLibrary final : public UBlueprintFunctionLibrary
{
public:
	static EOptimizeMaterialCheckResultType CanUseOptimizeSwitchMaterialPlayerActor(class AActor* TargetActor, class USkeletalMeshComponent** TargetMeshComp);
	static EOptimizeMaterialCheckResultType CanUseOptimizeSwitchMaterialPlayerComp(class USkeletalMeshComponent* TargetComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimizeSwitchMaterialLibrary">();
	}
	static class UOptimizeSwitchMaterialLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimizeSwitchMaterialLibrary>();
	}
};
static_assert(alignof(UOptimizeSwitchMaterialLibrary) == 0x000008, "Wrong alignment on UOptimizeSwitchMaterialLibrary");
static_assert(sizeof(UOptimizeSwitchMaterialLibrary) == 0x000028, "Wrong size on UOptimizeSwitchMaterialLibrary");

// Class BattlePrototype.BTDecorator_RSPlayerIsDodgeAble
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsDodgeAble final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsDodgeAble">();
	}
	static class UBTDecorator_RSPlayerIsDodgeAble* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsDodgeAble>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsDodgeAble) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsDodgeAble");
static_assert(sizeof(UBTDecorator_RSPlayerIsDodgeAble) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsDodgeAble");

// Class BattlePrototype.BTDecorator_RSPlayerIsDown
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsDown final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsDown">();
	}
	static class UBTDecorator_RSPlayerIsDown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsDown>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsDown) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsDown");
static_assert(sizeof(UBTDecorator_RSPlayerIsDown) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsDown");

// Class BattlePrototype.DropItemManager
// 0x00A0 (0x02D0 - 0x0230)
class ADropItemManager final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADropItem*>                      AllDataDropDatas_;                                 // 0x0238(0x0010)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ADropItem*>                      AllCoreDropDatas_;                                 // 0x0248(0x0010)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 DataDropActiveData_;                               // 0x0258(0x0010)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 CoreDropActiveData_;                               // 0x0268(0x0010)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x50];                                     // 0x0278(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsItemGetDebugOn;                                  // 0x02C8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalledAtEndBrainField();
	void CalledAtStartBrainField();
	void ChangeActiveAllCoreDrops();
	void ChangeActiveAllDataDrops();
	void ChangeAllDropStateToDrop(float FirstDelay);
	void ControlDataDropActivateAtArea(const class FString& NextLevelName);
	void DoActiveCoreDrop(const struct FVector& Location, class FName ItemId, int32 ItemNum, bool bAutoTaken, class UParticleSystem* DropParticle, class UParticleSystem* AquParticle, class UParticleSystem* GetParticle);
	void DoActiveDataDrop(const struct FVector& Location, class FName ItemId, int32 ItemNum, bool bAutoTaken, class UParticleSystem* DropParticle, class UParticleSystem* AquParticle, class UParticleSystem* GetParticle, class FName CharID);
	void DoActiveStockDataDrop(const struct FVector& Location);
	void DoNotActiveCoreDrop(class ADropItem* ItemAdress);
	void DoNotActiveDataDrop(class ADropItem* ItemAdress);
	void RedropLandingItem(int32 ItemIndex);
	void RegistAllCoreDropDatas(class ADropItem* ItemAdress);
	void RegistAllDataDropDatas(class ADropItem* ItemAdress);
	void RegistStockDataItemData(const struct FDataItemSpawnState& Data);
	void SetActiveDropVisibility(bool Visibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropItemManager">();
	}
	static class ADropItemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADropItemManager>();
	}
};
static_assert(alignof(ADropItemManager) == 0x000008, "Wrong alignment on ADropItemManager");
static_assert(sizeof(ADropItemManager) == 0x0002D0, "Wrong size on ADropItemManager");
static_assert(offsetof(ADropItemManager, AllDataDropDatas_) == 0x000238, "Member 'ADropItemManager::AllDataDropDatas_' has a wrong offset!");
static_assert(offsetof(ADropItemManager, AllCoreDropDatas_) == 0x000248, "Member 'ADropItemManager::AllCoreDropDatas_' has a wrong offset!");
static_assert(offsetof(ADropItemManager, DataDropActiveData_) == 0x000258, "Member 'ADropItemManager::DataDropActiveData_' has a wrong offset!");
static_assert(offsetof(ADropItemManager, CoreDropActiveData_) == 0x000268, "Member 'ADropItemManager::CoreDropActiveData_' has a wrong offset!");
static_assert(offsetof(ADropItemManager, IsItemGetDebugOn) == 0x0002C8, "Member 'ADropItemManager::IsItemGetDebugOn' has a wrong offset!");

// Class BattlePrototype.UIConfigBrightness
// 0x00A0 (0x0428 - 0x0388)
class UUIConfigBrightness : public UUIBase
{
public:
	int32                                         MinX;                                              // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxX;                                              // 0x038C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x98];                                     // 0x0390(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyBrightness(float FValue);
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UImage* ImageSlider, class UTextBlock* TextDescription, class UREDOverlay* Gauge_set);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigBrightness">();
	}
	static class UUIConfigBrightness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigBrightness>();
	}
};
static_assert(alignof(UUIConfigBrightness) == 0x000008, "Wrong alignment on UUIConfigBrightness");
static_assert(sizeof(UUIConfigBrightness) == 0x000428, "Wrong size on UUIConfigBrightness");
static_assert(offsetof(UUIConfigBrightness, MinX) == 0x000388, "Member 'UUIConfigBrightness::MinX' has a wrong offset!");
static_assert(offsetof(UUIConfigBrightness, MaxX) == 0x00038C, "Member 'UUIConfigBrightness::MaxX' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsEvent
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsEvent final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsEvent">();
	}
	static class UBTDecorator_RSPlayerIsEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsEvent>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsEvent) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsEvent");
static_assert(sizeof(UBTDecorator_RSPlayerIsEvent) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsEvent");

// Class BattlePrototype.BTDecorator_RSPlayerIsEventMove
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsEventMove final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsEventMove">();
	}
	static class UBTDecorator_RSPlayerIsEventMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsEventMove>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsEventMove) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsEventMove");
static_assert(sizeof(UBTDecorator_RSPlayerIsEventMove) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsEventMove");

// Class BattlePrototype.RenderingSettingsFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URenderingSettingsFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FRenderingSettings MergeRenderingSettings(const struct FRenderingSettings& DefaultSettings, const struct FRenderingSettings& OverrideSettings);
	static void SetupRenderingSettingsSSRResolution(class UObject* WorldContextObject, const struct FRenderingSettings& Settings);
	static void SetupRenderingSettingsTranslucencyResolution(class UObject* WorldContextObject, const struct FRenderingSettings& Settings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RenderingSettingsFunctionLibrary">();
	}
	static class URenderingSettingsFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URenderingSettingsFunctionLibrary>();
	}
};
static_assert(alignof(URenderingSettingsFunctionLibrary) == 0x000008, "Wrong alignment on URenderingSettingsFunctionLibrary");
static_assert(sizeof(URenderingSettingsFunctionLibrary) == 0x000028, "Wrong size on URenderingSettingsFunctionLibrary");

// Class BattlePrototype.MessageHudManager
// 0x0040 (0x0270 - 0x0230)
class AMessageHudManager final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         M_swapTagArray;                                    // 0x0238(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETextGender                                   M_textGender;                                      // 0x0248(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_pluralTagArray;                                  // 0x0250(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int32>                                 M_ordinalTagArray;                                 // 0x0260(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ClearAllTag();
	int32 DrawMessage(int32 WindowType, const class FString& MessageTableName, const class FString& MessageLabel, class FName RipSyncBoardJointID, bool Skipable, float DrawSecond, bool IsSkipVoiceEnd, bool IsVoiceOnlyMessage);
	void GetMessageDataCellFromLabel(struct FMessageDataCell* MessageDataCell, const class FString& MessageLabel, const class FString& MessageTable);
	void GetMessageFromLabel(class FString* Message, const class FString& MessageLabel, const class FString& MessageTable);
	bool GetMessageTableName(class FString* MessageTableName, const class UObject* Object);
	void PreLoadAllVoice(const class FString& MessageTableName);
	void SetGenderTag(const ETextGender& TextGender);
	bool SetMessageTableName(const class FString& MessageTableName, class UObject* Object);
	void SetOrdinalTag(int32 Index_0, int32 Value);
	void SetOrdinalTagArray(const TArray<int32>& ValueArray);
	void SetPluralTag(int32 Index_0, int32 Value);
	void SetPluralTagArray(const TArray<int32>& ValueArray);
	void SetSwapTag(int32 Index_0, const class FString& String);
	void SetSwapTagArray(const TArray<class FString>& StringArray);

	bool CheckEndAllMessage() const;
	bool CheckEndMessage(int32 MessageIndex) const;
	int32 GetChoiceResult(int32 MessageIndex) const;
	int32 GetLastChoiceResult() const;
	const TArray<int32> GetOrdinalTagArray() const;
	const TArray<int32> GetPluralTagArray() const;
	const TArray<class FString> GetSwapTagArray() const;
	ETextGender GetTextGender() const;
	void SkipMessage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageHudManager">();
	}
	static class AMessageHudManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMessageHudManager>();
	}
};
static_assert(alignof(AMessageHudManager) == 0x000008, "Wrong alignment on AMessageHudManager");
static_assert(sizeof(AMessageHudManager) == 0x000270, "Wrong size on AMessageHudManager");
static_assert(offsetof(AMessageHudManager, M_swapTagArray) == 0x000238, "Member 'AMessageHudManager::M_swapTagArray' has a wrong offset!");
static_assert(offsetof(AMessageHudManager, M_textGender) == 0x000248, "Member 'AMessageHudManager::M_textGender' has a wrong offset!");
static_assert(offsetof(AMessageHudManager, M_pluralTagArray) == 0x000250, "Member 'AMessageHudManager::M_pluralTagArray' has a wrong offset!");
static_assert(offsetof(AMessageHudManager, M_ordinalTagArray) == 0x000260, "Member 'AMessageHudManager::M_ordinalTagArray' has a wrong offset!");

// Class BattlePrototype.UIQuestDetailsSub
// 0x0188 (0x0510 - 0x0388)
class UUIQuestDetailsSub : public UUIBase
{
public:
	uint8                                         Pad_388[0x188];                                    // 0x0388(0x0188)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeProgress(int32 Index_0, class UHorizontalBox* HorizontalBox, class UOverlay* IconSet, class UImage* ImageItemRarity, class UImage* ImageItemCategory, class UTextBlock* TextBlock, class UOverlay* NumSet, class UTextBlock* TextProgressCurrent, class UTextBlock* TextProgressSlash, class UTextBlock* TextProgressTarget);
	void InitializeReward(int32 Index_0, class UOverlay* TextSet, class UImage* ImageItemRarity, class UImage* ImageItemCategory);
	void InitializeThis(class UREDScrollBoxSimple* ScrollBox, class UTextBlock* TextTitle, class UTextBlock* TextIndexClient, class UTextBlock* TextIndexLocation, class UTextBlock* TextIndexProgress, class UTextBlock* TextIndexReward, class UTextBlock* TextClient, class UTextBlock* TextLocation, class USpacer* SpacerDescription1, class USpacer* SpacerDescription2, class UUIQuestIcon* UIQuestIcon, class UUIQuestNamePlate* UIQuestNamePlate, class UCanvasPanel* QuestPanel);
	void SetItemIcon(class UImage* ImageCategory, EItemIcon Category);
	void SetItemRarity(class UImage* ImageRarity, EItemRarity Rarity);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestDetailsSub">();
	}
	static class UUIQuestDetailsSub* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestDetailsSub>();
	}
};
static_assert(alignof(UUIQuestDetailsSub) == 0x000008, "Wrong alignment on UUIQuestDetailsSub");
static_assert(sizeof(UUIQuestDetailsSub) == 0x000510, "Wrong size on UUIQuestDetailsSub");

// Class BattlePrototype.BTDecorator_RSPlayerIsEventWait
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsEventWait final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsEventWait">();
	}
	static class UBTDecorator_RSPlayerIsEventWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsEventWait>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsEventWait) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsEventWait");
static_assert(sizeof(UBTDecorator_RSPlayerIsEventWait) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsEventWait");

// Class BattlePrototype.BTDecorator_RSPlayerIsJump
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsJump final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsJump">();
	}
	static class UBTDecorator_RSPlayerIsJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsJump>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsJump) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsJump");
static_assert(sizeof(UBTDecorator_RSPlayerIsJump) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsJump");

// Class BattlePrototype.EventSwitchPlayer
// 0x0010 (0x02C8 - 0x02B8)
class AEventSwitchPlayer : public ASkeletalMeshActor
{
public:
	TArray<TSoftObjectPtr<class USkeletalMesh>>   Meshes;                                            // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ResetMesh();
	void SetDummyMesh(class USkeletalMesh* InMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventSwitchPlayer">();
	}
	static class AEventSwitchPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventSwitchPlayer>();
	}
};
static_assert(alignof(AEventSwitchPlayer) == 0x000008, "Wrong alignment on AEventSwitchPlayer");
static_assert(sizeof(AEventSwitchPlayer) == 0x0002C8, "Wrong size on AEventSwitchPlayer");
static_assert(offsetof(AEventSwitchPlayer, Meshes) == 0x0002B8, "Member 'AEventSwitchPlayer::Meshes' has a wrong offset!");

// Class BattlePrototype.UIScarletLogo
// 0x0058 (0x03E0 - 0x0388)
class UUIScarletLogo : public UUIBase
{
public:
	uint8                                         Pad_388[0x58];                                     // 0x0388(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeAnime(class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Default_, class UWidgetAnimation* Out_title, class UWidgetAnimation* In_title, class UWidgetAnimation* Default_title);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIScarletLogo">();
	}
	static class UUIScarletLogo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIScarletLogo>();
	}
};
static_assert(alignof(UUIScarletLogo) == 0x000008, "Wrong alignment on UUIScarletLogo");
static_assert(sizeof(UUIScarletLogo) == 0x0003E0, "Wrong size on UUIScarletLogo");

// Class BattlePrototype.BTDecorator_RSPlayerIsMoveAble
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsMoveAble final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsMoveAble">();
	}
	static class UBTDecorator_RSPlayerIsMoveAble* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsMoveAble>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsMoveAble) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsMoveAble");
static_assert(sizeof(UBTDecorator_RSPlayerIsMoveAble) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsMoveAble");

// Class BattlePrototype.GimmickObjectInterface
// 0x0000 (0x0028 - 0x0028)
class IGimmickObjectInterface final : public IInterface
{
public:
	void GimmickClose();
	void GimmickCloseForce();
	void GimmickOpen();
	void GimmickOpenForce();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickObjectInterface">();
	}
	static class IGimmickObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGimmickObjectInterface>();
	}
};
static_assert(alignof(IGimmickObjectInterface) == 0x000008, "Wrong alignment on IGimmickObjectInterface");
static_assert(sizeof(IGimmickObjectInterface) == 0x000028, "Wrong size on IGimmickObjectInterface");

// Class BattlePrototype.BTDecorator_RSPlayerIsNoThink
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsNoThink final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsNoThink">();
	}
	static class UBTDecorator_RSPlayerIsNoThink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsNoThink>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsNoThink) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsNoThink");
static_assert(sizeof(UBTDecorator_RSPlayerIsNoThink) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsNoThink");

// Class BattlePrototype.UISASLink
// 0x0038 (0x03C0 - 0x0388)
class UUISASLink : public UUIBase
{
public:
	struct FLinearColor                           ContentsInOutTextColor;                            // 0x0388(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ContentsInOutTextColorMax;                         // 0x0398(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x18];                                     // 0x03A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UOverlay* OverlayAllSet, class UBorder* borderTextBondNum);
	void PlayContentsIn();
	void PlayContentsInMax();
	void PlayContentsOut();
	void PlayContentsOutMax();
	void UpdateProgramAnimation(float DeltaSeconds);

	bool IsPlayingContentsIn() const;
	bool IsPlayingContentsInMax() const;
	bool IsPlayingContentsOut() const;
	bool IsPlayingContentsOutMax() const;
	bool IsPlayingProgramAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISASLink">();
	}
	static class UUISASLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISASLink>();
	}
};
static_assert(alignof(UUISASLink) == 0x000008, "Wrong alignment on UUISASLink");
static_assert(sizeof(UUISASLink) == 0x0003C0, "Wrong size on UUISASLink");
static_assert(offsetof(UUISASLink, ContentsInOutTextColor) == 0x000388, "Member 'UUISASLink::ContentsInOutTextColor' has a wrong offset!");
static_assert(offsetof(UUISASLink, ContentsInOutTextColorMax) == 0x000398, "Member 'UUISASLink::ContentsInOutTextColorMax' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsPlayerRevive
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsPlayerRevive final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsPlayerRevive">();
	}
	static class UBTDecorator_RSPlayerIsPlayerRevive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsPlayerRevive>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsPlayerRevive) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsPlayerRevive");
static_assert(sizeof(UBTDecorator_RSPlayerIsPlayerRevive) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsPlayerRevive");

// Class BattlePrototype.BTDecorator_RSPlayerIsPsychicAble
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsPsychicAble final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsPsychicAble">();
	}
	static class UBTDecorator_RSPlayerIsPsychicAble* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsPsychicAble>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsPsychicAble) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsPsychicAble");
static_assert(sizeof(UBTDecorator_RSPlayerIsPsychicAble) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsPsychicAble");

// Class BattlePrototype.GameSingleton
// 0x0160 (0x0188 - 0x0028)
class UGameSingleton final : public UObject
{
public:
	uint8                                         Pad_28[0x130];                                     // 0x0028(0x0130)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              M_CurrentResolution;                               // 0x0158(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         M_MinimizeTimer;                                   // 0x0160(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         M_ResolutionChangeTimer;                           // 0x0164(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         M_DefaultResolutionTimer;                          // 0x0168(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_IsFocus;                                         // 0x016C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16D[0x1B];                                     // 0x016D(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGameSingleton* GetForBP();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSingleton">();
	}
	static class UGameSingleton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSingleton>();
	}
};
static_assert(alignof(UGameSingleton) == 0x000008, "Wrong alignment on UGameSingleton");
static_assert(sizeof(UGameSingleton) == 0x000188, "Wrong size on UGameSingleton");
static_assert(offsetof(UGameSingleton, M_CurrentResolution) == 0x000158, "Member 'UGameSingleton::M_CurrentResolution' has a wrong offset!");
static_assert(offsetof(UGameSingleton, M_MinimizeTimer) == 0x000160, "Member 'UGameSingleton::M_MinimizeTimer' has a wrong offset!");
static_assert(offsetof(UGameSingleton, M_ResolutionChangeTimer) == 0x000164, "Member 'UGameSingleton::M_ResolutionChangeTimer' has a wrong offset!");
static_assert(offsetof(UGameSingleton, M_DefaultResolutionTimer) == 0x000168, "Member 'UGameSingleton::M_DefaultResolutionTimer' has a wrong offset!");
static_assert(offsetof(UGameSingleton, M_IsFocus) == 0x00016C, "Member 'UGameSingleton::M_IsFocus' has a wrong offset!");

// Class BattlePrototype.UIQuestDetailsBonds
// 0x0048 (0x03D0 - 0x0388)
class UUIQuestDetailsBonds : public UUIBase
{
public:
	uint8                                         Pad_388[0x48];                                     // 0x0388(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UImage* Image, class UImage* ImageNoise, class UTextBlock* TextTitle, class UREDScrollBoxSimple* ScrollBox, class UUIQuestIcon* UIQuestIcon, class UUIQuestNamePlate* UIQuestNamePlate, class UCanvasPanel* QuestPanel, class UOverlay* OverlayImage);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestDetailsBonds">();
	}
	static class UUIQuestDetailsBonds* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestDetailsBonds>();
	}
};
static_assert(alignof(UUIQuestDetailsBonds) == 0x000008, "Wrong alignment on UUIQuestDetailsBonds");
static_assert(sizeof(UUIQuestDetailsBonds) == 0x0003D0, "Wrong size on UUIQuestDetailsBonds");

// Class BattlePrototype.BTDecorator_RSPlayerIsResetBehaviorTree
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsResetBehaviorTree final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsResetBehaviorTree">();
	}
	static class UBTDecorator_RSPlayerIsResetBehaviorTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsResetBehaviorTree>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsResetBehaviorTree) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsResetBehaviorTree");
static_assert(sizeof(UBTDecorator_RSPlayerIsResetBehaviorTree) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsResetBehaviorTree");

// Class BattlePrototype.RenderingManagerCoreComponent
// 0x0020 (0x00E0 - 0x00C0)
class URenderingManagerCoreComponent final : public UActorComponent
{
public:
	float                                         ShadeNoiseProgressScale;                           // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           MPC;                                               // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RenderingManagerCoreComponent">();
	}
	static class URenderingManagerCoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URenderingManagerCoreComponent>();
	}
};
static_assert(alignof(URenderingManagerCoreComponent) == 0x000008, "Wrong alignment on URenderingManagerCoreComponent");
static_assert(sizeof(URenderingManagerCoreComponent) == 0x0000E0, "Wrong size on URenderingManagerCoreComponent");
static_assert(offsetof(URenderingManagerCoreComponent, ShadeNoiseProgressScale) == 0x0000C0, "Member 'URenderingManagerCoreComponent::ShadeNoiseProgressScale' has a wrong offset!");
static_assert(offsetof(URenderingManagerCoreComponent, MPC) == 0x0000C8, "Member 'URenderingManagerCoreComponent::MPC' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsReviveNpc
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsReviveNpc final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsReviveNpc">();
	}
	static class UBTDecorator_RSPlayerIsReviveNpc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsReviveNpc>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsReviveNpc) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsReviveNpc");
static_assert(sizeof(UBTDecorator_RSPlayerIsReviveNpc) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsReviveNpc");

// Class BattlePrototype.RSActorUIBase
// 0x0000 (0x0230 - 0x0230)
class ARSActorUIBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorUIBase">();
	}
	static class ARSActorUIBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSActorUIBase>();
	}
};
static_assert(alignof(ARSActorUIBase) == 0x000008, "Wrong alignment on ARSActorUIBase");
static_assert(sizeof(ARSActorUIBase) == 0x000230, "Wrong size on ARSActorUIBase");

// Class BattlePrototype.MovingRoadInterface
// 0x0000 (0x0028 - 0x0028)
class IMovingRoadInterface final : public IInterface
{
public:
	struct FTransform GetMovingRoadTransform(class AActor* TargetActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovingRoadInterface">();
	}
	static class IMovingRoadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMovingRoadInterface>();
	}
};
static_assert(alignof(IMovingRoadInterface) == 0x000008, "Wrong alignment on IMovingRoadInterface");
static_assert(sizeof(IMovingRoadInterface) == 0x000028, "Wrong size on IMovingRoadInterface");

// Class BattlePrototype.UISASButton3
// 0x0018 (0x03A0 - 0x0388)
class UUISASButton3 : public UUIBase
{
public:
	uint8                                         Pad_388[0x18];                                     // 0x0388(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Decide();
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimChangeCv1, class UWidgetAnimation* AnimDefaultCv, class UWidgetAnimation* AnimChangeCv2, class UWidgetAnimation* AnimDecisionCv, class UWidgetAnimation* AnimChangePage1, class UWidgetAnimation* AnimDefaultPage, class UWidgetAnimation* AnimChangePage2, class UWidgetAnimation* AnimDecisionPage, class UImage* ImageSasIconFont, class UImage* ImageSasButton);
	void SetPageFlag(bool IsPage);
	void SetReadyFlag(bool IsReady);
	void UpdateStateThis(int32 State, int32 SubState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISASButton3">();
	}
	static class UUISASButton3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISASButton3>();
	}
};
static_assert(alignof(UUISASButton3) == 0x000008, "Wrong alignment on UUISASButton3");
static_assert(sizeof(UUISASButton3) == 0x0003A0, "Wrong size on UUISASButton3");

// Class BattlePrototype.BTDecorator_RSPlayerIsUseCppFunc
// 0x0008 (0x00A8 - 0x00A0)
class UBTDecorator_RSPlayerIsUseCppFunc final : public UBTDecorator_RSPlayerBase
{
public:
	bool                                          bEnable;                                           // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsUseCppFunc">();
	}
	static class UBTDecorator_RSPlayerIsUseCppFunc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsUseCppFunc>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsUseCppFunc) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsUseCppFunc");
static_assert(sizeof(UBTDecorator_RSPlayerIsUseCppFunc) == 0x0000A8, "Wrong size on UBTDecorator_RSPlayerIsUseCppFunc");
static_assert(offsetof(UBTDecorator_RSPlayerIsUseCppFunc, bEnable) == 0x0000A0, "Member 'UBTDecorator_RSPlayerIsUseCppFunc::bEnable' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsUseItem
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsUseItem final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsUseItem">();
	}
	static class UBTDecorator_RSPlayerIsUseItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsUseItem>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsUseItem) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsUseItem");
static_assert(sizeof(UBTDecorator_RSPlayerIsUseItem) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsUseItem");

// Class BattlePrototype.FinishMoveActor
// 0x0090 (0x02C0 - 0x0230)
class AFinishMoveActor : public AActor
{
public:
	ERSPartyPlayerKind                            TargetPartyType_;                                  // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TargetSocketName_;                                 // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Interp, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomParam_;                                        // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetLocationInterpolation_;                      // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetFOVInterpolation_;                           // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLocationInterpolation_;                      // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACameraActor*                           FinishMoveCamera_;                                 // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SequenceRate_;                                     // 0x0260(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       GameCameraComponet_;                               // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACameraActor*                           GameCameraActor_;                                  // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLookingForEnemy_;                                // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EnemyLocation_;                                    // 0x027C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_288[0x24];                                     // 0x0288(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               CameraRotatBeforeSwitch_;                          // 0x02AC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishMoveBegin(bool IsChangeBeforeData, const struct FVector& beforePos, float beforeFOV);
	void FinishMoveUpdate();
	struct FVector GetBeforeLocation();
	void SetCameraTick(bool bActivate);
	void SlowSpeedEvent();
	void SlowSpeedEventEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FinishMoveActor">();
	}
	static class AFinishMoveActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFinishMoveActor>();
	}
};
static_assert(alignof(AFinishMoveActor) == 0x000008, "Wrong alignment on AFinishMoveActor");
static_assert(sizeof(AFinishMoveActor) == 0x0002C0, "Wrong size on AFinishMoveActor");
static_assert(offsetof(AFinishMoveActor, TargetPartyType_) == 0x000230, "Member 'AFinishMoveActor::TargetPartyType_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, TargetSocketName_) == 0x000238, "Member 'AFinishMoveActor::TargetSocketName_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, ZoomParam_) == 0x000248, "Member 'AFinishMoveActor::ZoomParam_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, TargetLocationInterpolation_) == 0x00024C, "Member 'AFinishMoveActor::TargetLocationInterpolation_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, TargetFOVInterpolation_) == 0x000250, "Member 'AFinishMoveActor::TargetFOVInterpolation_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, CameraLocationInterpolation_) == 0x000254, "Member 'AFinishMoveActor::CameraLocationInterpolation_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, FinishMoveCamera_) == 0x000258, "Member 'AFinishMoveActor::FinishMoveCamera_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, SequenceRate_) == 0x000260, "Member 'AFinishMoveActor::SequenceRate_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, GameCameraComponet_) == 0x000268, "Member 'AFinishMoveActor::GameCameraComponet_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, GameCameraActor_) == 0x000270, "Member 'AFinishMoveActor::GameCameraActor_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, IsLookingForEnemy_) == 0x000278, "Member 'AFinishMoveActor::IsLookingForEnemy_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, EnemyLocation_) == 0x00027C, "Member 'AFinishMoveActor::EnemyLocation_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, CameraRotatBeforeSwitch_) == 0x0002AC, "Member 'AFinishMoveActor::CameraRotatBeforeSwitch_' has a wrong offset!");

// Class BattlePrototype.MaterialAccessorComponent
// 0x02A0 (0x0360 - 0x00C0)
class UMaterialAccessorComponent : public UActorComponent
{
public:
	class UMeshComponent*                         Mesh;                                              // 0x00C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMeshComponent*>                 AppendMeshes;                                      // 0x00C8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          EnableRestoreOverrideParamters;                    // 0x00D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMACSlotParameter>              MaterialList;                                      // 0x00E0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x270];                                     // 0x00F0(0x0270)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddColorByRate(float SumValue, const struct FLinearColor& BaseColor, float Rate, const struct FLinearColor& SourceColor, struct FLinearColor* OutColor);
	void GetDefaultScalarParameter(const TArray<int32>& SearchSlots, class FName ParameterName, float* OutParameters);
	void GetDefaultScalarParameterALL(class FName ParameterName, float* OutParameters);
	void GetDefaultScalarParameterByVariable(struct FMACVariableFloat& Variable);
	void GetDefaultVectorParameter(const TArray<int32>& SearchSlots, class FName ParameterName, struct FLinearColor* OutParameters);
	void GetDefaultVectorParameterALL(class FName ParameterName, struct FLinearColor* OutParameters);
	void GetDefaultVectorParameterByVariable(struct FMACVariableVector& Variable);
	void ManualRestoreOverrideParametersBP();
	void RegisterScalarParameters(const TArray<struct FMACVariableFloat>& Variables);
	void RegisterVectorParameters(const TArray<struct FMACVariableVector>& Variables);
	void Reset();
	void RestoreParameter();
	void SetAppendMesh(const TArray<class UMeshComponent*>& InAppedMeshes);
	void SetExcludeRestoreOverrideParameters(const TArray<class FName>& ParameterNames);
	void SetScalarParameter(EMaterialAccessorSetupID SetupID, float Value, float DefaultValue, class FName ParameterName, int32 SlotHandle);
	void SetScalarParameterByRegister(const TArray<float>& Variables, const TArray<EMaterialAccessorSetupID>& SetupIDs);
	void SetScalarParameterByVariable(struct FMACVariableFloat& Variable, EMaterialAccessorSetupID SetupID);
	void SetTextureParameter(class UTexture* Texture, class FName ParameterName, int32 SlotHandle);
	int32 SetupMaterialBySlotName(const class FString& SlotName);
	void SetVectorParameter(EMaterialAccessorSetupID SetupID, const struct FLinearColor& Value, const struct FLinearColor& DefaultValue, class FName ParameterName, int32 SlotHandle);
	void SetVectorParameterByRegister(const TArray<struct FVector>& Variables, const TArray<EMaterialAccessorSetupID>& SetupIDs);
	void SetVectorParameterByVariable(struct FMACVariableVector& Variable, EMaterialAccessorSetupID SetupID);
	void SetVisibleMaterialAllLODs(bool Show, int32 SlotHandle);
	void UpdateMateiral();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialAccessorComponent">();
	}
	static class UMaterialAccessorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialAccessorComponent>();
	}
};
static_assert(alignof(UMaterialAccessorComponent) == 0x000008, "Wrong alignment on UMaterialAccessorComponent");
static_assert(sizeof(UMaterialAccessorComponent) == 0x000360, "Wrong size on UMaterialAccessorComponent");
static_assert(offsetof(UMaterialAccessorComponent, Mesh) == 0x0000C0, "Member 'UMaterialAccessorComponent::Mesh' has a wrong offset!");
static_assert(offsetof(UMaterialAccessorComponent, AppendMeshes) == 0x0000C8, "Member 'UMaterialAccessorComponent::AppendMeshes' has a wrong offset!");
static_assert(offsetof(UMaterialAccessorComponent, EnableRestoreOverrideParamters) == 0x0000D8, "Member 'UMaterialAccessorComponent::EnableRestoreOverrideParamters' has a wrong offset!");
static_assert(offsetof(UMaterialAccessorComponent, MaterialList) == 0x0000E0, "Member 'UMaterialAccessorComponent::MaterialList' has a wrong offset!");

// Class BattlePrototype.EnemyMaterialAccessorComponent
// 0x0000 (0x0360 - 0x0360)
class UEnemyMaterialAccessorComponent : public UMaterialAccessorComponent
{
public:
	void SetEnemyMesh(class USkeletalMeshComponent* EnemyMesh);
	void SetupDefaultParameter(class ACharacter* Enemy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyMaterialAccessorComponent">();
	}
	static class UEnemyMaterialAccessorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyMaterialAccessorComponent>();
	}
};
static_assert(alignof(UEnemyMaterialAccessorComponent) == 0x000008, "Wrong alignment on UEnemyMaterialAccessorComponent");
static_assert(sizeof(UEnemyMaterialAccessorComponent) == 0x000360, "Wrong size on UEnemyMaterialAccessorComponent");

// Class BattlePrototype.BTTask_RSNativeBase
// 0x0030 (0x00A0 - 0x0070)
class UBTTask_RSNativeBase : public UBTTaskNode
{
public:
	class AAIController*                          _AIOwner;                                          // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIntervalCountdown                     TickInterval;                                      // 0x0078(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x18];                                      // 0x0080(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         ReceiveTickImplementations : 1;                    // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSNativeBase">();
	}
	static class UBTTask_RSNativeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSNativeBase>();
	}
};
static_assert(alignof(UBTTask_RSNativeBase) == 0x000008, "Wrong alignment on UBTTask_RSNativeBase");
static_assert(sizeof(UBTTask_RSNativeBase) == 0x0000A0, "Wrong size on UBTTask_RSNativeBase");
static_assert(offsetof(UBTTask_RSNativeBase, _AIOwner) == 0x000070, "Member 'UBTTask_RSNativeBase::_AIOwner' has a wrong offset!");
static_assert(offsetof(UBTTask_RSNativeBase, TickInterval) == 0x000078, "Member 'UBTTask_RSNativeBase::TickInterval' has a wrong offset!");

// Class BattlePrototype.UIShop3DManager
// 0x0000 (0x0230 - 0x0230)
class AUIShop3DManager : public AActor
{
public:
	bool End();
	bool Start();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShop3DManager">();
	}
	static class AUIShop3DManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIShop3DManager>();
	}
};
static_assert(alignof(AUIShop3DManager) == 0x000008, "Wrong alignment on AUIShop3DManager");
static_assert(sizeof(AUIShop3DManager) == 0x000230, "Wrong size on AUIShop3DManager");

// Class BattlePrototype.BTTask_RSPlayerBase
// 0x0008 (0x00A8 - 0x00A0)
class UBTTask_RSPlayerBase : public UBTTask_RSNativeBase
{
public:
	class UPlayerScriptComponent*                 _PlayerScript;                                     // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerBase">();
	}
	static class UBTTask_RSPlayerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerBase>();
	}
};
static_assert(alignof(UBTTask_RSPlayerBase) == 0x000008, "Wrong alignment on UBTTask_RSPlayerBase");
static_assert(sizeof(UBTTask_RSPlayerBase) == 0x0000A8, "Wrong size on UBTTask_RSPlayerBase");
static_assert(offsetof(UBTTask_RSPlayerBase, _PlayerScript) == 0x0000A0, "Member 'UBTTask_RSPlayerBase::_PlayerScript' has a wrong offset!");

// Class BattlePrototype.BTTask_RSPlayerBattleStart
// 0x0000 (0x00A8 - 0x00A8)
class UBTTask_RSPlayerBattleStart final : public UBTTask_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerBattleStart">();
	}
	static class UBTTask_RSPlayerBattleStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerBattleStart>();
	}
};
static_assert(alignof(UBTTask_RSPlayerBattleStart) == 0x000008, "Wrong alignment on UBTTask_RSPlayerBattleStart");
static_assert(sizeof(UBTTask_RSPlayerBattleStart) == 0x0000A8, "Wrong size on UBTTask_RSPlayerBattleStart");

// Class BattlePrototype.GimmickManager
// 0x0020 (0x0048 - 0x0028)
class UGimmickManager final : public UObject
{
public:
	TArray<class AGimmickObjectBase*>             Gimmicks;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AGimmickActionBase*>             GimmickActions;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Initialize(const class UObject* WorldContextObject);
	void OnBattleModeChange(class URSGameInstance* GameInstance, const bool bBattle);
	void RegisterGimmick(class AGimmickObjectBase* Gimmick);
	void RegisterGimmickAction(class AGimmickActionBase* GimmickAction);
	void UnregisterGimmick(class AGimmickObjectBase* Gimmick);
	void UnregisterGimmickAction(class AGimmickActionBase* GimmickAction);
	void UnregisterGimmickActionAll();
	void UnregisterGimmickAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickManager">();
	}
	static class UGimmickManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGimmickManager>();
	}
};
static_assert(alignof(UGimmickManager) == 0x000008, "Wrong alignment on UGimmickManager");
static_assert(sizeof(UGimmickManager) == 0x000048, "Wrong size on UGimmickManager");
static_assert(offsetof(UGimmickManager, Gimmicks) == 0x000028, "Member 'UGimmickManager::Gimmicks' has a wrong offset!");
static_assert(offsetof(UGimmickManager, GimmickActions) == 0x000038, "Member 'UGimmickManager::GimmickActions' has a wrong offset!");

// Class BattlePrototype.UISASActionIcon
// 0x0050 (0x03D8 - 0x0388)
class UUISASActionIcon : public UUIBase
{
public:
	struct FVector2D                              baseOffset;                                        // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isUsable;                                        // 0x0390(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_391[0x7];                                      // 0x0391(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerActor;                                        // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0x38];                                     // 0x03A0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimIn2, class UWidgetAnimation* AnimOut2, class UWidgetAnimation* AnimSelect);
	void SetIconType(ESASActionIconType Icontype, bool IsUsable);
	void SetOwnerActor(class AActor* OwnerActor_0);
	void SetUsable(bool IsUsable);
	void SetWorldOffset(const struct FVector& WorldOffset);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool IsUsable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISASActionIcon">();
	}
	static class UUISASActionIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISASActionIcon>();
	}
};
static_assert(alignof(UUISASActionIcon) == 0x000008, "Wrong alignment on UUISASActionIcon");
static_assert(sizeof(UUISASActionIcon) == 0x0003D8, "Wrong size on UUISASActionIcon");
static_assert(offsetof(UUISASActionIcon, baseOffset) == 0x000388, "Member 'UUISASActionIcon::baseOffset' has a wrong offset!");
static_assert(offsetof(UUISASActionIcon, M_isUsable) == 0x000390, "Member 'UUISASActionIcon::M_isUsable' has a wrong offset!");
static_assert(offsetof(UUISASActionIcon, OwnerActor) == 0x000398, "Member 'UUISASActionIcon::OwnerActor' has a wrong offset!");

// Class BattlePrototype.BTTask_RSPlayerBrainField
// 0x0010 (0x00B8 - 0x00A8)
class UBTTask_RSPlayerBrainField final : public UBTTask_RSPlayerBase
{
public:
	struct FGameTimer                             Timer;                                             // 0x00A8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerBrainField">();
	}
	static class UBTTask_RSPlayerBrainField* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerBrainField>();
	}
};
static_assert(alignof(UBTTask_RSPlayerBrainField) == 0x000008, "Wrong alignment on UBTTask_RSPlayerBrainField");
static_assert(sizeof(UBTTask_RSPlayerBrainField) == 0x0000B8, "Wrong size on UBTTask_RSPlayerBrainField");
static_assert(offsetof(UBTTask_RSPlayerBrainField, Timer) == 0x0000A8, "Member 'UBTTask_RSPlayerBrainField::Timer' has a wrong offset!");

// Class BattlePrototype.RSActorPsychicObjectBase
// 0x0000 (0x0230 - 0x0230)
class ARSActorPsychicObjectBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorPsychicObjectBase">();
	}
	static class ARSActorPsychicObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSActorPsychicObjectBase>();
	}
};
static_assert(alignof(ARSActorPsychicObjectBase) == 0x000008, "Wrong alignment on ARSActorPsychicObjectBase");
static_assert(sizeof(ARSActorPsychicObjectBase) == 0x000230, "Wrong size on ARSActorPsychicObjectBase");

// Class BattlePrototype.BTTask_RSPlayerDamage
// 0x0000 (0x00A8 - 0x00A8)
class UBTTask_RSPlayerDamage final : public UBTTask_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerDamage">();
	}
	static class UBTTask_RSPlayerDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerDamage>();
	}
};
static_assert(alignof(UBTTask_RSPlayerDamage) == 0x000008, "Wrong alignment on UBTTask_RSPlayerDamage");
static_assert(sizeof(UBTTask_RSPlayerDamage) == 0x0000A8, "Wrong size on UBTTask_RSPlayerDamage");

// Class BattlePrototype.RSAjitoAnimInstance
// 0x0100 (0x0720 - 0x0620)
class URSAjitoAnimInstance : public UASAnimInstance
{
public:
	uint8                                         Pad_620[0x8];                                      // 0x0620(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsWaitStateTransition;                             // 0x0628(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReadyToTransitionIdle;                           // 0x0629(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReadyToTransitionTalk;                           // 0x062A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLookAtInTalking;                                 // 0x062B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLookAt;                                          // 0x062C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseOverrideAnim;                                   // 0x062D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62E[0x2];                                      // 0x062E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LookAtPoint;                                       // 0x0630(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsToTalkWaiting;                                   // 0x063C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsToIdleWaiting;                                   // 0x063D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAjitoMemberState                             CurrentState;                                      // 0x063E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAjitoMemberState                             RequestedState;                                    // 0x063F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAjitoMemberIdleStateType                     IdleState;                                         // 0x0640(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAjitoMemberTalkStateType                     TalkState;                                         // 0x0641(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_642[0x6];                                      // 0x0642(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAjitoMemberAnimInfo                   AnimInfo;                                          // 0x0648(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAjitoMemberInfo                       MemberInfo;                                        // 0x0698(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAnimSequence*                          OverrideAnim;                                      // 0x06D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UASAnimationSet*                        AnimationSet;                                      // 0x06E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeHorizontal;                                     // 0x06E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeVertical;                                       // 0x06EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeBlendRate;                                      // 0x06F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsChangeStateImmediate;                            // 0x06F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsResetState;                                      // 0x06F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStartState;                                      // 0x06F6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsIdleOnlyAction;                                  // 0x06F7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextAnimNo;                                        // 0x06F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPresentEvent;                                    // 0x06FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6FD[0x3];                                      // 0x06FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               HeadRot;                                           // 0x0700(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsBoxNoDisp;                                       // 0x070C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70D[0x3];                                      // 0x070D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _bEnableEyeControl;                                // 0x0710(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ClearWaitTransitionToIdle();
	void ClearWaitTransitionToTalk();
	bool EndTalking();
	bool InitializeInstance(const struct FAjitoMemberInfo& Info);
	void SetEyeControlEnable(bool bEnable, class FName ClaimantName);
	void SetEyeControlParameter(float Horizontal, float Vertical);
	void SetIsLookAt(bool IsLookAt_0);
	bool StartTalking();
	void WaitTransitionToIdle(float WaitTime);
	void WaitTransitionToTalk(float WaitTime);

	class UAnimSequenceBase* GetCurrentASNodeAnimSequence() const;
	class FName GetCurrentASNodeAssetName() const;
	class AAjitoMember* GetOwningAjitoMember() const;
	bool IsWaitTransitionToIdle() const;
	bool IsWaitTransitionToTalk() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAjitoAnimInstance">();
	}
	static class URSAjitoAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAjitoAnimInstance>();
	}
};
static_assert(alignof(URSAjitoAnimInstance) == 0x000010, "Wrong alignment on URSAjitoAnimInstance");
static_assert(sizeof(URSAjitoAnimInstance) == 0x000720, "Wrong size on URSAjitoAnimInstance");
static_assert(offsetof(URSAjitoAnimInstance, IsWaitStateTransition) == 0x000628, "Member 'URSAjitoAnimInstance::IsWaitStateTransition' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsReadyToTransitionIdle) == 0x000629, "Member 'URSAjitoAnimInstance::IsReadyToTransitionIdle' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsReadyToTransitionTalk) == 0x00062A, "Member 'URSAjitoAnimInstance::IsReadyToTransitionTalk' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsLookAtInTalking) == 0x00062B, "Member 'URSAjitoAnimInstance::IsLookAtInTalking' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsLookAt) == 0x00062C, "Member 'URSAjitoAnimInstance::IsLookAt' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, UseOverrideAnim) == 0x00062D, "Member 'URSAjitoAnimInstance::UseOverrideAnim' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, LookAtPoint) == 0x000630, "Member 'URSAjitoAnimInstance::LookAtPoint' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsToTalkWaiting) == 0x00063C, "Member 'URSAjitoAnimInstance::IsToTalkWaiting' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsToIdleWaiting) == 0x00063D, "Member 'URSAjitoAnimInstance::IsToIdleWaiting' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, CurrentState) == 0x00063E, "Member 'URSAjitoAnimInstance::CurrentState' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, RequestedState) == 0x00063F, "Member 'URSAjitoAnimInstance::RequestedState' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IdleState) == 0x000640, "Member 'URSAjitoAnimInstance::IdleState' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, TalkState) == 0x000641, "Member 'URSAjitoAnimInstance::TalkState' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, AnimInfo) == 0x000648, "Member 'URSAjitoAnimInstance::AnimInfo' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, MemberInfo) == 0x000698, "Member 'URSAjitoAnimInstance::MemberInfo' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, OverrideAnim) == 0x0006D8, "Member 'URSAjitoAnimInstance::OverrideAnim' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, AnimationSet) == 0x0006E0, "Member 'URSAjitoAnimInstance::AnimationSet' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, EyeHorizontal) == 0x0006E8, "Member 'URSAjitoAnimInstance::EyeHorizontal' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, EyeVertical) == 0x0006EC, "Member 'URSAjitoAnimInstance::EyeVertical' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, EyeBlendRate) == 0x0006F0, "Member 'URSAjitoAnimInstance::EyeBlendRate' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsChangeStateImmediate) == 0x0006F4, "Member 'URSAjitoAnimInstance::IsChangeStateImmediate' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsResetState) == 0x0006F5, "Member 'URSAjitoAnimInstance::IsResetState' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsStartState) == 0x0006F6, "Member 'URSAjitoAnimInstance::IsStartState' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsIdleOnlyAction) == 0x0006F7, "Member 'URSAjitoAnimInstance::IsIdleOnlyAction' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, NextAnimNo) == 0x0006F8, "Member 'URSAjitoAnimInstance::NextAnimNo' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsPresentEvent) == 0x0006FC, "Member 'URSAjitoAnimInstance::IsPresentEvent' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, HeadRot) == 0x000700, "Member 'URSAjitoAnimInstance::HeadRot' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsBoxNoDisp) == 0x00070C, "Member 'URSAjitoAnimInstance::IsBoxNoDisp' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, _bEnableEyeControl) == 0x000710, "Member 'URSAjitoAnimInstance::_bEnableEyeControl' has a wrong offset!");

// Class BattlePrototype.NpcCommonInterface
// 0x0000 (0x0028 - 0x0028)
class INpcCommonInterface final : public IInterface
{
public:
	void ChangeAnimation(ENpcAnimationKind AnimKind);
	ETextGender GetNpcMeshGenderType();
	bool SetDrawMessageFacial(const class FString& MessageLabel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcCommonInterface">();
	}
	static class INpcCommonInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INpcCommonInterface>();
	}
};
static_assert(alignof(INpcCommonInterface) == 0x000008, "Wrong alignment on INpcCommonInterface");
static_assert(sizeof(INpcCommonInterface) == 0x000028, "Wrong size on INpcCommonInterface");

// Class BattlePrototype.BTTask_RSPlayerDead
// 0x0000 (0x00A8 - 0x00A8)
class UBTTask_RSPlayerDead final : public UBTTask_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerDead">();
	}
	static class UBTTask_RSPlayerDead* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerDead>();
	}
};
static_assert(alignof(UBTTask_RSPlayerDead) == 0x000008, "Wrong alignment on UBTTask_RSPlayerDead");
static_assert(sizeof(UBTTask_RSPlayerDead) == 0x0000A8, "Wrong size on UBTTask_RSPlayerDead");

// Class BattlePrototype.RenderingManager
// 0x0008 (0x0238 - 0x0230)
class ARenderingManager final : public AActor
{
public:
	class URenderingManagerCoreComponent*         CoreComponent;                                     // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RenderingManager">();
	}
	static class ARenderingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARenderingManager>();
	}
};
static_assert(alignof(ARenderingManager) == 0x000008, "Wrong alignment on ARenderingManager");
static_assert(sizeof(ARenderingManager) == 0x000238, "Wrong size on ARenderingManager");
static_assert(offsetof(ARenderingManager, CoreComponent) == 0x000230, "Member 'ARenderingManager::CoreComponent' has a wrong offset!");

// Class BattlePrototype.BTTask_RSPlayerDown
// 0x0000 (0x00A8 - 0x00A8)
class UBTTask_RSPlayerDown final : public UBTTask_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerDown">();
	}
	static class UBTTask_RSPlayerDown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerDown>();
	}
};
static_assert(alignof(UBTTask_RSPlayerDown) == 0x000008, "Wrong alignment on UBTTask_RSPlayerDown");
static_assert(sizeof(UBTTask_RSPlayerDown) == 0x0000A8, "Wrong size on UBTTask_RSPlayerDown");

// Class BattlePrototype.ManagerInterface
// 0x0000 (0x0028 - 0x0028)
class IManagerInterface final : public IInterface
{
public:
	void DelayBeginPlay();
	bool FinalizeManager(EManagerProcTiming Timing);
	bool InitializeManager(EManagerProcTiming Timing);
	bool IsNeedFrameWait();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ManagerInterface">();
	}
	static class IManagerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IManagerInterface>();
	}
};
static_assert(alignof(IManagerInterface) == 0x000008, "Wrong alignment on IManagerInterface");
static_assert(sizeof(IManagerInterface) == 0x000028, "Wrong size on IManagerInterface");

// Class BattlePrototype.UITitleCrossSave
// 0x00B0 (0x0438 - 0x0388)
class UUITitleCrossSave final : public UUIBase
{
public:
	uint8                                         Pad_388[0xB0];                                     // 0x0388(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefault, class UREDTextBlock* TextTitle, class UREDTextBlock* TextHelp, class UUIGuide* UIGuide, class UUITitleCrossSave_UpdatingWidget* UiUpdatingWidget, class UUITitleCrossSave_ConfirmWindow* UiConfirmWindow);
	void Start(class ARSTitleManager* TitleManager);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleCrossSave">();
	}
	static class UUITitleCrossSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleCrossSave>();
	}
};
static_assert(alignof(UUITitleCrossSave) == 0x000008, "Wrong alignment on UUITitleCrossSave");
static_assert(sizeof(UUITitleCrossSave) == 0x000438, "Wrong size on UUITitleCrossSave");

// Class BattlePrototype.BTTask_RSPlayerEvent
// 0x0000 (0x00A8 - 0x00A8)
class UBTTask_RSPlayerEvent final : public UBTTask_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerEvent">();
	}
	static class UBTTask_RSPlayerEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerEvent>();
	}
};
static_assert(alignof(UBTTask_RSPlayerEvent) == 0x000008, "Wrong alignment on UBTTask_RSPlayerEvent");
static_assert(sizeof(UBTTask_RSPlayerEvent) == 0x0000A8, "Wrong size on UBTTask_RSPlayerEvent");

// Class BattlePrototype.EventCaptureActorBase
// 0x0008 (0x0238 - 0x0230)
class AEventCaptureActorBase : public ARSActorSystemBase
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangePlMaterial(class ACharacter* ChildStaticPl, class UMaterialInterface* Source, EEventPlMaterialType Type);
	void CheckPlMaterialType(class ACharacter* ChildStaticPl, EEventPlMaterialType* Type, bool* Change);
	void SequenceAlpha(float Time, float Start, float End, class UCurveFloat* Curve, bool Loop);
	void SequenceMove(float Time, const struct FVector2D& Start, const struct FVector2D& End, class UCurveFloat* Curve, bool Loop);
	void SequenceScale(float Time, float Start, float End, class UCurveFloat* Curve, bool Loop);
	void SetEffectAlpha(float Alpha);
	void SetEffectMove(const struct FVector2D& Offset);
	void SetEffectScale(float Scale);
	void SetupAlphaSortNative(int32 Priority, const TArray<class UPrimitiveComponent*>& BackTargetPrimitiveComps, const TArray<class UPrimitiveComponent*>& TargetPrimitiveComps, const TArray<class UPrimitiveComponent*>& FrontTargetPrimitiveComps, class USkeletalMeshComponent* ChildMesh);
	void SetupAlphaSortNative2(class ACharacter* ChildStaticPl, class URSParticleSystemComponentBase* CurrentFrameParticle, class URSParticleSystemComponentBase* CurrentFrameTelepathyParticle, class URSParticleSystemComponentBase* CurrentFrameOverTelepathyParticle);
	void SetupHighResDOF(class URSSceneCaptureComponent2D* SceneCapture, float ScaleX);
	void StoreSequencerInGameTransform(class ULevelSequence* Sequnece, float SequencePosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventCaptureActorBase">();
	}
	static class AEventCaptureActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventCaptureActorBase>();
	}
};
static_assert(alignof(AEventCaptureActorBase) == 0x000008, "Wrong alignment on AEventCaptureActorBase");
static_assert(sizeof(AEventCaptureActorBase) == 0x000238, "Wrong size on AEventCaptureActorBase");

// Class BattlePrototype.BTTask_RSPlayerEventWait
// 0x0000 (0x00A8 - 0x00A8)
class UBTTask_RSPlayerEventWait final : public UBTTask_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerEventWait">();
	}
	static class UBTTask_RSPlayerEventWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerEventWait>();
	}
};
static_assert(alignof(UBTTask_RSPlayerEventWait) == 0x000008, "Wrong alignment on UBTTask_RSPlayerEventWait");
static_assert(sizeof(UBTTask_RSPlayerEventWait) == 0x0000A8, "Wrong size on UBTTask_RSPlayerEventWait");

// Class BattlePrototype.UIShopPartyStatusIcon
// 0x0118 (0x04A0 - 0x0388)
class UUIShopPartyStatusIcon : public UUIBase
{
public:
	struct FSlateColor                            ColorEqual;                                        // 0x0388(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            ColorUp;                                           // 0x03B0(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            ColorDown;                                         // 0x03D8(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_400[0xA0];                                     // 0x0400(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDark, class UWidgetAnimation* AnimDefaultMax, class UWidgetAnimation* AnimDarkMax, class UImage* ImageEquip, class UImage* ImageDone, class UOverlay* OverlayParamL, class UHorizonFlipbookWidget* ArrowL_UP, class UHorizonFlipbookWidget* ArrowL_DOWN, class UTextBlock* TextNumL, class UOverlay* OverlayParamR, class UHorizonFlipbookWidget* ArrowR_UP, class UHorizonFlipbookWidget* ArrowR_DOWN, class UTextBlock* TextNumR, class UOverlay* OverlayBondSet, class UTextBlock* TextBondNum, class UPaperFlipbook* PfArrowUP, class UPaperFlipbook* PfArrowDown);
	void SetEquipOrLoveIcon(EEquipOrLoveIcon Type);
	void SetFaceIcon(EPlayerID CharacterId);
	void SetParameterIcon(int32 Index_0, int32 Icon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopPartyStatusIcon">();
	}
	static class UUIShopPartyStatusIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopPartyStatusIcon>();
	}
};
static_assert(alignof(UUIShopPartyStatusIcon) == 0x000008, "Wrong alignment on UUIShopPartyStatusIcon");
static_assert(sizeof(UUIShopPartyStatusIcon) == 0x0004A0, "Wrong size on UUIShopPartyStatusIcon");
static_assert(offsetof(UUIShopPartyStatusIcon, ColorEqual) == 0x000388, "Member 'UUIShopPartyStatusIcon::ColorEqual' has a wrong offset!");
static_assert(offsetof(UUIShopPartyStatusIcon, ColorUp) == 0x0003B0, "Member 'UUIShopPartyStatusIcon::ColorUp' has a wrong offset!");
static_assert(offsetof(UUIShopPartyStatusIcon, ColorDown) == 0x0003D8, "Member 'UUIShopPartyStatusIcon::ColorDown' has a wrong offset!");

// Class BattlePrototype.BTTask_RSPlayerJump
// 0x0010 (0x00B8 - 0x00A8)
class UBTTask_RSPlayerJump final : public UBTTask_RSPlayerBase
{
public:
	bool                                          bPress;                                            // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameTimer                             Timer;                                             // 0x00AC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerJump">();
	}
	static class UBTTask_RSPlayerJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerJump>();
	}
};
static_assert(alignof(UBTTask_RSPlayerJump) == 0x000008, "Wrong alignment on UBTTask_RSPlayerJump");
static_assert(sizeof(UBTTask_RSPlayerJump) == 0x0000B8, "Wrong size on UBTTask_RSPlayerJump");
static_assert(offsetof(UBTTask_RSPlayerJump, bPress) == 0x0000A8, "Member 'UBTTask_RSPlayerJump::bPress' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerJump, Timer) == 0x0000AC, "Member 'UBTTask_RSPlayerJump::Timer' has a wrong offset!");

// Class BattlePrototype.BTTask_RSPlayerMoveToBase
// 0x0038 (0x00E0 - 0x00A8)
class UBTTask_RSPlayerMoveToBase : public UBTTask_RSPlayerBase
{
public:
	float                                         AcceptionRadius;                                   // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bJumpCheck;                                        // 0x00AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWallBackCheck;                                    // 0x00AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExit;                                             // 0x00AE(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInputMoveMode;                                    // 0x00AF(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameTimer                             Timer;                                             // 0x00B0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         Step;                                              // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameTimer                             CheckWallTimer;                                    // 0x00C0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         CheckJumpInterval;                                 // 0x00CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameTimer                             BackInputTimer;                                    // 0x00D0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EPlayerAIMoveWallCPP                          WallTypeCPP;                                       // 0x00DC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerMoveToBase">();
	}
	static class UBTTask_RSPlayerMoveToBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerMoveToBase>();
	}
};
static_assert(alignof(UBTTask_RSPlayerMoveToBase) == 0x000008, "Wrong alignment on UBTTask_RSPlayerMoveToBase");
static_assert(sizeof(UBTTask_RSPlayerMoveToBase) == 0x0000E0, "Wrong size on UBTTask_RSPlayerMoveToBase");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, AcceptionRadius) == 0x0000A8, "Member 'UBTTask_RSPlayerMoveToBase::AcceptionRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, bJumpCheck) == 0x0000AC, "Member 'UBTTask_RSPlayerMoveToBase::bJumpCheck' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, bWallBackCheck) == 0x0000AD, "Member 'UBTTask_RSPlayerMoveToBase::bWallBackCheck' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, bExit) == 0x0000AE, "Member 'UBTTask_RSPlayerMoveToBase::bExit' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, bInputMoveMode) == 0x0000AF, "Member 'UBTTask_RSPlayerMoveToBase::bInputMoveMode' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, Timer) == 0x0000B0, "Member 'UBTTask_RSPlayerMoveToBase::Timer' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, Step) == 0x0000BC, "Member 'UBTTask_RSPlayerMoveToBase::Step' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, CheckWallTimer) == 0x0000C0, "Member 'UBTTask_RSPlayerMoveToBase::CheckWallTimer' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, CheckJumpInterval) == 0x0000CC, "Member 'UBTTask_RSPlayerMoveToBase::CheckJumpInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, BackInputTimer) == 0x0000D0, "Member 'UBTTask_RSPlayerMoveToBase::BackInputTimer' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, WallTypeCPP) == 0x0000DC, "Member 'UBTTask_RSPlayerMoveToBase::WallTypeCPP' has a wrong offset!");

// Class BattlePrototype.HitCheckInterface
// 0x0000 (0x0028 - 0x0028)
class IHitCheckInterface final : public IInterface
{
public:
	class AActor* GetHitCheckIgnoredActor();
	bool IsCheckFriendlyFire(class AActor* HitActor);
	bool IsIgnoreAccelerator(EHCSkillExtraType Type);
	bool IsIgnoreHitCheck(class UPrimitiveComponent* PPrimitive, const struct FVector& HitPosition);
	bool IsObstacleHitCheck(class UPrimitiveComponent* PPrimitive, class AActor* PAttacker, const struct FVector& EndPosition);
	bool IsObstacleHitCheckToActor(class AActor* PTarget);

	bool IsDisableDamageHit() const;
	bool IsOnGround(bool bIncludeObject) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitCheckInterface">();
	}
	static class IHitCheckInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHitCheckInterface>();
	}
};
static_assert(alignof(IHitCheckInterface) == 0x000008, "Wrong alignment on IHitCheckInterface");
static_assert(sizeof(IHitCheckInterface) == 0x000028, "Wrong size on IHitCheckInterface");

// Class BattlePrototype.BTTask_RSPlayerMoveRoute
// 0x0000 (0x00E0 - 0x00E0)
class UBTTask_RSPlayerMoveRoute final : public UBTTask_RSPlayerMoveToBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerMoveRoute">();
	}
	static class UBTTask_RSPlayerMoveRoute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerMoveRoute>();
	}
};
static_assert(alignof(UBTTask_RSPlayerMoveRoute) == 0x000008, "Wrong alignment on UBTTask_RSPlayerMoveRoute");
static_assert(sizeof(UBTTask_RSPlayerMoveRoute) == 0x0000E0, "Wrong size on UBTTask_RSPlayerMoveRoute");

// Class BattlePrototype.RSAjitoAnimBaseInstance
// 0x0010 (0x0630 - 0x0620)
class URSAjitoAnimBaseInstance final : public UASAnimInstance
{
public:
	uint8                                         Pad_620[0x10];                                     // 0x0620(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAjitoAnimBaseInstance">();
	}
	static class URSAjitoAnimBaseInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAjitoAnimBaseInstance>();
	}
};
static_assert(alignof(URSAjitoAnimBaseInstance) == 0x000010, "Wrong alignment on URSAjitoAnimBaseInstance");
static_assert(sizeof(URSAjitoAnimBaseInstance) == 0x000630, "Wrong size on URSAjitoAnimBaseInstance");

// Class BattlePrototype.RegisterEffectInterface
// 0x0000 (0x0028 - 0x0028)
class IRegisterEffectInterface final : public IInterface
{
public:
	void RegisterEffectInterface(class URSParticleSystemComponentBase* Particle);
	void RegisterInterruptTelepoEffectInterface(class URSParticleSystemComponentBase* Particle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RegisterEffectInterface">();
	}
	static class IRegisterEffectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRegisterEffectInterface>();
	}
};
static_assert(alignof(IRegisterEffectInterface) == 0x000008, "Wrong alignment on IRegisterEffectInterface");
static_assert(sizeof(IRegisterEffectInterface) == 0x000028, "Wrong size on IRegisterEffectInterface");

// Class BattlePrototype.BTTask_RSPlayerMoveTo_BlueprintBase
// 0x00C8 (0x0170 - 0x00A8)
class UBTTask_RSPlayerMoveTo_BlueprintBase : public UBTTask_BlueprintBase
{
public:
	class ARSCharacterBase*                       OwnerCharacter;                                    // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerScriptComponent*                 OwnerPlayerScript;                                 // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerAIBaseComponent*                 OwnerPlayerAIComponent;                            // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AcceptionRadius;                                   // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AcceptionHeight;                                   // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExit;                                             // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInputMoveMode;                                    // 0x00C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CA[0x2];                                       // 0x00CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameTimer                             ResetAIMoveToTimer;                                // 0x00CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         Step;                                              // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bJumpCheck;                                        // 0x00DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedsJumpCheckCurrent;                            // 0x00DD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DE[0x2];                                       // 0x00DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpCheckMoveSpeedRatioThreshold;                  // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameTimer                             CheckWallTimer;                                    // 0x00E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         CheckJumpInterval;                                 // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameTimer                             BackInputTimer;                                    // 0x00F4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameTimer                             DetourInputTimer;                                  // 0x0100(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         DetourInputDuration;                               // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetourInputBeginYawAngle;                          // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetourInputDurationShort;                          // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetourInputBeginYawAngleShort;                     // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetourInputDurationRateWalk;                       // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetourInputDurationRateRun;                        // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetourInputDurationRateSprint;                     // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetourInputRotateDirection;                        // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetourInputBeginYawAngleCurrent;                   // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerAIMoveWallCPP                          WallTypeCPP;                                       // 0x0130(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWallBackCheck;                                    // 0x0131(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_132[0x2];                                      // 0x0132(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceWallBackNotMovedTime;                         // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWallDetourCheck;                                  // 0x0138(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAIMoving;                                         // 0x0139(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnemyCheck;                                       // 0x013A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWarpCheck;                                        // 0x013B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MovedDistanceCurrent;                              // 0x013C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MovedDistancePrevLocation;                         // 0x0144(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovedDistanceCheckTimer;                           // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovedDistanceCheckInterval;                        // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovedDistanceThreshold;                            // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NotMovedElapsedTime;                               // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForceWarpThresholdTime;                            // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceWarpRequest;                                 // 0x0160(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChangeWalkOrRun;                                  // 0x0161(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_162[0x2];                                      // 0x0162(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkingDistanceMax;                                // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RunningDistanceMin;                                // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWalking;                                          // 0x016C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16D[0x3];                                      // 0x016D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckAvoidWallOrWarpCPP();
	void CheckMovedDistance_InitializeCPP();
	void CheckMovedDistance_TickCPP(float DeltaSeconds);
	bool CheckMoveDistance_IsEndCPP();
	void CheckWallCPP();
	void Exit_CallFromCPP(class AAIController* OwnerController, class APawn* ControlledPawn);
	void ExitCPP();
	void ForceWarpCPP();
	void SetAIMoveTo_CallFromCPP(class AAIController* OwnerController, class APawn* ControlledPawn);
	void StopAIMoveToCPP(bool bRechargeResetAIMoveTimer);
	void TickMoveCPP();

	bool CheckArrivedGoalCPP() const;
	bool CheckDistanceXY_CPP(const struct FVector& Location1, const struct FVector& Location2, float DistanceXY) const;
	bool CheckDistanceXY_Z_CPP(const struct FVector& Location1, const struct FVector& Location2, float DistanceXY, float DistanceZ) const;
	bool CheckPlayerIsRun(class ARSCharacterBase* Character) const;
	bool CheckStickMoveEndCPP() const;
	class ARSCharacterBase* GetOwnerCharacter() const;
	class UPlayerAIBaseComponent* GetOwnerPlayerAI() const;
	class UPlayerScriptComponent* GetOwnerPlayerScript() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerMoveTo_BlueprintBase">();
	}
	static class UBTTask_RSPlayerMoveTo_BlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerMoveTo_BlueprintBase>();
	}
};
static_assert(alignof(UBTTask_RSPlayerMoveTo_BlueprintBase) == 0x000008, "Wrong alignment on UBTTask_RSPlayerMoveTo_BlueprintBase");
static_assert(sizeof(UBTTask_RSPlayerMoveTo_BlueprintBase) == 0x000170, "Wrong size on UBTTask_RSPlayerMoveTo_BlueprintBase");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, OwnerCharacter) == 0x0000A8, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, OwnerPlayerScript) == 0x0000B0, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::OwnerPlayerScript' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, OwnerPlayerAIComponent) == 0x0000B8, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::OwnerPlayerAIComponent' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, AcceptionRadius) == 0x0000C0, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::AcceptionRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, AcceptionHeight) == 0x0000C4, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::AcceptionHeight' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bExit) == 0x0000C8, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bExit' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bInputMoveMode) == 0x0000C9, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bInputMoveMode' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, ResetAIMoveToTimer) == 0x0000CC, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::ResetAIMoveToTimer' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, Step) == 0x0000D8, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::Step' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bJumpCheck) == 0x0000DC, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bJumpCheck' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bNeedsJumpCheckCurrent) == 0x0000DD, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bNeedsJumpCheckCurrent' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, JumpCheckMoveSpeedRatioThreshold) == 0x0000E0, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::JumpCheckMoveSpeedRatioThreshold' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, CheckWallTimer) == 0x0000E4, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::CheckWallTimer' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, CheckJumpInterval) == 0x0000F0, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::CheckJumpInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, BackInputTimer) == 0x0000F4, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::BackInputTimer' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputTimer) == 0x000100, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputTimer' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputDuration) == 0x00010C, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputDuration' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputBeginYawAngle) == 0x000110, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputBeginYawAngle' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputDurationShort) == 0x000114, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputDurationShort' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputBeginYawAngleShort) == 0x000118, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputBeginYawAngleShort' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputDurationRateWalk) == 0x00011C, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputDurationRateWalk' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputDurationRateRun) == 0x000120, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputDurationRateRun' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputDurationRateSprint) == 0x000124, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputDurationRateSprint' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputRotateDirection) == 0x000128, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputRotateDirection' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputBeginYawAngleCurrent) == 0x00012C, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputBeginYawAngleCurrent' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, WallTypeCPP) == 0x000130, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::WallTypeCPP' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bWallBackCheck) == 0x000131, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bWallBackCheck' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, ForceWallBackNotMovedTime) == 0x000134, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::ForceWallBackNotMovedTime' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bWallDetourCheck) == 0x000138, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bWallDetourCheck' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bAIMoving) == 0x000139, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bAIMoving' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bEnemyCheck) == 0x00013A, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bEnemyCheck' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bWarpCheck) == 0x00013B, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bWarpCheck' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, MovedDistanceCurrent) == 0x00013C, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::MovedDistanceCurrent' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, MovedDistancePrevLocation) == 0x000144, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::MovedDistancePrevLocation' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, MovedDistanceCheckTimer) == 0x00014C, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::MovedDistanceCheckTimer' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, MovedDistanceCheckInterval) == 0x000150, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::MovedDistanceCheckInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, MovedDistanceThreshold) == 0x000154, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::MovedDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, NotMovedElapsedTime) == 0x000158, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::NotMovedElapsedTime' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, ForceWarpThresholdTime) == 0x00015C, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::ForceWarpThresholdTime' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bForceWarpRequest) == 0x000160, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bForceWarpRequest' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bChangeWalkOrRun) == 0x000161, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bChangeWalkOrRun' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, WalkingDistanceMax) == 0x000164, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::WalkingDistanceMax' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, RunningDistanceMin) == 0x000168, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::RunningDistanceMin' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bWalking) == 0x00016C, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bWalking' has a wrong offset!");

// Class BattlePrototype.RSActorEnemyBase
// 0x0000 (0x0230 - 0x0230)
class ARSActorEnemyBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorEnemyBase">();
	}
	static class ARSActorEnemyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSActorEnemyBase>();
	}
};
static_assert(alignof(ARSActorEnemyBase) == 0x000008, "Wrong alignment on ARSActorEnemyBase");
static_assert(sizeof(ARSActorEnemyBase) == 0x000230, "Wrong size on ARSActorEnemyBase");

// Class BattlePrototype.BTTask_RSPlayerMoveToHero
// 0x0000 (0x00E0 - 0x00E0)
class UBTTask_RSPlayerMoveToHero final : public UBTTask_RSPlayerMoveToBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerMoveToHero">();
	}
	static class UBTTask_RSPlayerMoveToHero* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerMoveToHero>();
	}
};
static_assert(alignof(UBTTask_RSPlayerMoveToHero) == 0x000008, "Wrong alignment on UBTTask_RSPlayerMoveToHero");
static_assert(sizeof(UBTTask_RSPlayerMoveToHero) == 0x0000E0, "Wrong size on UBTTask_RSPlayerMoveToHero");

// Class BattlePrototype.RSMaterialSwitchLibrary
// 0x0000 (0x0028 - 0x0028)
class URSMaterialSwitchLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ClearMaterialSwitchCache(struct FMaterialSwitchCache& MaterialCache);
	static void ClearSwitchMaterialLayerIDs(struct FMaterialSwitchCache& MaterialCache, const TArray<int32>& LayerIDs);
	static bool RestoreSwitchMaterial(struct FMaterialSwitchCache& MaterialCache, int32 RestoreNum);
	static void RestoreSwitchMaterialLayerIDs(struct FMaterialSwitchCache& MaterialCache, const TArray<int32>& LayerIDs, bool ClearCache);
	static void SwitchMaterial(struct FMaterialSwitchCache& MaterialCache, class UPrimitiveComponent* Primitive, class UMaterialInterface* NewMaterial, int32* LayerID);
	static void SwitchMaterialExclude(struct FMaterialSwitchCache& MaterialCache, class UPrimitiveComponent* Primitive, const TArray<class FName>& ExcludeMaterialSlots, class UMaterialInterface* NewMaterial, int32* LayerID);
	static void SwitchMaterialExcludeLayerID(struct FMaterialSwitchCache& MaterialCache, int32 LayerID, class UPrimitiveComponent* Primitive, const TArray<class FName>& ExcludeMaterialSlots, class UMaterialInterface* NewMaterial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSMaterialSwitchLibrary">();
	}
	static class URSMaterialSwitchLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSMaterialSwitchLibrary>();
	}
};
static_assert(alignof(URSMaterialSwitchLibrary) == 0x000008, "Wrong alignment on URSMaterialSwitchLibrary");
static_assert(sizeof(URSMaterialSwitchLibrary) == 0x000028, "Wrong size on URSMaterialSwitchLibrary");

// Class BattlePrototype.UIMenuBattleControl
// 0x01A0 (0x0528 - 0x0388)
class UUIMenuBattleControl : public UUIBase
{
public:
	TSubclassOf<class UUINumberDamage>            ClassNumberDamage;                                 // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIGameOver*                            UIGameOver;                                        // 0x0390(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIBossName*                            UIBossName;                                        // 0x0398(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUILog*                                 UILog;                                             // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUITarget*                              UICursorNormal;                                    // 0x03A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVitalityPL01*                        UIVitalityPL01;                                    // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVitalityPL02*                        UIVitalityPL02;                                    // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVitalityPL02*                        UiVitalityPL02Flame;                               // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVitalityPL03*                        UIVitalityPL03;                                    // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVitalityPL03*                        UiVitalityPL03Flame;                               // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVitalityEN01*                        UIVitalityEN01;                                    // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVitalityEN01*                        UiVitalityEN01Flame;                               // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIBrainGaugeEN*                        UIBrainGaugeEN;                                    // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIBrainGaugeEN*                        UiBrainGaugeENFrame;                               // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIVitalityEN02*>                UIEnemyVitalityWidgetList;                         // 0x03F8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUINumberDamage*>                DamageWidgets;                                     // 0x0408(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIDiscover*>                    UIIDiscoverList;                                   // 0x0418(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIPkObjectTimer*>               UIPkObjectTimerList;                               // 0x0428(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagPlayUI;                                        // 0x0438(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagCloseDirect;                                   // 0x0439(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawHpGaugeMain;                               // 0x043A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawHpGaugeSub;                                // 0x043B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawPsychicGauge;                              // 0x043C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawBrainCrashGauge;                           // 0x043D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawBrainCrashGaugeEnemy;                      // 0x043E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawItemMenu;                                  // 0x043F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawSasMenu;                                   // 0x0440(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawMiniMap;                                   // 0x0441(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawLog;                                       // 0x0442(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawDroneGuide;                                // 0x0443(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawTeamBondLv;                                // 0x0444(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawMiniTips;                                  // 0x0445(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawBrainCrashBar;                             // 0x0446(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawBrainCrashBarBoss;                         // 0x0447(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawHpGaugeEnemyBoss;                          // 0x0448(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawShortcutGuide;                             // 0x0449(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawBrainTalk;                                 // 0x044A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawOtherWidget;                               // 0x044B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawTutoOperation;                             // 0x044C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawAreaHere;                                  // 0x044D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawSuccess;                                   // 0x044E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44F[0x1];                                      // 0x044F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIBrainTargetInfo>             CursorBrainTargetList;                             // 0x0450(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              CursorBrainTargetOffset2D;                         // 0x0460(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FUIEnemyInfo>                   EnemyList;                                         // 0x0468(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          EnemyHpWidgetVisibleFlag;                          // 0x0478(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_479[0x7];                                      // 0x0479(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSCharacterBase*                       CursorTarget;                                      // 0x0480(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeltaTime;                                         // 0x0488(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BrainGaugeENVisibleFlag;                           // 0x048C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48D[0xB];                                      // 0x048D(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIBrainCrashGauge*                     UIBrainCrashGauge;                                 // 0x0498(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIBrainCrashGauge*                     UIBrainCrashGaugeBoss;                             // 0x04A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARSCharacterBase*                       BackupBrainCrashTarget;                            // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FUIPkObjectTimerInfo>           PkObjectTimerWork;                                 // 0x04B0(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         LogMessageList;                                    // 0x04C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0xC];                                      // 0x04D0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              M_widgetsMaxMove;                                  // 0x04DC(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              M_widgetsMaxMovePerFrame;                          // 0x04E4(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              M_widgetsMaxScaleingMaxMove;                       // 0x04EC(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              M_widgetsMaxScaleingPerFrame;                      // 0x04F4(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4FC[0x2C];                                     // 0x04FC(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BrainGaugeENEndField();
	void BrainGaugeENSetGaugeMax(bool IsFull);
	void BrainGaugeENSetPercent(float Percent, float Time);
	void BrainGaugeENSetVisible(bool IsVisible_0);
	void BrainGaugeENStartField();
	bool ChangePlayUI(bool IsPlay);
	bool ChangeTown(bool IsTown, bool IsAjito);
	void CloseActiveAllBrainTargetCursor(class ARSCharacterBase* PExcludeTarget);
	void CloseAllDamageWidget();
	void CloseAllPkObjectTimer();
	bool CloseMinimap(bool Force);
	bool CloseMiniTips(EHelpTutorial ID);
	void CloseTargetCursor();
	int32 CreateDiscoverIndexList(class UUIDiscover* UIDiscover);
	int32 CreateIndexList(class UUIDiscover* UIDiscover);
	bool EndMinimapBrainField();
	void EnemyHpWidgetDisappearInstantly(class ARSCharacterBase* Target);
	int32 GetBrainTargetCursor(class ARSCharacterBase* PTarget);
	EHelpTutorial GetCurrentMiniTipsID();
	int32 GetEnemyLevel(class ARSCharacterBase* Target);
	class UUINumberDamage* GetFreeDamageWidget();
	void GetFreeHpWidget(class UUIVitalityEN02** Widget);
	EGameOverResult GetGameOverResult();
	void GetHp(class ARSCharacterBase* Character, float* Max, float* Current);
	float GetHPPercent(int32 Index_0);
	void GetHpTargetCharacter(int32 Index_0, class ARSCharacterBase** Instance, bool* IsEnable);
	void InitDamage();
	void InitializeThis(class UUILog* UILog_0, class UUIVitalityPL01* UIVitalityPL01_0, class UUIVitalityPL02* UIVitalityPL02_0, class UUIVitalityPL02* UiVitalityPL02Flame_0, class UUIVitalityPL03* UIVitalityPL03_0, class UUIVitalityPL03* UiVitalityPL03Flame_0, class UUIVitalityEN01* UIVitalityEN01_0, class UUIVitalityEN01* UiVitalityEN01Flame_0, class UUIBrainGaugeEN* UIBrainGaugeEN_0, class UUIBrainGaugeEN* UiBrainGaugeENFrame_0, class UOverlay* OverlayWidgets);
	void InitLogMessage();
	bool IsEndGameOver();
	bool IsPlayBrainTuto();
	bool MiniMapModelDelete();
	void OpenActiveAllBrainTargetCursor();
	void OpenAllActivePkObjectTimer();
	bool OpenBrainTuto();
	bool OpenMinimap(bool Force);
	bool PlayDamageEffect(bool IsCritical);
	bool PlayDecideAnimeBrainTuto();
	void ReleaseCrushBonus();
	bool RemoveDiscoverIndexList(int32 Index_0);
	bool SasSetChangePageReady(bool ReadyFlagL, bool ReadyFlagR);
	int32 SetBrainCrashEnable(class ARSCharacterBase* PTarget, bool IsEnable);
	void SetBrainCrashTarget(class ARSCharacterBase* PTarget, bool* bSuccess);
	bool SetCrushBonus(class ARSCharacterBase* Target, int32 bonus);
	void SetDamage2D(int32 Damage, const struct FVector2D& Position2D, bool IsPlayer, bool IsCritical, bool IsSasCritical, bool IsBrainCrashCritical, bool IsHeal, bool IsWeak, bool IsNoDamage, class ARSCharacterBase* CrushTarget, int32 CrushBonus);
	void SetDamage3D(int32 Damage, const struct FVector& Position3D, bool IsPlayer, bool IsCritical, bool IsSasCritical, bool IsBrainCrashCritical, bool IsHeal, bool IsWeak, bool IsNoDamage, class ARSCharacterBase* CrushTarget, int32 CrushBonus, const struct FVector2D& Offset);
	void SetEnemyDamage(class ARSCharacterBase* Target, int32 CurrentHp, int32 BaseHp, bool IsAlways, float Time);
	void SetEnemyHpWidgetVisible(bool IsVisible_0);
	void SetIcon(class ARSCharacterBase* Character, class UUIHealthControl* Widget);
	void SetLogDrawTime(float Time);
	void SetLogMessage(const class FString& LogMessage);
	void SetLogMessageSE(const class FString& LogMessage, EUI_SE Se);
	void SetLogWaitTime(float Time);
	void SetupPlayerHpGauge();
	void SetUUIVitalityEN02Visible(bool IsVisible_0);
	void StartGameOver();
	bool StartMinimapBrainField();
	void StartPkObjectTimer(class ARSCharacterBase* Target, float MaxSecond, float CurrentSecond);
	void StopPkObjectTimer(class ARSCharacterBase* Target);
	bool UpdateDrawWidgetMiniMap();
	void UpdateHpVisible(int32 Index_0, class ARSCharacterBase* Character);
	void UpdateHpWidgetInformation(class ARSCharacterBase* Actor, int32 Index_0);
	void UpdateLockTarget();
	void UpdateLogMessage(float DeltaSecond);
	void UpdatePkObjectTimer(class ARSCharacterBase* Target, float MaxSecond, float CurrentSecond);
	void UpdateStateThis(float FDeltaSecond);

	class ARSCharacterBase* GetBackupBossActor() const;
	float GetLogDrawTime() const;
	float GetLogWaitTime() const;
	bool IsLogMessageEmpty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMenuBattleControl">();
	}
	static class UUIMenuBattleControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMenuBattleControl>();
	}
};
static_assert(alignof(UUIMenuBattleControl) == 0x000008, "Wrong alignment on UUIMenuBattleControl");
static_assert(sizeof(UUIMenuBattleControl) == 0x000528, "Wrong size on UUIMenuBattleControl");
static_assert(offsetof(UUIMenuBattleControl, ClassNumberDamage) == 0x000388, "Member 'UUIMenuBattleControl::ClassNumberDamage' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIGameOver) == 0x000390, "Member 'UUIMenuBattleControl::UIGameOver' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIBossName) == 0x000398, "Member 'UUIMenuBattleControl::UIBossName' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UILog) == 0x0003A0, "Member 'UUIMenuBattleControl::UILog' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UICursorNormal) == 0x0003A8, "Member 'UUIMenuBattleControl::UICursorNormal' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIVitalityPL01) == 0x0003B0, "Member 'UUIMenuBattleControl::UIVitalityPL01' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIVitalityPL02) == 0x0003B8, "Member 'UUIMenuBattleControl::UIVitalityPL02' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UiVitalityPL02Flame) == 0x0003C0, "Member 'UUIMenuBattleControl::UiVitalityPL02Flame' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIVitalityPL03) == 0x0003C8, "Member 'UUIMenuBattleControl::UIVitalityPL03' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UiVitalityPL03Flame) == 0x0003D0, "Member 'UUIMenuBattleControl::UiVitalityPL03Flame' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIVitalityEN01) == 0x0003D8, "Member 'UUIMenuBattleControl::UIVitalityEN01' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UiVitalityEN01Flame) == 0x0003E0, "Member 'UUIMenuBattleControl::UiVitalityEN01Flame' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIBrainGaugeEN) == 0x0003E8, "Member 'UUIMenuBattleControl::UIBrainGaugeEN' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UiBrainGaugeENFrame) == 0x0003F0, "Member 'UUIMenuBattleControl::UiBrainGaugeENFrame' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIEnemyVitalityWidgetList) == 0x0003F8, "Member 'UUIMenuBattleControl::UIEnemyVitalityWidgetList' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, DamageWidgets) == 0x000408, "Member 'UUIMenuBattleControl::DamageWidgets' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIIDiscoverList) == 0x000418, "Member 'UUIMenuBattleControl::UIIDiscoverList' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIPkObjectTimerList) == 0x000428, "Member 'UUIMenuBattleControl::UIPkObjectTimerList' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagPlayUI) == 0x000438, "Member 'UUIMenuBattleControl::FlagPlayUI' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagCloseDirect) == 0x000439, "Member 'UUIMenuBattleControl::FlagCloseDirect' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawHpGaugeMain) == 0x00043A, "Member 'UUIMenuBattleControl::FlagDrawHpGaugeMain' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawHpGaugeSub) == 0x00043B, "Member 'UUIMenuBattleControl::FlagDrawHpGaugeSub' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawPsychicGauge) == 0x00043C, "Member 'UUIMenuBattleControl::FlagDrawPsychicGauge' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawBrainCrashGauge) == 0x00043D, "Member 'UUIMenuBattleControl::FlagDrawBrainCrashGauge' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawBrainCrashGaugeEnemy) == 0x00043E, "Member 'UUIMenuBattleControl::FlagDrawBrainCrashGaugeEnemy' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawItemMenu) == 0x00043F, "Member 'UUIMenuBattleControl::FlagDrawItemMenu' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawSasMenu) == 0x000440, "Member 'UUIMenuBattleControl::FlagDrawSasMenu' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawMiniMap) == 0x000441, "Member 'UUIMenuBattleControl::FlagDrawMiniMap' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawLog) == 0x000442, "Member 'UUIMenuBattleControl::FlagDrawLog' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawDroneGuide) == 0x000443, "Member 'UUIMenuBattleControl::FlagDrawDroneGuide' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawTeamBondLv) == 0x000444, "Member 'UUIMenuBattleControl::FlagDrawTeamBondLv' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawMiniTips) == 0x000445, "Member 'UUIMenuBattleControl::FlagDrawMiniTips' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawBrainCrashBar) == 0x000446, "Member 'UUIMenuBattleControl::FlagDrawBrainCrashBar' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawBrainCrashBarBoss) == 0x000447, "Member 'UUIMenuBattleControl::FlagDrawBrainCrashBarBoss' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawHpGaugeEnemyBoss) == 0x000448, "Member 'UUIMenuBattleControl::FlagDrawHpGaugeEnemyBoss' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawShortcutGuide) == 0x000449, "Member 'UUIMenuBattleControl::FlagDrawShortcutGuide' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawBrainTalk) == 0x00044A, "Member 'UUIMenuBattleControl::FlagDrawBrainTalk' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawOtherWidget) == 0x00044B, "Member 'UUIMenuBattleControl::FlagDrawOtherWidget' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawTutoOperation) == 0x00044C, "Member 'UUIMenuBattleControl::FlagDrawTutoOperation' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawAreaHere) == 0x00044D, "Member 'UUIMenuBattleControl::FlagDrawAreaHere' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawSuccess) == 0x00044E, "Member 'UUIMenuBattleControl::FlagDrawSuccess' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, CursorBrainTargetList) == 0x000450, "Member 'UUIMenuBattleControl::CursorBrainTargetList' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, CursorBrainTargetOffset2D) == 0x000460, "Member 'UUIMenuBattleControl::CursorBrainTargetOffset2D' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, EnemyList) == 0x000468, "Member 'UUIMenuBattleControl::EnemyList' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, EnemyHpWidgetVisibleFlag) == 0x000478, "Member 'UUIMenuBattleControl::EnemyHpWidgetVisibleFlag' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, CursorTarget) == 0x000480, "Member 'UUIMenuBattleControl::CursorTarget' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, DeltaTime) == 0x000488, "Member 'UUIMenuBattleControl::DeltaTime' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, BrainGaugeENVisibleFlag) == 0x00048C, "Member 'UUIMenuBattleControl::BrainGaugeENVisibleFlag' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIBrainCrashGauge) == 0x000498, "Member 'UUIMenuBattleControl::UIBrainCrashGauge' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIBrainCrashGaugeBoss) == 0x0004A0, "Member 'UUIMenuBattleControl::UIBrainCrashGaugeBoss' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, BackupBrainCrashTarget) == 0x0004A8, "Member 'UUIMenuBattleControl::BackupBrainCrashTarget' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, PkObjectTimerWork) == 0x0004B0, "Member 'UUIMenuBattleControl::PkObjectTimerWork' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, LogMessageList) == 0x0004C0, "Member 'UUIMenuBattleControl::LogMessageList' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, M_widgetsMaxMove) == 0x0004DC, "Member 'UUIMenuBattleControl::M_widgetsMaxMove' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, M_widgetsMaxMovePerFrame) == 0x0004E4, "Member 'UUIMenuBattleControl::M_widgetsMaxMovePerFrame' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, M_widgetsMaxScaleingMaxMove) == 0x0004EC, "Member 'UUIMenuBattleControl::M_widgetsMaxScaleingMaxMove' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, M_widgetsMaxScaleingPerFrame) == 0x0004F4, "Member 'UUIMenuBattleControl::M_widgetsMaxScaleingPerFrame' has a wrong offset!");

// Class BattlePrototype.BTTask_RSPlayerMoveToRevive
// 0x0000 (0x00E0 - 0x00E0)
class UBTTask_RSPlayerMoveToRevive final : public UBTTask_RSPlayerMoveToBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerMoveToRevive">();
	}
	static class UBTTask_RSPlayerMoveToRevive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerMoveToRevive>();
	}
};
static_assert(alignof(UBTTask_RSPlayerMoveToRevive) == 0x000008, "Wrong alignment on UBTTask_RSPlayerMoveToRevive");
static_assert(sizeof(UBTTask_RSPlayerMoveToRevive) == 0x0000E0, "Wrong size on UBTTask_RSPlayerMoveToRevive");

// Class BattlePrototype.EventSkeletalMeshSoft
// 0x0000 (0x02B8 - 0x02B8)
class AEventSkeletalMeshSoft final : public ASkeletalMeshActor
{
public:
	void SetDummyMesh(class USkeletalMesh* InMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventSkeletalMeshSoft">();
	}
	static class AEventSkeletalMeshSoft* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventSkeletalMeshSoft>();
	}
};
static_assert(alignof(AEventSkeletalMeshSoft) == 0x000008, "Wrong alignment on AEventSkeletalMeshSoft");
static_assert(sizeof(AEventSkeletalMeshSoft) == 0x0002B8, "Wrong size on AEventSkeletalMeshSoft");

// Class BattlePrototype.BTTask_RSPlayerNextBattleThink
// 0x0000 (0x00A8 - 0x00A8)
class UBTTask_RSPlayerNextBattleThink final : public UBTTask_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerNextBattleThink">();
	}
	static class UBTTask_RSPlayerNextBattleThink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerNextBattleThink>();
	}
};
static_assert(alignof(UBTTask_RSPlayerNextBattleThink) == 0x000008, "Wrong alignment on UBTTask_RSPlayerNextBattleThink");
static_assert(sizeof(UBTTask_RSPlayerNextBattleThink) == 0x0000A8, "Wrong size on UBTTask_RSPlayerNextBattleThink");

// Class BattlePrototype.UITitleCrossSave_ConfirmWindow_Parts_Select2
// 0x0158 (0x04E0 - 0x0388)
class UUITitleCrossSave_ConfirmWindow_Parts_Select2 final : public UUIBase
{
public:
	uint8                                         Pad_388[0x158];                                    // 0x0388(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeIndex(int32 Index_0, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimEnable, class UWidgetAnimation* AnimEnableIn, class UWidgetAnimation* AnimEnableOut, class UREDTextBlock* TextIndex);
	void InitializeThis();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleCrossSave_ConfirmWindow_Parts_Select2">();
	}
	static class UUITitleCrossSave_ConfirmWindow_Parts_Select2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleCrossSave_ConfirmWindow_Parts_Select2>();
	}
};
static_assert(alignof(UUITitleCrossSave_ConfirmWindow_Parts_Select2) == 0x000008, "Wrong alignment on UUITitleCrossSave_ConfirmWindow_Parts_Select2");
static_assert(sizeof(UUITitleCrossSave_ConfirmWindow_Parts_Select2) == 0x0004E0, "Wrong size on UUITitleCrossSave_ConfirmWindow_Parts_Select2");

// Class BattlePrototype.BTTask_RSPlayerPlayerRevive
// 0x0000 (0x00A8 - 0x00A8)
class UBTTask_RSPlayerPlayerRevive final : public UBTTask_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerPlayerRevive">();
	}
	static class UBTTask_RSPlayerPlayerRevive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerPlayerRevive>();
	}
};
static_assert(alignof(UBTTask_RSPlayerPlayerRevive) == 0x000008, "Wrong alignment on UBTTask_RSPlayerPlayerRevive");
static_assert(sizeof(UBTTask_RSPlayerPlayerRevive) == 0x0000A8, "Wrong size on UBTTask_RSPlayerPlayerRevive");

// Class BattlePrototype.BTTask_RSPlayerResetBehaviorTree
// 0x0000 (0x00A8 - 0x00A8)
class UBTTask_RSPlayerResetBehaviorTree final : public UBTTask_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerResetBehaviorTree">();
	}
	static class UBTTask_RSPlayerResetBehaviorTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerResetBehaviorTree>();
	}
};
static_assert(alignof(UBTTask_RSPlayerResetBehaviorTree) == 0x000008, "Wrong alignment on UBTTask_RSPlayerResetBehaviorTree");
static_assert(sizeof(UBTTask_RSPlayerResetBehaviorTree) == 0x0000A8, "Wrong size on UBTTask_RSPlayerResetBehaviorTree");

// Class BattlePrototype.EventAssetPoolComponent
// 0x0018 (0x00D8 - 0x00C0)
class UEventAssetPoolComponent : public UActorComponent
{
public:
	TArray<class UEventAsset*>                    Assets;                                            // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UEventAsset* GetHandle(int32 HandleId);
	class UEventAsset* LoadAsset(const class FString& Path, bool Async);
	void UnloadAll();
	bool UnloadAsset(int32 HandleId);

	bool IsLoaded(int32 HandleId) const;
	bool IsLoadedAll() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAssetPoolComponent">();
	}
	static class UEventAssetPoolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAssetPoolComponent>();
	}
};
static_assert(alignof(UEventAssetPoolComponent) == 0x000008, "Wrong alignment on UEventAssetPoolComponent");
static_assert(sizeof(UEventAssetPoolComponent) == 0x0000D8, "Wrong size on UEventAssetPoolComponent");
static_assert(offsetof(UEventAssetPoolComponent, Assets) == 0x0000C0, "Member 'UEventAssetPoolComponent::Assets' has a wrong offset!");

// Class BattlePrototype.BTTask_RSPlayerUseItem
// 0x0008 (0x00B0 - 0x00A8)
class UBTTask_RSPlayerUseItem final : public UBTTask_RSPlayerBase
{
public:
	int32                                         Step;                                              // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerUseItem">();
	}
	static class UBTTask_RSPlayerUseItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerUseItem>();
	}
};
static_assert(alignof(UBTTask_RSPlayerUseItem) == 0x000008, "Wrong alignment on UBTTask_RSPlayerUseItem");
static_assert(sizeof(UBTTask_RSPlayerUseItem) == 0x0000B0, "Wrong size on UBTTask_RSPlayerUseItem");
static_assert(offsetof(UBTTask_RSPlayerUseItem, Step) == 0x0000A8, "Member 'UBTTask_RSPlayerUseItem::Step' has a wrong offset!");

// Class BattlePrototype.RSAtomStatics
// 0x0000 (0x0028 - 0x0028)
class URSAtomStatics final : public UBlueprintFunctionLibrary
{
public:
	static float GetCueSheetVolume(const class FString& SheetName, const bool IsForceGet);
	static float GetNonPlayerCueSheetVolumeParam();
	static void PauseAudioOutputRS(bool bPause);
	static void PlayOneShotSoundAtLocationRS(class UObject* WorldContextObject, TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAtomCue* Sound, const struct FVector& Location, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, class UObject* Creator, EFilterCallbackType FilterCallbackType);
	static void PlaySoundAtLocationRS(class UObject* WorldContextObject, TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAtomCue* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, class UObject* Creator, EFilterCallbackType FilterCallbackType);
	static class URSAtomComponentBase* PlaySoundAttachedRS(TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAtomCue* Sound, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, class UObject* Creator, EFilterCallbackType FilterCallbackType);
	static void RemoveAllCueSheetVolume();
	static void RemoveCueSheetVolume(const class FString& SheetName);
	static void SetCueSheetVolume(const class FString& SheetName, const float Volume);
	static void SetIsCueSheetVolumeEnable(const bool Flag);
	static void SetNonPlayerCueSheetVolumeParam(const float Volume);
	static class URSAtomComponentBase* SpawnSound2DRS(const class UObject* WorldContextObject, TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAtomCue* Sound, float PitchMultiplier, float StartTime, bool bPersistAcrossLevelTransition, bool bAutoDestroy, bool bAutoActivate, class UObject* Creator, EFilterCallbackType FilterCallbackType);
	static class URSAtomComponentBase* SpawnSoundAtLocationLoadedSheetRS(const class UObject* WorldContextObject, TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAtomCue* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy, bool bAutoActivate, class UObject* Creator, EFilterCallbackType FilterCallbackType);
	static class URSAtomComponentBase* SpawnSoundAtLocationRS(const class UObject* WorldContextObject, TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAtomCue* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy, bool bAutoActivate, class UObject* Creator, EFilterCallbackType FilterCallbackType);
	static class URSAtomComponentBase* SpawnSoundAttachedLoadedSheetRS(const class UObject* WorldContextObject, TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAtomCue* Sound, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy, bool bAutoActivate, class UObject* Creator, EFilterCallbackType FilterCallbackType);
	static class URSAtomComponentBase* SpawnSoundAttachedRS(TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAtomCue* Sound, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy, bool bAutoActivate, class UObject* Creator, EFilterCallbackType FilterCallbackType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAtomStatics">();
	}
	static class URSAtomStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAtomStatics>();
	}
};
static_assert(alignof(URSAtomStatics) == 0x000008, "Wrong alignment on URSAtomStatics");
static_assert(sizeof(URSAtomStatics) == 0x000028, "Wrong size on URSAtomStatics");

// Class BattlePrototype.StaticCameraControlDataParam
// 0x0010 (0x0040 - 0x0030)
class UStaticCameraControlDataParam final : public UDataAsset
{
public:
	float                                         CameraInterpSpeed;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnableEaseInOut;                                 // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EaseInOutExp;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRotate;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticCameraControlDataParam">();
	}
	static class UStaticCameraControlDataParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStaticCameraControlDataParam>();
	}
};
static_assert(alignof(UStaticCameraControlDataParam) == 0x000008, "Wrong alignment on UStaticCameraControlDataParam");
static_assert(sizeof(UStaticCameraControlDataParam) == 0x000040, "Wrong size on UStaticCameraControlDataParam");
static_assert(offsetof(UStaticCameraControlDataParam, CameraInterpSpeed) == 0x000030, "Member 'UStaticCameraControlDataParam::CameraInterpSpeed' has a wrong offset!");
static_assert(offsetof(UStaticCameraControlDataParam, IsEnableEaseInOut) == 0x000034, "Member 'UStaticCameraControlDataParam::IsEnableEaseInOut' has a wrong offset!");
static_assert(offsetof(UStaticCameraControlDataParam, EaseInOutExp) == 0x000038, "Member 'UStaticCameraControlDataParam::EaseInOutExp' has a wrong offset!");
static_assert(offsetof(UStaticCameraControlDataParam, MaxRotate) == 0x00003C, "Member 'UStaticCameraControlDataParam::MaxRotate' has a wrong offset!");

// Class BattlePrototype.CalcMemoryManager
// 0x0080 (0x00A8 - 0x0028)
class UCalcMemoryManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ECalcMode                                     CurCalcMode;                                       // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ListIndex;                                         // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStartCalcMemory;                                  // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCalcPlayer;                                       // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCalcEnemy;                                        // 0x003A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCalcNPC;                                          // 0x003B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCalcObject;                                       // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCalcLevel;                                        // 0x003D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCancel;                                           // 0x003E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRequestLevel;                                     // 0x003F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAssetMemoryData*>               AssetInfos;                                        // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnyObjectCreator*                      CreateObject;                                      // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UAssetMemoryData*>               LevelInfos;                                        // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentIndex;                                      // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WaitTimer;                                         // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFinishedCurrentAsset;                             // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bExecLevel;                                        // 0x0079(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7A[0x2];                                       // 0x007A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentLevelIndex;                                 // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECalcProcess                                  MyProcess;                                         // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        PreUsedPhysical;                                   // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint64                                        PreUsedVirtual;                                    // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint64                                        PostUsedPhysical;                                  // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint64                                        PostUsedVirtual;                                   // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CalcMemory();
	void CancelLevel();
	ECalcTarget DecrementCalcTarget();
	ECalcMode GetCalcMode();
	class FName GetCurrentLevelName();
	ECalcTarget IncrementCalcTarget();
	void IncrementLevel();
	void PostMeasureLevel();
	void PreMeasureLevel();
	void PrintLevelInfo();
	void ReadyNextAsset();
	void RefleshSelectAsset();
	void ResetCalcMemory();
	void ResetStartCalcMemory();
	void SelectNextAsset(int32 AddValue);
	void SelectNextPageAsset();
	void SelectPrevAsset(int32 SubValue);
	void SelectPrevPageAsset();
	void SetCancel();
	void StartCalcLevel();
	void StartCalcMemory();
	void StartCurrentAsset();
	ECalcMode SwitchCalcMode(bool IsLevel);
	void SwitchCalcTargetEnemy();
	void SwitchCalcTargetLevel();
	void SwitchCalcTargetNPC();
	void SwitchCalcTargetObject();
	void SwitchCalcTargetPlayer();

	class FString GetIndividualStatusText() const;
	class FString GetLevelStatusText() const;
	class FString GetStatusText() const;
	bool IsCalcTargetEnemy() const;
	bool IsCalcTargetLevel() const;
	bool IsCalcTargetNPC() const;
	bool IsCalcTargetObject() const;
	bool IsCalcTargetPlayer() const;
	bool IsCancel() const;
	bool IsExec() const;
	bool IsExecLevel() const;
	bool IsFinished() const;
	bool IsFinishedCurrentAsset() const;
	bool IsReadyCurrentAsset() const;
	bool IsRequestLevel() const;
	bool IsStartCalcMemory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalcMemoryManager">();
	}
	static class UCalcMemoryManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCalcMemoryManager>();
	}
};
static_assert(alignof(UCalcMemoryManager) == 0x000008, "Wrong alignment on UCalcMemoryManager");
static_assert(sizeof(UCalcMemoryManager) == 0x0000A8, "Wrong size on UCalcMemoryManager");
static_assert(offsetof(UCalcMemoryManager, CurCalcMode) == 0x000030, "Member 'UCalcMemoryManager::CurCalcMode' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, ListIndex) == 0x000034, "Member 'UCalcMemoryManager::ListIndex' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bStartCalcMemory) == 0x000038, "Member 'UCalcMemoryManager::bStartCalcMemory' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bCalcPlayer) == 0x000039, "Member 'UCalcMemoryManager::bCalcPlayer' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bCalcEnemy) == 0x00003A, "Member 'UCalcMemoryManager::bCalcEnemy' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bCalcNPC) == 0x00003B, "Member 'UCalcMemoryManager::bCalcNPC' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bCalcObject) == 0x00003C, "Member 'UCalcMemoryManager::bCalcObject' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bCalcLevel) == 0x00003D, "Member 'UCalcMemoryManager::bCalcLevel' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bCancel) == 0x00003E, "Member 'UCalcMemoryManager::bCancel' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bRequestLevel) == 0x00003F, "Member 'UCalcMemoryManager::bRequestLevel' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, AssetInfos) == 0x000048, "Member 'UCalcMemoryManager::AssetInfos' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, CreateObject) == 0x000058, "Member 'UCalcMemoryManager::CreateObject' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, LevelInfos) == 0x000060, "Member 'UCalcMemoryManager::LevelInfos' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, CurrentIndex) == 0x000070, "Member 'UCalcMemoryManager::CurrentIndex' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, WaitTimer) == 0x000074, "Member 'UCalcMemoryManager::WaitTimer' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bFinishedCurrentAsset) == 0x000078, "Member 'UCalcMemoryManager::bFinishedCurrentAsset' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bExecLevel) == 0x000079, "Member 'UCalcMemoryManager::bExecLevel' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, CurrentLevelIndex) == 0x00007C, "Member 'UCalcMemoryManager::CurrentLevelIndex' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, MyProcess) == 0x000080, "Member 'UCalcMemoryManager::MyProcess' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, PreUsedPhysical) == 0x000088, "Member 'UCalcMemoryManager::PreUsedPhysical' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, PreUsedVirtual) == 0x000090, "Member 'UCalcMemoryManager::PreUsedVirtual' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, PostUsedPhysical) == 0x000098, "Member 'UCalcMemoryManager::PostUsedPhysical' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, PostUsedVirtual) == 0x0000A0, "Member 'UCalcMemoryManager::PostUsedVirtual' has a wrong offset!");

// Class BattlePrototype.UITargetBrain
// 0x0088 (0x0410 - 0x0388)
class UUITargetBrain : public UUIBase
{
public:
	uint8                                         Pad_388[0x88];                                     // 0x0388(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseThis();
	void Decide();
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimIn2, class UWidgetAnimation* AnimOut2, class UWidgetAnimation* AnimChange1_2, class UWidgetAnimation* AnimChange2_1, class UBorder* borderButtonSet);
	void SetEnable(bool IsEnable);
	bool UpdateButton();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool IsEnableDecide() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITargetBrain">();
	}
	static class UUITargetBrain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITargetBrain>();
	}
};
static_assert(alignof(UUITargetBrain) == 0x000008, "Wrong alignment on UUITargetBrain");
static_assert(sizeof(UUITargetBrain) == 0x000410, "Wrong size on UUITargetBrain");

// Class BattlePrototype.CameraInterface
// 0x0000 (0x0028 - 0x0028)
class ICameraInterface final : public IInterface
{
public:
	struct FVector GetCameraLookAtPos();
	struct FVector GetPlayerCameraDirection();
	float GetPlayerCameraFieldOfView();
	struct FVector GetPlayerCameraLocation();
	EPlayerCameraMode GetPlayerCameraMode();
	struct FRotator GetPlayerCameraRotation();
	struct FVector GetRemoteActorLocation();
	struct FRotator GetRemoteActorRotation();
	bool SetPlayerCameraDirection(const struct FVector& Pos);
	bool SetPlayerCameraFieldOfView(float FOV);
	bool SetPlayerCameraLocation(const struct FVector& Pos);
	bool SetPlayerCameraMode(EPlayerCameraMode Mode);
	bool SetPlayerCameraRotation(const struct FRotator& Rot);
	bool SetPlayerCameraViewTarget(float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraInterface">();
	}
	static class ICameraInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICameraInterface>();
	}
};
static_assert(alignof(ICameraInterface) == 0x000008, "Wrong alignment on ICameraInterface");
static_assert(sizeof(ICameraInterface) == 0x000028, "Wrong size on ICameraInterface");

// Class BattlePrototype.CameraPropertyMediatorComponent
// 0x0090 (0x0150 - 0x00C0)
class UCameraPropertyMediatorComponent final : public UActorComponent
{
public:
	float                                         PitchNoMove;                                       // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x8C];                                      // 0x00C4(0x008C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UCameraPropertyMediatorComponent* GetCameraPropertyMediatorComponentFromActor(class AActor* Actor);

	void ClearTargetArmLengthPitchByName(class FName Name_0);
	void ClearTargetArmLengthPitchByObject(const class UObject* Object);
	void SetControlledCameraByOwner();
	void SetTargetArmLengthPitchByName(class FName Name_0, float Length, float Pitch, float KeepSec, float InterpSec, EEasingFunc InterpType);
	void SetTargetArmLengthPitchByObject(const class UObject* Object, float Length, float Pitch, float KeepSec, float InterpSec, EEasingFunc InterpType);

	bool IsRestoreCamera() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraPropertyMediatorComponent">();
	}
	static class UCameraPropertyMediatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraPropertyMediatorComponent>();
	}
};
static_assert(alignof(UCameraPropertyMediatorComponent) == 0x000008, "Wrong alignment on UCameraPropertyMediatorComponent");
static_assert(sizeof(UCameraPropertyMediatorComponent) == 0x000150, "Wrong size on UCameraPropertyMediatorComponent");
static_assert(offsetof(UCameraPropertyMediatorComponent, PitchNoMove) == 0x0000C0, "Member 'UCameraPropertyMediatorComponent::PitchNoMove' has a wrong offset!");

// Class BattlePrototype.GimmickBase
// 0x0008 (0x0238 - 0x0230)
class AGimmickBase final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickBase">();
	}
	static class AGimmickBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickBase>();
	}
};
static_assert(alignof(AGimmickBase) == 0x000008, "Wrong alignment on AGimmickBase");
static_assert(sizeof(AGimmickBase) == 0x000238, "Wrong size on AGimmickBase");

// Class BattlePrototype.UICharaSelectParts
// 0x0020 (0x03A8 - 0x0388)
class UUICharaSelectParts final : public UUIBase
{
public:
	uint8                                         Pad_388[0x20];                                     // 0x0388(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeAnime(class UWidgetAnimation* Cursor_select, class UWidgetAnimation* Cursor_default_none, class UWidgetAnimation* Cursor_default);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICharaSelectParts">();
	}
	static class UUICharaSelectParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICharaSelectParts>();
	}
};
static_assert(alignof(UUICharaSelectParts) == 0x000008, "Wrong alignment on UUICharaSelectParts");
static_assert(sizeof(UUICharaSelectParts) == 0x0003A8, "Wrong size on UUICharaSelectParts");

// Class BattlePrototype.ChangeMinimapStateComponent
// 0x0010 (0x00D0 - 0x00C0)
class UChangeMinimapStateComponent final : public UActorComponent
{
public:
	bool                                          IsAccessed;                                        // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SquareDistance;                                    // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeightDifference;                                  // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeParam(bool IsAlreadyAccessed, float CheckDistance, float HeightDifference_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeMinimapStateComponent">();
	}
	static class UChangeMinimapStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangeMinimapStateComponent>();
	}
};
static_assert(alignof(UChangeMinimapStateComponent) == 0x000008, "Wrong alignment on UChangeMinimapStateComponent");
static_assert(sizeof(UChangeMinimapStateComponent) == 0x0000D0, "Wrong size on UChangeMinimapStateComponent");
static_assert(offsetof(UChangeMinimapStateComponent, IsAccessed) == 0x0000C0, "Member 'UChangeMinimapStateComponent::IsAccessed' has a wrong offset!");
static_assert(offsetof(UChangeMinimapStateComponent, SquareDistance) == 0x0000C4, "Member 'UChangeMinimapStateComponent::SquareDistance' has a wrong offset!");
static_assert(offsetof(UChangeMinimapStateComponent, HeightDifference) == 0x0000C8, "Member 'UChangeMinimapStateComponent::HeightDifference' has a wrong offset!");

// Class BattlePrototype.DebuggingWindowInterface
// 0x0000 (0x0028 - 0x0028)
class IDebuggingWindowInterface final : public IInterface
{
public:
	void OnChangePage(EDebuggingPage NewPage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingWindowInterface">();
	}
	static class IDebuggingWindowInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDebuggingWindowInterface>();
	}
};
static_assert(alignof(IDebuggingWindowInterface) == 0x000008, "Wrong alignment on IDebuggingWindowInterface");
static_assert(sizeof(IDebuggingWindowInterface) == 0x000028, "Wrong size on IDebuggingWindowInterface");

// Class BattlePrototype.ChangeMinimapStateInterface
// 0x0000 (0x0028 - 0x0028)
class IChangeMinimapStateInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeMinimapStateInterface">();
	}
	static class IChangeMinimapStateInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChangeMinimapStateInterface>();
	}
};
static_assert(alignof(IChangeMinimapStateInterface) == 0x000008, "Wrong alignment on IChangeMinimapStateInterface");
static_assert(sizeof(IChangeMinimapStateInterface) == 0x000028, "Wrong size on IChangeMinimapStateInterface");

// Class BattlePrototype.UICharaBooks
// 0x00D8 (0x0460 - 0x0388)
class UUICharaBooks : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x70];                                     // 0x03A0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               TextureCharacter[0x2];                             // 0x0410(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_420[0x40];                                     // 0x0420(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeFromBooks(class UUIBooksTop* Parent, class UImage* ImageChara);
	void InitializeFromMain(class UUIMainContents* UIMainContents, class UTextBlock* TextHelp, class UUIGuide* UiKeyGuide);
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimPresent, class UWidgetAnimation* AnimPresentIn, class UWidgetAnimation* AnimPresentOut, class UREDScrollBox* ScrollBox, class UUICharaInfoWindow* ChildInfoWin, class UUIEnemyListIndex* ChildListIndex, class UUICharaPresentWindow* PresentWindow);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUpdateElement(int32 Index_0, class UUserWidget* Widget);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICharaBooks">();
	}
	static class UUICharaBooks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICharaBooks>();
	}
};
static_assert(alignof(UUICharaBooks) == 0x000008, "Wrong alignment on UUICharaBooks");
static_assert(sizeof(UUICharaBooks) == 0x000460, "Wrong size on UUICharaBooks");
static_assert(offsetof(UUICharaBooks, ListElementSize) == 0x000388, "Member 'UUICharaBooks::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUICharaBooks, ListOffsetSize) == 0x000390, "Member 'UUICharaBooks::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUICharaBooks, ListIndexClass) == 0x000398, "Member 'UUICharaBooks::ListIndexClass' has a wrong offset!");
static_assert(offsetof(UUICharaBooks, TextureCharacter) == 0x000410, "Member 'UUICharaBooks::TextureCharacter' has a wrong offset!");

// Class BattlePrototype.ChangeWeakStateComponentBase
// 0x0128 (0x01E8 - 0x00C0)
class UChangeWeakStateComponentBase : public UActorComponent
{
public:
	float                                         MWeakFullInactiveTime;                             // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MElapsedWeakFullInactiveTime;                      // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MFullInactiveWeak;                                 // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MFullInactiveColorMapValueMin;                     // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFullInactiveColorMapValueMax;                     // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFullInactiveFrenelColorPowerMin;                  // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFullInactiveFrenelColorPowerMax;                  // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MForceEnableWeak;                                  // 0x00DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MForceEnableWeakTime;                              // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MElapsedForceEnableWeakTime;                       // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MStartWeakEmissive;                                // 0x00E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MWeakMaterialEmissiveCurve;                        // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEnemyWeakMaterialData>         MWeakMaterialList;                                 // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MWeakEmissiveTime;                                 // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEnemyWeakMaterialData>         MDisableWeakMaterialList;                          // 0x0110(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDisableWeakEmissiveTime;                          // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MWeakExtendTime;                                   // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbWeakExtendTime;                                  // 0x0128(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MCurrentWeakExtendTime;                            // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 MDisableWeakNumList;                               // 0x0130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MEnableWeakExtendTime;                             // 0x0140(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MMaxExtendTime;                                    // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAddFirstExtendTime;                               // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAddPconExtendTime;                                // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MChangeWeakState;                                  // 0x0150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEnemyEnableWeakData>           MEnableWeakDataList;                               // 0x0158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  MBeforeWeakStateList;                              // 0x0168(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 MCurrentTimeList;                                  // 0x0178(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  MEnableWeakList;                                   // 0x0188(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  MChangeWeakMaterial;                               // 0x0198(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  MFullInactivateList;                               // 0x01A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  MChangeFullInactiveList;                           // 0x01B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MWeakMaterialRateCurveData;                        // 0x01C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D0[0x18];                                     // 0x01D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddWeakExtendTime_Native();
	void ClearChangeWeakMaterial_Native();
	void EnableAllWeak_Native(bool bEnable);
	void EnableWeak_Native(bool bEnable, int32 WeakListNum);
	void EndForceEnableWeak_Native();
	void EndFullInactiveWeak_Native();
	void EndWeakExtendTime_Native();
	void ForceDisableAllWeak_Native();
	TArray<bool> GetFullInactiveList_Native();
	void Initialize_Native(bool IsChangeWeakState);
	bool IsAllWeakFullInactive_Native();
	bool IsEnableWeakExtendTime_Native();
	bool IsForceEnableWeak_Native();
	bool IsWeakExtendTime_Native();
	bool IsWeakFullInactive_Native(int32 WeakListNum);
	void RestoreWeakState_Native();
	void SetAllWeakFullInactive_Native(bool bFullInactive);
	void SetChangeWeakMaterial_Native(bool bChange, int32 WeakListNum);
	void SetEnableWeakExtendTime_Native(bool EnableExtend);
	void SetFullInactiveWeak_Native(bool FullInactive, int32 WeakListNum);
	void StartForceEnableWeak_Native();
	void StartFullInactiveWeak_Native();
	void StoreWeakState_Native();
	void Update_Native(float DeltaSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeWeakStateComponentBase">();
	}
	static class UChangeWeakStateComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangeWeakStateComponentBase>();
	}
};
static_assert(alignof(UChangeWeakStateComponentBase) == 0x000008, "Wrong alignment on UChangeWeakStateComponentBase");
static_assert(sizeof(UChangeWeakStateComponentBase) == 0x0001E8, "Wrong size on UChangeWeakStateComponentBase");
static_assert(offsetof(UChangeWeakStateComponentBase, MWeakFullInactiveTime) == 0x0000C0, "Member 'UChangeWeakStateComponentBase::MWeakFullInactiveTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MElapsedWeakFullInactiveTime) == 0x0000C4, "Member 'UChangeWeakStateComponentBase::MElapsedWeakFullInactiveTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MFullInactiveWeak) == 0x0000C8, "Member 'UChangeWeakStateComponentBase::MFullInactiveWeak' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MFullInactiveColorMapValueMin) == 0x0000CC, "Member 'UChangeWeakStateComponentBase::MFullInactiveColorMapValueMin' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MFullInactiveColorMapValueMax) == 0x0000D0, "Member 'UChangeWeakStateComponentBase::MFullInactiveColorMapValueMax' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MFullInactiveFrenelColorPowerMin) == 0x0000D4, "Member 'UChangeWeakStateComponentBase::MFullInactiveFrenelColorPowerMin' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MFullInactiveFrenelColorPowerMax) == 0x0000D8, "Member 'UChangeWeakStateComponentBase::MFullInactiveFrenelColorPowerMax' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MForceEnableWeak) == 0x0000DC, "Member 'UChangeWeakStateComponentBase::MForceEnableWeak' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MForceEnableWeakTime) == 0x0000E0, "Member 'UChangeWeakStateComponentBase::MForceEnableWeakTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MElapsedForceEnableWeakTime) == 0x0000E4, "Member 'UChangeWeakStateComponentBase::MElapsedForceEnableWeakTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MStartWeakEmissive) == 0x0000E8, "Member 'UChangeWeakStateComponentBase::MStartWeakEmissive' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MWeakMaterialEmissiveCurve) == 0x0000F0, "Member 'UChangeWeakStateComponentBase::MWeakMaterialEmissiveCurve' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MWeakMaterialList) == 0x0000F8, "Member 'UChangeWeakStateComponentBase::MWeakMaterialList' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MWeakEmissiveTime) == 0x000108, "Member 'UChangeWeakStateComponentBase::MWeakEmissiveTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MDisableWeakMaterialList) == 0x000110, "Member 'UChangeWeakStateComponentBase::MDisableWeakMaterialList' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MDisableWeakEmissiveTime) == 0x000120, "Member 'UChangeWeakStateComponentBase::MDisableWeakEmissiveTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MWeakExtendTime) == 0x000124, "Member 'UChangeWeakStateComponentBase::MWeakExtendTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MbWeakExtendTime) == 0x000128, "Member 'UChangeWeakStateComponentBase::MbWeakExtendTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MCurrentWeakExtendTime) == 0x00012C, "Member 'UChangeWeakStateComponentBase::MCurrentWeakExtendTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MDisableWeakNumList) == 0x000130, "Member 'UChangeWeakStateComponentBase::MDisableWeakNumList' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MEnableWeakExtendTime) == 0x000140, "Member 'UChangeWeakStateComponentBase::MEnableWeakExtendTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MMaxExtendTime) == 0x000144, "Member 'UChangeWeakStateComponentBase::MMaxExtendTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MAddFirstExtendTime) == 0x000148, "Member 'UChangeWeakStateComponentBase::MAddFirstExtendTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MAddPconExtendTime) == 0x00014C, "Member 'UChangeWeakStateComponentBase::MAddPconExtendTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MChangeWeakState) == 0x000150, "Member 'UChangeWeakStateComponentBase::MChangeWeakState' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MEnableWeakDataList) == 0x000158, "Member 'UChangeWeakStateComponentBase::MEnableWeakDataList' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MBeforeWeakStateList) == 0x000168, "Member 'UChangeWeakStateComponentBase::MBeforeWeakStateList' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MCurrentTimeList) == 0x000178, "Member 'UChangeWeakStateComponentBase::MCurrentTimeList' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MEnableWeakList) == 0x000188, "Member 'UChangeWeakStateComponentBase::MEnableWeakList' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MChangeWeakMaterial) == 0x000198, "Member 'UChangeWeakStateComponentBase::MChangeWeakMaterial' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MFullInactivateList) == 0x0001A8, "Member 'UChangeWeakStateComponentBase::MFullInactivateList' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MChangeFullInactiveList) == 0x0001B8, "Member 'UChangeWeakStateComponentBase::MChangeFullInactiveList' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MWeakMaterialRateCurveData) == 0x0001C8, "Member 'UChangeWeakStateComponentBase::MWeakMaterialRateCurveData' has a wrong offset!");

// Class BattlePrototype.CharacterDatatableAccessorComponent
// 0x0010 (0x00D0 - 0x00C0)
class UCharacterDatatableAccessorComponent : public UActorComponent
{
public:
	struct FAttackCalcInfo                        _attackCalcInfo;                                   // 0x00C0(0x0010)(Edit, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UCharacterDatatableAccessorComponent* GetCharacterDatatableAccessorComponent(class AActor* Actor);
	static void InheritAttackCalcInfo(class AActor* Parent, class AActor* Child);

	void SetAttackCalcInfo(const struct FAttackCalcInfo& AttackCalcInfo);

	struct FAttackCalcInfo GetAttackCalcInfo() const;
	struct FDamageCalcInfo GetDamageCalcInfo() const;
	struct FCharactersParameterBasic GetParamBasic() const;
	struct FCharactersParameterTable GetParamTable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterDatatableAccessorComponent">();
	}
	static class UCharacterDatatableAccessorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterDatatableAccessorComponent>();
	}
};
static_assert(alignof(UCharacterDatatableAccessorComponent) == 0x000008, "Wrong alignment on UCharacterDatatableAccessorComponent");
static_assert(sizeof(UCharacterDatatableAccessorComponent) == 0x0000D0, "Wrong size on UCharacterDatatableAccessorComponent");
static_assert(offsetof(UCharacterDatatableAccessorComponent, _attackCalcInfo) == 0x0000C0, "Member 'UCharacterDatatableAccessorComponent::_attackCalcInfo' has a wrong offset!");

// Class BattlePrototype.UIShopTransfer
// 0x0030 (0x03B8 - 0x0388)
class UUIShopTransfer : public UUIBase
{
public:
	uint8                                         Pad_388[0x30];                                     // 0x0388(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimBuy, class UWidgetAnimation* AnimSell, class UWidgetAnimation* AnimTrade, class UTextBlock* TextTransfer1, class UTextBlock* TextTransfer2);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopTransfer">();
	}
	static class UUIShopTransfer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopTransfer>();
	}
};
static_assert(alignof(UUIShopTransfer) == 0x000008, "Wrong alignment on UUIShopTransfer");
static_assert(sizeof(UUIShopTransfer) == 0x0003B8, "Wrong size on UUIShopTransfer");

// Class BattlePrototype.CharacterDitherDataAsset
// 0x0008 (0x0038 - 0x0030)
class UCharacterDitherDataAsset final : public UDataAsset
{
public:
	float                                         DitherSpeed;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterDitherDataAsset">();
	}
	static class UCharacterDitherDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterDitherDataAsset>();
	}
};
static_assert(alignof(UCharacterDitherDataAsset) == 0x000008, "Wrong alignment on UCharacterDitherDataAsset");
static_assert(sizeof(UCharacterDitherDataAsset) == 0x000038, "Wrong size on UCharacterDitherDataAsset");
static_assert(offsetof(UCharacterDitherDataAsset, DitherSpeed) == 0x000030, "Member 'UCharacterDitherDataAsset::DitherSpeed' has a wrong offset!");

// Class BattlePrototype.ExporterArg
// 0x0000 (0x0028 - 0x0028)
class UExporterArg final : public UObject
{
public:
	static bool IsStartAutoExporter();
	static void SetStartAutoExporter(bool IsStartAuto);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExporterArg">();
	}
	static class UExporterArg* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExporterArg>();
	}
};
static_assert(alignof(UExporterArg) == 0x000008, "Wrong alignment on UExporterArg");
static_assert(sizeof(UExporterArg) == 0x000028, "Wrong size on UExporterArg");

// Class BattlePrototype.CharacterHitCheckComponent
// 0x0018 (0x00D8 - 0x00C0)
class UCharacterHitCheckComponent final : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x18];                                      // 0x00C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterHitCheck(class UCapsuleComponent* Capsule0, class UCapsuleComponent* Capsule1);
	void SetEnable(bool bEnable);
	void UnregisterHitCheck(class UCapsuleComponent* Capsule0, class UCapsuleComponent* Capsule1);

	int32 GetRegisteredCount() const;
	class ARSCharacterBase* GetRegisteredHitCharacter(int32 Index_0) const;
	bool IsRegisteredAny() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterHitCheckComponent">();
	}
	static class UCharacterHitCheckComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterHitCheckComponent>();
	}
};
static_assert(alignof(UCharacterHitCheckComponent) == 0x000008, "Wrong alignment on UCharacterHitCheckComponent");
static_assert(sizeof(UCharacterHitCheckComponent) == 0x0000D8, "Wrong size on UCharacterHitCheckComponent");

// Class BattlePrototype.UITitleFirstConfigVoiceLanguage
// 0x00F8 (0x0480 - 0x0388)
class UUITitleFirstConfigVoiceLanguage final : public UUIBase
{
public:
	uint8                                         Pad_388[0xF8];                                     // 0x0388(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeIndex(class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UREDTextBlock* TextIndex);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextDescription, class UTextBlock* TextVoiceLanguage, class USpacer* GuideSpacer);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool IsBack() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleFirstConfigVoiceLanguage">();
	}
	static class UUITitleFirstConfigVoiceLanguage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleFirstConfigVoiceLanguage>();
	}
};
static_assert(alignof(UUITitleFirstConfigVoiceLanguage) == 0x000008, "Wrong alignment on UUITitleFirstConfigVoiceLanguage");
static_assert(sizeof(UUITitleFirstConfigVoiceLanguage) == 0x000480, "Wrong size on UUITitleFirstConfigVoiceLanguage");

// Class BattlePrototype.CharacterMaterialLightFunction
// 0x0000 (0x0028 - 0x0028)
class UCharacterMaterialLightFunction final : public UBlueprintFunctionLibrary
{
public:
	static void SetupCharacterMaterialLight(class UMeshComponent* MeshComponent, const struct FCharacterMaterialLightSetting& LightSetting, const TMap<class FName, struct FArrayOfFloat>& DefaultScalars, const TMap<class FName, struct FArrayOfLinearColor>& DefaultVectors, float Rate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterMaterialLightFunction">();
	}
	static class UCharacterMaterialLightFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterMaterialLightFunction>();
	}
};
static_assert(alignof(UCharacterMaterialLightFunction) == 0x000008, "Wrong alignment on UCharacterMaterialLightFunction");
static_assert(sizeof(UCharacterMaterialLightFunction) == 0x000028, "Wrong size on UCharacterMaterialLightFunction");

// Class BattlePrototype.CharactersParameterComponent
// 0x05A0 (0x0660 - 0x00C0)
class UCharactersParameterComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             HpEvent;                                           // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             BadStateOnEvent;                                   // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             BadStateOffEvent;                                  // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             BrainCrashAccessOnEvent;                           // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             BrainCrashAccessOffEvent;                          // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          MIsUseTick;                                        // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharactersParameterTable              MParamTable;                                       // 0x0118(0x01F8)(Edit, EditConst, NativeAccessSpecifierPrivate)
	struct FCharactersParameterBasic              MParamBasic;                                       // 0x0310(0x0068)(Edit, EditConst, NativeAccessSpecifierPrivate)
	struct FCharactersParameterTable              MParamInitTable;                                   // 0x0378(0x01F8)(Edit, EditConst, NativeAccessSpecifierPrivate)
	bool                                          MIsBrainCrashLock;                                 // 0x0570(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MIsNotUseBrainCrashTimer;                          // 0x0571(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_572[0x2];                                      // 0x0572(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MBrainCrashTimer;                                  // 0x0574(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MIsPauseBrainCrashTimer;                           // 0x0578(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_579[0x7];                                      // 0x0579(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnFinishActor;                                     // 0x0580(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnDead;                                            // 0x0590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	bool                                          MIsElectricTimer;                                  // 0x05A0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A1[0x2F];                                     // 0x05A1(0x002F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MBrainCrashTime;                                   // 0x05D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MBrainCrashMissAccumulationScale;                  // 0x05D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MFrameBaseTime;                                    // 0x05D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MElectricBaseTime;                                 // 0x05DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MElectricAddTime;                                  // 0x05E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MFloodedBaseTime;                                  // 0x05E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MOilBaseTime;                                      // 0x05E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MConfusionBaseTime;                                // 0x05EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MAddFrameBaseTime;                                 // 0x05F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MAddElectricBaseTime;                              // 0x05F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MOilDownScale;                                     // 0x05F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MFloodedMoveScale;                                 // 0x05FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MFlameScaleByOil;                                  // 0x0600(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MElectricScaleByFlooded;                           // 0x0604(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MEndlessFlame;                                     // 0x0608(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MEndlessFlooded;                                   // 0x0609(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MEndlessOil;                                       // 0x060A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MIsBeforeEndlessFlooded;                           // 0x060B(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MIsBeforeEndlessOil;                               // 0x060C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MIsUpdateCrashOldFrame;                            // 0x060D(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60E[0x2];                                      // 0x060E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MUpdateCrashOldFrameCnt;                           // 0x0610(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlameUpdateTimeRate;                               // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElectricUpdateTimeRate;                            // 0x0618(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloodedUpdateTimeRate;                             // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OilUpdateTimeRate;                                 // 0x0620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionUpdateTimeRate;                           // 0x0624(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_628[0x30];                                     // 0x0628(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MIgnoreDamageFlag;                                 // 0x0658(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_65C[0x4];                                      // 0x065C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UCharactersParameterComponent* GetCharactersParameterComponentFromActor(class AActor* Actor);

	void AddBrainCrashExtraTime(float ExtraTime);
	void AddHp(int32 HP);
	void AddHpArray(const TArray<int32>& HP);
	void AddParameterBasic(const struct FCharactersParameterBasic& Param, class AActor* Attacker, bool IsEnemy);
	void DisableCharacterIgnoreDamage(ECharacterIgnoreDamage SetFlag);
	void DisableCharacterIgnoreDamageAll();
	void DisableCharacterIgnoreDamageFromType(ECharacterIgnoreDamageType IgnoreType);
	void EnableCharacterIgnoreDamage(ECharacterIgnoreDamage SetFlag);
	void EnableCharacterIgnoreDamageAll();
	void EnableCharacterIgnoreDamageFromType(ECharacterIgnoreDamageType IgnoreType);
	void EndLimitCrashAccumulation();
	float GetBrainCrashMissAccumulationScale();
	float GetCrashResistance(int32 Part);
	float GetCrashResistanceMax();
	float GetElectricScaleByFlooded();
	float GetFloodedMoveScale();
	float GetWeakPointRate(int32 Part);
	float GetWeakPointRateOldFrame(int32 Part);
	bool IsBrainCrashAccess();
	bool IsBrainCrashLock();
	bool IsDead();
	bool IsDelayDeath();
	bool IsLimitCrashAccumulation();
	void ModifyParameterTable_Attack(int32 NewValue);
	void OutBreakConfusion(class AActor* Attacker, float Time);
	void OutBreakElectric(class AActor* Attacker, float Time);
	void OutBreakFlame(class AActor* Attacker, float Time, bool bEndless);
	void OutBreakFlooded(class AActor* Attacker, float Time, bool bEndless);
	void OutBreakOil(class AActor* Attacker, float Time, bool bEndless);
	void ParameterBasicCopy(const struct FCharactersParameterBasic& Param);
	void ReleaseAllBadStatus(bool bRsetAccumulation);
	void ReleaseConfusion(bool bRsetAccumulation);
	void ReleaseElectric(bool bRsetAccumulation);
	void ReleaseFlame(bool bRsetAccumulation);
	void ReleaseFlooded(bool bRsetAccumulation);
	void ReleaseOil(bool bRsetAccumulation);
	void ResetAttenuation(bool bResetCrash);
	void ResetBadStatusAttenuation();
	void ResetCrash();
	void ResetDelayDeath();
	void ResetHpDownLimit();
	void ResetPauseUpdate();
	void SetAddElectricBaseTime(float Num);
	void SetAddFrameBaseTime(float Num);
	void SetArmorHp(int32 HP);
	void SetAttenuation(const struct FCharactersParameterBasic& Param);
	void SetBadStatusAttenuation(const struct FCharactersParameterBasic& Param);
	void SetBrainCrashEnableTime(float Num);
	void SetBrainCrashLock(bool Lock);
	void SetBrainCrashMiss();
	void SetBrainCrashMissAccumulationScale(float Num);
	void SetBrainCrashTimeSeconds(float Seconds);
	void SetCharacterIgnoreDamageFlag(int32 Flags_0);
	void SetConfusionAttenuationCoefficient(float Coefficient);
	void SetConfusionBaseTime(float Num);
	void SetConfusionTimeCoefficient(float Coefficient);
	void SetCrashMax();
	void SetElectricAddTime(float Num);
	void SetElectricAttenuationCoefficient(float Coefficient);
	void SetElectricBaseTime(float Num);
	void SetElectricTimeCoefficient(float Coefficient);
	void SetElectricTimerOn(bool On);
	void SetEnableBadStatusTimeRate(bool bEnable);
	void SetEndlessFlame(bool bEndless);
	void SetEndlessFlooded(bool bEndless);
	void SetEndlessOil(bool bEndless);
	void SetFlameAttenuationCoefficient(float Coefficient);
	void SetFlameTimeCoefficient(float Coefficient);
	void SetFloodedAttenuationCoefficient(float Coefficient);
	void SetFloodedBaseTime(float Num);
	void SetFloodedMoveScale(float Num);
	void SetFloodedTimeCoefficient(float Coefficient);
	void SetFrameBaseTime(float Num);
	void SetHp(const TArray<int32>& HP);
	void SetHpDownLimit(EHpDownLimitType LimitType, float LimitValue);
	void SetHpPart(int32 No, int32 HP);
	void SetHpWithoutEvent(int32 HP);
	void SetLevelTable(float HP, float Attack, float brain, float Defense, float Exp);
	void SetNoReleaseBadState(bool bNoRelease);
	void SetNotUseBrainCrashTimer(bool bNotUse);
	void SetOilAttenuationCoefficient(float Coefficient);
	void SetOilBaseTime(float Num);
	void SetOilDownScale(float Num);
	void SetOilTimeCoefficient(float Coefficient);
	void SetParameterAll(const struct FCharactersParameterTable& Param);
	void SetParameterBasic(const struct FCharactersParameterTable& Param);
	void SetParameterInitTable(const struct FCharactersParameterTable& Param);
	void SetParameterTable(const struct FCharactersParameterTable& Param);
	void SetPauseBrainCrashTimer(bool bPause);
	void SetPauseUpdate();
	void StartDamageReactionAccumulationStopTimer();
	void StartLimitCrashAccumulation();
	int32 SufferDamage(int32 Damage, bool IsEnemy, bool IsNoDead, bool IsDelayDeath, bool IsGuts, class AActor* Attacker);
	void SufferPartDamage(int32 Part, int32 Damage);

	int32 GetAllHp() const;
	float GetAllHPPercent() const;
	int32 GetArmorHp() const;
	float GetArmorHPPercent() const;
	float GetBrainCrashTimer() const;
	float GetCaptureArea() const;
	int32 GetCharacterIgnoreDamageFlag() const;
	int32 GetCharacterIgnoreDamageFlagFromType(ECharacterIgnoreDamageType IgnoreType) const;
	int32 GetHp() const;
	TArray<int32> GetHpArray() const;
	int32 GetHpDownLimit() const;
	int32 GetHpPart(int32 No) const;
	float GetHPPercent() const;
	int32 GetMaxArmorHp() const;
	int32 GetMaxHp() const;
	int32 GetMaxHpPart(int32 No) const;
	float GetMoveArea() const;
	struct FCharactersParameterBasic GetParameterBasic() const;
	struct FCharactersParameterTable GetParameterInitTable() const;
	struct FCharactersParameterTable GetParameterTable() const;
	float GetSearchAngle() const;
	float GetSearchRange() const;
	float GetSensingArea() const;
	bool IsAnyBadStatus() const;
	bool IsCharacterIgnoreDamage(ECharacterIgnoreDamage CheckFlag) const;
	bool IsConfusion() const;
	bool IsElectric() const;
	bool IsElectricTimer() const;
	bool IsEndlessFlame() const;
	bool IsEndlessFlooded() const;
	bool IsEndlessOil() const;
	bool IsFlame() const;
	bool IsFlooded() const;
	bool IsHpDownLimit() const;
	bool IsOil() const;
	bool IsPauseUpdate() const;
	bool IsReinfoceFlame() const;
	bool NeedsStatusAssist() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharactersParameterComponent">();
	}
	static class UCharactersParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharactersParameterComponent>();
	}
};
static_assert(alignof(UCharactersParameterComponent) == 0x000008, "Wrong alignment on UCharactersParameterComponent");
static_assert(sizeof(UCharactersParameterComponent) == 0x000660, "Wrong size on UCharactersParameterComponent");
static_assert(offsetof(UCharactersParameterComponent, HpEvent) == 0x0000C0, "Member 'UCharactersParameterComponent::HpEvent' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, BadStateOnEvent) == 0x0000D0, "Member 'UCharactersParameterComponent::BadStateOnEvent' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, BadStateOffEvent) == 0x0000E0, "Member 'UCharactersParameterComponent::BadStateOffEvent' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, BrainCrashAccessOnEvent) == 0x0000F0, "Member 'UCharactersParameterComponent::BrainCrashAccessOnEvent' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, BrainCrashAccessOffEvent) == 0x000100, "Member 'UCharactersParameterComponent::BrainCrashAccessOffEvent' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MIsUseTick) == 0x000110, "Member 'UCharactersParameterComponent::MIsUseTick' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MParamTable) == 0x000118, "Member 'UCharactersParameterComponent::MParamTable' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MParamBasic) == 0x000310, "Member 'UCharactersParameterComponent::MParamBasic' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MParamInitTable) == 0x000378, "Member 'UCharactersParameterComponent::MParamInitTable' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MIsBrainCrashLock) == 0x000570, "Member 'UCharactersParameterComponent::MIsBrainCrashLock' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MIsNotUseBrainCrashTimer) == 0x000571, "Member 'UCharactersParameterComponent::MIsNotUseBrainCrashTimer' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MBrainCrashTimer) == 0x000574, "Member 'UCharactersParameterComponent::MBrainCrashTimer' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MIsPauseBrainCrashTimer) == 0x000578, "Member 'UCharactersParameterComponent::MIsPauseBrainCrashTimer' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, OnFinishActor) == 0x000580, "Member 'UCharactersParameterComponent::OnFinishActor' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, OnDead) == 0x000590, "Member 'UCharactersParameterComponent::OnDead' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MIsElectricTimer) == 0x0005A0, "Member 'UCharactersParameterComponent::MIsElectricTimer' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MBrainCrashTime) == 0x0005D0, "Member 'UCharactersParameterComponent::MBrainCrashTime' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MBrainCrashMissAccumulationScale) == 0x0005D4, "Member 'UCharactersParameterComponent::MBrainCrashMissAccumulationScale' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MFrameBaseTime) == 0x0005D8, "Member 'UCharactersParameterComponent::MFrameBaseTime' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MElectricBaseTime) == 0x0005DC, "Member 'UCharactersParameterComponent::MElectricBaseTime' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MElectricAddTime) == 0x0005E0, "Member 'UCharactersParameterComponent::MElectricAddTime' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MFloodedBaseTime) == 0x0005E4, "Member 'UCharactersParameterComponent::MFloodedBaseTime' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MOilBaseTime) == 0x0005E8, "Member 'UCharactersParameterComponent::MOilBaseTime' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MConfusionBaseTime) == 0x0005EC, "Member 'UCharactersParameterComponent::MConfusionBaseTime' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MAddFrameBaseTime) == 0x0005F0, "Member 'UCharactersParameterComponent::MAddFrameBaseTime' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MAddElectricBaseTime) == 0x0005F4, "Member 'UCharactersParameterComponent::MAddElectricBaseTime' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MOilDownScale) == 0x0005F8, "Member 'UCharactersParameterComponent::MOilDownScale' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MFloodedMoveScale) == 0x0005FC, "Member 'UCharactersParameterComponent::MFloodedMoveScale' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MFlameScaleByOil) == 0x000600, "Member 'UCharactersParameterComponent::MFlameScaleByOil' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MElectricScaleByFlooded) == 0x000604, "Member 'UCharactersParameterComponent::MElectricScaleByFlooded' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MEndlessFlame) == 0x000608, "Member 'UCharactersParameterComponent::MEndlessFlame' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MEndlessFlooded) == 0x000609, "Member 'UCharactersParameterComponent::MEndlessFlooded' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MEndlessOil) == 0x00060A, "Member 'UCharactersParameterComponent::MEndlessOil' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MIsBeforeEndlessFlooded) == 0x00060B, "Member 'UCharactersParameterComponent::MIsBeforeEndlessFlooded' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MIsBeforeEndlessOil) == 0x00060C, "Member 'UCharactersParameterComponent::MIsBeforeEndlessOil' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MIsUpdateCrashOldFrame) == 0x00060D, "Member 'UCharactersParameterComponent::MIsUpdateCrashOldFrame' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MUpdateCrashOldFrameCnt) == 0x000610, "Member 'UCharactersParameterComponent::MUpdateCrashOldFrameCnt' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, FlameUpdateTimeRate) == 0x000614, "Member 'UCharactersParameterComponent::FlameUpdateTimeRate' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, ElectricUpdateTimeRate) == 0x000618, "Member 'UCharactersParameterComponent::ElectricUpdateTimeRate' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, FloodedUpdateTimeRate) == 0x00061C, "Member 'UCharactersParameterComponent::FloodedUpdateTimeRate' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, OilUpdateTimeRate) == 0x000620, "Member 'UCharactersParameterComponent::OilUpdateTimeRate' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, ConfusionUpdateTimeRate) == 0x000624, "Member 'UCharactersParameterComponent::ConfusionUpdateTimeRate' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MIgnoreDamageFlag) == 0x000658, "Member 'UCharactersParameterComponent::MIgnoreDamageFlag' has a wrong offset!");

// Class BattlePrototype.HelpTutorialData
// 0x0018 (0x0040 - 0x0028)
class UHelpTutorialData final : public UObject
{
public:
	class UHelpTutorialDBAsset*                   HelptutorialDataAsset_;                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FHelpListSortParam>             HelpSortList_;                                     // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GetHelpDataAsset(TMap<EHelpTutorial, struct FHelpDBDataCell>* ReturnHelpMap);
	bool GetHelpDataCellFromAsset(EHelpTutorial HelpID, struct FHelpDBDataCell* ReturnCell);
	bool GetHelpDataIndexFromAsset(EHelpTutorial HelpID, int32* DataIndex);
	class UHelpTutorialDBAsset* GetHelpTutorialDataAsset();
	void GetMiniHelpDataAsset(TMap<EHelpTutorial, struct FMiniHelpRowDataCell>* ReturnMiniHelpMap);
	bool GetMiniHelpDataCellFromAsset(EHelpTutorial HelpID, struct FMiniHelpRowDataCell* ReturnCell);
	bool GetMiniHelpDataIndexFromAsset(EHelpTutorial HelpID, int32* DataIndex);
	void GetTutorialDataAsset(TMap<class FName, struct FTutorialDBDataCell>* ReturnTutorialMap);
	bool GetTutorialDataCellFromAsset(class FName TutorialID, struct FTutorialDBDataCell* ReturnCell);
	bool GetTutorialDataIndexFromAsset(class FName TutorialID, int32* DataIndex);
	bool LoadDataAsset(const class FString& DtPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelpTutorialData">();
	}
	static class UHelpTutorialData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelpTutorialData>();
	}
};
static_assert(alignof(UHelpTutorialData) == 0x000008, "Wrong alignment on UHelpTutorialData");
static_assert(sizeof(UHelpTutorialData) == 0x000040, "Wrong size on UHelpTutorialData");
static_assert(offsetof(UHelpTutorialData, HelptutorialDataAsset_) == 0x000028, "Member 'UHelpTutorialData::HelptutorialDataAsset_' has a wrong offset!");
static_assert(offsetof(UHelpTutorialData, HelpSortList_) == 0x000030, "Member 'UHelpTutorialData::HelpSortList_' has a wrong offset!");

// Class BattlePrototype.UIConfigControllerSelectMulti
// 0x00A8 (0x0430 - 0x0388)
class UUIConfigControllerSelectMulti : public UUIBase
{
public:
	uint8                                         Pad_388[0xA8];                                     // 0x0388(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextTitle);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigControllerSelectMulti">();
	}
	static class UUIConfigControllerSelectMulti* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigControllerSelectMulti>();
	}
};
static_assert(alignof(UUIConfigControllerSelectMulti) == 0x000008, "Wrong alignment on UUIConfigControllerSelectMulti");
static_assert(sizeof(UUIConfigControllerSelectMulti) == 0x000430, "Wrong size on UUIConfigControllerSelectMulti");

// Class BattlePrototype.CharactersParameterManager
// 0x0010 (0x0038 - 0x0028)
class UCharactersParameterManager final : public UObject
{
public:
	TArray<struct FCharacterInfo>                 M_characterInfoList;                               // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateCharacterInfo(const class AActor* Actor, const struct FCharactersParameterBasic& CharaParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharactersParameterManager">();
	}
	static class UCharactersParameterManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharactersParameterManager>();
	}
};
static_assert(alignof(UCharactersParameterManager) == 0x000008, "Wrong alignment on UCharactersParameterManager");
static_assert(sizeof(UCharactersParameterManager) == 0x000038, "Wrong size on UCharactersParameterManager");
static_assert(offsetof(UCharactersParameterManager, M_characterInfoList) == 0x000028, "Member 'UCharactersParameterManager::M_characterInfoList' has a wrong offset!");

// Class BattlePrototype.ConditionComponent
// 0x00A0 (0x0160 - 0x00C0)
class alignas(0x10) UConditionComponent : public UActorComponent
{
public:
	float                                         _accumulationLimit;                                // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _accumulationAddedScale;                           // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _cureAccumulation;                                 // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _conditionAutoEndSec;                              // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _intervalSec;                                      // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             _dispatchInterval;                                 // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             _dispatchBeginCondition;                           // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             _dispatchEndCondition;                             // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x58];                                     // 0x0108(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Accumulate(float Value, bool IsGuard);
	void ClearAccumulation();
	void FinishCondition();
	void OnBeginCondition();
	void OnEndCondition();
	void OnInterval();
	void SetFreeze(bool Flag);

	EConditionExclusionKind CheckExclusion(const class UConditionComponent* Other) const;
	EConditionKind GetConditionKind() const;
	bool IsActiveCondition() const;
	bool IsStateCondition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionComponent">();
	}
	static class UConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionComponent>();
	}
};
static_assert(alignof(UConditionComponent) == 0x000010, "Wrong alignment on UConditionComponent");
static_assert(sizeof(UConditionComponent) == 0x000160, "Wrong size on UConditionComponent");
static_assert(offsetof(UConditionComponent, _accumulationLimit) == 0x0000C0, "Member 'UConditionComponent::_accumulationLimit' has a wrong offset!");
static_assert(offsetof(UConditionComponent, _accumulationAddedScale) == 0x0000C4, "Member 'UConditionComponent::_accumulationAddedScale' has a wrong offset!");
static_assert(offsetof(UConditionComponent, _cureAccumulation) == 0x0000C8, "Member 'UConditionComponent::_cureAccumulation' has a wrong offset!");
static_assert(offsetof(UConditionComponent, _conditionAutoEndSec) == 0x0000CC, "Member 'UConditionComponent::_conditionAutoEndSec' has a wrong offset!");
static_assert(offsetof(UConditionComponent, _intervalSec) == 0x0000D0, "Member 'UConditionComponent::_intervalSec' has a wrong offset!");
static_assert(offsetof(UConditionComponent, _dispatchInterval) == 0x0000D8, "Member 'UConditionComponent::_dispatchInterval' has a wrong offset!");
static_assert(offsetof(UConditionComponent, _dispatchBeginCondition) == 0x0000E8, "Member 'UConditionComponent::_dispatchBeginCondition' has a wrong offset!");
static_assert(offsetof(UConditionComponent, _dispatchEndCondition) == 0x0000F8, "Member 'UConditionComponent::_dispatchEndCondition' has a wrong offset!");

// Class BattlePrototype.FlamesConditionComponent
// 0x0020 (0x0180 - 0x0160)
class UFlamesConditionComponent final : public UConditionComponent
{
public:
	float                                         _intervalDamagePercent;                            // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        _pFlameEffect;                                     // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _pAttackedComp;                                    // 0x0170(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               _pEffectComp;                                      // 0x0178(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlamesConditionComponent">();
	}
	static class UFlamesConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlamesConditionComponent>();
	}
};
static_assert(alignof(UFlamesConditionComponent) == 0x000010, "Wrong alignment on UFlamesConditionComponent");
static_assert(sizeof(UFlamesConditionComponent) == 0x000180, "Wrong size on UFlamesConditionComponent");
static_assert(offsetof(UFlamesConditionComponent, _intervalDamagePercent) == 0x000160, "Member 'UFlamesConditionComponent::_intervalDamagePercent' has a wrong offset!");
static_assert(offsetof(UFlamesConditionComponent, _pFlameEffect) == 0x000168, "Member 'UFlamesConditionComponent::_pFlameEffect' has a wrong offset!");
static_assert(offsetof(UFlamesConditionComponent, _pAttackedComp) == 0x000170, "Member 'UFlamesConditionComponent::_pAttackedComp' has a wrong offset!");
static_assert(offsetof(UFlamesConditionComponent, _pEffectComp) == 0x000178, "Member 'UFlamesConditionComponent::_pEffectComp' has a wrong offset!");

// Class BattlePrototype.CheatCommandListenerComponent
// 0x0010 (0x00D0 - 0x00C0)
class UCheatCommandListenerComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnCheatCommand;                                    // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	static class UCheatCommandListenerComponent* GetCheatCommandListenerComponentFromActor(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheatCommandListenerComponent">();
	}
	static class UCheatCommandListenerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheatCommandListenerComponent>();
	}
};
static_assert(alignof(UCheatCommandListenerComponent) == 0x000008, "Wrong alignment on UCheatCommandListenerComponent");
static_assert(sizeof(UCheatCommandListenerComponent) == 0x0000D0, "Wrong size on UCheatCommandListenerComponent");
static_assert(offsetof(UCheatCommandListenerComponent, OnCheatCommand) == 0x0000C0, "Member 'UCheatCommandListenerComponent::OnCheatCommand' has a wrong offset!");

// Class BattlePrototype.UICode
// 0x0078 (0x0400 - 0x0388)
class UUICode : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x60];                                     // 0x03A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UREDScrollBox* ScrollBox, class UTextBlock* TextTitle);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUpdateElement(int32 Index_0, class UUserWidget* Widget);
	void Start();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICode">();
	}
	static class UUICode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICode>();
	}
};
static_assert(alignof(UUICode) == 0x000008, "Wrong alignment on UUICode");
static_assert(sizeof(UUICode) == 0x000400, "Wrong size on UUICode");
static_assert(offsetof(UUICode, ListElementSize) == 0x000388, "Member 'UUICode::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUICode, ListOffsetSize) == 0x000390, "Member 'UUICode::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUICode, ListIndexClass) == 0x000398, "Member 'UUICode::ListIndexClass' has a wrong offset!");

// Class BattlePrototype.DebuggingItemClearGetterGroup
// 0x0018 (0x02E8 - 0x02D0)
class ADebuggingItemClearGetterGroup final : public ADebuggingItemGroup
{
public:
	TWeakObjectPtr<class ADebuggingItemBool>      DebugDispBool;                                     // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemEvent>     ExecParamChange;                                   // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UClearGetterManager>     Manager;                                           // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DisplayDebugParam(float X, float Y, const struct FLinearColor& Color, const struct FVector2D& Scale);
	void OnExecuteParameterChange(const class ADebuggingItemEvent* Item);
	void OnPageOpened();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemClearGetterGroup">();
	}
	static class ADebuggingItemClearGetterGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemClearGetterGroup>();
	}
};
static_assert(alignof(ADebuggingItemClearGetterGroup) == 0x000008, "Wrong alignment on ADebuggingItemClearGetterGroup");
static_assert(sizeof(ADebuggingItemClearGetterGroup) == 0x0002E8, "Wrong size on ADebuggingItemClearGetterGroup");
static_assert(offsetof(ADebuggingItemClearGetterGroup, DebugDispBool) == 0x0002D0, "Member 'ADebuggingItemClearGetterGroup::DebugDispBool' has a wrong offset!");
static_assert(offsetof(ADebuggingItemClearGetterGroup, ExecParamChange) == 0x0002D8, "Member 'ADebuggingItemClearGetterGroup::ExecParamChange' has a wrong offset!");
static_assert(offsetof(ADebuggingItemClearGetterGroup, Manager) == 0x0002E0, "Member 'ADebuggingItemClearGetterGroup::Manager' has a wrong offset!");

// Class BattlePrototype.ClearGetterManager
// 0x00F0 (0x0118 - 0x0028)
class UClearGetterManager final : public UObject
{
public:
	uint8                                         Pad_28[0xF0];                                      // 0x0028(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddItemUseCount(int32 Num);
	void CheckAllClearGetterMission();
	void CheckAssaultVision(int32 Num);
	void CheckBattleSimulatorClear();
	void CheckBrainCrash(int32 Num);
	void CheckBrainField(int32 Num);
	void CheckClearGetterMission();
	void CheckCombinationVisionCombo(int32 Num);
	void CheckCombinationVisionDamage(int32 Damage);
	void CheckCrashVisionCombo(int32 Num);
	void CheckDLCBondsEpisode();
	void CheckEnableNexusDrive();
	void CheckEnemyDefeated(const struct FHCHitResult& HitResult, bool bBrainField);
	void CheckExistStrongestWeapon();
	void CheckGameClear();
	void CheckGetStrongestWeapon(const class FName& WeaponId);
	void CheckKarenEpisode();
	void CheckMoney();
	void CheckNexusDrive(int32 Num);
	void CheckNpcDrive(int32 Num);
	void CheckPhaseClear();
	void CheckPlayerDrive(int32 Num);
	void CheckPlayerLevel();
	void CheckPlayerParameter(const struct FPlayerInfo& PlayerInfo);
	void CheckPresent(int32 Num);
	void CheckPresentUnique();
	void CheckProtectVision(int32 Num);
	void CheckQuestClear(int32 Num);
	void CheckReviveNpc(int32 Num);
	void CheckTeamBonds();
	void CheckThrowPsychicObject(int32 Num);
	void CheckTotalExp(int32 AddExp);
	void CheckTotalNexusDriveTime(float Time);
	void CheckTotalPlayTime();
	void CheckUniquePsychicObjectSuccess(int32 Num);
	void ClearParameter(bool bExNewGame);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClearGetterManager">();
	}
	static class UClearGetterManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClearGetterManager>();
	}
};
static_assert(alignof(UClearGetterManager) == 0x000008, "Wrong alignment on UClearGetterManager");
static_assert(sizeof(UClearGetterManager) == 0x000118, "Wrong size on UClearGetterManager");

// Class BattlePrototype.DebuggingWidget
// 0x0058 (0x0288 - 0x0230)
class UDebuggingWidget final : public UUserWidget
{
public:
	uint8                                         Pad_230[0x58];                                     // 0x0230(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingWidget">();
	}
	static class UDebuggingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebuggingWidget>();
	}
};
static_assert(alignof(UDebuggingWidget) == 0x000008, "Wrong alignment on UDebuggingWidget");
static_assert(sizeof(UDebuggingWidget) == 0x000288, "Wrong size on UDebuggingWidget");

// Class BattlePrototype.UITitleFirstConfigBrightness
// 0x0118 (0x04A0 - 0x0388)
class UUITitleFirstConfigBrightness final : public UUIBase
{
public:
	int32                                         MinX;                                              // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxX;                                              // 0x038C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x110];                                    // 0x0390(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyBrightness(float FValue);
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeIndex(class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UREDTextBlock* TextIndex);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UImage* ImageSlider, class UTextBlock* TextTopDescription, class UTextBlock* TextBottomDescription, class UREDOverlay* Gauge_set, class USpacer* GuideSpacer);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool IsBack() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleFirstConfigBrightness">();
	}
	static class UUITitleFirstConfigBrightness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleFirstConfigBrightness>();
	}
};
static_assert(alignof(UUITitleFirstConfigBrightness) == 0x000008, "Wrong alignment on UUITitleFirstConfigBrightness");
static_assert(sizeof(UUITitleFirstConfigBrightness) == 0x0004A0, "Wrong size on UUITitleFirstConfigBrightness");
static_assert(offsetof(UUITitleFirstConfigBrightness, MinX) == 0x000388, "Member 'UUITitleFirstConfigBrightness::MinX' has a wrong offset!");
static_assert(offsetof(UUITitleFirstConfigBrightness, MaxX) == 0x00038C, "Member 'UUITitleFirstConfigBrightness::MaxX' has a wrong offset!");

// Class BattlePrototype.PostProcessSettingsDataAsset
// 0x0780 (0x07B0 - 0x0030)
class UPostProcessSettingsDataAsset final : public UDataAsset
{
public:
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0030(0x0780)(Edit, BlueprintVisible, Interp, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessSettingsDataAsset">();
	}
	static class UPostProcessSettingsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPostProcessSettingsDataAsset>();
	}
};
static_assert(alignof(UPostProcessSettingsDataAsset) == 0x000010, "Wrong alignment on UPostProcessSettingsDataAsset");
static_assert(sizeof(UPostProcessSettingsDataAsset) == 0x0007B0, "Wrong size on UPostProcessSettingsDataAsset");
static_assert(offsetof(UPostProcessSettingsDataAsset, PostProcessSettings) == 0x000030, "Member 'UPostProcessSettingsDataAsset::PostProcessSettings' has a wrong offset!");

// Class BattlePrototype.FixPoseActorComponent
// 0x0018 (0x00D8 - 0x00C0)
class UFixPoseActorComponent final : public UActorComponent
{
public:
	class UShapeComponent*                        TargetShape;                                       // 0x00C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotate;                                            // 0x00C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsFixVelocity;                                     // 0x00D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFixRot;                                          // 0x00D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D6[0x2];                                       // 0x00D6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FixPoseActorComponent">();
	}
	static class UFixPoseActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFixPoseActorComponent>();
	}
};
static_assert(alignof(UFixPoseActorComponent) == 0x000008, "Wrong alignment on UFixPoseActorComponent");
static_assert(sizeof(UFixPoseActorComponent) == 0x0000D8, "Wrong size on UFixPoseActorComponent");
static_assert(offsetof(UFixPoseActorComponent, TargetShape) == 0x0000C0, "Member 'UFixPoseActorComponent::TargetShape' has a wrong offset!");
static_assert(offsetof(UFixPoseActorComponent, Rotate) == 0x0000C8, "Member 'UFixPoseActorComponent::Rotate' has a wrong offset!");
static_assert(offsetof(UFixPoseActorComponent, IsFixVelocity) == 0x0000D4, "Member 'UFixPoseActorComponent::IsFixVelocity' has a wrong offset!");
static_assert(offsetof(UFixPoseActorComponent, IsFixRot) == 0x0000D5, "Member 'UFixPoseActorComponent::IsFixRot' has a wrong offset!");

// Class BattlePrototype.UIMiniTips
// 0x0000 (0x0388 - 0x0388)
class UUIMiniTips : public UUIBase
{
public:
	void UpdateSpacerMiniTips();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiniTips">();
	}
	static class UUIMiniTips* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMiniTips>();
	}
};
static_assert(alignof(UUIMiniTips) == 0x000008, "Wrong alignment on UUIMiniTips");
static_assert(sizeof(UUIMiniTips) == 0x000388, "Wrong size on UUIMiniTips");

// Class BattlePrototype.ConditionUtility
// 0x0000 (0x0028 - 0x0028)
class UConditionUtility final : public UBlueprintFunctionLibrary
{
public:
	static void AccumulateCondition(class AActor* Actor, const struct FHCHitResult& HitResult, bool IsGuard);
	static void FinishStateConditionAll(class AActor* Actor);
	static bool IsActiveStateCondition(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionUtility">();
	}
	static class UConditionUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionUtility>();
	}
};
static_assert(alignof(UConditionUtility) == 0x000008, "Wrong alignment on UConditionUtility");
static_assert(sizeof(UConditionUtility) == 0x000028, "Wrong size on UConditionUtility");

// Class BattlePrototype.ContinualMoveComponent
// 0x0020 (0x00E0 - 0x00C0)
class UContinualMoveComponent final : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x20];                                      // 0x00C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UContinualMoveComponent* GetContinualMoveComponent(class AActor* Actor);

	void ClearMove(const class FName& ClaimantName);
	void ForceClearMove();
	void SetInvalidMove(bool bInvalid);
	void StartMove(const class FName& ClaimantName, const struct FVector& FrontVector, float InitSpeed, float Acceleration, float EndSpeed);
	void UpdateFunction(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContinualMoveComponent">();
	}
	static class UContinualMoveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContinualMoveComponent>();
	}
};
static_assert(alignof(UContinualMoveComponent) == 0x000008, "Wrong alignment on UContinualMoveComponent");
static_assert(sizeof(UContinualMoveComponent) == 0x0000E0, "Wrong size on UContinualMoveComponent");

// Class BattlePrototype.EnemyScriptComponent
// 0x02A8 (0x0368 - 0x00C0)
class UEnemyScriptComponent final : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x94];                                      // 0x00C0(0x0094)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MTargetHeight;                                     // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MReceiveMontage;                                   // 0x0158(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIgnoreUpdateMoveMaxSpeed;                         // 0x0160(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsSpawnNow;                                      // 0x0161(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbUseDefaultSpawnSearchParam;                      // 0x0162(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsBattleEnemy;                                   // 0x0163(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsWait;                                          // 0x0164(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsEventWait;                                     // 0x0165(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsBT_ForceBreak;                                 // 0x0166(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsWander;                                        // 0x0167(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbEnableWander;                                    // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsBattleStart;                                   // 0x0169(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsBoss;                                          // 0x016A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbCollisionHitWall;                                // 0x016B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MESpawnState;                                      // 0x016C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D[0x3];                                      // 0x016D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MInitGroundPos;                                    // 0x0170(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFlyModeChangeIgnoreSeconds;                       // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 MFlyEnemyPawn;                                     // 0x0180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnemyFormType                                MEFormType;                                        // 0x0188(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MOutRangeFadeValue;                                // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MOutRangeFadeValueInt;                             // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MWeaponOutRangeFadeValueInt;                       // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UActorComponent*>                MRecordTickEnabledComponentList;                   // 0x0198(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A8[0x24];                                     // 0x01A8(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MTickActorSeconds;                                 // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D0[0x84];                                     // 0x01D0(0x0084)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MUpdateFindPlayerNotRenderedTime;                  // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x50];                                     // 0x0258(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  MbDisableWeakAroundEffect;                         // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MGroupID;                                          // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MBattlefieldFenceAppearRate;                       // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<uint8, struct FAiParamEnemyInfo>         MAiTableDataMap;                                   // 0x02C0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          MbInvincible;                                      // 0x0318(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_319[0x3];                                      // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MWeakNo;                                           // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MArmorNo;                                          // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterDeadType                            MCharaDeadType;                                    // 0x0324(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsDeadStartNotify;                                // 0x0325(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_326[0x2];                                      // 0x0326(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDamagePartCollisionComponent*>  MWeakComponent;                                    // 0x0328(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIgnorePenetrateArmor;                            // 0x0338(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_339[0x2F];                                     // 0x0339(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBattleActor(bool& IsNotAddedBattleManager);
	void AddResetSecondRate();
	void BrakeArmor(const TArray<int32>& ArmorPartsNo);
	void CalcAccumulationByDefence(float RefWince, float RefKnockback, float RefDown, float RefCrashScale, float* OutWince, float* OutKnockback, float* OutDown, float* OutCrashScale, class AActor* AttackActor, bool IsEnemyDamageknockBack);
	bool CalcAccumulationByDefence_CheckInvincible(float& RefWince, float& RefKnockback, float& RefDown, float& RefLaunch, float& RefFlame, float& RefElectric, float& RefFlooded, float& RefOil, float& RefConfusion, float& RefCrashScale);
	float CalcFinalDamageByDefence(float BaseDamage);
	void CalcNormalMaterialRate(float& L_Value, float& L_EmissivePowerValue, float& WeakDamageMaterialTime, float NormalWeakMaterialScale, float NormalWeakMaterialRateMin, float NormalWeakMaterialRateMax, float NormalWeakMaterialEmissivePowerMin, float NormalWeakMaterialEmissivePowerMax, class UCurveFloat* WeakMaterialCurve);
	class ARSCharacterBase* CalcTargetInfo(float* L_TargetDistance, float* L_TargetHeight, float* L_TargetAngle, bool InIsBattling, const struct FVector& InBaseLocation);
	void CalcTickNative(const struct FVector& InitPos, float EnableMoveArea, float EnableMoveHeight, bool* IsHitCheck, float* DistanceFromEnemyInitToPlayer, float* HeightFromEnemyInitToPlayer, float* DistanceFromEnemyToPlayer, float* HeightFromEnemyToPlayer);
	bool CalcTickSeconds_Native(float DeltaSec);
	void CalcTickSecondsNative(float* OutIntervalActorTime, bool* OutExecTick, bool* OutIncrementUpdateEnemy, float DeltaSec, EEnemyTickPriorityType InTickPriority, bool InCanUpdateEnemy);
	float CalcWeakAttackMaterialRate(float& L_Value, float& L_EmissivePowerValue, float& WeakDamageMaterialTime, float WeakDamageMaterialScale, float WeakMaterialPointRateMax, float WeakMaterialEmissivePowerMax, class UCurveFloat* WeakMaterialCurve, bool& ChangingWeakDamageMaterial, bool& IsWeakEffect, bool IsMultiWeak);
	void CheckIgnoreSuperArmor(const TArray<EHCSkillExtraType>& SkillExtraTypes);
	void CheckUniqueObjState_AddSkillExtraType(const struct FHCHitResult& HitResult, TArray<EHCSkillExtraType>& SkillExtraType);
	bool CheckUniqueObjState_CrashChanceCancel(bool IsBrainCrashAccess);
	void ClearSaveBodyEmissiveValue();
	bool EnableInvincible(bool Enable);
	void EnableLostAction(bool bEnable);
	void EnableTickComponentWasRecording();
	void FlyHeightAdjust(float DeltaSeconds, float FlyBaseZ, bool IsFlyState, bool IsMoveAnim_0, bool FlyAdjust, float FlyLowerHeight, float FlyHighestHeight, float FlyAdjustSpeed, float AnyMoreDifferenceUpdate);
	void FlyPawnSetActorAllTickEnabledNative(bool Enabled, class AActor* FlyEnemyPawn, class UActorComponent* DefaultSceneRoot, class UActorComponent* FloatingPawnMovement, class AActor* AIController, class UActorComponent* PathFollowingComp);
	void ForceSettingOutRangeFade(bool IsDisp);
	struct FAiParamEnemyInfo GetAiTableDataNative(uint8 ActionEnum);
	bool GetAndUpdateContinuousSameDamageReaction();
	float GetCaptureAreaNative(uint8 SpawnState, float ChangeCaptureArea);
	struct FVector GetDamagePartDir(class UDamagePartCollisionComponent* DamagePartCollisionComponent);
	struct FVector GetEyePositionNative(class FName EyeSocketName);
	void GetHitStopParam(const struct FHCSkillCommonInfo& SkillInfo, bool* IgnoreTarget, EHCHitStopCauseType* CauseType);
	bool GetIsBattleMode_Native();
	bool GetIsDead_Native();
	float GetMoveAreaNative();
	float GetParamBasicAccumulation(EEnemyDamageType DamageType);
	float GetParamTableResistance(EEnemyDamageType DamageType);
	struct FVector GetRestoreBrainFieldLocation();
	float GetSaveBodyEmissiveValue(int32 Index_0);
	float GetSearchAngleNative(uint8 SpawnState, float ChangeSearchAngle);
	float GetSearchRangeNative(uint8 SpawnState, float ChangeSearchRange);
	float GetSensingAreaNative(uint8 SpawnState, float ChangeSensingArea);
	float GetTargetAngle(const struct FVector& baseDist, const struct FVector& TargetDist);
	void GetTickIntervalSecondsParam(float* OutDefaultSeconds, float* OutMaxSeconds, EEnemyTickPriorityType InTickPriority);
	void GetUsedWeaponAllListNative(const TArray<class AEnemyWeaponBase*>& WeaponList, TArray<class AEnemyWeaponBase*>& Result);
	void InitCoolDownTimerBP(int32 Num);
	void Initialize(class UCharacterMovementComponent* CharaMoveComp, class UCharactersParameterComponent* CharactersParameterComp, class UEnemyLookCheckComponent* LookCheckComp, class UEnemyAnimControllerComponent* AnimController, class USkeletalMeshComponent* MeshComp, class UHateTargetComponent* HateTargetComp, class UEnemyFixParamComponentBase* FixParam, class USearchingComponent* SearchingComponent, class UChangeWeakStateComponentBase* ChangeWeakStateComponent, class UEnemyAroundEffectComponentBase* AroundEffectComponentBase, bool IsIgnoreAllowance, bool IsIgnoreRestrictAttackOther, bool UseDefaultSpawnSearchParam);
	bool IsArmor(class UPrimitiveComponent* PrimitiveComponent);
	bool IsBrainCrashDeadState();
	bool IsContinuityDamageMotion(EnemyAliveAnimKind AliveAnimKind);
	bool IsCrashChanceAndIgnore();
	bool IsDamageDownWait();
	bool IsDamageKnockBack();
	bool IsDamageSuperArmor();
	bool IsDeadAfterReaction(const TArray<EHCSkillExtraType>& SkillExtraTypes);
	bool IsDelayDeath_Native();
	bool IsDisableTargetBattleNative();
	bool IsDisableWeakAroundEffect(int32 Index_0);
	bool IsDistanceAngleCheck(class AActor* Target, const struct FVector& TargetLocation, float Range, float Angle, const struct FRotator& Rot, bool NoHeight, const struct FVector& SelfLocation, bool SelfLocationOn);
	bool IsDownDamageToDead(bool bEnableConsiderFlag);
	bool IsDuringLaunchDamage(bool IsNewLaunch, bool DamageFloating, bool NewDamageFloating);
	bool IsEnableMoveRangeNative(float EnableMoveArea, float DistanceFromEnemyInitToPlayer, float EnableMoveHeight, float HeightFromEnemyInitToPlayer);
	bool IsEnableWeak();
	bool IsEnemyTickDisableCondition_Native(bool bDiscoverClosed);
	bool IsFloodedAnimRootMotionScale(bool IsMoveAnim_0);
	bool IsFlyHeightAdjust();
	bool IsFlying();
	bool IsHitFromMainPlayer(class AActor* Attacker);
	bool IsHitPart(class UPrimitiveComponent* PrimitiveComponent, int32 No);
	bool IsHitWeak(class UPrimitiveComponent* PrimitiveComponent, const struct FHCSkillCommonInfo& SkillInfo);
	bool IsHitWeak_HitResult(const TArray<struct FHCHitResult>& HitResults);
	bool IsHitWeak_HitResultS(const struct FHCHitResult& HitResults);
	bool IsHpPercentDown(float Percent, bool* Error);
	bool IsInitLayout_Native();
	bool IsInvincible(bool* InvincibleAll, bool* InvincibleParts);
	bool IsNotDamageMotion(bool NotDamageMotion);
	bool IsNotTargetNative();
	bool IsPlayerOutOfBattleFieldFence();
	bool IsPsychic_Obj_MapGimmickDamage(EHCSkillAttackType SkillAttackType);
	bool IsPsychicObjectCombo(const struct FHCHitResult& HitResult);
	bool IsSkillExtraType(const TArray<EHCSkillExtraType>& SkillExtraTypes, EHCSkillExtraType ExtraType);
	bool IsSkillExtraType_CommonInfo(const struct FHCSkillCommonInfo& SkillInfo, EHCSkillExtraType ExtraType);
	bool IsStateStealthNative(EEnemyStealthState StealthState);
	bool IsStealthEnableNative();
	bool IsStealthSeeEnebleNative(bool* IsValid);
	bool IsStopWeakEmissive();
	bool IsSuspendFollowAttack();
	bool IsSuspendIKCondition();
	bool IsTrigger(const TArray<EHCSkillExtraType>& SkillExtraTypes);
	bool IsValidSaveBodyEmissiveValue(int32 Index_0);
	void MainTick(float DeltaSeconds);
	void ModifyElectricAccumulationBySuperArmor(float& RefElectric, bool IsSuperArmor);
	void ModifyHitResultPrimitiveWeakPoint(class USkeletalMeshComponent* Mesh, struct FHCHitResult& HitResult, bool* ModifiedPrimitive);
	bool NotDamageMontage(bool IsRequestAddDamageMontage);
	void OnDamageActorHit_ChangeWeakState(class AActor* Attacker, const struct FHCHitResult& HitResult);
	void OnDamageActorHit_DamageInfo(const struct FHCHitResult& HitResult, class AActor** Attack, struct FVector* DamageLocation, struct FVector* DamageDir);
	void OnDamageActorHit_IsHitWeek(struct FHCHitResult& RefHitResult);
	void PostTick(float DeltaSeconds);
	bool PreAreaCheck(int32 AreaOutSequence);
	void PreTick(float DeltaSeconds);
	bool PreUpdateWeakAroundEffect(bool* IsExit);
	void PreUpdateWeakMaterialRate(const TArray<class FString>& SlotNameList, float& MaterialTime, float DeltaSec, bool* R_isMultiWeak);
	EEnemyTickPriorityType PrioritizeTickNative(EEnemyTickPriorityType InTickPriority, bool InIsBoss, bool InIsSimple, bool InIsBattling, float InRangeMiddle, float RangeTop, float HeightTop);
	void PutoutInformation(bool IsSideDamage, const struct FVector& HitDir, const struct FVector& HitPosition, bool* IsRight, bool* IsLeft, bool* IsBack);
	void RecordTickEnabledComponents(const TArray<class UActorComponent*>& ComponentList);
	struct FHCHitResult ReplaceHitResult(const struct FHCHitResult& HitResult);
	bool RequestAddDamageL(const struct FHCSkillCommonInfo& SkillInfo);
	bool RequestDownMotion(const struct FHCSkillCommonInfo& SkillInfo, bool IsDownSasFlagIgnoreDownTriggerFlag);
	bool RequestLaunchMotion(bool LaunchIgnorePriority, bool IsMotionReception, bool& IsOverWriteMotion);
	bool RequestLaunchMotion_Damage(bool LaunchIgnorePriority);
	void ResetAreaOutParam();
	void RestoreWeakEmissive_Native(const class FString& WeakSlotName);
	void SearchForceReactionType(const TArray<EHCSkillExtraType>& SkillExtraTypes, TArray<EHCSkillExtraType>& ForceExtraTypes);
	void SetAbsoluteDetectTarget(bool IsAbsolute, class FName ClaimantName);
	void SetAbsolutelyNoReactionBP(bool bEnable);
	void SetAreaOutDamageWaitTimer(float AddTime, float MaxTime);
	void SetConsiderDownDead(bool bEnable);
	void SetCoolDownTimerBP(int32 Index_0, float Value);
	void SetDisableTargetBattleNative(bool _disable);
	void SetDisableWeakAroundEffect(int32 Index_0, bool _isEnable);
	void SetEnableWeak(bool _isEnable);
	void SetFindPlayerType(EEnemyFindPlayerType FindType);
	void SetFindValue(float Value);
	void SetIgnoreCaptureRange(bool IsIgnore);
	void SetIgnoreCrashChance(bool bIgnoreCrashChance);
	void SetIgnorePenetrateArmor(bool bIgnore);
	void SetMainPlayerSearchBasicInfo(const struct FSearchBasicInfo& Info);
	void SetMainPlayerSearchTestInfo(const struct FSearchTestInfo& Info);
	void SetOutRangeFadeValue(float FadeValue);
	void SetQuickFind(bool bEnable);
	void SetRestoreBrainFieldLocation(const struct FVector& RestoreLocation);
	void SetSaveBodyEmissiveValue(int32 Index_0, float Value);
	void SetSimulatePhisics(bool bEnable);
	void SetStopWeakEmissive(bool _isStop);
	void SetTargetSearchBasicInfo(const struct FSearchBasicInfo& Info);
	void SetTargetSearchTestInfo(const struct FSearchTestInfo& Info);
	void SetTickIntervalSecondsParam(float _TickPriorityIntervalMiddle, float _TickPriorityLimitMiddle, float _TickPriorityIntervalTop, float _TickPriorityLimitTop, float _TickPriorityIntervalBottom, float _TickPriorityLimitBottom);
	void SettingOutRangeFade(float OutRange);
	void SetWeakEmissiveOff_Native(const class FString& WeakSlotName);
	void SetWeakMaterialValue(float _emissivePowerMax, float _pointRateMax);
	void SetWeaponOutRangeFade(const TArray<class AEnemyWeaponBase*>& WeaponArray, float DeitherValue, float FadeRate);
	void StartDamageAnimFunc(bool ObjAttackDirect, const struct FVector& LDir, const struct FVector& ObjAttackDirection, const struct FVector& ObjLocation, const struct FVector& AttackLocation, const struct FVector& AttackDir, struct FRotator& RefRotator, struct FVector& RefHit, struct FVector& RefDir);
	float TimerDecrement(float Base, float Time);
	void TimerDecrementRef(float& Base, float Time, bool bLimitZero);
	void TimerIncrementRef(float& Base, float Time);
	struct FVector UpdateAdditionalDecal(float& DecalLerpSpeed, float DecalFollowSpeedDefault, float DecalFollowSpeedFast, const struct FVector& LastAdditionalDecalLocation, const struct FVector& Offset, class FName AttachSocketNameAdditionalDecal);
	bool UpdateAreaCheck(int32 AreaOutSequence, bool IsAreaOut, const struct FVector& InitPos, float DeltaSeconds, float OutRange, float OffsetRange, float AreaOutTimer);
	struct FVector UpdateCommonDecal(float& DecalLerpSpeed, float DecalFollowSpeedDefault, float DecalFollowSpeedFast, float DeletaSeconds, const struct FVector& LastDecalLocation, const struct FVector& Offset, class FName AttachSocketNameAdditionalDecal);
	void UpdateDetectPlayer(float SearchViewRange, float SearchViewAngle, float SearchSensingRange, float CaptureRange, float SearchHeight);
	void UpdateDetectTarget(const class ARSCharacterBase* Target, float SearchViewRange, float SearchViewAngle, float SearchSensingRange, float CaptureRange, float SearchHeight);
	bool UpdateEnableIK(bool EnableRequestIk);
	void UpdateEnemyUro();
	void UpdateFindPlayerValue(float DeltaSeconds);
	void UpdateFloodedAnimRootMotionScale(bool& IsFoodedFlg, bool IsMoveAnim);
	void UpdateFlyEnemyParam(float DeltaSeconds, const struct FVector& OldLocation);
	bool UpdateFlyMoveSlopeRestoreSeconds(bool FlyMoveSlopeRestore, float DeltaSeconds, float RotPow);
	bool UpdateGroundCheckTimer(struct FGameTimer& GameTimer, float GroundCheckTime);
	void UpdateGroundEffect(EEm0800EffectType& GroundEffectType);
	float UpdateHitDamageMaterialArmor(float Sec, float ArmorFlashScale, float& RefArmorFlashTime);
	void UpdateIsSameDamageReaction(bool IsMotionReception, EnemyDamageAnimKind DamageKind);
	void UpdateMainPlayerInfo();
	void UpdateOutRangeFade(float* DeitherValue, float TargetRange, float DeltaSeconds, float FadeRange, float InRange, float OutRange, float FadeTime, float FadeRate, bool ForceDisp);
	void UpdatePreviousElapsedTime(float ElapsedTime);
	void UpdateRootMotionChildPawn(const struct FVector& RootLocation, bool PossibleGroundCheck, float BeforeFlyPawnZ, struct FVector& ActorLocation, float& FlyPawnZ, float AnyMoreDifferenceUpdate);
	void UpdateRotator(bool ChildMove, float DeltaSeconds, float NoNavMoveInterpSpeed);
	void UpdateScoutingNative(float DeltaSeconds, uint8 SpawnState, float ChangeSearchRange, float ChangeSearchAngle, float ChangeSensingArea, float ChangeCaptureArea, class FName EyeSocketName);
	bool UpdateSetFlying(bool DamageFloating, bool IsFlyState);
	void UpdateTargetInfo(const class ARSCharacterBase* Target);
	void UpdateTraceChildPawn(const struct FVector& RootLocation, bool PossibleGroundCheck, float BeforeFlyPawnZ, struct FVector& ActorLocation, float& FlyPawnZ);
	void UpdateUro(class USkinnedMeshComponent* TargetMesh, EnemyAliveAnimKind AnimKind);
	bool UpdateWeakAroundEffect(TArray<bool>& StartWeakAroundEffect, bool BrainFieldSealWeakParticle, bool PreCheck);
	void UpdateWeakMaterialRate(const TArray<class FString>& SlotNameList, float RateValue, float EmissivePowerValue);
	bool WeakMaterialHitDamage(const TArray<struct FHCHitResult>& HitResults);

	struct FSearchBasicInfo CalcSearchInfo(const class ARSCharacterBase* Target) const;
	struct FSearchTestInfo CalcSearchTest(const class ARSCharacterBase* Target, const struct FSearchBasicInfo& basicInfo, float SearchViewRange, float SearchViewAngle, float SearchSensingRange, float CaptureRange, float SearchHeight) const;
	float GetCoolDownTimerBP(int32 Index_0) const;
	EEnemyFindPlayerType GetFindPlayerType() const;
	float GetFindValue() const;
	const struct FSearchBasicInfo GetMainPlayerSearchBasicInfo() const;
	const struct FSearchTestInfo GetMainPlayerSearchTestInfo() const;
	EEnemyFindPlayerType GetOldFindPlayerType() const;
	const struct FSearchBasicInfo GetTargetSearchBasicInfo() const;
	const struct FSearchTestInfo GetTargetSearchTestInfo() const;
	bool IsAbsoluteDetectTarget() const;
	bool IsAbsolutelyNoReactionBP() const;
	bool IsChangeOldFindType() const;
	bool IsCheckAliveAnimKind(EnemyAliveAnimKind CheckKind) const;
	bool IsCheckDamageAnimKind(EnemyDamageAnimKind CheckKind) const;
	bool IsCheckDamageDownAnimKind(EnemyDamageDownAnimKind CheckKind) const;
	bool IsCheckEnemyKind(EnemyKind CheckKind) const;
	bool IsConsiderDownDead() const;
	bool IsDamage() const;
	bool IsEnableLostAction() const;
	bool IsEnemyDamageLaunchCPP() const;
	bool IsEnemyStopAnimKind(bool IsWait, bool IsEventWait) const;
	bool IsEvent() const;
	bool IsIgnoreCaptureRange() const;
	bool IsIgnorePenetrateArmor() const;
	bool IsMoveAnim(EnemyMoveAnimKind CheckKind) const;
	bool IsNeedResetStateMachine(float ElapsedTime, float ResetSecond) const;
	bool IsQuickFind() const;
	bool IsUpdateEnemyTickEnableNative(bool IsBoss, bool StopUpdateEnemyTickEnable, bool IsTickMove) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyScriptComponent">();
	}
	static class UEnemyScriptComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyScriptComponent>();
	}
};
static_assert(alignof(UEnemyScriptComponent) == 0x000008, "Wrong alignment on UEnemyScriptComponent");
static_assert(sizeof(UEnemyScriptComponent) == 0x000368, "Wrong size on UEnemyScriptComponent");
static_assert(offsetof(UEnemyScriptComponent, MTargetHeight) == 0x000154, "Member 'UEnemyScriptComponent::MTargetHeight' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MReceiveMontage) == 0x000158, "Member 'UEnemyScriptComponent::MReceiveMontage' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MIgnoreUpdateMoveMaxSpeed) == 0x000160, "Member 'UEnemyScriptComponent::MIgnoreUpdateMoveMaxSpeed' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbIsSpawnNow) == 0x000161, "Member 'UEnemyScriptComponent::MbIsSpawnNow' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbUseDefaultSpawnSearchParam) == 0x000162, "Member 'UEnemyScriptComponent::MbUseDefaultSpawnSearchParam' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbIsBattleEnemy) == 0x000163, "Member 'UEnemyScriptComponent::MbIsBattleEnemy' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbIsWait) == 0x000164, "Member 'UEnemyScriptComponent::MbIsWait' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbIsEventWait) == 0x000165, "Member 'UEnemyScriptComponent::MbIsEventWait' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbIsBT_ForceBreak) == 0x000166, "Member 'UEnemyScriptComponent::MbIsBT_ForceBreak' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbIsWander) == 0x000167, "Member 'UEnemyScriptComponent::MbIsWander' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbEnableWander) == 0x000168, "Member 'UEnemyScriptComponent::MbEnableWander' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbIsBattleStart) == 0x000169, "Member 'UEnemyScriptComponent::MbIsBattleStart' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbIsBoss) == 0x00016A, "Member 'UEnemyScriptComponent::MbIsBoss' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbCollisionHitWall) == 0x00016B, "Member 'UEnemyScriptComponent::MbCollisionHitWall' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MESpawnState) == 0x00016C, "Member 'UEnemyScriptComponent::MESpawnState' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MInitGroundPos) == 0x000170, "Member 'UEnemyScriptComponent::MInitGroundPos' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MFlyModeChangeIgnoreSeconds) == 0x00017C, "Member 'UEnemyScriptComponent::MFlyModeChangeIgnoreSeconds' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MFlyEnemyPawn) == 0x000180, "Member 'UEnemyScriptComponent::MFlyEnemyPawn' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MEFormType) == 0x000188, "Member 'UEnemyScriptComponent::MEFormType' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MOutRangeFadeValue) == 0x00018C, "Member 'UEnemyScriptComponent::MOutRangeFadeValue' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MOutRangeFadeValueInt) == 0x000190, "Member 'UEnemyScriptComponent::MOutRangeFadeValueInt' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MWeaponOutRangeFadeValueInt) == 0x000194, "Member 'UEnemyScriptComponent::MWeaponOutRangeFadeValueInt' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MRecordTickEnabledComponentList) == 0x000198, "Member 'UEnemyScriptComponent::MRecordTickEnabledComponentList' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MTickActorSeconds) == 0x0001CC, "Member 'UEnemyScriptComponent::MTickActorSeconds' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MUpdateFindPlayerNotRenderedTime) == 0x000254, "Member 'UEnemyScriptComponent::MUpdateFindPlayerNotRenderedTime' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbDisableWeakAroundEffect) == 0x0002A8, "Member 'UEnemyScriptComponent::MbDisableWeakAroundEffect' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MGroupID) == 0x0002B8, "Member 'UEnemyScriptComponent::MGroupID' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MBattlefieldFenceAppearRate) == 0x0002BC, "Member 'UEnemyScriptComponent::MBattlefieldFenceAppearRate' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MAiTableDataMap) == 0x0002C0, "Member 'UEnemyScriptComponent::MAiTableDataMap' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbInvincible) == 0x000318, "Member 'UEnemyScriptComponent::MbInvincible' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MWeakNo) == 0x00031C, "Member 'UEnemyScriptComponent::MWeakNo' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MArmorNo) == 0x000320, "Member 'UEnemyScriptComponent::MArmorNo' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MCharaDeadType) == 0x000324, "Member 'UEnemyScriptComponent::MCharaDeadType' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MIsDeadStartNotify) == 0x000325, "Member 'UEnemyScriptComponent::MIsDeadStartNotify' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MWeakComponent) == 0x000328, "Member 'UEnemyScriptComponent::MWeakComponent' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbIgnorePenetrateArmor) == 0x000338, "Member 'UEnemyScriptComponent::MbIgnorePenetrateArmor' has a wrong offset!");

// Class BattlePrototype.UIConfigSelect5
// 0x0260 (0x05E8 - 0x0388)
class UUIConfigSelect5 : public UUIBase
{
public:
	uint8                                         Pad_388[0x260];                                    // 0x0388(0x0260)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeIndex(int32 Index_0, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimEnable, class UWidgetAnimation* AnimEnableIn, class UWidgetAnimation* AnimEnableOut);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextTitle);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigSelect5">();
	}
	static class UUIConfigSelect5* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigSelect5>();
	}
};
static_assert(alignof(UUIConfigSelect5) == 0x000008, "Wrong alignment on UUIConfigSelect5");
static_assert(sizeof(UUIConfigSelect5) == 0x0005E8, "Wrong size on UUIConfigSelect5");

// Class BattlePrototype.ControllablePsychicObjectComponent
// 0x0048 (0x0108 - 0x00C0)
class UControllablePsychicObjectComponent final : public UActorComponent
{
public:
	float                                         MaxTurnSpeed;                                      // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationSpeed;                                 // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowDownSpeed;                                     // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnSlowDown;                                     // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnSlowDownAngleMin;                              // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnSlowDownAngleMax;                              // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnSlowDownMaxSpeedRate;                          // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x28];                                      // 0x00E0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BeginControl(class ARSCharacterBase* InControlOwner, class UPlayerInputBaseComponent* InInputComponent, float InitializeSpeed);
	void EndControl();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllablePsychicObjectComponent">();
	}
	static class UControllablePsychicObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControllablePsychicObjectComponent>();
	}
};
static_assert(alignof(UControllablePsychicObjectComponent) == 0x000008, "Wrong alignment on UControllablePsychicObjectComponent");
static_assert(sizeof(UControllablePsychicObjectComponent) == 0x000108, "Wrong size on UControllablePsychicObjectComponent");
static_assert(offsetof(UControllablePsychicObjectComponent, MaxTurnSpeed) == 0x0000C0, "Member 'UControllablePsychicObjectComponent::MaxTurnSpeed' has a wrong offset!");
static_assert(offsetof(UControllablePsychicObjectComponent, MaxSpeed) == 0x0000C4, "Member 'UControllablePsychicObjectComponent::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UControllablePsychicObjectComponent, AccelerationSpeed) == 0x0000C8, "Member 'UControllablePsychicObjectComponent::AccelerationSpeed' has a wrong offset!");
static_assert(offsetof(UControllablePsychicObjectComponent, SlowDownSpeed) == 0x0000CC, "Member 'UControllablePsychicObjectComponent::SlowDownSpeed' has a wrong offset!");
static_assert(offsetof(UControllablePsychicObjectComponent, bTurnSlowDown) == 0x0000D0, "Member 'UControllablePsychicObjectComponent::bTurnSlowDown' has a wrong offset!");
static_assert(offsetof(UControllablePsychicObjectComponent, TurnSlowDownAngleMin) == 0x0000D4, "Member 'UControllablePsychicObjectComponent::TurnSlowDownAngleMin' has a wrong offset!");
static_assert(offsetof(UControllablePsychicObjectComponent, TurnSlowDownAngleMax) == 0x0000D8, "Member 'UControllablePsychicObjectComponent::TurnSlowDownAngleMax' has a wrong offset!");
static_assert(offsetof(UControllablePsychicObjectComponent, TurnSlowDownMaxSpeedRate) == 0x0000DC, "Member 'UControllablePsychicObjectComponent::TurnSlowDownMaxSpeedRate' has a wrong offset!");

// Class BattlePrototype.CopyPlayerAnimInstance
// 0x0090 (0x0300 - 0x0270)
class UCopyPlayerAnimInstance : public UAnimInstance
{
public:
	TWeakObjectPtr<class USkeletalMeshComponent>  SourceMesh;                                        // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMontage;                                       // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               SpineAimRot;                                       // 0x027C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FootIKBlendRate;                                   // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKMaxHeight;                                   // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootIKOffset_Left;                                 // 0x0290(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootIKOffset_Right;                                // 0x029C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootIKJointTargetLocation_Left;                    // 0x02A8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootIKJointTargetLocation_Right;                   // 0x02B4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _MeshOffset;                                       // 0x02C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x3C];                                     // 0x02C4(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetupFootIK(class URSPlayerAnimInstance* InOriginalAnimInstance, float InFloorAngle, float InCapsuleHeight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CopyPlayerAnimInstance">();
	}
	static class UCopyPlayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCopyPlayerAnimInstance>();
	}
};
static_assert(alignof(UCopyPlayerAnimInstance) == 0x000010, "Wrong alignment on UCopyPlayerAnimInstance");
static_assert(sizeof(UCopyPlayerAnimInstance) == 0x000300, "Wrong size on UCopyPlayerAnimInstance");
static_assert(offsetof(UCopyPlayerAnimInstance, SourceMesh) == 0x000270, "Member 'UCopyPlayerAnimInstance::SourceMesh' has a wrong offset!");
static_assert(offsetof(UCopyPlayerAnimInstance, bUseMontage) == 0x000278, "Member 'UCopyPlayerAnimInstance::bUseMontage' has a wrong offset!");
static_assert(offsetof(UCopyPlayerAnimInstance, SpineAimRot) == 0x00027C, "Member 'UCopyPlayerAnimInstance::SpineAimRot' has a wrong offset!");
static_assert(offsetof(UCopyPlayerAnimInstance, FootIKBlendRate) == 0x000288, "Member 'UCopyPlayerAnimInstance::FootIKBlendRate' has a wrong offset!");
static_assert(offsetof(UCopyPlayerAnimInstance, FootIKMaxHeight) == 0x00028C, "Member 'UCopyPlayerAnimInstance::FootIKMaxHeight' has a wrong offset!");
static_assert(offsetof(UCopyPlayerAnimInstance, FootIKOffset_Left) == 0x000290, "Member 'UCopyPlayerAnimInstance::FootIKOffset_Left' has a wrong offset!");
static_assert(offsetof(UCopyPlayerAnimInstance, FootIKOffset_Right) == 0x00029C, "Member 'UCopyPlayerAnimInstance::FootIKOffset_Right' has a wrong offset!");
static_assert(offsetof(UCopyPlayerAnimInstance, FootIKJointTargetLocation_Left) == 0x0002A8, "Member 'UCopyPlayerAnimInstance::FootIKJointTargetLocation_Left' has a wrong offset!");
static_assert(offsetof(UCopyPlayerAnimInstance, FootIKJointTargetLocation_Right) == 0x0002B4, "Member 'UCopyPlayerAnimInstance::FootIKJointTargetLocation_Right' has a wrong offset!");
static_assert(offsetof(UCopyPlayerAnimInstance, _MeshOffset) == 0x0002C0, "Member 'UCopyPlayerAnimInstance::_MeshOffset' has a wrong offset!");

// Class BattlePrototype.UIConfigGraphics
// 0x0090 (0x0418 - 0x0388)
class UUIConfigGraphics : public UUIBase
{
public:
	uint8                                         Pad_388[0x90];                                     // 0x0388(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UREDScrollBoxSimple* ScrollBox, class UUIConfigSelect3* UiAntiAliasingQuality, class UUIConfigSelect2* UiVSync, class UUIConfigSelect3* UiTextureQuality, class UUIConfigSelect3* UiShadowQuality, class UUIConfigSelect3* UiPostProccessingQuality, class UUIConfigSelectMulti* UiResolution, class UUIConfigSelect3* UiWindowMode, class UUIConfigSelect3* UiFrameRate);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigGraphics">();
	}
	static class UUIConfigGraphics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigGraphics>();
	}
};
static_assert(alignof(UUIConfigGraphics) == 0x000008, "Wrong alignment on UUIConfigGraphics");
static_assert(sizeof(UUIConfigGraphics) == 0x000418, "Wrong size on UUIConfigGraphics");

// Class BattlePrototype.CosmosSaveTest
// 0x0018 (0x0040 - 0x0028)
class UCosmosSaveTest final : public USaveGame
{
public:
	TArray<struct FCosmosSaveImageBuf>            ImageData;                                         // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddImageData(const TArray<uint8>& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CosmosSaveTest">();
	}
	static class UCosmosSaveTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCosmosSaveTest>();
	}
};
static_assert(alignof(UCosmosSaveTest) == 0x000008, "Wrong alignment on UCosmosSaveTest");
static_assert(sizeof(UCosmosSaveTest) == 0x000040, "Wrong size on UCosmosSaveTest");
static_assert(offsetof(UCosmosSaveTest, ImageData) == 0x000028, "Member 'UCosmosSaveTest::ImageData' has a wrong offset!");

// Class BattlePrototype.CosmosWebManager
// 0x0490 (0x06C0 - 0x0230)
class ACosmosWebManager : public AActor
{
public:
	uint8                                         Pad_230[0x38];                                     // 0x0230(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TitleCd;                                           // 0x0268(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Limitsec;                                          // 0x0270(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeOutSec;                                        // 0x0274(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RetryCount;                                        // 0x0278(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResultOK;                                          // 0x027C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResultMaintenance;                                 // 0x0280(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResponseOK;                                        // 0x0284(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SessionNG;                                         // 0x0288(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SessionTimeout;                                    // 0x028C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResponseNotExistUser;                              // 0x0290(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaMax;                                           // 0x0294(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseYear;                                          // 0x0298(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseMonth;                                         // 0x029C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseDay;                                           // 0x02A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoginSkuType;                                      // 0x02A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RankingGetNum;                                     // 0x02A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SealDistnce;                                       // 0x02AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugConnsectTime;                                 // 0x02C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ErrorCodeSuccess;                                  // 0x02C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimeInterlockingProgressIdYuito;                  // 0x02C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimeInterlockingProgressIdKasane;                 // 0x02CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimeInterlockingContentsId;                       // 0x02D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimeInterlockingTssSlotTop;                       // 0x02D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnvInitialized;                                  // 0x02D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRunningAuthEvent;                                // 0x02D9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRunningWebEvent;                                 // 0x02DA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRunningWebLoginEvent;                            // 0x02DB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRunningWebSubEvent;                              // 0x02DC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRunningWebSealEvent;                             // 0x02DD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRunningHttpEvet;                                 // 0x02DE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRunningMainEvent;                                // 0x02DF(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Platform;                                          // 0x02E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCosmosResultParam                     ResultParam;                                       // 0x02E8(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosSysGetEnvResponse               SysGetEnvResponse;                                 // 0x0310(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosSysKpiParam                     SysKpiParam;                                       // 0x0328(0x0010)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmsoSysKpiResponse                  SysKpiResponse;                                    // 0x0338(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCosmosSysAgreeKpiParam                SysAgreeKpiParam;                                  // 0x033C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCosmosSysAgreeKpiResponse             SysAgreeKpiResponse;                               // 0x0340(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCosmosUserParam                       UserParam;                                         // 0x0348(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosUserResponse                    UserResponse;                                      // 0x0370(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosUserResponseV2                  UserResponseV2;                                    // 0x0388(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosTusReadParam                    TusReadParam;                                      // 0x03A8(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosTusReadResponse                 TusReadResponse;                                   // 0x03C0(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosTusWriteParam                   TusWriteParam;                                     // 0x03D8(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosTusWriteResponse                TusWriteResponse;                                  // 0x03F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCosmosRankingGetMasterResponse        RankingGetMasterResponse;                          // 0x03F8(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosRankingSetScoreParam            RankingSetScoreParam;                              // 0x0410(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosRankingSetScoreResponse         RankingSetScoreResponse;                           // 0x0438(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCosmosRankingGetByRangeParam          RankingGetByRangeParam;                            // 0x0440(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosRankingGetByRangeResponse       RankingGetByRangeResponse;                         // 0x0460(0x0030)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            RankingIDList;                                     // 0x0490(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosSavedataUploadParam             SavedataUploadParam;                               // 0x04E0(0x0048)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosSavedataUploadResponse          SavedataUploadResponse;                            // 0x0528(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_52C[0x4];                                      // 0x052C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCosmosSavedataDownloadParam           SavedataDownloadParam;                             // 0x0530(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosSavedataDownloadResponse        SavedataDownloadResponse;                          // 0x0548(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosSavedataDeleteParam             SavedataDeleteParam;                               // 0x0560(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosSavedataDeleteResponse          SavedataDeleteResponse;                            // 0x0578(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_57C[0x4];                                      // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URSFrameGrabberComponent*               FrameGrabberComponent;                             // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FCosmosSealInfo>   SealInfoList;                                      // 0x0588(0x0050)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<int32>                                 HttpLastErrorCode;                                 // 0x05D8(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCosmosHugeTssReadListParam            HugeTssReadListParam;                              // 0x05E8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F4[0x4];                                      // 0x05F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCosmosHugeTssReadListResponse         HugeTssReadListResponse;                           // 0x05F8(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FAnimeInterlockingURL>          PlayableQuestList;                                 // 0x0610(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimeInterlockingAnswer               AnimeInterlockingAnswer;                           // 0x0620(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void(bool bCommunicationSuccess, TArray<class FString>& QuestList)> GetPlayableQuestsDelegate;                         // 0x0640(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(bool bCommunicationSuccess, class FName QuestName, TArray<class FString>& Answers)> GetQuestAnswersDelegate;                           // 0x0650(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(bool bCommunicationSuccess, bool bCorrect)> CheckAnswerDelegate;                               // 0x0660(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	EAnimeInterlockingState                       AnimeInterlockingState;                            // 0x0670(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimeInterlockingErrorType                   AnimeInterlockingErrorType;                        // 0x0671(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AnimeInterlockingIsGetPlayableQuestListLoaded;     // 0x0672(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AnimeInterlockingIsAnswerSuccess;                  // 0x0673(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AnimeInterlockingIsAnswerLoaded;                   // 0x0674(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_675[0x3];                                      // 0x0675(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UUITitleCrossSave_UpdatingWidget*       UITitleCrossSave_UpdatingWidget;                   // 0x0678(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_680[0x40];                                     // 0x0680(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Base64ToBase64Url(const class FString& Base64, class FString* Base64Url);
	void Base64UrlToBase64(const class FString& Base64Url, class FString* Base64);
	bool CallCheckAnswerDelegate(const class FString& QuestName, const class FString& Answer);
	void CallGetPlayableQuestListDelegate(bool bForceFinish);
	void CallGetQuestAnswersDelegate(class FName QuestName);
	bool CheckSealPosition(const struct FVector& Pos);
	void ClearAllSeal(float StartDelay, float Duration);
	void CosmosAddBrainMessage(class UObject* WorldContextObject);
	void CosmosAgreeKpiEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, int32 AgreeFlag);
	void CosmosAgreeKpiEventInternal();
	void CosmosAgreeKpiEventNoLatent(int32 AgreeFlag);
	bool CosmosAnimeInterlockingGetErrorCode(int32* ErrorCode);
	bool CosmosAnimeInterlockingIsMaintenance();
	void CosmosCheckAnswerEventInternal(const struct FAmieInterlockingCheckAnswer& Param);
	void CosmosCoreAgreeKpiEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void CosmosCoreAgreeKpiEventInternal();
	void CosmosCoreGetEnvEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void CosmosCoreGetEvnEventInternal();
	void CosmosGetEnvEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void CosmosGetEvnEventInternal();
	void CosmosGetPlayableQuestEventInternal(int32 Region, int32 Use, int32 Language, bool IsWait);
	void CosmosGetPlayableQuestList(bool* IsConnectSuccess, TArray<class FString>* QuestList);
	bool CosmosGetQuestAnswers(class FName QuestName, TArray<class FString>* Answers);
	void CosmosGetQuestAnswersEventInternal(class FName QuestName);
	void CosmosHttpEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const class FString& QuestName, bool IsCheckAnswer);
	bool CosmosHttpRequest(const class FString& QuestName);
	bool CosmosIsLoadedPlayableQuestList();
	bool CosmosIsQuestAnswerLoaded(const class FString& QuestName);
	bool CosmosRequestCheckAnswer(class FName QuestName, const class FString& Answer);
	bool CosmosRequestGetPlayableQuestList();
	bool CosmosRequestGetPlayableQuestListNoWait();
	bool CosmosRequestGetQuestAnswers(class FName QuestName);
	void CosmosResetAnimeInterlocking();
	void CosmosSetLoading();
	void CosmosUserConvertUserIdEventNoLatent(const TArray<class FString>& PlatformUserIDList);
	void CosmosWebCoreEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, ECosmosWebAPIType Type);
	void CosmosWebCoreEventInternal(ECosmosWebAPIType Type);
	void CosmosWebCoreLoginEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void CosmosWebCoreLoginEventInternal();
	void CosmosWebEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, ECosmosWebAPIType Type);
	void CosmosWebEventInternal(ECosmosWebAPIType Type);
	void CosmosWebEventNoLatent(ECosmosWebAPIType Type);
	void CosmosWebGetRankingEventInternal();
	void CosmosWebGetRankingEvnet(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const class FString& AreaName, int32 RankingType, int32 StartRank, int32 GetNum);
	void CosmosWebLoginEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void CosmosWebLoginEventInternal();
	void CosmosWebSealEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, int32 SlotNo, const class FString& TusData, const class FString& AreaName, const class FString& RankingUserData);
	void CosmosWebSealEventInternal();
	void CosmosWebSetRankingEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const class FString& AreaName, const class FString& UserData);
	void CosmosWebSetRankingEventInternal();
	void CosmosWebTusReadEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const class FString& UserId, int32 SlotNo);
	void CosmosWebTusReadEventInternal();
	void CosmosWebTusWriteEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, int32 SlotNo, const class FString& TusData);
	void CosmosWebTusWriteEventInternal();
	void CosmsoAddNotificationBrainMessageEventInternal();
	void CreateRankingUserData(class UObject* WorldContextObject, const struct FCosmosRankingUserData& RankingUserData, class FString* UserData);
	void CreateTusData(const struct FVector& Pos, const struct FRotator& Rotate, const TArray<uint8>& Image, class FString* TusData);
	void DebugSetAnswers(const class FString& QuestName);
	void DebugSetOverwriteErrorType(EAnimeInterlockingErrorType ErrorType);
	void DebugSetQuestForceFail(bool bSet);
	void DebugSetQuestForceSuccess(bool bSet);
	void DebugSetQuestList();
	void DebugSetQuestRelease(int32 Index_0);
	void DebugWriteHttp();
	void DebugWriteParam(ECosmosWebAPIType Type, const class FString& URL, const class FString& UserId, const class FString& SessionID, bool IsSend);
	void DecryptImageData(const TArray<uint8>& TusData, TArray<uint8>* Buff);
	void EnvFinalize();
	int32 EnvInitialize();
	void EnvironmentRebuild();
	bool EnvironmentValidate();
	int32 EnvUpdate();
	bool GetAgreeKpiFlg(const class UObject* WorldContextObject);
	void GetBaseURL(class FName* baseUrl);
	void GetBaseURL_V2(ECosmosWebAPIType Type, class FName* baseUrl);
	void GetBitMap(class UTextureRenderTarget2D* Target, int32 Quality, TArray<uint8>* Buff);
	void GetIssuerID(int32* IssuerID);
	class FString GetLoginTalken();
	class FString GetRankingName(const class FString& Json);
	void GetRankingUserData(class UObject* WorldContextObject, const class FString& UserData, struct FCosmosRankingUserData* RankingUserData);
	int32 GetRegion();
	bool GetTokenAndSignature();
	void GetTusData(class UObject* WorldContextObject, const class FString& Data, struct FCosmosTusData* TusData);
	bool IsCompleteTokenAndSignature();
	bool IsEnvironmentBuildComplete();
	bool IsRunningCosmosWebAPI();
	void ReceiveErrorResponse(ECosmosWebAPIType Type, int32 RespCode);
	bool RequestAddNotificationBrainMessage();
	bool RequestGetPlayableQuestListInternal(bool IsWait);
	bool SetPlayableQuestList(bool IsTimeOut);
	void SpawnSealByWebData(const class UObject* WorldContextObject, class UMaterialInterface* DecalMaterial, const class FString& AreaName);
	void UserConvertUserIdResponseEventBroadcast(const struct FCosmosUserConvertUserIdResponseParam& Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CosmosWebManager">();
	}
	static class ACosmosWebManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACosmosWebManager>();
	}
};
static_assert(alignof(ACosmosWebManager) == 0x000008, "Wrong alignment on ACosmosWebManager");
static_assert(sizeof(ACosmosWebManager) == 0x0006C0, "Wrong size on ACosmosWebManager");
static_assert(offsetof(ACosmosWebManager, TitleCd) == 0x000268, "Member 'ACosmosWebManager::TitleCd' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, Limitsec) == 0x000270, "Member 'ACosmosWebManager::Limitsec' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, TimeOutSec) == 0x000274, "Member 'ACosmosWebManager::TimeOutSec' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, RetryCount) == 0x000278, "Member 'ACosmosWebManager::RetryCount' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, ResultOK) == 0x00027C, "Member 'ACosmosWebManager::ResultOK' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, ResultMaintenance) == 0x000280, "Member 'ACosmosWebManager::ResultMaintenance' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, ResponseOK) == 0x000284, "Member 'ACosmosWebManager::ResponseOK' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SessionNG) == 0x000288, "Member 'ACosmosWebManager::SessionNG' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SessionTimeout) == 0x00028C, "Member 'ACosmosWebManager::SessionTimeout' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, ResponseNotExistUser) == 0x000290, "Member 'ACosmosWebManager::ResponseNotExistUser' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AreaMax) == 0x000294, "Member 'ACosmosWebManager::AreaMax' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, BaseYear) == 0x000298, "Member 'ACosmosWebManager::BaseYear' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, BaseMonth) == 0x00029C, "Member 'ACosmosWebManager::BaseMonth' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, BaseDay) == 0x0002A0, "Member 'ACosmosWebManager::BaseDay' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, LoginSkuType) == 0x0002A4, "Member 'ACosmosWebManager::LoginSkuType' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, RankingGetNum) == 0x0002A8, "Member 'ACosmosWebManager::RankingGetNum' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SealDistnce) == 0x0002AC, "Member 'ACosmosWebManager::SealDistnce' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, DebugConnsectTime) == 0x0002C0, "Member 'ACosmosWebManager::DebugConnsectTime' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, ErrorCodeSuccess) == 0x0002C4, "Member 'ACosmosWebManager::ErrorCodeSuccess' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingProgressIdYuito) == 0x0002C8, "Member 'ACosmosWebManager::AnimeInterlockingProgressIdYuito' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingProgressIdKasane) == 0x0002CC, "Member 'ACosmosWebManager::AnimeInterlockingProgressIdKasane' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingContentsId) == 0x0002D0, "Member 'ACosmosWebManager::AnimeInterlockingContentsId' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingTssSlotTop) == 0x0002D4, "Member 'ACosmosWebManager::AnimeInterlockingTssSlotTop' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, IsEnvInitialized) == 0x0002D8, "Member 'ACosmosWebManager::IsEnvInitialized' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, IsRunningAuthEvent) == 0x0002D9, "Member 'ACosmosWebManager::IsRunningAuthEvent' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, IsRunningWebEvent) == 0x0002DA, "Member 'ACosmosWebManager::IsRunningWebEvent' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, IsRunningWebLoginEvent) == 0x0002DB, "Member 'ACosmosWebManager::IsRunningWebLoginEvent' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, IsRunningWebSubEvent) == 0x0002DC, "Member 'ACosmosWebManager::IsRunningWebSubEvent' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, IsRunningWebSealEvent) == 0x0002DD, "Member 'ACosmosWebManager::IsRunningWebSealEvent' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, IsRunningHttpEvet) == 0x0002DE, "Member 'ACosmosWebManager::IsRunningHttpEvet' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, IsRunningMainEvent) == 0x0002DF, "Member 'ACosmosWebManager::IsRunningMainEvent' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, Platform) == 0x0002E0, "Member 'ACosmosWebManager::Platform' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, ResultParam) == 0x0002E8, "Member 'ACosmosWebManager::ResultParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SysGetEnvResponse) == 0x000310, "Member 'ACosmosWebManager::SysGetEnvResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SysKpiParam) == 0x000328, "Member 'ACosmosWebManager::SysKpiParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SysKpiResponse) == 0x000338, "Member 'ACosmosWebManager::SysKpiResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SysAgreeKpiParam) == 0x00033C, "Member 'ACosmosWebManager::SysAgreeKpiParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SysAgreeKpiResponse) == 0x000340, "Member 'ACosmosWebManager::SysAgreeKpiResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, UserParam) == 0x000348, "Member 'ACosmosWebManager::UserParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, UserResponse) == 0x000370, "Member 'ACosmosWebManager::UserResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, UserResponseV2) == 0x000388, "Member 'ACosmosWebManager::UserResponseV2' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, TusReadParam) == 0x0003A8, "Member 'ACosmosWebManager::TusReadParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, TusReadResponse) == 0x0003C0, "Member 'ACosmosWebManager::TusReadResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, TusWriteParam) == 0x0003D8, "Member 'ACosmosWebManager::TusWriteParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, TusWriteResponse) == 0x0003F0, "Member 'ACosmosWebManager::TusWriteResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, RankingGetMasterResponse) == 0x0003F8, "Member 'ACosmosWebManager::RankingGetMasterResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, RankingSetScoreParam) == 0x000410, "Member 'ACosmosWebManager::RankingSetScoreParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, RankingSetScoreResponse) == 0x000438, "Member 'ACosmosWebManager::RankingSetScoreResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, RankingGetByRangeParam) == 0x000440, "Member 'ACosmosWebManager::RankingGetByRangeParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, RankingGetByRangeResponse) == 0x000460, "Member 'ACosmosWebManager::RankingGetByRangeResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, RankingIDList) == 0x000490, "Member 'ACosmosWebManager::RankingIDList' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SavedataUploadParam) == 0x0004E0, "Member 'ACosmosWebManager::SavedataUploadParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SavedataUploadResponse) == 0x000528, "Member 'ACosmosWebManager::SavedataUploadResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SavedataDownloadParam) == 0x000530, "Member 'ACosmosWebManager::SavedataDownloadParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SavedataDownloadResponse) == 0x000548, "Member 'ACosmosWebManager::SavedataDownloadResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SavedataDeleteParam) == 0x000560, "Member 'ACosmosWebManager::SavedataDeleteParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SavedataDeleteResponse) == 0x000578, "Member 'ACosmosWebManager::SavedataDeleteResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, FrameGrabberComponent) == 0x000580, "Member 'ACosmosWebManager::FrameGrabberComponent' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SealInfoList) == 0x000588, "Member 'ACosmosWebManager::SealInfoList' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, HttpLastErrorCode) == 0x0005D8, "Member 'ACosmosWebManager::HttpLastErrorCode' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, HugeTssReadListParam) == 0x0005E8, "Member 'ACosmosWebManager::HugeTssReadListParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, HugeTssReadListResponse) == 0x0005F8, "Member 'ACosmosWebManager::HugeTssReadListResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, PlayableQuestList) == 0x000610, "Member 'ACosmosWebManager::PlayableQuestList' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingAnswer) == 0x000620, "Member 'ACosmosWebManager::AnimeInterlockingAnswer' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, GetPlayableQuestsDelegate) == 0x000640, "Member 'ACosmosWebManager::GetPlayableQuestsDelegate' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, GetQuestAnswersDelegate) == 0x000650, "Member 'ACosmosWebManager::GetQuestAnswersDelegate' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, CheckAnswerDelegate) == 0x000660, "Member 'ACosmosWebManager::CheckAnswerDelegate' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingState) == 0x000670, "Member 'ACosmosWebManager::AnimeInterlockingState' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingErrorType) == 0x000671, "Member 'ACosmosWebManager::AnimeInterlockingErrorType' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingIsGetPlayableQuestListLoaded) == 0x000672, "Member 'ACosmosWebManager::AnimeInterlockingIsGetPlayableQuestListLoaded' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingIsAnswerSuccess) == 0x000673, "Member 'ACosmosWebManager::AnimeInterlockingIsAnswerSuccess' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingIsAnswerLoaded) == 0x000674, "Member 'ACosmosWebManager::AnimeInterlockingIsAnswerLoaded' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, UITitleCrossSave_UpdatingWidget) == 0x000678, "Member 'ACosmosWebManager::UITitleCrossSave_UpdatingWidget' has a wrong offset!");

// Class BattlePrototype.DebugWarpPointBase
// 0x0000 (0x0230 - 0x0230)
class ADebugWarpPointBase final : public AActor
{
public:
	class FName GetWarpPointName();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugWarpPointBase">();
	}
	static class ADebugWarpPointBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugWarpPointBase>();
	}
};
static_assert(alignof(ADebugWarpPointBase) == 0x000008, "Wrong alignment on ADebugWarpPointBase");
static_assert(sizeof(ADebugWarpPointBase) == 0x000230, "Wrong size on ADebugWarpPointBase");

// Class BattlePrototype.UIMiniMap
// 0x0150 (0x04D8 - 0x0388)
class UUIMiniMap : public UUIBase
{
public:
	class FName                                   M_SceneName;                                       // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ConfigMiniMapDisp;                                 // 0x0390(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ConfigMiniMapScale;                                // 0x0391(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ConfigMiniMapRotate;                               // 0x0392(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_393[0x1];                                      // 0x0393(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_limit;                                           // 0x0394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABP_UI_SceneMap*                        M_ParentSceneMap;                                  // 0x0398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIMiniMainQuestGoal*                   M_MainQuestGoalWidgete;                            // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIMiniSubQuestGoal*                    M_SubQuestGoalWidgete;                             // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIMiniBondsQuestGoal*                  M_BondsQuestGoalWidgete;                           // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              M_VectorCenter;                                    // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              M_VectorNorthRadios;                               // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              M_VectorQuestIconRadios;                           // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_DebugFlagNative;                                 // 0x03D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D1[0xE7];                                     // 0x03D1(0x00E7)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSHUDBase*                             M_pHudBase;                                        // 0x04B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerController*                      M_PlayerController;                                // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIMinimapDistance*>             M_MinimapDistanceData;                             // 0x04C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CloseMinimap();
	bool CreateMapSetting();
	void EndMinimapBrainField();
	void ForceLoadMap();
	void GetActiveSubquest(class FName* SubquestName, class FName* SubQuestID, bool* Flag);
	bool GetDebugFlagNative();
	TSubclassOf<class ABP_UI_SceneMap> GetMinimapRefalence(const class FString& Path);
	void InitializeAnime(class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_, class UWidgetAnimation* Out_noise, class UWidgetAnimation* In_noise, class UWidgetAnimation* Default_noise);
	void InitializeDirectionImage(class UImage* Imagemain, class UImage* Imagekizuna);
	void InitializeImage(class UImage* Imagecamera, class UImage* Imageplayer);
	void InitializeMinimap(class UOverlay* Allset);
	void InitializeMinimapDistance(class UUIMinimapDistance* Distance, int32 Num);
	void InitializeNorthWidget(class UUserWidget* Widgetnorthring, class UUserWidget* Widgetnorthicon, class UUserWidget* Widgetnorthstring);
	void InitializePlayerWidget(class UUserWidget* Widgetcamera, class UUserWidget* Widgetplayer);
	bool InitIcon_Etc_Native();
	bool IsBrainField();
	bool MapOpenListSetting(int32 AreaNo);
	bool MinimapMaterialBrainfield(bool Flag);
	void OnAfterChangeProgress();
	void OpenMinimap();
	bool ReleaseMapSetting();
	void SetBrainField(bool Flag);
	bool SetDirectionDest();
	void SetDirectionDestNative();
	bool SetDirectionDestSubQuest(class FName SubquestTitle, class FName SubQuestID, bool Flag);
	void SetDistanceReset();
	void SetDistanceSetting(EUIMinmapDistanceIcon Icontype);
	void SetThumbnail(int32 Icon);
	bool SetWidgetCameraThumbnail(const class UObject* WorldContextObject, class UImage* Image, int32 Index_0);
	bool SetWidgetPlayerThumbnail(const class UObject* WorldContextObject, class UImage* Image, int32 Index_0);
	void StartMinimapBrainField();
	bool UpdateConfigSetting();
	void UpdateStateMinimap(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiniMap">();
	}
	static class UUIMiniMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMiniMap>();
	}
};
static_assert(alignof(UUIMiniMap) == 0x000008, "Wrong alignment on UUIMiniMap");
static_assert(sizeof(UUIMiniMap) == 0x0004D8, "Wrong size on UUIMiniMap");
static_assert(offsetof(UUIMiniMap, M_SceneName) == 0x000388, "Member 'UUIMiniMap::M_SceneName' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, ConfigMiniMapDisp) == 0x000390, "Member 'UUIMiniMap::ConfigMiniMapDisp' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, ConfigMiniMapScale) == 0x000391, "Member 'UUIMiniMap::ConfigMiniMapScale' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, ConfigMiniMapRotate) == 0x000392, "Member 'UUIMiniMap::ConfigMiniMapRotate' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_limit) == 0x000394, "Member 'UUIMiniMap::M_limit' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_ParentSceneMap) == 0x000398, "Member 'UUIMiniMap::M_ParentSceneMap' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_MainQuestGoalWidgete) == 0x0003A0, "Member 'UUIMiniMap::M_MainQuestGoalWidgete' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_SubQuestGoalWidgete) == 0x0003A8, "Member 'UUIMiniMap::M_SubQuestGoalWidgete' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_BondsQuestGoalWidgete) == 0x0003B0, "Member 'UUIMiniMap::M_BondsQuestGoalWidgete' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_VectorCenter) == 0x0003B8, "Member 'UUIMiniMap::M_VectorCenter' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_VectorNorthRadios) == 0x0003C0, "Member 'UUIMiniMap::M_VectorNorthRadios' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_VectorQuestIconRadios) == 0x0003C8, "Member 'UUIMiniMap::M_VectorQuestIconRadios' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_DebugFlagNative) == 0x0003D0, "Member 'UUIMiniMap::M_DebugFlagNative' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_pHudBase) == 0x0004B8, "Member 'UUIMiniMap::M_pHudBase' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_PlayerController) == 0x0004C0, "Member 'UUIMiniMap::M_PlayerController' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_MinimapDistanceData) == 0x0004C8, "Member 'UUIMiniMap::M_MinimapDistanceData' has a wrong offset!");

// Class BattlePrototype.CosmosWebManagerUtility
// 0x0000 (0x0028 - 0x0028)
class UCosmosWebManagerUtility final : public UBlueprintFunctionLibrary
{
public:
	static void CosmosAddKpiOrg10_ItemsUsed(EConsumeItemID Item_id, int32 Num);
	static void CosmosAddKpiOrg19_PlayedPhases(int32 brainSpaceActivation_cnt);
	static void CosmosAddKpiOrg6_PlayedPhases(EPlayerID Members_id, int32 Num);
	static void CosmosAddKpiOrg7_PlayedPhases(int32 brainCrash_type, int32 Num);
	static void CosmosAddKpiOrg8_PlayedPhases(int32 EnemySubjugation_cnt, int32 EnemySubjugation_brainCrash_0type_cnt, int32 EnemySubjugation_brainCrash_1type_cnt);
	static void CosmosAddKpiOrg9_PlayedPhases(EPlayerID Members_id, int32 SupportType, int32 Num);
	static void CosmosClearParam();
	static void CosmosEndBattle();
	static void CosmosEndEvent();
	static void CosmosEndIngame();
	static void CosmosEndMenu();
	static void CosmosGetPlatformUserID(class APlayerController* PlayerController, class FString* PlatformUserID, bool* Result);
	static bool CosmosIsSendedAtOnce();
	static void CosmosResetKpiParam();
	static void CosmosResetSendedAtOnce();
	static void CosmosSendedAtOnce();
	static void CosmosSendKpi10_CurrencyCirculation();
	static bool CosmosSendKpi10_IsDirtyCurrencyCirculation();
	static bool CosmosSendKpi14_IsDirtyPlayedPhases();
	static void CosmosSendKpi14_PlayedPhases();
	static bool CosmosSendKpi16_IsDirtyPlayedPhasesSelectedMembers();
	static void CosmosSendKpi16_PlayedPhasesSelectedMembers();
	static void CosmosSendKpi17_Sale(const class UObject* WorldContextObject);
	static void CosmosSendKpi22_GameLanguage();
	static void CosmosSendKpi289_Upgrade();
	static bool CosmosSendKpi5_IsDirtyTimePlayed();
	static void CosmosSendKpi5_ResetTimePlayed();
	static void CosmosSendKpi5_TimePlayed();
	static void CosmosSendKpi7_Ending();
	static void CosmosSendKpi7_PlayedPhaseLevel();
	static void CosmosSendKpi7_PlayedQuestLevel(class FName Sub_quest_id);
	static void CosmosSendKpi7_Progress();
	static void CosmosSendKpi7_Quest(class FName Sub_quest_id);
	static void CosmosSendKpiOrg10_Avoidance(int32 Avoidancestate_0type_cnt, int32 Avoidancestate_1type_cnt, int32 Avoidancestate_2type_cnt, int32 Avoidancestate_3type_cnt, int32 Avoidancestate_4type_cnt);
	static void CosmosSendKpiOrg10_GameOver(int32 GameOverState, class FName Enemy);
	static bool CosmosSendKpiOrg10_IsDirtyItemsUsed();
	static void CosmosSendKpiOrg10_ItemsUsed();
	static void CosmosSendKpiOrg10_Retry(class FName Enemy);
	static void CosmosSendKpiOrg13_Attachment();
	static void CosmosSendKpiOrg13_BackupAttachment();
	static void CosmosSendKpiOrg13_BackupCostume();
	static void CosmosSendKpiOrg13_Costume();
	static bool CosmosSendKpiOrg13_IsDirtyAttachment();
	static bool CosmosSendKpiOrg13_IsDirtyCostume();
	static void CosmosSendKpiOrg13_Plugin();
	static void CosmosSendKpiOrg13_Weapon();
	static void CosmosSendKpiOrg14_Brightness(float Brightness);
	static void CosmosSendKpiOrg14_Config(EHCGameDifficulty Difficult_id, EAttackAutoLockOn AttackAutoLockOn, ETargetCameraTrace TargetCameraTrace, ECameraAfterMoveType CameraAfterMoveType, EOptionDisplayEnemyDamage DispEnemyDamage, EOptionMinimapDisplay MinimapDisplay, EOptionMinimapRotation MinimapRotation, EOptionMinimapScaling MinimapScaling, EEventMessageAutoPlay MessageAutoPlay, uint8 CameraSpeed, EOptionCameraPitch CameraPitch, EOptionCameraYaw CameraYaw, EOptionControllerVibration Vibration);
	static void CosmosSendKpiOrg14_Controller(ERSGamepadInputName WeaponAttack, ERSGamepadInputName Jump, ERSGamepadInputName StrafeAndDash, ERSGamepadInputName SpecialAttack, ERSGamepadInputName ActivateSASMenu, ERSGamepadInputName EnableComboVisionMenu, ERSGamepadInputName PKAttack, ERSGamepadInputName SpecialObjectAndBrainCrush, ELockonActionType ChangeLockOnTarget);
	static void CosmosSendKpiOrg14_Graphic(bool IsVerticalSyncOff, EOptionAAQuality AntiAliasingQuality, EGradualQuality TextureQuality, EGradualQuality ShadowQuality, EGradualQuality PostQuality, EWindowMode WindowMode, EFPSType FpsType);
	static void CosmosSendKpiOrg16_PlayedPhases(EPlayerSkill Skill_id);
	static void CosmosSendKpiOrg17_ShopsUsed(int32 Status, class FName Item);
	static void CosmosSendKpiOrg17_ShopVisits();
	static bool CosmosSendKpiOrg19_IsDirtyPlayedPhases();
	static void CosmosSendKpiOrg19_PlayedPhases(class FName Location);
	static void CosmosSendKpiOrg1_LapInfo(EPlayerID Character_id);
	static void CosmosSendKpiOrg21_GameVoice(ETextLanguage TextLanguage);
	static void CosmosSendKpiOrg3_KizunaEpisodeInfo(EPlayerID Members_id);
	static void CosmosSendKpiOrg3_TeamKizunaEpisodeInfo(const class FString& Team_kizuna_episode_id);
	static void CosmosSendKpiOrg4_PresentInfo(EPlayerID Members_id, class FName Present_id);
	static void CosmosSendKpiOrg5_KizunaLevel(EPlayerID Members_id);
	static bool CosmosSendKpiOrg6_IsDirtyPlayedPhases();
	static void CosmosSendKpiOrg6_PlayedPhases();
	static bool CosmosSendKpiOrg7_IsDirtyPlayedPhases();
	static void CosmosSendKpiOrg7_PlayedPhases(class FName Location);
	static bool CosmosSendKpiOrg8_IsDirtyPlayedPhases();
	static void CosmosSendKpiOrg8_PlayedPhases(int32 DriveModeActivation_num, int32 DriveModeActivation_time);
	static bool CosmosSendKpiOrg9_IsDirtyPlayedPhases();
	static void CosmosSendKpiOrg9_PlayedPhases(class FName Location);
	static void CosmosSendKpiParam();
	static void CosmosSendKpiParamAfterSave();
	static void CosmosSendKpiParamAtFirst();
	static void CosmosSendKpiParamGameover();
	static void CosmosSendKpiParamMapChange();
	static void CosmosSendKpiParamNextPhase();
	static void CosmosSendKpiParamStartGame(const class UObject* WorldContextObject);
	static void CosmosStartBattle();
	static void CosmosStartEvent();
	static void CosmosStartIngame();
	static void CosmosStartMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CosmosWebManagerUtility">();
	}
	static class UCosmosWebManagerUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCosmosWebManagerUtility>();
	}
};
static_assert(alignof(UCosmosWebManagerUtility) == 0x000008, "Wrong alignment on UCosmosWebManagerUtility");
static_assert(sizeof(UCosmosWebManagerUtility) == 0x000028, "Wrong size on UCosmosWebManagerUtility");

// Class BattlePrototype.MapGimmickManager
// 0x0108 (0x0338 - 0x0230)
class AMapGimmickManager : public ARSActorSystemBase
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnBeginOverlapMapGimmickAreaEvent;                 // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndOverlapMapGimmickAreaEvent;                   // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExecMapGimmickEvent;                             // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeFinishedMapGimmickEvent;                   // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeReuseStartMapGimmickEvent;                 // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class FString>                         FinishedGimmickNames;                              // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         AllMapGimmicks;                                    // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AGimmickTriggerVolume*>          AllTriggerVolumes;                                 // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AMapGimmickObject*>              ActivatedMapGimmicks;                              // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FMovingRoadActor>               MovingActors;                                      // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<uint8>                                 LiftFloorList;                                     // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EMapGimmickType, int32>                  GimmickUseTimeMap;                                 // 0x02E8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	bool ActivateMapGimmick(class AMapGimmickObject* Map_gimmick);
	bool AddMapGimmickUseTime(class AMapGimmickObject* Gimmick);
	bool CallOnBeginOverlapMapGimmickAreaEvent(class AMapGimmickObject* Map_gimmick);
	bool CallOnChangeFinishedMapGimmickEvent(class AMapGimmickObject* Map_gimmick);
	bool CallOnChangeReuseStartMapGimmickEvent(class AMapGimmickObject* Map_gimmick);
	bool CallOnEndOverlapMapGimmickAreaEvent(class AMapGimmickObject* Map_gimmick);
	bool CallOnExecMapGimmickEvent(class AMapGimmickObject* Map_gimmick);
	bool CanChargeMapGimmick(class AMapGimmickObject* Map_gimmick);
	bool DeactivateMapGimmick(class AMapGimmickObject* Map_gimmick);
	int32 GetLiftFloor(ELiftFloorInfoId ID);
	int32 GetMapGimmickUseTime(EMapGimmickType Type);
	void InitializeAreaData();
	void InitializeAtAreaStart();
	void OnBeginOverlapMovingRoad(class AActor* Actor, class AActor* RoadActor);
	void OnEndOverlapMovingRoad(class AActor* Actor, class AActor* RoadActor);
	void RegisterMapGimmick(class AActor* Actor);
	bool RequestToMapGimmick(EMapGimmickStateRequest Request, class AMapGimmickObject* Map_gimmick);
	void SetLiftFloor(ELiftFloorInfoId ID, int32 Floor);

	bool IsActivatedMapGimmick(class AMapGimmickObject* Map_gimmick) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapGimmickManager">();
	}
	static class AMapGimmickManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapGimmickManager>();
	}
};
static_assert(alignof(AMapGimmickManager) == 0x000008, "Wrong alignment on AMapGimmickManager");
static_assert(sizeof(AMapGimmickManager) == 0x000338, "Wrong size on AMapGimmickManager");
static_assert(offsetof(AMapGimmickManager, OnBeginOverlapMapGimmickAreaEvent) == 0x000238, "Member 'AMapGimmickManager::OnBeginOverlapMapGimmickAreaEvent' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, OnEndOverlapMapGimmickAreaEvent) == 0x000248, "Member 'AMapGimmickManager::OnEndOverlapMapGimmickAreaEvent' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, OnExecMapGimmickEvent) == 0x000258, "Member 'AMapGimmickManager::OnExecMapGimmickEvent' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, OnChangeFinishedMapGimmickEvent) == 0x000268, "Member 'AMapGimmickManager::OnChangeFinishedMapGimmickEvent' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, OnChangeReuseStartMapGimmickEvent) == 0x000278, "Member 'AMapGimmickManager::OnChangeReuseStartMapGimmickEvent' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, FinishedGimmickNames) == 0x000288, "Member 'AMapGimmickManager::FinishedGimmickNames' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, AllMapGimmicks) == 0x000298, "Member 'AMapGimmickManager::AllMapGimmicks' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, AllTriggerVolumes) == 0x0002A8, "Member 'AMapGimmickManager::AllTriggerVolumes' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, ActivatedMapGimmicks) == 0x0002B8, "Member 'AMapGimmickManager::ActivatedMapGimmicks' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, MovingActors) == 0x0002C8, "Member 'AMapGimmickManager::MovingActors' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, LiftFloorList) == 0x0002D8, "Member 'AMapGimmickManager::LiftFloorList' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, GimmickUseTimeMap) == 0x0002E8, "Member 'AMapGimmickManager::GimmickUseTimeMap' has a wrong offset!");

// Class BattlePrototype.CullDistanceEffectBackgroundVolume
// 0x0010 (0x0278 - 0x0268)
class ACullDistanceEffectBackgroundVolume final : public AVolume
{
public:
	float                                         CullDistance;                                      // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Unbound;                                           // 0x0270(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorBeginOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorEndOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CullDistanceEffectBackgroundVolume">();
	}
	static class ACullDistanceEffectBackgroundVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACullDistanceEffectBackgroundVolume>();
	}
};
static_assert(alignof(ACullDistanceEffectBackgroundVolume) == 0x000008, "Wrong alignment on ACullDistanceEffectBackgroundVolume");
static_assert(sizeof(ACullDistanceEffectBackgroundVolume) == 0x000278, "Wrong size on ACullDistanceEffectBackgroundVolume");
static_assert(offsetof(ACullDistanceEffectBackgroundVolume, CullDistance) == 0x000268, "Member 'ACullDistanceEffectBackgroundVolume::CullDistance' has a wrong offset!");
static_assert(offsetof(ACullDistanceEffectBackgroundVolume, Priority) == 0x00026C, "Member 'ACullDistanceEffectBackgroundVolume::Priority' has a wrong offset!");
static_assert(offsetof(ACullDistanceEffectBackgroundVolume, Unbound) == 0x000270, "Member 'ACullDistanceEffectBackgroundVolume::Unbound' has a wrong offset!");

// Class BattlePrototype.UIPkActionIcon
// 0x0000 (0x0388 - 0x0388)
class UUIPkActionIcon : public UUIBase
{
public:
	EMouseIconType GetMouseIndex(int32 KeyIndex, bool IsEnableMouseMove);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPkActionIcon">();
	}
	static class UUIPkActionIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPkActionIcon>();
	}
};
static_assert(alignof(UUIPkActionIcon) == 0x000008, "Wrong alignment on UUIPkActionIcon");
static_assert(sizeof(UUIPkActionIcon) == 0x000388, "Wrong size on UUIPkActionIcon");

// Class BattlePrototype.CutCameraComponent
// 0x0040 (0x0100 - 0x00C0)
class UCutCameraComponent final : public UActorComponent
{
public:
	float                                         _OwnerOldCustomDilation;                           // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x3C];                                      // 0x00C4(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CameraBlendTimeUpdate();
	void ChangeCameraRequest(class FName ParameterName, bool bEnd, bool bPitchSet, float Pitch, class UMeshComponent* Mesh);
	void DebugDisableCutCamera(bool bSet);
	void Setup(class UDataTable* DataTable);

	bool IsUseCutCamera() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CutCameraComponent">();
	}
	static class UCutCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCutCameraComponent>();
	}
};
static_assert(alignof(UCutCameraComponent) == 0x000008, "Wrong alignment on UCutCameraComponent");
static_assert(sizeof(UCutCameraComponent) == 0x000100, "Wrong size on UCutCameraComponent");
static_assert(offsetof(UCutCameraComponent, _OwnerOldCustomDilation) == 0x0000C0, "Member 'UCutCameraComponent::_OwnerOldCustomDilation' has a wrong offset!");

// Class BattlePrototype.DamageAcceptInterface
// 0x0000 (0x0028 - 0x0028)
class IDamageAcceptInterface final : public IInterface
{
public:
	bool IsStartDamageAnimAdditional(const struct FHCHitResult& HitResult, int32 Damage, bool IsDown);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageAcceptInterface">();
	}
	static class IDamageAcceptInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDamageAcceptInterface>();
	}
};
static_assert(alignof(IDamageAcceptInterface) == 0x000008, "Wrong alignment on IDamageAcceptInterface");
static_assert(sizeof(IDamageAcceptInterface) == 0x000028, "Wrong size on IDamageAcceptInterface");

// Class BattlePrototype.EventFacialCaptureRenderFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UEventFacialCaptureRenderFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FEventFacialCaptureRenderSettings AddEventFacialCaptureRenderSettings(const struct FEventFacialCaptureRenderSettings& BaseSetting, const struct FEventFacialCaptureRenderSettings& OverrideSetting);
	static void ConvertEventFacialCaptureRenderSettingsToMaterialParameters(const struct FEventFacialCaptureRenderSettings& Setting, TArray<class FName>* ParameterNames, TArray<float>* ParameterValues);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventFacialCaptureRenderFunctionLibrary">();
	}
	static class UEventFacialCaptureRenderFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventFacialCaptureRenderFunctionLibrary>();
	}
};
static_assert(alignof(UEventFacialCaptureRenderFunctionLibrary) == 0x000008, "Wrong alignment on UEventFacialCaptureRenderFunctionLibrary");
static_assert(sizeof(UEventFacialCaptureRenderFunctionLibrary) == 0x000028, "Wrong size on UEventFacialCaptureRenderFunctionLibrary");

// Class BattlePrototype.UISASFrame2
// 0x0048 (0x03D0 - 0x0388)
class UUISASFrame2 : public UUIBase
{
public:
	uint8                                         Pad_388[0x48];                                     // 0x0388(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UImage* ImageSasFrame, class UImage* ImageCvFrame, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimFullIn, class UWidgetAnimation* AnimFull, class UWidgetAnimation* AnimFullOut, class UWidgetAnimation* AnimInFull, class UWidgetAnimation* AnimOutFull, class UWidgetAnimation* AnimFullIn2, class UWidgetAnimation* AnimFull2, class UWidgetAnimation* AnimInFull2, class UWidgetAnimation* AnimOutFull2, const struct FLinearColor& ColorDefault, const struct FLinearColor& ColorLockSas, const struct FLinearColor& ColorLockCv);
	void UpdateStateThis(int32 State, int32 SubState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISASFrame2">();
	}
	static class UUISASFrame2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISASFrame2>();
	}
};
static_assert(alignof(UUISASFrame2) == 0x000008, "Wrong alignment on UUISASFrame2");
static_assert(sizeof(UUISASFrame2) == 0x0003D0, "Wrong size on UUISASFrame2");

// Class BattlePrototype.DamageAcceptComponent
// 0x0208 (0x02C8 - 0x00C0)
class UDamageAcceptComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             StartDamageAnim;                                   // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             DamagePopup;                                       // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             DamageHit;                                         // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FDamageAnimParam                       ReservedDamageAnimParam;                           // 0x00F0(0x01C0)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x18];                                     // 0x02B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsEnemy();
	void TakeDamage(const struct FHCHitResult& HitResult, int32 Damage, float CrashDamage, bool IsDispDamagePoint, bool IsAnimDamage, bool IsDown);
	void TakeDamageSimple(int32 Damage, int32 ReduceGuard, bool IsDispDamagePoint, bool IsPercentDamage);

	EDamagePointKind DecideDamagePointKind() const;
	bool IsStartDamageAnim(const struct FHCHitResult& HitResult, int32 Damage, bool IsDown) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageAcceptComponent">();
	}
	static class UDamageAcceptComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageAcceptComponent>();
	}
};
static_assert(alignof(UDamageAcceptComponent) == 0x000008, "Wrong alignment on UDamageAcceptComponent");
static_assert(sizeof(UDamageAcceptComponent) == 0x0002C8, "Wrong size on UDamageAcceptComponent");
static_assert(offsetof(UDamageAcceptComponent, StartDamageAnim) == 0x0000C0, "Member 'UDamageAcceptComponent::StartDamageAnim' has a wrong offset!");
static_assert(offsetof(UDamageAcceptComponent, DamagePopup) == 0x0000D0, "Member 'UDamageAcceptComponent::DamagePopup' has a wrong offset!");
static_assert(offsetof(UDamageAcceptComponent, DamageHit) == 0x0000E0, "Member 'UDamageAcceptComponent::DamageHit' has a wrong offset!");
static_assert(offsetof(UDamageAcceptComponent, ReservedDamageAnimParam) == 0x0000F0, "Member 'UDamageAcceptComponent::ReservedDamageAnimParam' has a wrong offset!");

// Class BattlePrototype.GimmickActionBase
// 0x0080 (0x02B0 - 0x0230)
class AGimmickActionBase final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsActionEnableWhileOpen;                           // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActionEnableWhileClose;                          // 0x0239(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23A[0x6];                                      // 0x023A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActionIcon*                            ActionIcon;                                        // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          ShowBoxComponent;                                  // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          EventBoxComponent;                                 // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChildActorComponent*                   ChildActionIcon;                                   // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AMakeEventActor>            OnActionMakeEventActorClass;                       // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMakeEventActor*                        OnActionMakeEventActor;                            // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AMakeEventActor>            OnExitMakeEventActorClass;                         // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMakeEventActor*                        OnExitMakeEventActor;                              // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x4];                                      // 0x0288(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ActionIconWorldPositionOffset;                     // 0x028C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionIconType                               ActionIconType;                                    // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionIconSubQuestState                      ActionIconSubQuestState;                           // 0x0299(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsOnAction;                                        // 0x029A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsOnExit;                                          // 0x029B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGimmickObjectBase*                     TargetGimmickObject;                               // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUseActionIcon;                                   // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CallCloseEventToGimmickObject();
	bool CallOpenEventToGimmickObject();
	void DisableAction();
	bool IsActionEnable();
	void SetActionIconVisible(bool Visible);
	void UpdateActionEnable(EGimmickObjectStatus Status);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickActionBase">();
	}
	static class AGimmickActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickActionBase>();
	}
};
static_assert(alignof(AGimmickActionBase) == 0x000008, "Wrong alignment on AGimmickActionBase");
static_assert(sizeof(AGimmickActionBase) == 0x0002B0, "Wrong size on AGimmickActionBase");
static_assert(offsetof(AGimmickActionBase, IsActionEnableWhileOpen) == 0x000238, "Member 'AGimmickActionBase::IsActionEnableWhileOpen' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, IsActionEnableWhileClose) == 0x000239, "Member 'AGimmickActionBase::IsActionEnableWhileClose' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, ActionIcon) == 0x000240, "Member 'AGimmickActionBase::ActionIcon' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, ShowBoxComponent) == 0x000250, "Member 'AGimmickActionBase::ShowBoxComponent' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, EventBoxComponent) == 0x000258, "Member 'AGimmickActionBase::EventBoxComponent' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, ChildActionIcon) == 0x000260, "Member 'AGimmickActionBase::ChildActionIcon' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, OnActionMakeEventActorClass) == 0x000268, "Member 'AGimmickActionBase::OnActionMakeEventActorClass' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, OnActionMakeEventActor) == 0x000270, "Member 'AGimmickActionBase::OnActionMakeEventActor' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, OnExitMakeEventActorClass) == 0x000278, "Member 'AGimmickActionBase::OnExitMakeEventActorClass' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, OnExitMakeEventActor) == 0x000280, "Member 'AGimmickActionBase::OnExitMakeEventActor' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, ActionIconWorldPositionOffset) == 0x00028C, "Member 'AGimmickActionBase::ActionIconWorldPositionOffset' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, ActionIconType) == 0x000298, "Member 'AGimmickActionBase::ActionIconType' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, ActionIconSubQuestState) == 0x000299, "Member 'AGimmickActionBase::ActionIconSubQuestState' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, IsOnAction) == 0x00029A, "Member 'AGimmickActionBase::IsOnAction' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, IsOnExit) == 0x00029B, "Member 'AGimmickActionBase::IsOnExit' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, TargetGimmickObject) == 0x0002A0, "Member 'AGimmickActionBase::TargetGimmickObject' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, IsUseActionIcon) == 0x0002A8, "Member 'AGimmickActionBase::IsUseActionIcon' has a wrong offset!");

// Class BattlePrototype.DamageArrayComponent
// 0x0008 (0x00C8 - 0x00C0)
class UDamageArrayComponent final : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<struct FHCHitResult> HitResultDamageSort(const TArray<struct FHCHitResult>& HitResult, bool IsDes) const;
	struct FHCHitResult HitResultMaxDamage(const TArray<struct FHCHitResult>& HitResult) const;
	TArray<struct FHCHitResult> HitResultMaxDamageMultiActor(const TArray<struct FHCHitResult>& HitResult) const;
	TArray<struct FHCHitResult> HitResultMaxDamagePriorityMultiActor(const TArray<struct FHCHitResult>& HitResult, bool* IsPartsInvinsible) const;
	bool IsRangeCheck(const struct FVector& VecStart, const struct FVector& VecEnd, const struct FVector& VecForward, float Range) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageArrayComponent">();
	}
	static class UDamageArrayComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageArrayComponent>();
	}
};
static_assert(alignof(UDamageArrayComponent) == 0x000008, "Wrong alignment on UDamageArrayComponent");
static_assert(sizeof(UDamageArrayComponent) == 0x0000C8, "Wrong size on UDamageArrayComponent");

// Class BattlePrototype.UIConfigSelectSlider
// 0x00C0 (0x0448 - 0x0388)
class UUIConfigSelectSlider : public UUIBase
{
public:
	int32                                         MinX;                                              // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxX;                                              // 0x038C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0xB8];                                     // 0x0390(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextTitle, class UREDImage* ImageSlider, class UREDOverlay* Gauge_set);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigSelectSlider">();
	}
	static class UUIConfigSelectSlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigSelectSlider>();
	}
};
static_assert(alignof(UUIConfigSelectSlider) == 0x000008, "Wrong alignment on UUIConfigSelectSlider");
static_assert(sizeof(UUIConfigSelectSlider) == 0x000448, "Wrong size on UUIConfigSelectSlider");
static_assert(offsetof(UUIConfigSelectSlider, MinX) == 0x000388, "Member 'UUIConfigSelectSlider::MinX' has a wrong offset!");
static_assert(offsetof(UUIConfigSelectSlider, MaxX) == 0x00038C, "Member 'UUIConfigSelectSlider::MaxX' has a wrong offset!");

// Class BattlePrototype.DamageCalcComponent
// 0x0078 (0x0138 - 0x00C0)
class UDamageCalcComponent final : public UActorComponent
{
public:
	float                                         DAMAGE_FACTOR;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OBJECT_DAMAGE_FACTOR;                              // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FIRE_DAMAGE_FACTOR;                                // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ELECTRIC_DAMAGE_FACTOR;                            // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RANDOM_FACTOR_MIN;                                 // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RANDOM_FACTOR_MAX;                                 // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CRITICAL_FACTOR;                                   // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CRITICAL_CRASH_FACTOR;                             // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BAD_STATE_UP_FACTOR;                               // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BAD_STATE_DOWN_FACTOR;                             // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CRASH_FACTIR;                                      // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ARMOR_DAMAGE_UP_FACTOR;                            // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         COPY_PSYCHIC_ARMOR_FACTOR;                         // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PSYCHICFIELD_DAMAGE_FACTOR_BOSS;                   // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x40];                                      // 0x00F8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDifficultyDamageRate(EHCGameDifficulty Difficulty, const struct FDifficultyDamageRate& Rate);

	int32 CalcDamageValue(const struct FHCHitResult& HitResult, bool IsGuard, bool IsRandom, bool IsArmor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageCalcComponent">();
	}
	static class UDamageCalcComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageCalcComponent>();
	}
};
static_assert(alignof(UDamageCalcComponent) == 0x000008, "Wrong alignment on UDamageCalcComponent");
static_assert(sizeof(UDamageCalcComponent) == 0x000138, "Wrong size on UDamageCalcComponent");
static_assert(offsetof(UDamageCalcComponent, DAMAGE_FACTOR) == 0x0000C0, "Member 'UDamageCalcComponent::DAMAGE_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, OBJECT_DAMAGE_FACTOR) == 0x0000C4, "Member 'UDamageCalcComponent::OBJECT_DAMAGE_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, FIRE_DAMAGE_FACTOR) == 0x0000C8, "Member 'UDamageCalcComponent::FIRE_DAMAGE_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, ELECTRIC_DAMAGE_FACTOR) == 0x0000CC, "Member 'UDamageCalcComponent::ELECTRIC_DAMAGE_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, RANDOM_FACTOR_MIN) == 0x0000D0, "Member 'UDamageCalcComponent::RANDOM_FACTOR_MIN' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, RANDOM_FACTOR_MAX) == 0x0000D4, "Member 'UDamageCalcComponent::RANDOM_FACTOR_MAX' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, CRITICAL_FACTOR) == 0x0000D8, "Member 'UDamageCalcComponent::CRITICAL_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, CRITICAL_CRASH_FACTOR) == 0x0000DC, "Member 'UDamageCalcComponent::CRITICAL_CRASH_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, BAD_STATE_UP_FACTOR) == 0x0000E0, "Member 'UDamageCalcComponent::BAD_STATE_UP_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, BAD_STATE_DOWN_FACTOR) == 0x0000E4, "Member 'UDamageCalcComponent::BAD_STATE_DOWN_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, CRASH_FACTIR) == 0x0000E8, "Member 'UDamageCalcComponent::CRASH_FACTIR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, ARMOR_DAMAGE_UP_FACTOR) == 0x0000EC, "Member 'UDamageCalcComponent::ARMOR_DAMAGE_UP_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, COPY_PSYCHIC_ARMOR_FACTOR) == 0x0000F0, "Member 'UDamageCalcComponent::COPY_PSYCHIC_ARMOR_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, PSYCHICFIELD_DAMAGE_FACTOR_BOSS) == 0x0000F4, "Member 'UDamageCalcComponent::PSYCHICFIELD_DAMAGE_FACTOR_BOSS' has a wrong offset!");

// Class BattlePrototype.DamageCalcInterface
// 0x0000 (0x0028 - 0x0028)
class IDamageCalcInterface final : public IInterface
{
public:
	bool CalcAccumulationByAttack(float& RefWince, float& RefKnockback, float& RefDown, float& RefLaunch, float& RefFlame, float& RefElectric, float& RefFlooded, float& RefOil, float& RefConfusion, float& RefCrashScale, class AActor* DefenseActor, EHCSkillAttackType AttackType, bool bCopyActor);
	bool CalcAccumulationByDefence(float& RefWince, float& RefKnockback, float& RefDown, float& RefLaunch, float& RefFlame, float& RefElectric, float& RefFlooded, float& RefOil, float& RefConfusion, float& RefCrashScale, class AActor* AttackActor);
	float CalcCritical(float Critical, class AActor* DefenseActor);
	bool CalcDamageByAttack(float& RefPhysicsDamage, float& RefObjDamage, float& RefFlameDamage, float& RefElectricDamage, float& RefCriticalDamageRate, class AActor* DefenseActor);
	bool CalcDamageByDefence(float& RefPhysicsDamage, float& RefObjDamage, float& RefFlameDamage, float& RefElectricDamage, float& RefCriticalDamageRate, class AActor* AttackActor);
	bool CalcDefence(float& RefPhysicsDefence, float& RefObjDefence, float& RefFlameDefence, float& RefElectricPhysics);
	float CalcFinalDamageByAttack(float Damage, class AActor* DefenseActor, const struct FHCSkillCommonInfo& SkillInfo);
	float CalcFinalDamageByDefence(float Damage, class AActor* AttackActor);
	struct FCharactersParameterTable GetCharactersParameterTableInterface();
	bool IsPsychicFieldDamageRateToBoss();
	bool OverwriteAttackCollisionInfo(struct FHCCollisionCommonInfo& RefCommonInfo, struct FHCSkillCommonInfo& RefSkill);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageCalcInterface">();
	}
	static class IDamageCalcInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDamageCalcInterface>();
	}
};
static_assert(alignof(IDamageCalcInterface) == 0x000008, "Wrong alignment on IDamageCalcInterface");
static_assert(sizeof(IDamageCalcInterface) == 0x000028, "Wrong size on IDamageCalcInterface");

// Class BattlePrototype.FreeCameraController
// 0x0028 (0x05C0 - 0x0598)
class AFreeCameraController final : public APlayerController
{
public:
	class APlayerController*                      OriginalControllerRef;                             // 0x0598(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayer*                                OriginalPlayer;                                    // 0x05A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      OriginalViewTargetPCRef;                           // 0x05A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OriginalViewTargetRef;                             // 0x05B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FreeCameraController">();
	}
	static class AFreeCameraController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFreeCameraController>();
	}
};
static_assert(alignof(AFreeCameraController) == 0x000008, "Wrong alignment on AFreeCameraController");
static_assert(sizeof(AFreeCameraController) == 0x0005C0, "Wrong size on AFreeCameraController");
static_assert(offsetof(AFreeCameraController, OriginalControllerRef) == 0x000598, "Member 'AFreeCameraController::OriginalControllerRef' has a wrong offset!");
static_assert(offsetof(AFreeCameraController, OriginalPlayer) == 0x0005A0, "Member 'AFreeCameraController::OriginalPlayer' has a wrong offset!");
static_assert(offsetof(AFreeCameraController, OriginalViewTargetPCRef) == 0x0005A8, "Member 'AFreeCameraController::OriginalViewTargetPCRef' has a wrong offset!");
static_assert(offsetof(AFreeCameraController, OriginalViewTargetRef) == 0x0005B0, "Member 'AFreeCameraController::OriginalViewTargetRef' has a wrong offset!");

// Class BattlePrototype.UIParty
// 0x0030 (0x03B8 - 0x0388)
class UUIParty : public UUIBase
{
public:
	struct FVector2D                              RT1_InOut1_Translation;                            // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              RT1_Out2_Translation;                              // 0x0390(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_398[0x20];                                     // 0x0398(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeScrollBox(class UREDScrollBox* ScrollBox);
	void InitializeThis(class UBorder* borderAllColor, class UImage* ImageRT1);
	void PlayContentsIn();
	void PlayContentsOut();
	void PlayContentsOut2();
	void UpdatePartyMouseFocus();
	void UpdateProgramAnimation(float DeltaSeconds);

	bool IsPlayingContentsIn() const;
	bool IsPlayingContentsOut() const;
	bool IsPlayingContentsOut2() const;
	bool IsPlayingProgramAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIParty">();
	}
	static class UUIParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIParty>();
	}
};
static_assert(alignof(UUIParty) == 0x000008, "Wrong alignment on UUIParty");
static_assert(sizeof(UUIParty) == 0x0003B8, "Wrong size on UUIParty");
static_assert(offsetof(UUIParty, RT1_InOut1_Translation) == 0x000388, "Member 'UUIParty::RT1_InOut1_Translation' has a wrong offset!");
static_assert(offsetof(UUIParty, RT1_Out2_Translation) == 0x000390, "Member 'UUIParty::RT1_Out2_Translation' has a wrong offset!");

// Class BattlePrototype.DamageFlyConditionComponent
// 0x0040 (0x01A0 - 0x0160)
class UDamageFlyConditionComponent final : public UConditionComponent
{
public:
	float                                         _landingSec;                                       // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _recoverableHeight;                                // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _recoverStartVelocity;                             // 0x0168(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_174[0x2C];                                     // 0x0174(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InputRecoverButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageFlyConditionComponent">();
	}
	static class UDamageFlyConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageFlyConditionComponent>();
	}
};
static_assert(alignof(UDamageFlyConditionComponent) == 0x000010, "Wrong alignment on UDamageFlyConditionComponent");
static_assert(sizeof(UDamageFlyConditionComponent) == 0x0001A0, "Wrong size on UDamageFlyConditionComponent");
static_assert(offsetof(UDamageFlyConditionComponent, _landingSec) == 0x000160, "Member 'UDamageFlyConditionComponent::_landingSec' has a wrong offset!");
static_assert(offsetof(UDamageFlyConditionComponent, _recoverableHeight) == 0x000164, "Member 'UDamageFlyConditionComponent::_recoverableHeight' has a wrong offset!");
static_assert(offsetof(UDamageFlyConditionComponent, _recoverStartVelocity) == 0x000168, "Member 'UDamageFlyConditionComponent::_recoverStartVelocity' has a wrong offset!");

// Class BattlePrototype.DamagePartCollisionComponent
// 0x0040 (0x0470 - 0x0430)
class UDamagePartCollisionComponent final : public UCapsuleComponent
{
public:
	int32                                         MParameterNo;                                      // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHPartNo                                      MPartNo;                                           // 0x042C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsWeakPoint;                                      // 0x042D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHDamageEffectType                            MDamageEffectType;                                 // 0x042E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42F[0x1];                                      // 0x042F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MDamagePriority;                                   // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MHitRotator;                                       // 0x0434(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MHitAngle;                                         // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MOffset;                                           // 0x0444(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsBoneEnable;                                     // 0x0450(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_451[0x3];                                      // 0x0451(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MBoneBase;                                         // 0x0454(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MBoneDir;                                          // 0x045C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsNoDamage;                                       // 0x0464(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsNoCrash;                                        // 0x0465(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsNoReaction;                                     // 0x0466(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsNoBadStatus;                                    // 0x0467(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCalcDamageInfo(bool bNoDamage, bool bNoCrash, bool bNoReaction, bool bNoBadStatus);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamagePartCollisionComponent">();
	}
	static class UDamagePartCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamagePartCollisionComponent>();
	}
};
static_assert(alignof(UDamagePartCollisionComponent) == 0x000010, "Wrong alignment on UDamagePartCollisionComponent");
static_assert(sizeof(UDamagePartCollisionComponent) == 0x000470, "Wrong size on UDamagePartCollisionComponent");
static_assert(offsetof(UDamagePartCollisionComponent, MParameterNo) == 0x000428, "Member 'UDamagePartCollisionComponent::MParameterNo' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MPartNo) == 0x00042C, "Member 'UDamagePartCollisionComponent::MPartNo' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MIsWeakPoint) == 0x00042D, "Member 'UDamagePartCollisionComponent::MIsWeakPoint' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MDamageEffectType) == 0x00042E, "Member 'UDamagePartCollisionComponent::MDamageEffectType' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MDamagePriority) == 0x000430, "Member 'UDamagePartCollisionComponent::MDamagePriority' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MHitRotator) == 0x000434, "Member 'UDamagePartCollisionComponent::MHitRotator' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MHitAngle) == 0x000440, "Member 'UDamagePartCollisionComponent::MHitAngle' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MOffset) == 0x000444, "Member 'UDamagePartCollisionComponent::MOffset' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MIsBoneEnable) == 0x000450, "Member 'UDamagePartCollisionComponent::MIsBoneEnable' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MBoneBase) == 0x000454, "Member 'UDamagePartCollisionComponent::MBoneBase' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MBoneDir) == 0x00045C, "Member 'UDamagePartCollisionComponent::MBoneDir' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MIsNoDamage) == 0x000464, "Member 'UDamagePartCollisionComponent::MIsNoDamage' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MIsNoCrash) == 0x000465, "Member 'UDamagePartCollisionComponent::MIsNoCrash' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MIsNoReaction) == 0x000466, "Member 'UDamagePartCollisionComponent::MIsNoReaction' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MIsNoBadStatus) == 0x000467, "Member 'UDamagePartCollisionComponent::MIsNoBadStatus' has a wrong offset!");

// Class BattlePrototype.DamageResponseComponent
// 0x0060 (0x0120 - 0x00C0)
class UDamageResponseComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             SpawnGuardEffect;                                  // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SpawnHitEffect;                                    // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDamaging;                                        // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SpawnDamageHitEffect;                              // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x20];                                     // 0x0100(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 OnDamageActorHit(const struct FHCHitResult& HitResult, bool IsGuard, bool IsForceCritical, bool IsArmor, bool IsRatio, bool IsAccumurateRatio, bool IsFixCalcCrash);
	void OnDamageAfter();
	int32 OnDamageDirectAttack(bool bUseFixDamage, int32 FixDamage, const struct FHCHitResult& HitResult, bool IsForceCritical);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageResponseComponent">();
	}
	static class UDamageResponseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageResponseComponent>();
	}
};
static_assert(alignof(UDamageResponseComponent) == 0x000008, "Wrong alignment on UDamageResponseComponent");
static_assert(sizeof(UDamageResponseComponent) == 0x000120, "Wrong size on UDamageResponseComponent");
static_assert(offsetof(UDamageResponseComponent, SpawnGuardEffect) == 0x0000C0, "Member 'UDamageResponseComponent::SpawnGuardEffect' has a wrong offset!");
static_assert(offsetof(UDamageResponseComponent, SpawnHitEffect) == 0x0000D0, "Member 'UDamageResponseComponent::SpawnHitEffect' has a wrong offset!");
static_assert(offsetof(UDamageResponseComponent, OnDamaging) == 0x0000E0, "Member 'UDamageResponseComponent::OnDamaging' has a wrong offset!");
static_assert(offsetof(UDamageResponseComponent, SpawnDamageHitEffect) == 0x0000F0, "Member 'UDamageResponseComponent::SpawnDamageHitEffect' has a wrong offset!");

// Class BattlePrototype.DataTableTest
// 0x0020 (0x0250 - 0x0230)
class ADataTableTest final : public AActor
{
public:
	class UDataTable*                             _datatable;                                        // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDataTableRowTest>              _dataContents;                                     // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTableExtends*                      _datatableExtends;                                 // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void InitDataContents();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataTableTest">();
	}
	static class ADataTableTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADataTableTest>();
	}
};
static_assert(alignof(ADataTableTest) == 0x000008, "Wrong alignment on ADataTableTest");
static_assert(sizeof(ADataTableTest) == 0x000250, "Wrong size on ADataTableTest");
static_assert(offsetof(ADataTableTest, _datatable) == 0x000230, "Member 'ADataTableTest::_datatable' has a wrong offset!");
static_assert(offsetof(ADataTableTest, _dataContents) == 0x000238, "Member 'ADataTableTest::_dataContents' has a wrong offset!");
static_assert(offsetof(ADataTableTest, _datatableExtends) == 0x000248, "Member 'ADataTableTest::_datatableExtends' has a wrong offset!");

// Class BattlePrototype.DebuggingGameActivityManager
// 0x0028 (0x0258 - 0x0230)
class ADebuggingGameActivityManager final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayString;                                     // 0x0238(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           TextColor;                                         // 0x0248(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool IsDisplayFlag();
	void SetDisplayFlag(bool Flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingGameActivityManager">();
	}
	static class ADebuggingGameActivityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingGameActivityManager>();
	}
};
static_assert(alignof(ADebuggingGameActivityManager) == 0x000008, "Wrong alignment on ADebuggingGameActivityManager");
static_assert(sizeof(ADebuggingGameActivityManager) == 0x000258, "Wrong size on ADebuggingGameActivityManager");
static_assert(offsetof(ADebuggingGameActivityManager, DisplayString) == 0x000238, "Member 'ADebuggingGameActivityManager::DisplayString' has a wrong offset!");
static_assert(offsetof(ADebuggingGameActivityManager, TextColor) == 0x000248, "Member 'ADebuggingGameActivityManager::TextColor' has a wrong offset!");

// Class BattlePrototype.DebuggingItemEvent
// 0x0018 (0x02E0 - 0x02C8)
class ADebuggingItemEvent : public ADebuggingItemBase
{
public:
	FMulticastInlineDelegateProperty_             OnEvent;                                           // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallEvent();
	void OnKeySelectFunc(const class ADebuggingItemBase* InItem, bool IsRepeat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemEvent">();
	}
	static class ADebuggingItemEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemEvent>();
	}
};
static_assert(alignof(ADebuggingItemEvent) == 0x000008, "Wrong alignment on ADebuggingItemEvent");
static_assert(sizeof(ADebuggingItemEvent) == 0x0002E0, "Wrong size on ADebuggingItemEvent");
static_assert(offsetof(ADebuggingItemEvent, OnEvent) == 0x0002C8, "Member 'ADebuggingItemEvent::OnEvent' has a wrong offset!");

// Class BattlePrototype.DebuggingItemFloat
// 0x0038 (0x0300 - 0x02C8)
class ADebuggingItemFloat final : public ADebuggingItemBase
{
public:
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSliderSettingChanged;                            // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x02E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Max;                                               // 0x02EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Step;                                              // 0x02F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Value;                                             // 0x02F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKeyLeftFunc(const class ADebuggingItemBase* InItem, bool IsRepeat, int32 InSpeed);
	void OnKeyRightFunc(const class ADebuggingItemBase* InItem, bool IsRepeat, int32 InSpeed);
	void SetSliderSettings(float InMin, float InMax, float InStep);
	void SetValue(float InValue);

	float GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemFloat">();
	}
	static class ADebuggingItemFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemFloat>();
	}
};
static_assert(alignof(ADebuggingItemFloat) == 0x000008, "Wrong alignment on ADebuggingItemFloat");
static_assert(sizeof(ADebuggingItemFloat) == 0x000300, "Wrong size on ADebuggingItemFloat");
static_assert(offsetof(ADebuggingItemFloat, OnChanged) == 0x0002C8, "Member 'ADebuggingItemFloat::OnChanged' has a wrong offset!");
static_assert(offsetof(ADebuggingItemFloat, OnSliderSettingChanged) == 0x0002D8, "Member 'ADebuggingItemFloat::OnSliderSettingChanged' has a wrong offset!");
static_assert(offsetof(ADebuggingItemFloat, Min) == 0x0002E8, "Member 'ADebuggingItemFloat::Min' has a wrong offset!");
static_assert(offsetof(ADebuggingItemFloat, Max) == 0x0002EC, "Member 'ADebuggingItemFloat::Max' has a wrong offset!");
static_assert(offsetof(ADebuggingItemFloat, Step) == 0x0002F0, "Member 'ADebuggingItemFloat::Step' has a wrong offset!");
static_assert(offsetof(ADebuggingItemFloat, Value) == 0x0002F4, "Member 'ADebuggingItemFloat::Value' has a wrong offset!");

// Class BattlePrototype.DebuggingItemLabel
// 0x0030 (0x02F8 - 0x02C8)
class ADebuggingItemLabel final : public ADebuggingItemBase
{
public:
	class FText                                   DispLabel;                                         // 0x02C8(0x0018)(BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetText(const class FText& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemLabel">();
	}
	static class ADebuggingItemLabel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemLabel>();
	}
};
static_assert(alignof(ADebuggingItemLabel) == 0x000008, "Wrong alignment on ADebuggingItemLabel");
static_assert(sizeof(ADebuggingItemLabel) == 0x0002F8, "Wrong size on ADebuggingItemLabel");
static_assert(offsetof(ADebuggingItemLabel, DispLabel) == 0x0002C8, "Member 'ADebuggingItemLabel::DispLabel' has a wrong offset!");
static_assert(offsetof(ADebuggingItemLabel, OnChanged) == 0x0002E0, "Member 'ADebuggingItemLabel::OnChanged' has a wrong offset!");

// Class BattlePrototype.DebuggingItemScrResOutputChange
// 0x0000 (0x0310 - 0x0310)
class ADebuggingItemScrResOutputChange final : public ADebuggingItemScrSetting
{
public:
	void OnChangeValue(const class ADebuggingItemStringArray* InItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemScrResOutputChange">();
	}
	static class ADebuggingItemScrResOutputChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemScrResOutputChange>();
	}
};
static_assert(alignof(ADebuggingItemScrResOutputChange) == 0x000008, "Wrong alignment on ADebuggingItemScrResOutputChange");
static_assert(sizeof(ADebuggingItemScrResOutputChange) == 0x000310, "Wrong size on ADebuggingItemScrResOutputChange");

// Class BattlePrototype.DebuggingItemScrApply
// 0x0010 (0x02F0 - 0x02E0)
class ADebuggingItemScrApply final : public ADebuggingItemEvent
{
public:
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyEvent(const class ADebuggingItemEvent* InItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemScrApply">();
	}
	static class ADebuggingItemScrApply* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemScrApply>();
	}
};
static_assert(alignof(ADebuggingItemScrApply) == 0x000008, "Wrong alignment on ADebuggingItemScrApply");
static_assert(sizeof(ADebuggingItemScrApply) == 0x0002F0, "Wrong size on ADebuggingItemScrApply");

// Class BattlePrototype.DebuggingItemWidgetBase
// 0x0008 (0x0238 - 0x0230)
class UDebuggingItemWidgetBase final : public UUserWidget
{
public:
	class ADebuggingItemBase*                     Item;                                              // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Setup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemWidgetBase">();
	}
	static class UDebuggingItemWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebuggingItemWidgetBase>();
	}
};
static_assert(alignof(UDebuggingItemWidgetBase) == 0x000008, "Wrong alignment on UDebuggingItemWidgetBase");
static_assert(sizeof(UDebuggingItemWidgetBase) == 0x000238, "Wrong size on UDebuggingItemWidgetBase");
static_assert(offsetof(UDebuggingItemWidgetBase, Item) == 0x000230, "Member 'UDebuggingItemWidgetBase::Item' has a wrong offset!");

// Class BattlePrototype.DebuggingStatsManager
// 0x0030 (0x0058 - 0x0028)
class UDebuggingStatsManager final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingStatsManager">();
	}
	static class UDebuggingStatsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebuggingStatsManager>();
	}
};
static_assert(alignof(UDebuggingStatsManager) == 0x000008, "Wrong alignment on UDebuggingStatsManager");
static_assert(sizeof(UDebuggingStatsManager) == 0x000058, "Wrong size on UDebuggingStatsManager");

// Class BattlePrototype.DebuggingStartupObject
// 0x0130 (0x0158 - 0x0028)
class UDebuggingStartupObject final : public UObject
{
public:
	int32                                         SaveDataNo;                                        // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DebugSaveDataNo;                                   // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pDebugSaveLoadScreenParamManager;                // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pDebugAutoSaveLoadScreenParamManager;            // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pDebugSystemSaveLoadScreenParamManager;          // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pDebugDebugSaveLoadScreenParamManager;           // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x108];                                     // 0x0050(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetDebugSaveDataNo();
	int32 GetSaveDataNo();
	void OnACAccountControllerInfo(const class ADebuggingItemEvent* Item);
	void OnACFirstProfileCheck(const class ADebuggingItemEvent* Item);
	void OnACTickOutputLogOff(const class ADebuggingItemEvent* Item);
	void OnACTickOutputLogOn(const class ADebuggingItemEvent* Item);
	void OnAllCharaLibrary(const class ADebuggingItemBool* Item);
	void OnAllCharaLibraryDLC(const class ADebuggingItemBool* Item);
	void OnAllEnemyLibrary(const class ADebuggingItemEvent* Item);
	void OnAllGetContents(const class ADebuggingItemBool* Item);
	void OnAllPresentList(const class ADebuggingItemBool* Item);
	void OnAllQuests(const class ADebuggingItemEvent* Item);
	void OnAllShop(const class ADebuggingItemBool* Item);
	void OnAllTutoList(const class ADebuggingItemBool* Item);
	void OnAutoDeleteFileGameData(const class ADebuggingItemEvent* Item);
	void OnAutoDeleteGameData(const class ADebuggingItemEvent* Item);
	void OnAutoLoadGameData(const class ADebuggingItemEvent* Item);
	void OnAutoSaveGameData(const class ADebuggingItemEvent* Item);
	void OnBTResetBeforePlayTime(const class ADebuggingItemEvent* Item);
	void OnBTResetIsOnce(const class ADebuggingItemEvent* Item);
	void OnChangeAnimInterLockingErrorTest(const class ADebuggingItemStringArray* Item);
	void OnChangeAnimInterLockingFailTest(const class ADebuggingItemBool* Item);
	void OnChangeAnimInterLockingQuestRelease(const class ADebuggingItemInt* Item);
	void OnChangeAnimInterLockingSuccessTest(const class ADebuggingItemBool* Item);
	void OnChangeArrangeItemForceRepopTime(const class ADebuggingItemInt* Item);
	void OnChangeArrangeItemForceRepopTimeFlag(const class ADebuggingItemBool* Item);
	void OnChangeArrangeItemGetLog(const class ADebuggingItemBool* Item);
	void OnChangeBoolBrainCrashOpend(const class ADebuggingItemBool* Item);
	void OnChangeBoolDirectPause(const class ADebuggingItemBool* Item);
	void OnChangeBoolParticleSpawnDisable(const class ADebuggingItemBool* Item);
	void OnChangeBoolSample(const class ADebuggingItemBool* Item);
	void OnChangeBoolSoundSpawnDisable(const class ADebuggingItemBool* Item);
	void OnChangeBrainTalkAllInvalidFlag(const class ADebuggingItemBool* Item);
	void OnChangeBrainTalkBTInvalidFlag(const class ADebuggingItemBool* Item);
	void OnChangedDispMessageId(const class ADebuggingItemBool* Item);
	void OnChangeDebugPauseInput(const class ADebuggingItemBool* Item);
	void OnChangeDecideButtonType(const class ADebuggingItemBool* Item);
	void OnChangeDispBrainTalkLogFlag(const class ADebuggingItemBool* Item);
	void OnChangeDispIndexDropItemLotteryParam(const class ADebuggingItemInt* Item);
	void OnChangeDisplayDropItemLotteryParam(const class ADebuggingItemBool* Item);
	void OnChangeDropItemGetRule(const class ADebuggingItemBool* Item);
	void OnChangeGuideDeviceType(const class ADebuggingItemStringArray* Item);
	void OnChangeLastShopID(const class ADebuggingItemInt* Item);
	void OnChangeLastTradeShopID(const class ADebuggingItemInt* Item);
	void OnChangeLoadingTipsID(const class ADebuggingItemStringArray* Item);
	void OnChangeMoney(const class ADebuggingItemInt* Item);
	void OnChangeMouseCameraMove(const class ADebuggingItemBool* Item);
	void OnChangeScenarioClearF(const class ADebuggingItemBool* Item);
	void OnChangeScenarioClearM(const class ADebuggingItemBool* Item);
	void OnChangeSelectDebugTimeSaveData(const class ADebuggingItemStringArray* Item);
	void OnChangeTransferObject(const class ADebuggingItemStringArray* Item);
	void OnDebugDrawAnimationName(const class ADebuggingItemBool* Item);
	void OnDebugDrawWidgetName(const class ADebuggingItemBool* Item);
	void OnDebugKeyboard(const class ADebuggingItemBool* Item);
	void OnDebugLoadGameData(const class ADebuggingItemEvent* Item);
	void OnDebugSaveGameData(const class ADebuggingItemEvent* Item);
	void OnDebugTimeSaveGameData(const class ADebuggingItemEvent* Item);
	void OnDeleteFileGameData(const class ADebuggingItemEvent* Item);
	void OnDeleteGameData(const class ADebuggingItemEvent* Item);
	void OnDeleteSystemData(const class ADebuggingItemEvent* Item);
	void OnDispMouseRectangle(const class ADebuggingItemBool* Item);
	void OnDrawActionIconProperty(const class ADebuggingItemBool* Item);
	void OnDrawFontAtlasProperty(const class ADebuggingItemBool* Item);
	void OnDrawNoticeStack(const class ADebuggingItemBool* Item);
	void OnDrawShopTradeProperty(const class ADebuggingItemBool* Item);
	void OnDrawUIBaseProperty(const class ADebuggingItemBool* Item);
	void OnExecExSystemSaveDump(const class ADebuggingItemEvent* Item);
	void OnExecuteAllBaseItems(const class ADebuggingItemEvent* Item);
	void OnExecuteAllBattleItems(const class ADebuggingItemEvent* Item);
	void OnExecuteAllEquipments(const class ADebuggingItemEvent* Item);
	void OnExecuteAllFoods(const class ADebuggingItemEvent* Item);
	void OnExecuteAllKeyItem(const class ADebuggingItemEvent* Item);
	void OnExecuteAllMaterials(const class ADebuggingItemEvent* Item);
	void OnExecuteBondsQuestNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteBrainCrashOpendChange(const class ADebuggingItemEvent* Item);
	void OnExecuteBTEnemyDebugPlay(const class ADebuggingItemEvent* Item);
	void OnExecuteBTEnemyListChanged(const class ADebuggingItemStringArray* Item);
	void OnExecuteBTMapGimmickDebugPlay(const class ADebuggingItemEvent* Item);
	void OnExecuteBTMapGimmickListChanged(const class ADebuggingItemStringArray* Item);
	void OnExecuteBTSysDebugPlay(const class ADebuggingItemEvent* Item);
	void OnExecuteBTSysForceWataruHarukaFlagChanged(const class ADebuggingItemStringArray* Item);
	void OnExecuteBTSysListChanged(const class ADebuggingItemStringArray* Item);
	void OnExecuteBTSysSkipIsOnceCheckChanged(const class ADebuggingItemBool* Item);
	void OnExecuteBTSysSkipProgressIDCheckChanged(const class ADebuggingItemBool* Item);
	void OnExecuteBTTutorialDebugPlay(const class ADebuggingItemEvent* Item);
	void OnExecuteBTTutorialListChanged(const class ADebuggingItemStringArray* Item);
	void OnExecuteCharaLibraryNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteCollectDebugMenuStrings(const class ADebuggingItemEvent* Item);
	void OnExecuteContentsClosedFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteEnemyLibraryNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteItemNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteMainQuestNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteResetDropItemLotteryParam(const class ADebuggingItemEvent* Item);
	void OnExecuteRich(const class ADebuggingItemEvent* Item);
	void OnExecuteShopItemNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteSubQuestNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteTradeItemNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteTutoGetFlag(const class ADebuggingItemStringArray* Item);
	void OnExecuteTutorialNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteWorldMapNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExitGame(const class ADebuggingItemEvent* Item);
	void OnFlushFontCache(const class ADebuggingItemEvent* Item);
	void OnForceAutoSaveDisable(const class ADebuggingItemBool* Item);
	void OnForceAutoSaveEnable(const class ADebuggingItemBool* Item);
	void OnForceCrcCheckError(const class ADebuggingItemBool* Item);
	void OnForceExecGarbageCollect(const class ADebuggingItemEvent* Item);
	void OnKeyRightCEBankGroup(const class ADebuggingItemBase* Item, bool IsRepeat, int32 InSpeed);
	void OnLoadAreaSelectLevel(const class ADebuggingItemEvent* Item);
	void OnLoadAutoData(const class ADebuggingItemEvent* Item);
	void OnLoadGameData(const class ADebuggingItemEvent* Item);
	void OnLoadLaunchScreen(const class ADebuggingItemEvent* Item);
	void OnLoadRetryData(const class ADebuggingItemEvent* Item);
	void OnLoadSystemData(const class ADebuggingItemEvent* Item);
	void OnLoadTrialSaveData(const class ADebuggingItemEvent* Item);
	void OnMinimapCreateMapDisable(const class ADebuggingItemBool* Item);
	void OnMinimapDisp(const class ADebuggingItemBool* Item);
	void OnMinimapIconEnemyTickDisable(const class ADebuggingItemBool* Item);
	void OnMinimapIconFootTickDisable(const class ADebuggingItemBool* Item);
	void OnMinimapIconNpcTickDisable(const class ADebuggingItemBool* Item);
	void OnMinimapIconTickDisable(const class ADebuggingItemBool* Item);
	void OnMinimapIconUpdateAdjust(const class ADebuggingItemBool* Item);
	void OnMinimapMaterialTickDisable(const class ADebuggingItemBool* Item);
	void OnMinimapMenuSetting(const class ADebuggingItemStringArray* Item);
	void OnMinimapRotate(const class ADebuggingItemBool* Item);
	void OnMinimapScale(const class ADebuggingItemBool* Item);
	void OnMinimapTickDisable(const class ADebuggingItemBool* Item);
	void OnMinimapTraceTickDisable(const class ADebuggingItemBool* Item);
	void OnOpenLoadMenu(const class ADebuggingItemEvent* Item);
	void OnOpenLoginUI(const class ADebuggingItemEvent* Item);
	void OnOpenSaveMenu(const class ADebuggingItemEvent* Item);
	void OnOutputFlagUpdateAlways(const class ADebuggingItemEvent* Item);
	void OnOutputUIBaseAnimationList(const class ADebuggingItemEvent* Item);
	void OnOutputUIBaseList(const class ADebuggingItemEvent* Item);
	void OnReloadLevel(const class ADebuggingItemEvent* Item);
	void OnSaveAutoData(const class ADebuggingItemEvent* Item);
	void OnSaveDataCapture(const class ADebuggingItemEvent* Item);
	void OnSaveGameData(const class ADebuggingItemEvent* Item);
	void OnSaveLoadMenuSetting(const class ADebuggingItemStringArray* Item);
	void OnSaveRetryData(const class ADebuggingItemEvent* Item);
	void OnSaveSystemData(const class ADebuggingItemEvent* Item);
	void OnSetDebugSaveIndex(const class ADebuggingItemInt* Item);
	void OnSetSaveIndex(const class ADebuggingItemInt* Item);
	void OnSystemChangeClearFlag(const class ADebuggingItemBool* Item);
	void OnSystemChangeZeroEpClearFlag(const class ADebuggingItemBool* Item);
	void OnSystemLoadGameData(const class ADebuggingItemEvent* Item);
	void OnSystemSaveGameData(const class ADebuggingItemEvent* Item);
	void OnTitleBack(const class ADebuggingItemEvent* Item);
	void OnUseMouseCursor(const class ADebuggingItemBool* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingStartupObject">();
	}
	static class UDebuggingStartupObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebuggingStartupObject>();
	}
};
static_assert(alignof(UDebuggingStartupObject) == 0x000008, "Wrong alignment on UDebuggingStartupObject");
static_assert(sizeof(UDebuggingStartupObject) == 0x000158, "Wrong size on UDebuggingStartupObject");
static_assert(offsetof(UDebuggingStartupObject, SaveDataNo) == 0x000028, "Member 'UDebuggingStartupObject::SaveDataNo' has a wrong offset!");
static_assert(offsetof(UDebuggingStartupObject, DebugSaveDataNo) == 0x00002C, "Member 'UDebuggingStartupObject::DebugSaveDataNo' has a wrong offset!");
static_assert(offsetof(UDebuggingStartupObject, M_pDebugSaveLoadScreenParamManager) == 0x000030, "Member 'UDebuggingStartupObject::M_pDebugSaveLoadScreenParamManager' has a wrong offset!");
static_assert(offsetof(UDebuggingStartupObject, M_pDebugAutoSaveLoadScreenParamManager) == 0x000038, "Member 'UDebuggingStartupObject::M_pDebugAutoSaveLoadScreenParamManager' has a wrong offset!");
static_assert(offsetof(UDebuggingStartupObject, M_pDebugSystemSaveLoadScreenParamManager) == 0x000040, "Member 'UDebuggingStartupObject::M_pDebugSystemSaveLoadScreenParamManager' has a wrong offset!");
static_assert(offsetof(UDebuggingStartupObject, M_pDebugDebugSaveLoadScreenParamManager) == 0x000048, "Member 'UDebuggingStartupObject::M_pDebugDebugSaveLoadScreenParamManager' has a wrong offset!");

// Class BattlePrototype.DebugPresetFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UDebugPresetFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void InitalizePreset(class UObject* WorldContextObject, class FName Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugPresetFunctionLibrary">();
	}
	static class UDebugPresetFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugPresetFunctionLibrary>();
	}
};
static_assert(alignof(UDebugPresetFunctionLibrary) == 0x000008, "Wrong alignment on UDebugPresetFunctionLibrary");
static_assert(sizeof(UDebugPresetFunctionLibrary) == 0x000028, "Wrong size on UDebugPresetFunctionLibrary");

// Class BattlePrototype.DebugSaveDataListWindow
// 0x0008 (0x0238 - 0x0230)
class ADebugSaveDataListWindow final : public AActor
{
public:
	class USaveLoadScreenParamManager*            M_pDebugDebugSaveLoadScreenParamManager;           // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DoNewGame();
	void LoadDebugSaveData(const class FString& Filename);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugSaveDataListWindow">();
	}
	static class ADebugSaveDataListWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugSaveDataListWindow>();
	}
};
static_assert(alignof(ADebugSaveDataListWindow) == 0x000008, "Wrong alignment on ADebugSaveDataListWindow");
static_assert(sizeof(ADebugSaveDataListWindow) == 0x000238, "Wrong size on ADebugSaveDataListWindow");
static_assert(offsetof(ADebugSaveDataListWindow, M_pDebugDebugSaveLoadScreenParamManager) == 0x000230, "Member 'ADebugSaveDataListWindow::M_pDebugDebugSaveLoadScreenParamManager' has a wrong offset!");

// Class BattlePrototype.DebugInfoScreenParticle
// 0x0000 (0x02C8 - 0x02C8)
class ADebugInfoScreenParticle final : public ADebugInfoScreenBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugInfoScreenParticle">();
	}
	static class ADebugInfoScreenParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugInfoScreenParticle>();
	}
};
static_assert(alignof(ADebugInfoScreenParticle) == 0x000008, "Wrong alignment on ADebugInfoScreenParticle");
static_assert(sizeof(ADebugInfoScreenParticle) == 0x0002C8, "Wrong size on ADebugInfoScreenParticle");

// Class BattlePrototype.DecoyComponent
// 0x0008 (0x00C8 - 0x00C0)
class UDecoyComponent final : public UActorComponent
{
public:
	TSubclassOf<class ARSCharacterBase>           _targetClass;                                      // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static TArray<class AActor*> Decoy_SortByDistance(const TArray<class AActor*>& Actors, const class AActor* OriginActor);
	static class UDecoyComponent* GetDecoyComponentFromActor(class AActor* Actor);

	bool IsDecoyTarget(const class AActor* TargetActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecoyComponent">();
	}
	static class UDecoyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecoyComponent>();
	}
};
static_assert(alignof(UDecoyComponent) == 0x000008, "Wrong alignment on UDecoyComponent");
static_assert(sizeof(UDecoyComponent) == 0x0000C8, "Wrong size on UDecoyComponent");
static_assert(offsetof(UDecoyComponent, _targetClass) == 0x0000C0, "Member 'UDecoyComponent::_targetClass' has a wrong offset!");

// Class BattlePrototype.DestroyConditionComponent
// 0x0000 (0x0160 - 0x0160)
class UDestroyConditionComponent final : public UConditionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestroyConditionComponent">();
	}
	static class UDestroyConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestroyConditionComponent>();
	}
};
static_assert(alignof(UDestroyConditionComponent) == 0x000010, "Wrong alignment on UDestroyConditionComponent");
static_assert(sizeof(UDestroyConditionComponent) == 0x000160, "Wrong size on UDestroyConditionComponent");

// Class BattlePrototype.DetailedMapDBAsset
// 0x0050 (0x0078 - 0x0028)
class UDetailedMapDBAsset final : public UObject
{
public:
	TMap<class FName, struct FDetailedMapDBDataCell> DetailedMapDBMap_;                                 // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	void Convert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DetailedMapDBAsset">();
	}
	static class UDetailedMapDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDetailedMapDBAsset>();
	}
};
static_assert(alignof(UDetailedMapDBAsset) == 0x000008, "Wrong alignment on UDetailedMapDBAsset");
static_assert(sizeof(UDetailedMapDBAsset) == 0x000078, "Wrong size on UDetailedMapDBAsset");
static_assert(offsetof(UDetailedMapDBAsset, DetailedMapDBMap_) == 0x000028, "Member 'UDetailedMapDBAsset::DetailedMapDBMap_' has a wrong offset!");

// Class BattlePrototype.DropItem
// 0x00C8 (0x02F8 - 0x0230)
class ADropItem : public AActor
{
public:
	class FName                                   ItemNameID_;                                       // 0x0230(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ItemNum_;                                          // 0x0238(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCoreDrop_;                                       // 0x023C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23D[0x3];                                      // 0x023D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DropSpeedBase_;                                    // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DropAddSpeed_;                                     // 0x0244(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AddSpeedValue_;                                    // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         becomeCanGettingItemTime_;                         // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DropDownSpeed_;                                    // 0x0250(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URSParticleSystemComponentBase*         DropParticleComponent_;                            // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URSParticleSystemComponentBase*         AcquiredParticleComponent_;                        // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URSParticleSystemComponentBase*         GetParticleComponent_;                             // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TakenDistance_;                                    // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TakenAndDestroyDistance_;                          // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       TakenSphereComponent_;                             // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       AdsorptionSphereComponent_;                        // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdsorptionSpeed_;                                  // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                AdsorptionVector_;                                 // 0x028C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDropItemStateName                            NowState_;                                         // 0x0298(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetPos_;                                        // 0x029C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDispersionMove_;                                 // 0x02A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActiveTickCounter_;                                // 0x02AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RegistNum_;                                        // 0x02B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          GetSound_;                                         // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          AddItemSeCue;                                      // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x30];                                     // 0x02C8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindGetItem();
	void ComputeAdsorptionVector(const struct FVector& TargetLocation);
	float ComputeAndGetDropDownSpeed(float Time);
	void DestroyThisItem();
	void DoActiveAcquiredParticle();
	void DoAdsorption(float DTime);
	void DropDown(float DropSpeed);
	void GetParticleFinished(class UParticleSystemComponent* PSystem);
	void PlayAddItemSound();
	void PlayGetSound();
	void SetAutoTakenFlag(bool bAuto);
	void SetDropParticle();
	void SetItemDataID(class FName SId);
	void SetItemDataNum(int32 Num);
	void SetItemState(EDropItemStateName NewState);
	void SetMeshVisibleAndActive(bool IsVisible);
	void SetOtherParticle(class UParticleSystem* DropParticle, class UParticleSystem* AquParticle, class UParticleSystem* GetParticle);
	void SetUseParticle(EDropItemParticleName DpName);
	void SwitchTickAtBeforeRenderInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropItem">();
	}
	static class ADropItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADropItem>();
	}
};
static_assert(alignof(ADropItem) == 0x000008, "Wrong alignment on ADropItem");
static_assert(sizeof(ADropItem) == 0x0002F8, "Wrong size on ADropItem");
static_assert(offsetof(ADropItem, ItemNameID_) == 0x000230, "Member 'ADropItem::ItemNameID_' has a wrong offset!");
static_assert(offsetof(ADropItem, ItemNum_) == 0x000238, "Member 'ADropItem::ItemNum_' has a wrong offset!");
static_assert(offsetof(ADropItem, IsCoreDrop_) == 0x00023C, "Member 'ADropItem::IsCoreDrop_' has a wrong offset!");
static_assert(offsetof(ADropItem, DropSpeedBase_) == 0x000240, "Member 'ADropItem::DropSpeedBase_' has a wrong offset!");
static_assert(offsetof(ADropItem, DropAddSpeed_) == 0x000244, "Member 'ADropItem::DropAddSpeed_' has a wrong offset!");
static_assert(offsetof(ADropItem, AddSpeedValue_) == 0x000248, "Member 'ADropItem::AddSpeedValue_' has a wrong offset!");
static_assert(offsetof(ADropItem, becomeCanGettingItemTime_) == 0x00024C, "Member 'ADropItem::becomeCanGettingItemTime_' has a wrong offset!");
static_assert(offsetof(ADropItem, DropDownSpeed_) == 0x000250, "Member 'ADropItem::DropDownSpeed_' has a wrong offset!");
static_assert(offsetof(ADropItem, DropParticleComponent_) == 0x000258, "Member 'ADropItem::DropParticleComponent_' has a wrong offset!");
static_assert(offsetof(ADropItem, AcquiredParticleComponent_) == 0x000260, "Member 'ADropItem::AcquiredParticleComponent_' has a wrong offset!");
static_assert(offsetof(ADropItem, GetParticleComponent_) == 0x000268, "Member 'ADropItem::GetParticleComponent_' has a wrong offset!");
static_assert(offsetof(ADropItem, TakenDistance_) == 0x000270, "Member 'ADropItem::TakenDistance_' has a wrong offset!");
static_assert(offsetof(ADropItem, TakenAndDestroyDistance_) == 0x000274, "Member 'ADropItem::TakenAndDestroyDistance_' has a wrong offset!");
static_assert(offsetof(ADropItem, TakenSphereComponent_) == 0x000278, "Member 'ADropItem::TakenSphereComponent_' has a wrong offset!");
static_assert(offsetof(ADropItem, AdsorptionSphereComponent_) == 0x000280, "Member 'ADropItem::AdsorptionSphereComponent_' has a wrong offset!");
static_assert(offsetof(ADropItem, AdsorptionSpeed_) == 0x000288, "Member 'ADropItem::AdsorptionSpeed_' has a wrong offset!");
static_assert(offsetof(ADropItem, AdsorptionVector_) == 0x00028C, "Member 'ADropItem::AdsorptionVector_' has a wrong offset!");
static_assert(offsetof(ADropItem, NowState_) == 0x000298, "Member 'ADropItem::NowState_' has a wrong offset!");
static_assert(offsetof(ADropItem, TargetPos_) == 0x00029C, "Member 'ADropItem::TargetPos_' has a wrong offset!");
static_assert(offsetof(ADropItem, IsDispersionMove_) == 0x0002A8, "Member 'ADropItem::IsDispersionMove_' has a wrong offset!");
static_assert(offsetof(ADropItem, ActiveTickCounter_) == 0x0002AC, "Member 'ADropItem::ActiveTickCounter_' has a wrong offset!");
static_assert(offsetof(ADropItem, RegistNum_) == 0x0002B0, "Member 'ADropItem::RegistNum_' has a wrong offset!");
static_assert(offsetof(ADropItem, GetSound_) == 0x0002B8, "Member 'ADropItem::GetSound_' has a wrong offset!");
static_assert(offsetof(ADropItem, AddItemSeCue) == 0x0002C0, "Member 'ADropItem::AddItemSeCue' has a wrong offset!");

// Class BattlePrototype.DynamicMaterialControllerComponent
// 0x0070 (0x0130 - 0x00C0)
class UDynamicMaterialControllerComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             _dispatcherEndParameterFade;                       // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x60];                                      // 0x00D0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDynamicMaterialControllerComponent* GetDynamicMaterialControllerComponent(class AActor* Actor);

	float GetScalarParameterValue(class FName ParameterName);
	struct FLinearColor GetVectorParameterValue(class FName ParameterName);
	void SetScalarParameterValue(class FName ParameterName, float Value);
	void SetTextureParameterValue(class FName ParameterName, class UTexture* Value);
	void SetupMeshMaterials();
	void SetVectorParameterValue(class FName ParameterName, const struct FLinearColor& Value);
	void StartFadeScalarParameter(class FName ParameterName, bool bToOne, float FadeSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicMaterialControllerComponent">();
	}
	static class UDynamicMaterialControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicMaterialControllerComponent>();
	}
};
static_assert(alignof(UDynamicMaterialControllerComponent) == 0x000008, "Wrong alignment on UDynamicMaterialControllerComponent");
static_assert(sizeof(UDynamicMaterialControllerComponent) == 0x000130, "Wrong size on UDynamicMaterialControllerComponent");
static_assert(offsetof(UDynamicMaterialControllerComponent, _dispatcherEndParameterFade) == 0x0000C0, "Member 'UDynamicMaterialControllerComponent::_dispatcherEndParameterFade' has a wrong offset!");

// Class BattlePrototype.EffectBackgroundMother
// 0x0008 (0x0238 - 0x0230)
class AEffectBackgroundMother : public AActor
{
public:
	float                                         MergeDistance_;                                    // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool MergeEffectBG();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectBackgroundMother">();
	}
	static class AEffectBackgroundMother* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEffectBackgroundMother>();
	}
};
static_assert(alignof(AEffectBackgroundMother) == 0x000008, "Wrong alignment on AEffectBackgroundMother");
static_assert(sizeof(AEffectBackgroundMother) == 0x000238, "Wrong size on AEffectBackgroundMother");
static_assert(offsetof(AEffectBackgroundMother, MergeDistance_) == 0x000230, "Member 'AEffectBackgroundMother::MergeDistance_' has a wrong offset!");

// Class BattlePrototype.EnemyAiComponentBase
// 0x0060 (0x0120 - 0x00C0)
class UEnemyAiComponentBase : public UActorComponent
{
public:
	TWeakObjectPtr<class ARSCharacterBase>        MOwnerCharacter;                                   // 0x00C0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         MCurrentAction;                                    // 0x00C8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEnemyThinkActionType                         MThinkActionType;                                  // 0x00C9(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MEnableAllowance;                                  // 0x00CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CB[0x1];                                       // 0x00CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MAllowanceWaitSeconds;                             // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameTimer                             MAllowanceWaitTimer;                               // 0x00D0(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          MCanAttackOnce;                                    // 0x00DC(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DD[0x43];                                      // 0x00DD(0x0043)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckIdleMoveActionNative(uint8 CheckAction, const TArray<uint8>& IdleMoveAction);
	bool CheckIsAiActionParam(bool NotProbability, float LProbability, float LHp, uint8 ActionEnum);
	float GetActionTimeNative(uint8 CurAction);
	float GetAiTimer_FromNative(uint8 ActionEnym);
	void Initialize(class UEnemyScriptComponent* EnemyScript, bool IsFlyEnemy, float AIActionHeight);
	bool IsAiActionNative(uint8 ActionEnum, float* Range_Work, float* NoRange_Work, float* Angle_Work, float* NoAngle_Work, TArray<uint8>* LConditions, bool bIgnoreMove, class ARSCharacterBase* MTargetCharacter, bool IsContrlPlayer, float TargetHeight, bool* IsPreCondition, bool NotProbability);
	bool IsAttackingOtherEnemyNative(class ARSCharacterBase* MTargetCharacter);
	bool IsCommonAreaOKNative(EEnemyThinkActionType ActionType, float TargetHeight);
	bool IsPossibleAttackNative(bool IsControlPlayer, bool IgnoreOutofScreen, bool IgnoreRestrictAttackOther, class ARSCharacterBase* MTargetCharacter);
	bool IsPossibleMoveNative(bool IgnoreOutofScreen, bool IgnoreRestrictAttackOther, class ARSCharacterBase* MTargetCharacter);
	bool IsPreConditionOKNative(EEnemyThinkActionType ActionType, bool bNeedRay, bool IgnoreOutofScreen, bool IgnoreRestrictAttackOther, bool NotBrainField, bool bIgnoreMove, class ARSCharacterBase* MTargetCharacter, bool IsContrlPlayer, float TargetHeight);
	bool IsTimerOKNative(uint8 ActionEnym);
	void NotifyExecAttack();
	void ResetReserveActionNative();
	void SetActionFromReservedNative();
	void SetActionNative(uint8 ActionEnum, class FName Action, class ARSCharacterBase* MTargetCharacter, bool bIgnoreMove);
	void SetCurrentAction(uint8 Value);
	void SetIdleMoveActionNative(TArray<uint8>& IdleMoveAction);
	void SetReserveActionNative(uint8 Action, float Param00, float Param01);
	void SetThinkActionType(EEnemyThinkActionType Type);
	void SetWaitNextActionTimer(float Seconds);

	uint8 GetCurrentAction() const;
	EEnemyThinkActionType GetThinkActionType() const;
	bool IsCanAttack() const;
	bool IsDamageNative() const;
	bool IsEventNative() const;
	bool IsHpPercentDownNative(float Percent, bool* Error) const;
	bool IsIdleMoveNative(bool IsIdleMove) const;
	bool IsRandomCheckNative(float CheckValue) const;
	bool IsReservedActionNative() const;
	bool IsTimeCheckNative(float CheckValue) const;
	bool IsWaitNextActionTimer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyAiComponentBase">();
	}
	static class UEnemyAiComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyAiComponentBase>();
	}
};
static_assert(alignof(UEnemyAiComponentBase) == 0x000008, "Wrong alignment on UEnemyAiComponentBase");
static_assert(sizeof(UEnemyAiComponentBase) == 0x000120, "Wrong size on UEnemyAiComponentBase");
static_assert(offsetof(UEnemyAiComponentBase, MOwnerCharacter) == 0x0000C0, "Member 'UEnemyAiComponentBase::MOwnerCharacter' has a wrong offset!");
static_assert(offsetof(UEnemyAiComponentBase, MCurrentAction) == 0x0000C8, "Member 'UEnemyAiComponentBase::MCurrentAction' has a wrong offset!");
static_assert(offsetof(UEnemyAiComponentBase, MThinkActionType) == 0x0000C9, "Member 'UEnemyAiComponentBase::MThinkActionType' has a wrong offset!");
static_assert(offsetof(UEnemyAiComponentBase, MEnableAllowance) == 0x0000CA, "Member 'UEnemyAiComponentBase::MEnableAllowance' has a wrong offset!");
static_assert(offsetof(UEnemyAiComponentBase, MAllowanceWaitSeconds) == 0x0000CC, "Member 'UEnemyAiComponentBase::MAllowanceWaitSeconds' has a wrong offset!");
static_assert(offsetof(UEnemyAiComponentBase, MAllowanceWaitTimer) == 0x0000D0, "Member 'UEnemyAiComponentBase::MAllowanceWaitTimer' has a wrong offset!");
static_assert(offsetof(UEnemyAiComponentBase, MCanAttackOnce) == 0x0000DC, "Member 'UEnemyAiComponentBase::MCanAttackOnce' has a wrong offset!");

// Class BattlePrototype.EnemyAnimControllerComponent
// 0x0038 (0x0118 - 0x00E0)
class UEnemyAnimControllerComponent final : public UAnimControllerComponent
{
public:
	FMulticastInlineDelegateProperty_             DispatchMontageBlendingOut;                        // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class URSEnemyAnimInstance>    _animBP;                                           // 0x00F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x20];                                      // 0x00F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UEnemyAnimControllerComponent* GetEnemyAnimControllerComponentFromActor(class AActor* Actor);

	void BeginAction(EnemyActionAnimKind Action);
	void BeginAttack(EnemyAttackAnimKind Attack);
	void BeginDie();
	void BeginExcite();
	void BeginGetUp();
	void BeginMove(EnemyMoveAnimKind Move);
	void BeginMoveBackward();
	bool CheckEndExcite(bool IsEndAnim);
	bool CheckGoToIdleMove(bool IsEndAnim);
	void EndMoveBackward();
	void OnEndAnimDie();
	void OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void SetAliveAnimKind(EnemyAliveAnimKind Alive);
	void SetAnimRootMotionScale(float Scale);
	void SetBrainCrash(EnemyBrainCrashAnimKind Crash);
	void SetCrashChance(EnemyCrashChanceAnimKind Chance);
	void SetDamage(EnemyDamageAnimKind Damage);
	void SetDamageDown(EnemyDamageDownAnimKind Damage);
	void SetDead(EnemyDeadAnimKind Dead);
	void SetEnemyKind(EnemyKind Kind);
	void SetIgnoreStandUpSuperArmor(bool IsIgnoreStandUpSuperArmor);
	void SetIgnoreSuperArmor(bool IsIgnoreSuperArmor);
	void SetInitLayout(EnemyInitLayoutAnimKind Layout);
	void SetLanded(bool Landed);
	void SetMove(EnemyMoveAnimKind Move);
	void SetSuperArmor(bool IsSuperArmor);
	void SetSwitchAnimKind(EnemySwitchAnimKind Anim);
	void UpdateAnimDirectionAndSpeed();

	bool AliveToDie() const;
	bool CheckFaintToWakeup(bool IsEndAnim) const;
	float DotOfHitDirAndRight() const;
	float DotOfHitDirAndUp() const;
	float GetDirection() const;
	EnemyActionAnimKind GetEnemyActionAnimKind() const;
	EnemyAliveAnimKind GetEnemyAliveAnimKind() const;
	EnemyAttackAnimKind GetEnemyAttackAnimKind() const;
	EnemyBrainCrashAnimKind GetEnemyBrainCrashAnimKind() const;
	EnemyCrashChanceAnimKind GetEnemyCrashChanceAnimKind() const;
	EnemyDamageAnimKind GetEnemyDamageAnimKind() const;
	EnemyDamageDownAnimKind GetEnemyDamageDownAnimKind() const;
	EnemyDeadAnimKind GetEnemyDeadAnimKind() const;
	EnemyKind GetEnemyKind() const;
	EnemyMoveAnimKind GetMove() const;
	float GetSpeed() const;
	EnemySwitchAnimKind GetSwitchAnimKind() const;
	bool IsAction(EnemyActionAnimKind Action) const;
	bool IsActionAnimKind(const TArray<EnemyActionAnimKind>& KindArray) const;
	bool IsASNodePlayEnd() const;
	bool IsAttack(EnemyAttackAnimKind Attack) const;
	bool IsAttackAnimKind(const TArray<EnemyAttackAnimKind>& KindArray) const;
	bool IsAttackFlg() const;
	bool IsBrainCrashAnimKind() const;
	bool IsCrashChanceAnimKind() const;
	bool IsDamage() const;
	bool IsDamageAnimKindBlow() const;
	bool IsDamageAnimKindDamageChance() const;
	bool IsDamageAnimKindDown() const;
	bool IsDamageAnimKindKnockBack() const;
	bool IsDamageAnimKindLaunch() const;
	bool IsDamageAnimKindSpecialDamage() const;
	bool IsDamageAnimKindSpecialDamageDown() const;
	bool IsDamageAnimKindWince() const;
	bool IsDamageAnimLight2() const;
	bool IsDamageAnimStateB() const;
	bool IsDeadComplete() const;
	bool IsDie() const;
	bool IsIgnoreCrashChance() const;
	bool IsLanded() const;
	bool IsMove(EnemyMoveAnimKind Move) const;
	bool IsPossibleDamageAnimKind() const;
	bool IsPossibleDamageAnimKindBlow() const;
	bool IsPossibleDamageAnimKindDamageChance() const;
	bool IsPossibleDamageAnimKindDown() const;
	bool IsPossibleDamageAnimKindKnockBack() const;
	bool IsPossibleDamageAnimKindLaunch() const;
	bool IsPossibleDamageAnimKindSpecialDamageDown() const;
	bool IsPossibleDamageAnimKindWince() const;
	bool IsPressDownAnimKind() const;
	bool StateAliveIsAction() const;
	bool StateAliveIsAttack() const;
	bool StateAliveIsDamage() const;
	bool StateAliveIsIdleMove() const;
	bool StateAliveIsInitLayout() const;
	bool StateIsBack() const;
	bool StateIsExcite() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyAnimControllerComponent">();
	}
	static class UEnemyAnimControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyAnimControllerComponent>();
	}
};
static_assert(alignof(UEnemyAnimControllerComponent) == 0x000008, "Wrong alignment on UEnemyAnimControllerComponent");
static_assert(sizeof(UEnemyAnimControllerComponent) == 0x000118, "Wrong size on UEnemyAnimControllerComponent");
static_assert(offsetof(UEnemyAnimControllerComponent, DispatchMontageBlendingOut) == 0x0000E0, "Member 'UEnemyAnimControllerComponent::DispatchMontageBlendingOut' has a wrong offset!");
static_assert(offsetof(UEnemyAnimControllerComponent, _animBP) == 0x0000F0, "Member 'UEnemyAnimControllerComponent::_animBP' has a wrong offset!");

// Class BattlePrototype.EnemyCalcGoalComponent
// 0x0050 (0x0120 - 0x00D0)
class UEnemyCalcGoalComponent final : public UEnemyAsyncTaskComponentBase
{
public:
	uint8                                         Pad_D0[0x50];                                      // 0x00D0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginAsyncTask();
	void EndAsyncTask();
	void ReSetIntervalTime();
	void SetCalcParam(const struct FVector& Start, const struct FVector& End, float Radius);
	void SetIntervalTime(float NewIntervalTime);

	struct FVector GetCalcLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyCalcGoalComponent">();
	}
	static class UEnemyCalcGoalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyCalcGoalComponent>();
	}
};
static_assert(alignof(UEnemyCalcGoalComponent) == 0x000008, "Wrong alignment on UEnemyCalcGoalComponent");
static_assert(sizeof(UEnemyCalcGoalComponent) == 0x000120, "Wrong size on UEnemyCalcGoalComponent");

// Class BattlePrototype.EnemyDamageMoveComponentBase
// 0x0058 (0x0118 - 0x00C0)
class UEnemyDamageMoveComponentBase : public UActorComponent
{
public:
	class ARSCharacterBase*                       MOwnerEnemy;                                       // 0x00C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x50];                                      // 0x00C8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetLength();
	void SetDamageMoveScale(float Scale);
	void Start_Native(const struct FVector& DamageDir, float Power, bool DeadMove, class AActor* Attacker);
	void Update_Native(float DeltaSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyDamageMoveComponentBase">();
	}
	static class UEnemyDamageMoveComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyDamageMoveComponentBase>();
	}
};
static_assert(alignof(UEnemyDamageMoveComponentBase) == 0x000008, "Wrong alignment on UEnemyDamageMoveComponentBase");
static_assert(sizeof(UEnemyDamageMoveComponentBase) == 0x000118, "Wrong size on UEnemyDamageMoveComponentBase");
static_assert(offsetof(UEnemyDamageMoveComponentBase, MOwnerEnemy) == 0x0000C0, "Member 'UEnemyDamageMoveComponentBase::MOwnerEnemy' has a wrong offset!");

// Class BattlePrototype.EnemyDefineFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UEnemyDefineFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool EnemyGrade_LockOnIsGreater(EEnemyGrade MyPri, EEnemyGrade OtherPri);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyDefineFunctionLibrary">();
	}
	static class UEnemyDefineFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyDefineFunctionLibrary>();
	}
};
static_assert(alignof(UEnemyDefineFunctionLibrary) == 0x000008, "Wrong alignment on UEnemyDefineFunctionLibrary");
static_assert(sizeof(UEnemyDefineFunctionLibrary) == 0x000028, "Wrong size on UEnemyDefineFunctionLibrary");

// Class BattlePrototype.EnemyDropDataUtility
// 0x0000 (0x0028 - 0x0028)
class UEnemyDropDataUtility final : public UBlueprintFunctionLibrary
{
public:
	static void DebugDropItemLotteryParam(class FName EnemyID, int32 TableNo, float Rate, float Randnum);
	static bool GetCoreDropItemID(const struct FEnemyDropDataCell& RCell, const bool IsRare, class FName* ItemId, int32* ItemNum, class FName EnemyID, int32 TableNo, float Rate, float Randnum);
	static bool GetDataDropItemID(const struct FEnemyDropDataCell& RCell, const bool IsRare, class FName* ItemId, int32* ItemNum, class FName EnemyID, int32 TableNo, float Rate, float Randnum);
	static class FString GetDebugLotteryParamString(int32 Index_0);
	static int32 GetDropExperience(const struct FEnemyDropDataCell& RCell);
	static float GetDropItemProbability(const struct FEnemyDropDataCell& RCell);
	static int32 GetDropMoney(const struct FEnemyDropDataCell& RCell);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyDropDataUtility">();
	}
	static class UEnemyDropDataUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyDropDataUtility>();
	}
};
static_assert(alignof(UEnemyDropDataUtility) == 0x000008, "Wrong alignment on UEnemyDropDataUtility");
static_assert(sizeof(UEnemyDropDataUtility) == 0x000028, "Wrong size on UEnemyDropDataUtility");

// Class BattlePrototype.EnemyGoalComponentBase
// 0x0040 (0x0100 - 0x00C0)
class UEnemyGoalComponentBase : public UActorComponent
{
public:
	class UEnemyCalcGoalComponent*                MCalcComponent;                                    // 0x00C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 MMoveGoalActor;                                    // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 MMyEnemy;                                          // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARSCharacterBase*                       MTargetCharacter;                                  // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MTargetLocation;                                   // 0x00E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnemyGoalType                                MGoalType;                                         // 0x00EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MHitWallRadius;                                    // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MHitWallHeight;                                    // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbDisableUpdateCharacter;                          // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector CorrectionHitCollision_Native(const struct FVector& SrcLocation, const struct FVector& DstLocation, float Radius);
	void EndPlay_Native();
	class AActor* GetGoalActor_Native();
	class ARSCharacterBase* GetTargetActor_Native();
	struct FVector GetTargetLocation_Native();
	void Initialize_Native();
	float InitializeGetCapsuleRadius_FromNative(class AActor* Owner);
	class UEnemyCalcGoalComponent* InitializeGetEnemyCalcComponent_FromNative(class AActor* Owner);
	class AActor* InitializeSpawnMoveGoalActor_FromNative(class AActor* Owner);
	void MainTick_Native(float DeltaSeconds);
	void ResetGoalIntervalTime_Native();
	void SetGoalIntervalTime_Native(float NewIntervalTime);
	void SetTargetActor_Native(class ARSCharacterBase* Character);
	void SetTargetLocation_Native(const struct FVector& Location);
	void UpdateTargetCharacter_Native(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyGoalComponentBase">();
	}
	static class UEnemyGoalComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyGoalComponentBase>();
	}
};
static_assert(alignof(UEnemyGoalComponentBase) == 0x000008, "Wrong alignment on UEnemyGoalComponentBase");
static_assert(sizeof(UEnemyGoalComponentBase) == 0x000100, "Wrong size on UEnemyGoalComponentBase");
static_assert(offsetof(UEnemyGoalComponentBase, MCalcComponent) == 0x0000C0, "Member 'UEnemyGoalComponentBase::MCalcComponent' has a wrong offset!");
static_assert(offsetof(UEnemyGoalComponentBase, MMoveGoalActor) == 0x0000C8, "Member 'UEnemyGoalComponentBase::MMoveGoalActor' has a wrong offset!");
static_assert(offsetof(UEnemyGoalComponentBase, MMyEnemy) == 0x0000D0, "Member 'UEnemyGoalComponentBase::MMyEnemy' has a wrong offset!");
static_assert(offsetof(UEnemyGoalComponentBase, MTargetCharacter) == 0x0000D8, "Member 'UEnemyGoalComponentBase::MTargetCharacter' has a wrong offset!");
static_assert(offsetof(UEnemyGoalComponentBase, MTargetLocation) == 0x0000E0, "Member 'UEnemyGoalComponentBase::MTargetLocation' has a wrong offset!");
static_assert(offsetof(UEnemyGoalComponentBase, MGoalType) == 0x0000EC, "Member 'UEnemyGoalComponentBase::MGoalType' has a wrong offset!");
static_assert(offsetof(UEnemyGoalComponentBase, MHitWallRadius) == 0x0000F0, "Member 'UEnemyGoalComponentBase::MHitWallRadius' has a wrong offset!");
static_assert(offsetof(UEnemyGoalComponentBase, MHitWallHeight) == 0x0000F4, "Member 'UEnemyGoalComponentBase::MHitWallHeight' has a wrong offset!");
static_assert(offsetof(UEnemyGoalComponentBase, MbDisableUpdateCharacter) == 0x0000F8, "Member 'UEnemyGoalComponentBase::MbDisableUpdateCharacter' has a wrong offset!");

// Class BattlePrototype.EnemyLookCheckComponent
// 0x00A0 (0x0170 - 0x00D0)
class UEnemyLookCheckComponent final : public UEnemyAsyncTaskComponentBase
{
public:
	uint8                                         Pad_D0[0xA0];                                      // 0x00D0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginLookCheck();
	void EndLookCheck();
	bool GetFailedLook();
	void SetRayPos(const struct FVector& Start, const struct FVector& End);
	void SetRayPos2(const struct FVector& MainStart, const struct FVector& MainEnd, const struct FVector& TargetStart, const struct FVector& TargetEnd);

	bool IsLookMain() const;
	bool IsLookTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyLookCheckComponent">();
	}
	static class UEnemyLookCheckComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyLookCheckComponent>();
	}
};
static_assert(alignof(UEnemyLookCheckComponent) == 0x000008, "Wrong alignment on UEnemyLookCheckComponent");
static_assert(sizeof(UEnemyLookCheckComponent) == 0x000170, "Wrong size on UEnemyLookCheckComponent");

// Class BattlePrototype.EnemyPathAreaCheckComponent
// 0x0050 (0x0120 - 0x00D0)
class UEnemyPathAreaCheckComponent final : public UEnemyAsyncTaskComponentBase
{
public:
	uint8                                         Pad_D0[0x50];                                      // 0x00D0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginAreaCheck();
	void EndAreaCheck();
	void SetCheckPos(const struct FVector& StartPos, const struct FVector& EndPos, class AActor* TargetActor);
	void SetIntervalTime(float NewIntervalTime);

	bool IsAreaOut() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyPathAreaCheckComponent">();
	}
	static class UEnemyPathAreaCheckComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyPathAreaCheckComponent>();
	}
};
static_assert(alignof(UEnemyPathAreaCheckComponent) == 0x000008, "Wrong alignment on UEnemyPathAreaCheckComponent");
static_assert(sizeof(UEnemyPathAreaCheckComponent) == 0x000120, "Wrong size on UEnemyPathAreaCheckComponent");

// Class BattlePrototype.EnemyScrollCheckComponent
// 0x0048 (0x0118 - 0x00D0)
class UEnemyScrollCheckComponent final : public UEnemyAsyncTaskComponentBase
{
public:
	uint8                                         Pad_D0[0x48];                                      // 0x00D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginScrollCheck();
	void EndScrollCheck();
	void SetCheckPos(const struct FVector& StartPos, const struct FVector& EndPos);
	void SetFloorAngle(float NewFloorAngle);
	void SetIntervalTime(float NewIntervalTime);

	bool IsHitFloorOrCeiling() const;
	bool IsHitScroll() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyScrollCheckComponent">();
	}
	static class UEnemyScrollCheckComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyScrollCheckComponent>();
	}
};
static_assert(alignof(UEnemyScrollCheckComponent) == 0x000008, "Wrong alignment on UEnemyScrollCheckComponent");
static_assert(sizeof(UEnemyScrollCheckComponent) == 0x000118, "Wrong size on UEnemyScrollCheckComponent");

// Class BattlePrototype.EventAsset
// 0x0038 (0x0060 - 0x0028)
class UEventAsset final : public UObject
{
public:
	int32                                         ID;                                                // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        FilePath;                                          // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Asset;                                             // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishLoad();
	void Release();

	class UObject* GetAsset() const;
	bool IsLoaded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAsset">();
	}
	static class UEventAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAsset>();
	}
};
static_assert(alignof(UEventAsset) == 0x000008, "Wrong alignment on UEventAsset");
static_assert(sizeof(UEventAsset) == 0x000060, "Wrong size on UEventAsset");
static_assert(offsetof(UEventAsset, ID) == 0x000028, "Member 'UEventAsset::ID' has a wrong offset!");
static_assert(offsetof(UEventAsset, FilePath) == 0x000030, "Member 'UEventAsset::FilePath' has a wrong offset!");
static_assert(offsetof(UEventAsset, Asset) == 0x000048, "Member 'UEventAsset::Asset' has a wrong offset!");

// Class BattlePrototype.EventCelLookLightBase
// 0x0000 (0x0230 - 0x0230)
class AEventCelLookLightBase : public AActor
{
public:
	bool IsEditorTimelineSetup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventCelLookLightBase">();
	}
	static class AEventCelLookLightBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventCelLookLightBase>();
	}
};
static_assert(alignof(AEventCelLookLightBase) == 0x000008, "Wrong alignment on AEventCelLookLightBase");
static_assert(sizeof(AEventCelLookLightBase) == 0x000230, "Wrong size on AEventCelLookLightBase");

// Class BattlePrototype.EventInterface
// 0x0000 (0x0028 - 0x0028)
class IEventInterface final : public IInterface
{
public:
	bool BattleSequencerEnd(bool IsRestoreTransform, bool IsSetEnemyEvent, bool bDriveSequence);
	bool BattleSequencerStart(bool IsSetEnemyEvent, bool bDriveSequence);
	bool DynamicEventBeforeBindCharacter();
	bool DynamicEventEnd(bool IsRestoreTransform);
	bool DynamicEventStart();
	bool EventEnd();
	void EventPhysicsIdling(float IdlingSec, float IdleRestoreDelay);
	bool EventStart();
	bool IsEndEventAnimMontage(class UAnimMontage* AnimMontage);
	bool PlayEventAnimMontage(class UAnimMontage* AnimMontage, class FName Section, float InPlayRate);
	bool ResetShadowOffset();
	bool SetEventVisible(bool Visible);
	bool SetHoodVisible(bool Visible);
	bool SetShadowOffsetMapID(EMaterialShadowOffsetID ShadowOffsetID);
	bool SetShadowOffsetTexture(class UTexture2D* Texture);
	bool StaticEventEnd(bool IsRestoreTransform);
	bool StaticEventStart();
	bool StopEventAnimMontage(class UAnimMontage* AnimMontage);
	bool TalkEventEnd(bool IsRestoreTransform);
	bool TalkEventStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventInterface">();
	}
	static class IEventInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEventInterface>();
	}
};
static_assert(alignof(IEventInterface) == 0x000008, "Wrong alignment on IEventInterface");
static_assert(sizeof(IEventInterface) == 0x000028, "Wrong size on IEventInterface");

// Class BattlePrototype.EventManager
// 0x0100 (0x0330 - 0x0230)
class AEventManager : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProgressId;                                        // 0x0238(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StoreOwnerShipExternalActorTag;                    // 0x0240(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInvalidFade;                                     // 0x0248(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSkipEvent;                                       // 0x0249(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCutSceneCalledSkipEvent;                         // 0x024A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCurrentSkipFadeOut;                              // 0x024B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCurrentTalkEvent;                                // 0x024C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsForceBrainTalkMode;                              // 0x024D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24E[0x2];                                      // 0x024E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaticEventSoundPressure;                          // 0x0250(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARSCharaAnimationAccessor*>      CharaAnimationAccessorArray;                       // 0x0258(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_StoreUnControlMgrFlags;                          // 0x0268(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDisableDynamicResInStaticCutScene;               // 0x026C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStoreSequencerInGameTransformEvent;              // 0x026D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26E[0x2];                                      // 0x026E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStartCutSceneNative;                             // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndCutSceneNative;                               // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBeforeChangeProgressIDNative;                    // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAfterChangeProgressIDNative;                     // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class URSParticleSystemComponentBase*         StaticCutsceneBG;                                  // 0x02B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARSLevelSequenceActor*                  Sequencer;                                         // 0x02B8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_messageTableName;                                // 0x02C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         MakeEventActorArray;                               // 0x02D0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FArrayOfMID>                    CapturePPMStatic;                                  // 0x02F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FArrayOfMID>                    CapturePPMDynamic;                                 // 0x0300(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInterface*>             M_PreLoadPPMList;                                  // 0x0310(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMakeEventActorArray(class AActor* Actor);
	void AddMessageVoiceRipSyncInfoList(class URSAtomComponentBase* AtomComp, class FName RipSyncBoardJointID);
	void AfterChangeProgressID();
	void BeforeChangeProgressID();
	void BindingActorNative(const class FName& ActorTag, const class FText& BindingName);
	void CallAfterChangeProgressIDNative();
	void CallBeforeChangeProgressIDNative();
	void CallEndCutSceneNative();
	void CallStartCutSceneNative();
	void ChangeSpeakerToVoice(class URSAtomComponentBase* Voice);
	void CheckAndSetTalkEventPlayerRipSync(const class FString& MessageLabel, class URSAtomComponentBase* PAtomComponent);
	bool CheckProgressID(int32 MinProgressID, int32 MaxProgressID);
	bool CheckScenarioFlagListC(const TArray<struct FShowDestinationFlgCheck>& FlgCheckList);
	void ClearFacialNormalCache();
	void ClearSequencerInCharacter();
	bool EnableEventUnControlMgrFlag(EEventUnControlManagerType UnControlMgrType);
	void EndTalkEvent();
	void EndWork();
	void EventAllManagerEnd(bool RestoreTickEnable, bool RestoreVisibility);
	void EventAllManagerStart(bool TickEnable, bool Visibility);
	void FinishSequencer();
	class UEventAssetPoolComponent* GetAssetPool();
	class AEventCaptureActorBase* GetCaptureActorBase(int32 Index_0);
	int32 GetCurrentChapterID();
	TArray<class FString> GetLoadedAndLoadingMakeEventPathList();
	TArray<class AActor*> GetMakeEventActorArray();
	int32 GetMakeEventActorArrayNum();
	const struct FArrayOfMID GetOrLoadPPMDynamic(EEventPostProcessID EventPostProcessID, bool Load);
	const struct FArrayOfMID GetOrLoadPPMStatic(EEventPostProcessID EventPostProcessID, bool Load);
	bool IsCurrentCreditEvent();
	bool IsCurrentEventOffSkipEndFade();
	bool IsCurrentZeroEP();
	bool IsCutSceneEventNative();
	bool IsEmptySeqCaptureFuncList();
	bool IsEndDynamicCutscene();
	bool IsEndPostProcessSequencer();
	bool IsFadeAnimation();
	bool IsLoadingMakeEventAsset();
	bool IsNowSettingSeqCaptureBrainMes();
	bool IsPlayBeforeBoardAnimation();
	bool IsPlayingNewStaticBaseAnimation();
	bool IsPlayingNewStaticPhaseAnimation();
	bool IsTalkEvent();
	void IsValidEventCommandTypeFromNative(EEventTriggerCheckType EventCommandType, bool CheckBrainTalkEvent, bool* IsValid);
	bool IsVisibleCharaNameForProgressID(EPlayerID PlayerId);
	bool IsWaitSequencerCaptureBG();
	void IsWorldMapShowDestinationForAreaName2Native(int32 LocationId, int32 AreaId, int32 PortalID, uint8 ShowType, class UDatabaseManager* DatabaseManager, bool IsProgressBondsEpisode, class UUserParamManager* UserParamManager, bool* IsShow, int32* VisibleWeight);
	void OnChangeSoundPressure(float SoundPressure);
	bool OnSkipInput();
	bool OnWaitInputFinishEvent();
	void PreLoadPPM(EEventPostProcessID EventPostProcessID, TArray<class UMaterialInterface*>* OutPPMList);
	void PreLoadPPMResident(const TArray<EEventPostProcessID>& EventPostProcessIDList);
	void ResetPrestreamTextures(const TArray<class UTexture2D*>& SetupTextures);
	void SetMessageTableName(const class FString& TableName);
	void SetPPMAsset(EEventPostProcessID EventPostProcessID, const TArray<TSoftObjectPtr<class UMaterialInterface>>& Assets, class FName ResetParamName, float ResetParamValue);
	void SetProgressIDNative(int32 ProgressId_0);
	void SetSequenceEnd();
	void SetupPrestreamTextures(class AActor* MakeEventActor, TArray<class UTexture2D*>* OutSetupTextures);
	class AActor* SpawnActorEvent(class UClass* ActorAsset, bool IsPersistant);
	class AActor* SpawnActorFromBP(class UBlueprint* ActorAsset, const class FText& BindingName);
	class AActor* SpawnActorNative(class UClass* ActorAsset, const class FText& BindingName);
	void StartDynamicCutscene(const class FString& CutsceneName);
	void StartDynamicCutsceneFromAsset(class ULevelSequence* Sequence, bool IsSeamlessInGame);
	void StartEventFinishWaitMode_AfterCounter();
	void StartTalkEvent();
	void SubMakeEventActorArray(class AActor* Actor);
	void UnloadPPMNative(EEventPostProcessID EventPostProcessID);
	void UpdateFacialNormalNative(TArray<class AActor*>* TargetSkelMeshActors, bool bUseCache);
	void WaitSequencerSetting(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);

	class FString GetMessageTableName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventManager">();
	}
	static class AEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventManager>();
	}
};
static_assert(alignof(AEventManager) == 0x000008, "Wrong alignment on AEventManager");
static_assert(sizeof(AEventManager) == 0x000330, "Wrong size on AEventManager");
static_assert(offsetof(AEventManager, ProgressId) == 0x000238, "Member 'AEventManager::ProgressId' has a wrong offset!");
static_assert(offsetof(AEventManager, StoreOwnerShipExternalActorTag) == 0x000240, "Member 'AEventManager::StoreOwnerShipExternalActorTag' has a wrong offset!");
static_assert(offsetof(AEventManager, IsInvalidFade) == 0x000248, "Member 'AEventManager::IsInvalidFade' has a wrong offset!");
static_assert(offsetof(AEventManager, IsSkipEvent) == 0x000249, "Member 'AEventManager::IsSkipEvent' has a wrong offset!");
static_assert(offsetof(AEventManager, IsCutSceneCalledSkipEvent) == 0x00024A, "Member 'AEventManager::IsCutSceneCalledSkipEvent' has a wrong offset!");
static_assert(offsetof(AEventManager, IsCurrentSkipFadeOut) == 0x00024B, "Member 'AEventManager::IsCurrentSkipFadeOut' has a wrong offset!");
static_assert(offsetof(AEventManager, IsCurrentTalkEvent) == 0x00024C, "Member 'AEventManager::IsCurrentTalkEvent' has a wrong offset!");
static_assert(offsetof(AEventManager, IsForceBrainTalkMode) == 0x00024D, "Member 'AEventManager::IsForceBrainTalkMode' has a wrong offset!");
static_assert(offsetof(AEventManager, StaticEventSoundPressure) == 0x000250, "Member 'AEventManager::StaticEventSoundPressure' has a wrong offset!");
static_assert(offsetof(AEventManager, CharaAnimationAccessorArray) == 0x000258, "Member 'AEventManager::CharaAnimationAccessorArray' has a wrong offset!");
static_assert(offsetof(AEventManager, M_StoreUnControlMgrFlags) == 0x000268, "Member 'AEventManager::M_StoreUnControlMgrFlags' has a wrong offset!");
static_assert(offsetof(AEventManager, IsDisableDynamicResInStaticCutScene) == 0x00026C, "Member 'AEventManager::IsDisableDynamicResInStaticCutScene' has a wrong offset!");
static_assert(offsetof(AEventManager, IsStoreSequencerInGameTransformEvent) == 0x00026D, "Member 'AEventManager::IsStoreSequencerInGameTransformEvent' has a wrong offset!");
static_assert(offsetof(AEventManager, OnStartCutSceneNative) == 0x000270, "Member 'AEventManager::OnStartCutSceneNative' has a wrong offset!");
static_assert(offsetof(AEventManager, OnEndCutSceneNative) == 0x000280, "Member 'AEventManager::OnEndCutSceneNative' has a wrong offset!");
static_assert(offsetof(AEventManager, OnBeforeChangeProgressIDNative) == 0x000290, "Member 'AEventManager::OnBeforeChangeProgressIDNative' has a wrong offset!");
static_assert(offsetof(AEventManager, OnAfterChangeProgressIDNative) == 0x0002A0, "Member 'AEventManager::OnAfterChangeProgressIDNative' has a wrong offset!");
static_assert(offsetof(AEventManager, StaticCutsceneBG) == 0x0002B0, "Member 'AEventManager::StaticCutsceneBG' has a wrong offset!");
static_assert(offsetof(AEventManager, Sequencer) == 0x0002B8, "Member 'AEventManager::Sequencer' has a wrong offset!");
static_assert(offsetof(AEventManager, M_messageTableName) == 0x0002C0, "Member 'AEventManager::M_messageTableName' has a wrong offset!");
static_assert(offsetof(AEventManager, MakeEventActorArray) == 0x0002D0, "Member 'AEventManager::MakeEventActorArray' has a wrong offset!");
static_assert(offsetof(AEventManager, CapturePPMStatic) == 0x0002F0, "Member 'AEventManager::CapturePPMStatic' has a wrong offset!");
static_assert(offsetof(AEventManager, CapturePPMDynamic) == 0x000300, "Member 'AEventManager::CapturePPMDynamic' has a wrong offset!");
static_assert(offsetof(AEventManager, M_PreLoadPPMList) == 0x000310, "Member 'AEventManager::M_PreLoadPPMList' has a wrong offset!");

// Class BattlePrototype.EventManagerInterface
// 0x0000 (0x0028 - 0x0028)
class IEventManagerInterface final : public IInterface
{
public:
	bool EventManagerEnd(bool RestoreEnableTick, bool RestoreVisibility);
	bool EventManagerStart(bool EnableTick, bool Visibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventManagerInterface">();
	}
	static class IEventManagerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEventManagerInterface>();
	}
};
static_assert(alignof(IEventManagerInterface) == 0x000008, "Wrong alignment on IEventManagerInterface");
static_assert(sizeof(IEventManagerInterface) == 0x000028, "Wrong size on IEventManagerInterface");

// Class BattlePrototype.EventSplineMovePoint
// 0x0008 (0x0238 - 0x0230)
class AEventSplineMovePoint : public AActor
{
public:
	class USplineComponent*                       SplineComponent;                                   // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventSplineMovePoint">();
	}
	static class AEventSplineMovePoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventSplineMovePoint>();
	}
};
static_assert(alignof(AEventSplineMovePoint) == 0x000008, "Wrong alignment on AEventSplineMovePoint");
static_assert(sizeof(AEventSplineMovePoint) == 0x000238, "Wrong size on AEventSplineMovePoint");
static_assert(offsetof(AEventSplineMovePoint, SplineComponent) == 0x000230, "Member 'AEventSplineMovePoint::SplineComponent' has a wrong offset!");

// Class BattlePrototype.ExporterBase
// 0x0010 (0x0240 - 0x0230)
class AExporterBase final : public AActor
{
public:
	EExporterType                                 ExporterType;                                      // 0x0230(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231[0xF];                                      // 0x0231(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndExportInternal();
	void EndExportShowDestination();
	void ExecExportInternal(int32 LocationId, int32 AreaId);
	void LoopExportShowDestination(int32 LocationId, int32 AreaId);
	void StartExportInternal();
	void StartExportShowDestination();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExporterBase">();
	}
	static class AExporterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExporterBase>();
	}
};
static_assert(alignof(AExporterBase) == 0x000008, "Wrong alignment on AExporterBase");
static_assert(sizeof(AExporterBase) == 0x000240, "Wrong size on AExporterBase");
static_assert(offsetof(AExporterBase, ExporterType) == 0x000230, "Member 'AExporterBase::ExporterType' has a wrong offset!");

// Class BattlePrototype.ExtendableArrowComponent
// 0x0000 (0x0420 - 0x0420)
class UExtendableArrowComponent final : public UArrowComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtendableArrowComponent">();
	}
	static class UExtendableArrowComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExtendableArrowComponent>();
	}
};
static_assert(alignof(UExtendableArrowComponent) == 0x000010, "Wrong alignment on UExtendableArrowComponent");
static_assert(sizeof(UExtendableArrowComponent) == 0x000420, "Wrong size on UExtendableArrowComponent");

// Class BattlePrototype.FaintConditionComponent
// 0x0030 (0x0190 - 0x0160)
class UFaintConditionComponent final : public UConditionComponent
{
public:
	float                                         _faintSec;                                         // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        _pFaintEffect;                                     // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               _pEffectComp;                                      // 0x0170(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_178[0x18];                                     // 0x0178(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FaintConditionComponent">();
	}
	static class UFaintConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFaintConditionComponent>();
	}
};
static_assert(alignof(UFaintConditionComponent) == 0x000010, "Wrong alignment on UFaintConditionComponent");
static_assert(sizeof(UFaintConditionComponent) == 0x000190, "Wrong size on UFaintConditionComponent");
static_assert(offsetof(UFaintConditionComponent, _faintSec) == 0x000160, "Member 'UFaintConditionComponent::_faintSec' has a wrong offset!");
static_assert(offsetof(UFaintConditionComponent, _pFaintEffect) == 0x000168, "Member 'UFaintConditionComponent::_pFaintEffect' has a wrong offset!");
static_assert(offsetof(UFaintConditionComponent, _pEffectComp) == 0x000170, "Member 'UFaintConditionComponent::_pEffectComp' has a wrong offset!");

// Class BattlePrototype.FallFloorAnimInstance
// 0x0020 (0x0290 - 0x0270)
class UFallFloorAnimInstance final : public UAnimInstance
{
public:
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsBreakAll;                                        // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRemovedAnyBlock;                                 // 0x0279(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A[0x6];                                      // 0x027A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        BoneScales;                                        // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallFloorAnimInstance">();
	}
	static class UFallFloorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallFloorAnimInstance>();
	}
};
static_assert(alignof(UFallFloorAnimInstance) == 0x000010, "Wrong alignment on UFallFloorAnimInstance");
static_assert(sizeof(UFallFloorAnimInstance) == 0x000290, "Wrong size on UFallFloorAnimInstance");
static_assert(offsetof(UFallFloorAnimInstance, IsBreakAll) == 0x000278, "Member 'UFallFloorAnimInstance::IsBreakAll' has a wrong offset!");
static_assert(offsetof(UFallFloorAnimInstance, IsRemovedAnyBlock) == 0x000279, "Member 'UFallFloorAnimInstance::IsRemovedAnyBlock' has a wrong offset!");
static_assert(offsetof(UFallFloorAnimInstance, BoneScales) == 0x000280, "Member 'UFallFloorAnimInstance::BoneScales' has a wrong offset!");

// Class BattlePrototype.FallFloorAnimInstanceInterface
// 0x0000 (0x0028 - 0x0028)
class IFallFloorAnimInstanceInterface final : public IInterface
{
public:
	bool AppearBlock(int32 BlockNo);
	bool RemoveBlock(int32 BlockNo);
	bool SetLaserDamage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallFloorAnimInstanceInterface">();
	}
	static class IFallFloorAnimInstanceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFallFloorAnimInstanceInterface>();
	}
};
static_assert(alignof(IFallFloorAnimInstanceInterface) == 0x000008, "Wrong alignment on IFallFloorAnimInstanceInterface");
static_assert(sizeof(IFallFloorAnimInstanceInterface) == 0x000028, "Wrong size on IFallFloorAnimInstanceInterface");

// Class BattlePrototype.FinishMoveActorManager
// 0x0050 (0x0280 - 0x0230)
class AFinishMoveActorManager : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 FmActor_;                                          // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCallingEffectFinish_;                            // 0x0240(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0xF];                                      // 0x0241(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSLevelSequenceActor*                  RsLevelSequencer_;                                 // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_258[0x18];                                     // 0x0258(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SequencePath_;                                     // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void FinishMoveBegin();
	void FinishMoveEnd();
	void FinishMoveUpdate();
	float GetSequenceRate();
	bool PauseFinishMove();
	void PauseFinishMoveSequence();
	bool RestartFinishMove();
	void RestartFinishMoveSequence();
	void RotateCameraYawAfterEvent(float RotYaw);
	void SetSequencePlayRate(float NewRate);
	void SpawnAndSwapFinishMoveActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FinishMoveActorManager">();
	}
	static class AFinishMoveActorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFinishMoveActorManager>();
	}
};
static_assert(alignof(AFinishMoveActorManager) == 0x000008, "Wrong alignment on AFinishMoveActorManager");
static_assert(sizeof(AFinishMoveActorManager) == 0x000280, "Wrong size on AFinishMoveActorManager");
static_assert(offsetof(AFinishMoveActorManager, FmActor_) == 0x000238, "Member 'AFinishMoveActorManager::FmActor_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActorManager, IsCallingEffectFinish_) == 0x000240, "Member 'AFinishMoveActorManager::IsCallingEffectFinish_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActorManager, RsLevelSequencer_) == 0x000250, "Member 'AFinishMoveActorManager::RsLevelSequencer_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActorManager, SequencePath_) == 0x000270, "Member 'AFinishMoveActorManager::SequencePath_' has a wrong offset!");

// Class BattlePrototype.FlagManager
// 0x0160 (0x0188 - 0x0028)
class UFlagManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchContentsOpend;                             // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchContentsRestricted;                        // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FFlag                                  ItemNewFlag;                                       // 0x0058(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  ShopItemNewFlag;                                   // 0x0068(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  TradeItemNewFlag;                                  // 0x0078(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  WorldMapNewFlag;                                   // 0x0088(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  TutorialNewFlag;                                   // 0x0098(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  HelpNewDataFlag;                                   // 0x00A8(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  HelpGetDataFlag;                                   // 0x00B8(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  HelpDisplayFlag;                                   // 0x00C8(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  MainQuestNewFlag;                                  // 0x00D8(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  SubQuestNewFlag;                                   // 0x00E8(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  BondsQuestNewFlag;                                 // 0x00F8(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  CharaLibraryNewFlag;                               // 0x0108(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  EnemyLibraryNewFlag;                               // 0x0118(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  PresentNewFlag;                                    // 0x0128(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  ContentsOpenedFlag;                                // 0x0138(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  OperationRestrictionFlag;                          // 0x0148(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  BrainmapOpenInfoFlag;                              // 0x0158(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  AddContentsNewFlag;                                // 0x0168(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  SystemSaveDataCommonFlag;                          // 0x0178(0x0010)(NativeAccessSpecifierPrivate)

public:
	void AddContentsNewFlagOff(int32 FlagIdx);
	void AddContentsNewFlagOn(int32 FlagIdx);
	void BrainmapOpenInfoFlagOff(int32 FlagIdx);
	void BrainmapOpenInfoFlagOn(int32 FlagIdx);
	void HelpDisplayFlagOff(EHelpTutorial HelpID);
	void HelpDisplayFlagOn(EHelpTutorial HelpID);
	void HelpGetFlagClear();
	void HelpGetFlagOff(int32 Index_0);
	void HelpGetFlagOn(int32 Index_0);
	int32 HelpGetFlagSize();
	void HelpNewFlagClear();
	void HelpNewFlagOff(int32 Index_0);
	void InitializeFlag();
	void ItemNewFlagClear();
	void ItemNewFlagOff(int32 Index_0);
	void OperationRestrictionFlagOff(EOperationRestriction Type);
	void OperationRestrictionFlagOn(EOperationRestriction Type);
	void SetAllContentsOpened();
	void SetContentsClosed(EContentsOpening Type);
	void SetContentsOpened(EContentsOpening Type);
	void ShopItemNewFlagClear();
	void ShopItemNewFlagOff(int32 Index_0);
	bool SystemSaveDataCommonFlagCheck(ESystemSaveDataCommonFlag Type);
	void SystemSaveDataCommonFlagClear();
	void SystemSaveDataCommonFlagOff(ESystemSaveDataCommonFlag Type);
	void SystemSaveDataCommonFlagOn(ESystemSaveDataCommonFlag Type);
	void TradeItemNewFlagClear();
	void TradeItemNewFlagOff(int32 Index_0);
	void TutorialNewFlagClear();
	void TutorialNewFlagOff(int32 Index_0);
	void WorldMapNewFlagClear();
	void WorldMapNewFlagOff(int32 Index_0);

	bool AddContentsNewFlagCheck(int32 FlagIdx) const;
	bool BrainmapOpenInfoFlagCheck(int32 FlagIdx) const;
	bool HelpDisplayFlagCheck(EHelpTutorial HelpID) const;
	bool HelpGetFlagCheck(int32 Index_0) const;
	bool HelpNewFlagCheck(int32 Index_0) const;
	bool IsContentsOpened(EContentsOpening Type) const;
	bool ItemNewFlagCheck(int32 Index_0) const;
	bool OperationRestrictionFlagCheck(EOperationRestriction Type) const;
	bool ShopItemNewFlagCheck(int32 Index_0) const;
	bool TradeItemNewFlagCheck(int32 Index_0) const;
	bool TutorialNewFlagCheck(int32 Index_0) const;
	bool WorldMapNewFlagCheck(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlagManager">();
	}
	static class UFlagManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlagManager>();
	}
};
static_assert(alignof(UFlagManager) == 0x000008, "Wrong alignment on UFlagManager");
static_assert(sizeof(UFlagManager) == 0x000188, "Wrong size on UFlagManager");
static_assert(offsetof(UFlagManager, DispatchContentsOpend) == 0x000038, "Member 'UFlagManager::DispatchContentsOpend' has a wrong offset!");
static_assert(offsetof(UFlagManager, DispatchContentsRestricted) == 0x000048, "Member 'UFlagManager::DispatchContentsRestricted' has a wrong offset!");
static_assert(offsetof(UFlagManager, ItemNewFlag) == 0x000058, "Member 'UFlagManager::ItemNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, ShopItemNewFlag) == 0x000068, "Member 'UFlagManager::ShopItemNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, TradeItemNewFlag) == 0x000078, "Member 'UFlagManager::TradeItemNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, WorldMapNewFlag) == 0x000088, "Member 'UFlagManager::WorldMapNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, TutorialNewFlag) == 0x000098, "Member 'UFlagManager::TutorialNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, HelpNewDataFlag) == 0x0000A8, "Member 'UFlagManager::HelpNewDataFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, HelpGetDataFlag) == 0x0000B8, "Member 'UFlagManager::HelpGetDataFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, HelpDisplayFlag) == 0x0000C8, "Member 'UFlagManager::HelpDisplayFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, MainQuestNewFlag) == 0x0000D8, "Member 'UFlagManager::MainQuestNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, SubQuestNewFlag) == 0x0000E8, "Member 'UFlagManager::SubQuestNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, BondsQuestNewFlag) == 0x0000F8, "Member 'UFlagManager::BondsQuestNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, CharaLibraryNewFlag) == 0x000108, "Member 'UFlagManager::CharaLibraryNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, EnemyLibraryNewFlag) == 0x000118, "Member 'UFlagManager::EnemyLibraryNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, PresentNewFlag) == 0x000128, "Member 'UFlagManager::PresentNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, ContentsOpenedFlag) == 0x000138, "Member 'UFlagManager::ContentsOpenedFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, OperationRestrictionFlag) == 0x000148, "Member 'UFlagManager::OperationRestrictionFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, BrainmapOpenInfoFlag) == 0x000158, "Member 'UFlagManager::BrainmapOpenInfoFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, AddContentsNewFlag) == 0x000168, "Member 'UFlagManager::AddContentsNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, SystemSaveDataCommonFlag) == 0x000178, "Member 'UFlagManager::SystemSaveDataCommonFlag' has a wrong offset!");

// Class BattlePrototype.FlagManagerUtility
// 0x0000 (0x0028 - 0x0028)
class UFlagManagerUtility final : public UBlueprintFunctionLibrary
{
public:
	static void CharaLibraryNewFlagOff(const class UObject* WorldContextObject, ELibraryFlagType Index_0);
	static bool CheckOperationRestrictionFlag(const class UObject* WorldContextObject, EOperationRestriction Type);
	static bool HelpGetFlagCheck(const class UObject* WorldContextObject, EHelpTutorial Type);
	static void HelpGetFlagOff(const class UObject* WorldContextObject, EHelpTutorial Type);
	static void HelpGetFlagOn(const class UObject* WorldContextObject, EHelpTutorial Type);
	static void InitializeFlagManager(const class UObject* WorldContextObject);
	static bool IsContentsOpened(const class UObject* WorldContextObject, EContentsOpening Type);
	static void OperationRestrictionFlagOff(const class UObject* WorldContextObject, EOperationRestriction Type);
	static void OperationRestrictionFlagOn(const class UObject* WorldContextObject, EOperationRestriction Type);
	static void SetAllContentsOpened(const class UObject* WorldContextObject);
	static void SetContentsClosed(const class UObject* WorldContextObject, EContentsOpening Type);
	static void SetContentsOpened(const class UObject* WorldContextObject, EContentsOpening Type);
	static bool SystemSaveDataCommonFlagCheck(const class UObject* WorldContextObject, ESystemSaveDataCommonFlag Type);
	static void SystemSaveDataCommonFlagOff(const class UObject* WorldContextObject, ESystemSaveDataCommonFlag Type);
	static void SystemSaveDataCommonFlagOn(const class UObject* WorldContextObject, ESystemSaveDataCommonFlag Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlagManagerUtility">();
	}
	static class UFlagManagerUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlagManagerUtility>();
	}
};
static_assert(alignof(UFlagManagerUtility) == 0x000008, "Wrong alignment on UFlagManagerUtility");
static_assert(sizeof(UFlagManagerUtility) == 0x000028, "Wrong size on UFlagManagerUtility");

// Class BattlePrototype.DebuggingItemFlagManagerGroup
// 0x0030 (0x0300 - 0x02D0)
class ADebuggingItemFlagManagerGroup final : public ADebuggingItemGroup
{
public:
	uint8                                         Pad_2D0[0x20];                                     // 0x02D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ADebuggingItemBool2>> FlagBool;                                          // 0x02F0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnChangeFlagBool(const class ADebuggingItemBool* Item);
	void OnPageOpened();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemFlagManagerGroup">();
	}
	static class ADebuggingItemFlagManagerGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemFlagManagerGroup>();
	}
};
static_assert(alignof(ADebuggingItemFlagManagerGroup) == 0x000008, "Wrong alignment on ADebuggingItemFlagManagerGroup");
static_assert(sizeof(ADebuggingItemFlagManagerGroup) == 0x000300, "Wrong size on ADebuggingItemFlagManagerGroup");
static_assert(offsetof(ADebuggingItemFlagManagerGroup, FlagBool) == 0x0002F0, "Member 'ADebuggingItemFlagManagerGroup::FlagBool' has a wrong offset!");

// Class BattlePrototype.CharacterPhysicalSurfaceActionEffectResource
// 0x0018 (0x0040 - 0x0028)
class UCharacterPhysicalSurfaceActionEffectResource final : public UObject
{
public:
	TArray<struct FCharacterPhysicalSurfaceActionEffectResourceArray> ResourceList;                                      // 0x0028(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UParticleSystem* GetResource(EGamePhysicalSurfaceType SurfaceType, ECharacterPhysicalActionType ActionType);
	bool IsLoaded();
	bool LoadAsset(const struct FCharacterPhysicalSurfaceActionEffect& ActionEffect);
	bool UnloadAsset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterPhysicalSurfaceActionEffectResource">();
	}
	static class UCharacterPhysicalSurfaceActionEffectResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterPhysicalSurfaceActionEffectResource>();
	}
};
static_assert(alignof(UCharacterPhysicalSurfaceActionEffectResource) == 0x000008, "Wrong alignment on UCharacterPhysicalSurfaceActionEffectResource");
static_assert(sizeof(UCharacterPhysicalSurfaceActionEffectResource) == 0x000040, "Wrong size on UCharacterPhysicalSurfaceActionEffectResource");
static_assert(offsetof(UCharacterPhysicalSurfaceActionEffectResource, ResourceList) == 0x000028, "Member 'UCharacterPhysicalSurfaceActionEffectResource::ResourceList' has a wrong offset!");

// Class BattlePrototype.CharacterPhysicalSurfaceActionSoundResource
// 0x0018 (0x0040 - 0x0028)
class UCharacterPhysicalSurfaceActionSoundResource final : public UObject
{
public:
	TArray<struct FCharacterPhysicalSurfaceActionSoundResourceArrray> ResourceList;                                      // 0x0028(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USoundAtomCue* GetResource(EGamePhysicalSurfaceType SurfaceType, ECharacterPhysicalActionType ActionType);
	bool IsLoaded();
	bool LoadAsset(const struct FCharacterPhysicalSurfaceActionSound& ActionSound);
	bool UnloadAsset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterPhysicalSurfaceActionSoundResource">();
	}
	static class UCharacterPhysicalSurfaceActionSoundResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterPhysicalSurfaceActionSoundResource>();
	}
};
static_assert(alignof(UCharacterPhysicalSurfaceActionSoundResource) == 0x000008, "Wrong alignment on UCharacterPhysicalSurfaceActionSoundResource");
static_assert(sizeof(UCharacterPhysicalSurfaceActionSoundResource) == 0x000040, "Wrong size on UCharacterPhysicalSurfaceActionSoundResource");
static_assert(offsetof(UCharacterPhysicalSurfaceActionSoundResource, ResourceList) == 0x000028, "Member 'UCharacterPhysicalSurfaceActionSoundResource::ResourceList' has a wrong offset!");

// Class BattlePrototype.FootStepInterface
// 0x0000 (0x0028 - 0x0028)
class IFootStepInterface final : public IInterface
{
public:
	bool FootStepPlay(const EGamePhysicalSurfaceType PhysicsType, const ECharacterPhysicalActionType ActionType, const struct FTransform& Transform, class AActor* Creator, const bool IsPlayEffect, const bool IsPlaySound);
	bool FootStepPlayEffect(const EGamePhysicalSurfaceType PhysicsType, const class FName ActionType, const struct FTransform& Transform, class AActor* Creator);
	bool FootStepPlaySound(const EGamePhysicalSurfaceType PhysicsType, const class FName ActionType, const struct FTransform& Transform, class AActor* Creator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootStepInterface">();
	}
	static class IFootStepInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFootStepInterface>();
	}
};
static_assert(alignof(IFootStepInterface) == 0x000008, "Wrong alignment on IFootStepInterface");
static_assert(sizeof(IFootStepInterface) == 0x000028, "Wrong size on IFootStepInterface");

// Class BattlePrototype.FootStepUtility
// 0x0000 (0x0028 - 0x0028)
class UFootStepUtility final : public UBlueprintFunctionLibrary
{
public:
	static EGamePhysicalSurfaceType ConvertPhysicalSurfaceToGamePhysicalSurface(const EPhysicalSurface SurfaceType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootStepUtility">();
	}
	static class UFootStepUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootStepUtility>();
	}
};
static_assert(alignof(UFootStepUtility) == 0x000008, "Wrong alignment on UFootStepUtility");
static_assert(sizeof(UFootStepUtility) == 0x000028, "Wrong size on UFootStepUtility");

// Class BattlePrototype.FreeCameraSpectatorPawn
// 0x0020 (0x02D8 - 0x02B8)
class AFreeCameraSpectatorPawn final : public ASpectatorPawn
{
public:
	class UCameraComponent*                       CameraComponent;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedScale;                                        // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitialMaxSpeed;                                   // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitialAccel;                                      // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitialDecel;                                      // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FreeCameraSpectatorPawn">();
	}
	static class AFreeCameraSpectatorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFreeCameraSpectatorPawn>();
	}
};
static_assert(alignof(AFreeCameraSpectatorPawn) == 0x000008, "Wrong alignment on AFreeCameraSpectatorPawn");
static_assert(sizeof(AFreeCameraSpectatorPawn) == 0x0002D8, "Wrong size on AFreeCameraSpectatorPawn");
static_assert(offsetof(AFreeCameraSpectatorPawn, CameraComponent) == 0x0002B8, "Member 'AFreeCameraSpectatorPawn::CameraComponent' has a wrong offset!");
static_assert(offsetof(AFreeCameraSpectatorPawn, SpeedScale) == 0x0002C0, "Member 'AFreeCameraSpectatorPawn::SpeedScale' has a wrong offset!");
static_assert(offsetof(AFreeCameraSpectatorPawn, InitialMaxSpeed) == 0x0002C4, "Member 'AFreeCameraSpectatorPawn::InitialMaxSpeed' has a wrong offset!");
static_assert(offsetof(AFreeCameraSpectatorPawn, InitialAccel) == 0x0002C8, "Member 'AFreeCameraSpectatorPawn::InitialAccel' has a wrong offset!");
static_assert(offsetof(AFreeCameraSpectatorPawn, InitialDecel) == 0x0002CC, "Member 'AFreeCameraSpectatorPawn::InitialDecel' has a wrong offset!");

// Class BattlePrototype.GameBaseLevelActor
// 0x0008 (0x0240 - 0x0238)
class AGameBaseLevelActor : public ALevelScriptActor
{
public:
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameBaseLevelActor">();
	}
	static class AGameBaseLevelActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameBaseLevelActor>();
	}
};
static_assert(alignof(AGameBaseLevelActor) == 0x000008, "Wrong alignment on AGameBaseLevelActor");
static_assert(sizeof(AGameBaseLevelActor) == 0x000240, "Wrong size on AGameBaseLevelActor");

// Class BattlePrototype.GameMainManager
// 0x00A0 (0x02D0 - 0x0230)
class alignas(0x10) AGameMainManager : public AActor
{
public:
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             M_pSaveDataCapturePicture;                         // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USaveLoadScreenParamManager*            M_pAutoSaveLoadScreenParamManager;                 // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_AutoSaveIntervalTime;                            // 0x0250(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                M_AutoSavePlayerLocation;                          // 0x0254(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isAutoSaveEnable;                                // 0x0260(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isAsyncAutoSaveRequest;                          // 0x0261(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_262[0x6];                                      // 0x0262(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class URSSaveGame*                            M_AsyncAutoSaveClass;                              // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x58];                                     // 0x0270(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_isForceAutoSaveEnable;                           // 0x02C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isForceAutoSaveDisable;                          // 0x02C9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CA[0x6];                                      // 0x02CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AsyncAutoSaveExec();
	bool AutoSaveExec();
	class UTexture2D* ConvertTextureRenderTarget2DtoTexture2D(class UTextureRenderTarget2D* PSrcRenderTex);
	bool DoSaveDataCapture();
	class UTextureRenderTarget2D* GetSaveDataCapture();
	class UTexture2D* GetSaveDataCapturePicture();
	bool IsAutoSaveEnable();
	bool IsForceAutoSaveDisable();
	bool IsForceAutoSaveEnable();
	bool LoadRetryDataExec();
	bool SaveRetryDataExec();
	void SetIsAutoSaveEnable(const bool Flag);
	void SetIsForceAutoSaveDisable(const bool Flag);
	void SetIsForceAutoSaveEnable(const bool Flag);
	void SetSaveDataCapturePicture(class UTexture2D* PCapturePic);
	void StartGameoverFlow(EGameOverResult ResultType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMainManager">();
	}
	static class AGameMainManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameMainManager>();
	}
};
static_assert(alignof(AGameMainManager) == 0x000010, "Wrong alignment on AGameMainManager");
static_assert(sizeof(AGameMainManager) == 0x0002D0, "Wrong size on AGameMainManager");
static_assert(offsetof(AGameMainManager, M_pSaveDataCapturePicture) == 0x000240, "Member 'AGameMainManager::M_pSaveDataCapturePicture' has a wrong offset!");
static_assert(offsetof(AGameMainManager, M_pAutoSaveLoadScreenParamManager) == 0x000248, "Member 'AGameMainManager::M_pAutoSaveLoadScreenParamManager' has a wrong offset!");
static_assert(offsetof(AGameMainManager, M_AutoSaveIntervalTime) == 0x000250, "Member 'AGameMainManager::M_AutoSaveIntervalTime' has a wrong offset!");
static_assert(offsetof(AGameMainManager, M_AutoSavePlayerLocation) == 0x000254, "Member 'AGameMainManager::M_AutoSavePlayerLocation' has a wrong offset!");
static_assert(offsetof(AGameMainManager, M_isAutoSaveEnable) == 0x000260, "Member 'AGameMainManager::M_isAutoSaveEnable' has a wrong offset!");
static_assert(offsetof(AGameMainManager, M_isAsyncAutoSaveRequest) == 0x000261, "Member 'AGameMainManager::M_isAsyncAutoSaveRequest' has a wrong offset!");
static_assert(offsetof(AGameMainManager, M_AsyncAutoSaveClass) == 0x000268, "Member 'AGameMainManager::M_AsyncAutoSaveClass' has a wrong offset!");
static_assert(offsetof(AGameMainManager, M_isForceAutoSaveEnable) == 0x0002C8, "Member 'AGameMainManager::M_isForceAutoSaveEnable' has a wrong offset!");
static_assert(offsetof(AGameMainManager, M_isForceAutoSaveDisable) == 0x0002C9, "Member 'AGameMainManager::M_isForceAutoSaveDisable' has a wrong offset!");

// Class BattlePrototype.GameTimerFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGameTimerFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float AddElapsedTime(struct FGameTimer& GameTimer, float AddTime);
	static void EndTimer(struct FGameTimer& GameTimer);
	static float GetElapsedTime(const struct FGameTimer& GameTimer);
	static float GetEndTime(const struct FGameTimer& GameTimer);
	static float GetRate(const struct FGameTimer& GameTimer);
	static float GetRemainingTime(const struct FGameTimer& GameTimer);
	static bool IsEnable(const struct FGameTimer& GameTimer);
	static bool IsOver(const struct FGameTimer& GameTimer);
	static bool IsPause(const struct FGameTimer& GameTimer);
	static void SetPause(struct FGameTimer& GameTimer, bool bPause);
	static void SetTimer(struct FGameTimer& GameTimer, float Time);
	static void UpdateTimer(struct FGameTimer& GameTimer, float Delta);
	static void UpdateTimerByActor(struct FGameTimer& GameTimer, class AActor* Actor);
	static void UpdateTimerByWorld(struct FGameTimer& GameTimer, class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameTimerFunctionLibrary">();
	}
	static class UGameTimerFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameTimerFunctionLibrary>();
	}
};
static_assert(alignof(UGameTimerFunctionLibrary) == 0x000008, "Wrong alignment on UGameTimerFunctionLibrary");
static_assert(sizeof(UGameTimerFunctionLibrary) == 0x000028, "Wrong size on UGameTimerFunctionLibrary");

// Class BattlePrototype.GimmickAttackAreaVolume
// 0x0008 (0x0270 - 0x0268)
class AGimmickAttackAreaVolume final : public AVolume
{
public:
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsEnemyInArea();
	void OnActorBeginOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorEndOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickAttackAreaVolume">();
	}
	static class AGimmickAttackAreaVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickAttackAreaVolume>();
	}
};
static_assert(alignof(AGimmickAttackAreaVolume) == 0x000008, "Wrong alignment on AGimmickAttackAreaVolume");
static_assert(sizeof(AGimmickAttackAreaVolume) == 0x000270, "Wrong size on AGimmickAttackAreaVolume");

// Class BattlePrototype.GimmickHorrorBase
// 0x0010 (0x0240 - 0x0230)
class AGimmickHorrorBase final : public ARSActorBackgroundBase
{
public:
	EGimmickHorrorType                            Type;                                              // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TriggerRadius;                                     // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasActioned;                                       // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDrawDebug;                                       // 0x0239(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23A[0x6];                                      // 0x023A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickHorrorBase">();
	}
	static class AGimmickHorrorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickHorrorBase>();
	}
};
static_assert(alignof(AGimmickHorrorBase) == 0x000008, "Wrong alignment on AGimmickHorrorBase");
static_assert(sizeof(AGimmickHorrorBase) == 0x000240, "Wrong size on AGimmickHorrorBase");
static_assert(offsetof(AGimmickHorrorBase, Type) == 0x000230, "Member 'AGimmickHorrorBase::Type' has a wrong offset!");
static_assert(offsetof(AGimmickHorrorBase, TriggerRadius) == 0x000234, "Member 'AGimmickHorrorBase::TriggerRadius' has a wrong offset!");
static_assert(offsetof(AGimmickHorrorBase, HasActioned) == 0x000238, "Member 'AGimmickHorrorBase::HasActioned' has a wrong offset!");
static_assert(offsetof(AGimmickHorrorBase, IsDrawDebug) == 0x000239, "Member 'AGimmickHorrorBase::IsDrawDebug' has a wrong offset!");

// Class BattlePrototype.GimmickLimitTriggerVolume
// 0x0000 (0x0290 - 0x0290)
class AGimmickLimitTriggerVolume final : public AGimmickTriggerVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickLimitTriggerVolume">();
	}
	static class AGimmickLimitTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickLimitTriggerVolume>();
	}
};
static_assert(alignof(AGimmickLimitTriggerVolume) == 0x000008, "Wrong alignment on AGimmickLimitTriggerVolume");
static_assert(sizeof(AGimmickLimitTriggerVolume) == 0x000290, "Wrong size on AGimmickLimitTriggerVolume");

// Class BattlePrototype.GimmickObjectBase
// 0x0040 (0x0270 - 0x0230)
class AGimmickObjectBase : public AActor
{
public:
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          Blocker;                                           // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenValue;                                         // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenThreshold;                                     // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenCloseTime;                                     // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChangeStatus;                                    // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EGimmickObjectStatus GetGimmickStatus();
	void SetBlockerCollision(bool Enable);
	void SetGimmickStatus(EGimmickObjectStatus Status);
	void UpdateOpenValueInClosing(float DelataSeconds);
	void UpdateOpenValueInOpening(float DelataSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickObjectBase">();
	}
	static class AGimmickObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickObjectBase>();
	}
};
static_assert(alignof(AGimmickObjectBase) == 0x000008, "Wrong alignment on AGimmickObjectBase");
static_assert(sizeof(AGimmickObjectBase) == 0x000270, "Wrong size on AGimmickObjectBase");
static_assert(offsetof(AGimmickObjectBase, Blocker) == 0x000240, "Member 'AGimmickObjectBase::Blocker' has a wrong offset!");
static_assert(offsetof(AGimmickObjectBase, OpenValue) == 0x000248, "Member 'AGimmickObjectBase::OpenValue' has a wrong offset!");
static_assert(offsetof(AGimmickObjectBase, OpenThreshold) == 0x00024C, "Member 'AGimmickObjectBase::OpenThreshold' has a wrong offset!");
static_assert(offsetof(AGimmickObjectBase, OpenCloseTime) == 0x000250, "Member 'AGimmickObjectBase::OpenCloseTime' has a wrong offset!");
static_assert(offsetof(AGimmickObjectBase, OnChangeStatus) == 0x000258, "Member 'AGimmickObjectBase::OnChangeStatus' has a wrong offset!");

// Class BattlePrototype.HateTargetComponent
// 0x0120 (0x01E0 - 0x00C0)
class UHateTargetComponent final : public UActorComponent
{
public:
	TWeakObjectPtr<class ARSCharacterBase>        MTargetLock;                                       // 0x00C0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MTargetLockNo;                                     // 0x00C8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharactersParameterComponent*          MTargetLockParam;                                  // 0x00D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ARSCharacterBase>        MTargetLockOnce;                                   // 0x00D8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MTargetLockOnceNo;                                 // 0x00E0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharactersParameterComponent*          MTargetLockOnceParam;                              // 0x00E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ARSCharacterBase>        MTargetLockConfusion;                              // 0x00F0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharactersParameterComponent*          MOwnerParam;                                       // 0x00F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetLockTime;                                   // 0x0100(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetLockUpdateTime;                             // 0x0104(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetLockNearUpdateTime;                         // 0x0108(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsTargetLockNear;                                 // 0x010C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsTargetLockPlayer;                               // 0x010D(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsTargetLockNPC;                                  // 0x010E(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MBeforeIsTargetLockPlayer;                         // 0x010F(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MBeforeIsTargetLockNPC;                            // 0x0110(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MRange;                                            // 0x0114(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHateTargetParam>               MHateTargetParam;                                  // 0x0118(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHateParam                             MHateParam;                                        // 0x0128(0x0080)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MBerserkOnHateRate;                                // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsLookTargetRange;                                // 0x01AC(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MTargetNearRange;                                  // 0x01B0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetFarRange;                                   // 0x01B4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsTargetRangeIgnoreHate;                          // 0x01B8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B9[0x3];                                      // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ARSCharacterBase>        MDirectTargetLock;                                 // 0x01BC(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsLookTargetRangeHate;                            // 0x01C4(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C5[0x3];                                      // 0x01C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MTargetNearRangeHate;                              // 0x01C8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetFarRangeHate;                               // 0x01CC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D0[0x10];                                     // 0x01D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddHate(class ARSCharacterBase* Target, float HateValue, float TechScale, bool bAccumulation, bool bDirect);
	void AddHateTargetParam(class ARSCharacterBase* Target, EHATETYPE Num, EHATETYPE Down);
	void ClearHateTargetParam();
	void EnableLockTargetNPC(bool bEnable);
	void EnableLockTargetPlayer(bool bEnable);
	void EnableLockTargetRange(bool bEnable, float RangeNear, float RangeFar, bool bIgnoreHate);
	void EnableLockTargetRangeHate(bool bEnable, float RangeNear, float RangeFar);
	float GetBasisHate(class ARSCharacterBase* MainPlayer, class ARSCharacterBase* Target);
	void HateTargetParamAddHate(class ARSCharacterBase* Target, EHATETYPE Num);
	void HateTargetParamSubHate(class ARSCharacterBase* Target, EHATETYPE Num);
	void ResetAllHate();
	void ResetDirectTargetLock();
	void ResetHate(class ARSCharacterBase* Target);
	void SetDirectTargetLock(class ARSCharacterBase* Target);
	void SetHateParam(const struct FHateParam& Param);
	void SetNoAttackCount(float NoAttackSecond);
	void SetTargetLock(class ARSCharacterBase* Target, int32 No);
	void SetTargetLockConfusion(class ARSCharacterBase* Target);
	void SubHate(class ARSCharacterBase* Target, float HateValue, float TechScale);
	void UpdateTarget(float DeltaTime);

	TArray<struct FHateTargetParam> GetHateTargetParam() const;
	class ARSCharacterBase* GetTargetLock() const;
	class ARSCharacterBase* GetTargetLockConfusion() const;
	bool IsLockTargetNPC() const;
	bool IsLockTargetPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HateTargetComponent">();
	}
	static class UHateTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHateTargetComponent>();
	}
};
static_assert(alignof(UHateTargetComponent) == 0x000008, "Wrong alignment on UHateTargetComponent");
static_assert(sizeof(UHateTargetComponent) == 0x0001E0, "Wrong size on UHateTargetComponent");
static_assert(offsetof(UHateTargetComponent, MTargetLock) == 0x0000C0, "Member 'UHateTargetComponent::MTargetLock' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetLockNo) == 0x0000C8, "Member 'UHateTargetComponent::MTargetLockNo' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetLockParam) == 0x0000D0, "Member 'UHateTargetComponent::MTargetLockParam' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetLockOnce) == 0x0000D8, "Member 'UHateTargetComponent::MTargetLockOnce' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetLockOnceNo) == 0x0000E0, "Member 'UHateTargetComponent::MTargetLockOnceNo' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetLockOnceParam) == 0x0000E8, "Member 'UHateTargetComponent::MTargetLockOnceParam' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetLockConfusion) == 0x0000F0, "Member 'UHateTargetComponent::MTargetLockConfusion' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MOwnerParam) == 0x0000F8, "Member 'UHateTargetComponent::MOwnerParam' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetLockTime) == 0x000100, "Member 'UHateTargetComponent::MTargetLockTime' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetLockUpdateTime) == 0x000104, "Member 'UHateTargetComponent::MTargetLockUpdateTime' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetLockNearUpdateTime) == 0x000108, "Member 'UHateTargetComponent::MTargetLockNearUpdateTime' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MIsTargetLockNear) == 0x00010C, "Member 'UHateTargetComponent::MIsTargetLockNear' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MIsTargetLockPlayer) == 0x00010D, "Member 'UHateTargetComponent::MIsTargetLockPlayer' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MIsTargetLockNPC) == 0x00010E, "Member 'UHateTargetComponent::MIsTargetLockNPC' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MBeforeIsTargetLockPlayer) == 0x00010F, "Member 'UHateTargetComponent::MBeforeIsTargetLockPlayer' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MBeforeIsTargetLockNPC) == 0x000110, "Member 'UHateTargetComponent::MBeforeIsTargetLockNPC' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MRange) == 0x000114, "Member 'UHateTargetComponent::MRange' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MHateTargetParam) == 0x000118, "Member 'UHateTargetComponent::MHateTargetParam' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MHateParam) == 0x000128, "Member 'UHateTargetComponent::MHateParam' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MBerserkOnHateRate) == 0x0001A8, "Member 'UHateTargetComponent::MBerserkOnHateRate' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MIsLookTargetRange) == 0x0001AC, "Member 'UHateTargetComponent::MIsLookTargetRange' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetNearRange) == 0x0001B0, "Member 'UHateTargetComponent::MTargetNearRange' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetFarRange) == 0x0001B4, "Member 'UHateTargetComponent::MTargetFarRange' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MIsTargetRangeIgnoreHate) == 0x0001B8, "Member 'UHateTargetComponent::MIsTargetRangeIgnoreHate' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MDirectTargetLock) == 0x0001BC, "Member 'UHateTargetComponent::MDirectTargetLock' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MIsLookTargetRangeHate) == 0x0001C4, "Member 'UHateTargetComponent::MIsLookTargetRangeHate' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetNearRangeHate) == 0x0001C8, "Member 'UHateTargetComponent::MTargetNearRangeHate' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetFarRangeHate) == 0x0001CC, "Member 'UHateTargetComponent::MTargetFarRangeHate' has a wrong offset!");

// Class BattlePrototype.HelpTutorialDBAsset
// 0x00F0 (0x0118 - 0x0028)
class UHelpTutorialDBAsset final : public UObject
{
public:
	TMap<EHelpTutorial, struct FHelpDBDataCell>   HelpDBMap_;                                        // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TMap<EHelpTutorial, struct FMiniHelpRowDataCell> MiniHelpDBMap_;                                    // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TMap<class FName, struct FTutorialDBDataCell> TutorialDBMap_;                                    // 0x00C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	void Convert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelpTutorialDBAsset">();
	}
	static class UHelpTutorialDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelpTutorialDBAsset>();
	}
};
static_assert(alignof(UHelpTutorialDBAsset) == 0x000008, "Wrong alignment on UHelpTutorialDBAsset");
static_assert(sizeof(UHelpTutorialDBAsset) == 0x000118, "Wrong size on UHelpTutorialDBAsset");
static_assert(offsetof(UHelpTutorialDBAsset, HelpDBMap_) == 0x000028, "Member 'UHelpTutorialDBAsset::HelpDBMap_' has a wrong offset!");
static_assert(offsetof(UHelpTutorialDBAsset, MiniHelpDBMap_) == 0x000078, "Member 'UHelpTutorialDBAsset::MiniHelpDBMap_' has a wrong offset!");
static_assert(offsetof(UHelpTutorialDBAsset, TutorialDBMap_) == 0x0000C8, "Member 'UHelpTutorialDBAsset::TutorialDBMap_' has a wrong offset!");

// Class BattlePrototype.HitCheckComponent
// 0x0050 (0x0110 - 0x00C0)
class UHitCheckComponent final : public UActorComponent
{
public:
	bool                                          IsCallCheckHitInTick;                              // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x4F];                                      // 0x00C1(0x004F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHitCheckComponent* GetHitCheckComponentFromActor(class AActor* Actor);
	static bool IsNoDamagePartFromHCHitResult(const struct FHCHitResult& HitResult);

	void AddAttackCollision(class UObject* Notify, class AActor* Owner, class UAnimSequenceBase* Animation, const struct FHCAttackCollisionInfo& AttackCollisionInfo, class UMeshComponent* OtherMesh);
	void AddFixedCollisionByPrimitiveSkill(class AActor* Owner, class UPrimitiveComponent* Primitive, const struct FHCCollisionCommonInfo& CommonInfo, const struct FHCSkillCommonInfo& Skill, const struct FHCHitEffectInfo& EffectInfo, class AActor* AttackOwner, float LimitHeight);
	void AddFixedCollisionBySceneCompSkill(class AActor* Owner, class USceneComponent* SceneComp, float Radius, float HalfHeight, const struct FHCCollisionCommonInfo& CommonInfo, const struct FHCSkillCommonInfo& Skill, const struct FHCHitEffectInfo& EffectInfo, class AActor* AttackOwner, float LimitHeight);
	void AddIgnoreJustDodgeFixedCollisionData(class USceneComponent* SceneComp);
	bool CheckAttackCollisionSkillExtraType(int32 Index_0, EHCSkillExtraType CheckExtraType);
	bool CheckFixedCollisionSkillExtraType(int32 Index_0, EHCSkillExtraType CheckExtraType);
	void CheckHit(float DeltaSeconds);
	bool GetAttackCollisionCapsule(int32 Index_0, struct FVector* OutStartLocation, struct FVector* OutEndLocation, float* OutRadius);
	bool GetFixedCollisionCapsule(int32 Index_0, struct FVector* OutStartLocation, struct FVector* OutEndLocation, float* OutRadius);
	void InterceptFixedCollisionData(class USceneComponent* SceneComp, class AActor* NewAttackOwner);
	void InterceptFixedCollisionDataEnemy(class USceneComponent* SceneComp, class AActor* NewAttackOwner, const struct FHCCollisionCommonInfo& RefInterceptCommon, const struct FHCSkillCommonInfo& RefInterceptSkill);
	void RemoveAttackCollision(class UObject* Notify, class AActor* Owner, class UAnimSequenceBase* Animation);
	void RemoveFixedCollision(class USceneComponent* SceneComp);

	class AActor* GetAttackCollisionAttacker(int32 Index_0) const;
	int32 GetAttackCollisionNum() const;
	class AActor* GetFixedCollisionAttacker(int32 Index_0) const;
	class AActor* GetFixedCollisionAttackSource(int32 Index_0) const;
	int32 GetFixedCollisionNum() const;
	bool IsFixedCollisionInterceptAble(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitCheckComponent">();
	}
	static class UHitCheckComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitCheckComponent>();
	}
};
static_assert(alignof(UHitCheckComponent) == 0x000008, "Wrong alignment on UHitCheckComponent");
static_assert(sizeof(UHitCheckComponent) == 0x000110, "Wrong size on UHitCheckComponent");
static_assert(offsetof(UHitCheckComponent, IsCallCheckHitInTick) == 0x0000C0, "Member 'UHitCheckComponent::IsCallCheckHitInTick' has a wrong offset!");

// Class BattlePrototype.RSAtomComponentBase
// 0x0040 (0x1250 - 0x1210)
class URSAtomComponentBase : public UAtomComponent
{
public:
	class AActor*                                 CreatorActor;                                      // 0x1210(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCalcSIWAttenuation;                               // 0x1218(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1219[0x3];                                     // 0x1219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MSoundVolumeScale;                                 // 0x121C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESoundFadeState                               MFadeState;                                        // 0x1220(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESoundActionOnFadeOutEnd                      MActionOnFadeOutEnd;                               // 0x1221(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1222[0x2];                                     // 0x1222(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MFadeTime;                                         // 0x1224(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFadeTimer;                                        // 0x1228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFadeVolume;                                       // 0x122C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFadeStartVolume;                                  // 0x1230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFadeFinishVolume;                                 // 0x1234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MSIWAttenuationRate;                               // 0x1238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MSkipAtSequencer;                                  // 0x123C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_123D[0x3];                                     // 0x123D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class URSAtomComponentBase* AtomComp)> OnEndPlayAtom;                                     // 0x1240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)

public:
	void _OnEndPlayAtom();
	void ChangeFade(float FadeTime);
	void Fade(float DeltaTime);
	bool GetAisacByName(const class FString& ControlName, float* Value);
	void Initialize();
	void PauseSound(float FadeTime, float FadeVolume);
	void PlaySound(const class UObject* WorldContextObject, class USoundAtomCue* NewSound, float StartTime, float FadeTime, float FadeVolume, EFilterCallbackType FilterCallbackType);
	void PlaySoundToPad(const class UObject* WorldContextObject, class USoundAtomCue* NewSound, float StartTime, float FadeTime, float FadeVolume, EFilterCallbackType FilterCallbackType);
	void ResumeSound(float FadeTime, float FadeVolume);
	void RSFadeIn(float FadeTime, float FadeVolume);
	void RSFadeOut(float FadeTime, float FadeVolume, ESoundActionOnFadeOutEnd ActionOnFadeOutEnd);
	void SetFadeParam(float FadeTime, float FadeFinishVolume);
	void SetSIWAttenuationRate(float AttenuationRate);
	void StopSound(float FadeTime, float FadeVolume);
	void UpdateVolume();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAtomComponentBase">();
	}
	static class URSAtomComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAtomComponentBase>();
	}
};
static_assert(alignof(URSAtomComponentBase) == 0x000010, "Wrong alignment on URSAtomComponentBase");
static_assert(sizeof(URSAtomComponentBase) == 0x001250, "Wrong size on URSAtomComponentBase");
static_assert(offsetof(URSAtomComponentBase, CreatorActor) == 0x001210, "Member 'URSAtomComponentBase::CreatorActor' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, bCalcSIWAttenuation) == 0x001218, "Member 'URSAtomComponentBase::bCalcSIWAttenuation' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MSoundVolumeScale) == 0x00121C, "Member 'URSAtomComponentBase::MSoundVolumeScale' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MFadeState) == 0x001220, "Member 'URSAtomComponentBase::MFadeState' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MActionOnFadeOutEnd) == 0x001221, "Member 'URSAtomComponentBase::MActionOnFadeOutEnd' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MFadeTime) == 0x001224, "Member 'URSAtomComponentBase::MFadeTime' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MFadeTimer) == 0x001228, "Member 'URSAtomComponentBase::MFadeTimer' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MFadeVolume) == 0x00122C, "Member 'URSAtomComponentBase::MFadeVolume' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MFadeStartVolume) == 0x001230, "Member 'URSAtomComponentBase::MFadeStartVolume' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MFadeFinishVolume) == 0x001234, "Member 'URSAtomComponentBase::MFadeFinishVolume' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MSIWAttenuationRate) == 0x001238, "Member 'URSAtomComponentBase::MSIWAttenuationRate' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MSkipAtSequencer) == 0x00123C, "Member 'URSAtomComponentBase::MSkipAtSequencer' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, OnEndPlayAtom) == 0x001240, "Member 'URSAtomComponentBase::OnEndPlayAtom' has a wrong offset!");

// Class BattlePrototype.HitCheckUtility
// 0x0000 (0x0028 - 0x0028)
class UHitCheckUtility final : public UBlueprintFunctionLibrary
{
public:
	static float GetCollisionValueFromCommonInfo(const struct FHCCollisionCommonInfo& CommonInfo, EHCCollisionValueKind Kind);
	static float GetConditionValueFromCommonInfo(const struct FHCCollisionCommonInfo& CommonInfo, EConditionKind Kind);
	static float GetElementValueFromCommonInfo(const struct FHCCollisionCommonInfo& CommonInfo, EHCElementKind Kind);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitCheckUtility">();
	}
	static class UHitCheckUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitCheckUtility>();
	}
};
static_assert(alignof(UHitCheckUtility) == 0x000008, "Wrong alignment on UHitCheckUtility");
static_assert(sizeof(UHitCheckUtility) == 0x000028, "Wrong size on UHitCheckUtility");

// Class BattlePrototype.HitEffectInterface
// 0x0000 (0x0028 - 0x0028)
class IHitEffectInterface final : public IInterface
{
public:
	EFHitEffectPriority GetHitEffectPriorityInterface();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitEffectInterface">();
	}
	static class IHitEffectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHitEffectInterface>();
	}
};
static_assert(alignof(IHitEffectInterface) == 0x000008, "Wrong alignment on IHitEffectInterface");
static_assert(sizeof(IHitEffectInterface) == 0x000028, "Wrong size on IHitEffectInterface");

// Class BattlePrototype.PsychicObjectSoundComponent
// 0x0040 (0x0100 - 0x00C0)
class UPsychicObjectSoundComponent final : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OverrideEffectTableId;                             // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OverrideSoundTableId;                              // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFootStepComponent*                     FootStepComponent;                                 // 0x00D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHitActorInfoAtPsychic>         HitActorList;                                      // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitSeInterval;                                     // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaySeVelocity;                                    // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRunSeVelocity;                                 // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHitCallback(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsychicObjectSoundComponent">();
	}
	static class UPsychicObjectSoundComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPsychicObjectSoundComponent>();
	}
};
static_assert(alignof(UPsychicObjectSoundComponent) == 0x000008, "Wrong alignment on UPsychicObjectSoundComponent");
static_assert(sizeof(UPsychicObjectSoundComponent) == 0x000100, "Wrong size on UPsychicObjectSoundComponent");
static_assert(offsetof(UPsychicObjectSoundComponent, OverrideEffectTableId) == 0x0000C8, "Member 'UPsychicObjectSoundComponent::OverrideEffectTableId' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSoundComponent, OverrideSoundTableId) == 0x0000D0, "Member 'UPsychicObjectSoundComponent::OverrideSoundTableId' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSoundComponent, FootStepComponent) == 0x0000D8, "Member 'UPsychicObjectSoundComponent::FootStepComponent' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSoundComponent, HitActorList) == 0x0000E0, "Member 'UPsychicObjectSoundComponent::HitActorList' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSoundComponent, HitSeInterval) == 0x0000F0, "Member 'UPsychicObjectSoundComponent::HitSeInterval' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSoundComponent, PlaySeVelocity) == 0x0000F4, "Member 'UPsychicObjectSoundComponent::PlaySeVelocity' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSoundComponent, PlayRunSeVelocity) == 0x0000F8, "Member 'UPsychicObjectSoundComponent::PlayRunSeVelocity' has a wrong offset!");

// Class BattlePrototype.HitStopComponent
// 0x0048 (0x0108 - 0x00C0)
class UHitStopComponent final : public UActorComponent
{
public:
	float                                         HitStopTime_Short;                                 // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopTime_Middle;                                // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopTime_Large;                                 // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopTime_XLarge;                                // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopTime_XXLarge;                               // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopRate_Short;                                 // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopRate_Middle;                                // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopRate_Large;                                 // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopRate_XLarge;                                // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopRate_XXLarge;                               // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopDelay;                                      // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x1C];                                      // 0x00EC(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHitStopComponent* GetHitStopComponent(class AActor* Actor);

	void EndHitStop();
	void SetActiveHitStop(bool ActiveHitStop);
	void StartHitStop(float HitStopSec, float ActionSpeedRate);
	void StartHitStopByType(EHCRestictedHitStopType HitStopType, bool bCritical);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitStopComponent">();
	}
	static class UHitStopComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitStopComponent>();
	}
};
static_assert(alignof(UHitStopComponent) == 0x000008, "Wrong alignment on UHitStopComponent");
static_assert(sizeof(UHitStopComponent) == 0x000108, "Wrong size on UHitStopComponent");
static_assert(offsetof(UHitStopComponent, HitStopTime_Short) == 0x0000C0, "Member 'UHitStopComponent::HitStopTime_Short' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopTime_Middle) == 0x0000C4, "Member 'UHitStopComponent::HitStopTime_Middle' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopTime_Large) == 0x0000C8, "Member 'UHitStopComponent::HitStopTime_Large' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopTime_XLarge) == 0x0000CC, "Member 'UHitStopComponent::HitStopTime_XLarge' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopTime_XXLarge) == 0x0000D0, "Member 'UHitStopComponent::HitStopTime_XXLarge' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopRate_Short) == 0x0000D4, "Member 'UHitStopComponent::HitStopRate_Short' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopRate_Middle) == 0x0000D8, "Member 'UHitStopComponent::HitStopRate_Middle' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopRate_Large) == 0x0000DC, "Member 'UHitStopComponent::HitStopRate_Large' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopRate_XLarge) == 0x0000E0, "Member 'UHitStopComponent::HitStopRate_XLarge' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopRate_XXLarge) == 0x0000E4, "Member 'UHitStopComponent::HitStopRate_XXLarge' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopDelay) == 0x0000E8, "Member 'UHitStopComponent::HitStopDelay' has a wrong offset!");

// Class BattlePrototype.RSAutoTestBase
// 0x0070 (0x02A0 - 0x0230)
class ARSAutoTestBase : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnTestPrepare;                                     // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTestStart;                                       // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTestFinished;                                    // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ERSAutoTestResult                             Result;                                            // 0x0260(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDelayGCInTest;                                  // 0x0261(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_262[0x2];                                      // 0x0262(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreparationTimeLimit;                              // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeLimit;                                         // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TimesUpMessage;                                    // 0x0270(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ERSAutoTestResult                             TimesUpResult;                                     // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRunning;                                        // 0x0289(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A[0x2];                                      // 0x028A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TotalTime;                                         // 0x028C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         TestArgs;                                          // 0x0290(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void FinishTest(ERSAutoTestResult TestResult, const class FString& Message);
	bool IsReady();
	void ReceivePrepareTest();
	void ReceiveStartTest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAutoTestBase">();
	}
	static class ARSAutoTestBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSAutoTestBase>();
	}
};
static_assert(alignof(ARSAutoTestBase) == 0x000008, "Wrong alignment on ARSAutoTestBase");
static_assert(sizeof(ARSAutoTestBase) == 0x0002A0, "Wrong size on ARSAutoTestBase");
static_assert(offsetof(ARSAutoTestBase, OnTestPrepare) == 0x000230, "Member 'ARSAutoTestBase::OnTestPrepare' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, OnTestStart) == 0x000240, "Member 'ARSAutoTestBase::OnTestStart' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, OnTestFinished) == 0x000250, "Member 'ARSAutoTestBase::OnTestFinished' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, Result) == 0x000260, "Member 'ARSAutoTestBase::Result' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, bIsDelayGCInTest) == 0x000261, "Member 'ARSAutoTestBase::bIsDelayGCInTest' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, PreparationTimeLimit) == 0x000264, "Member 'ARSAutoTestBase::PreparationTimeLimit' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, TimeLimit) == 0x000268, "Member 'ARSAutoTestBase::TimeLimit' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, TimesUpMessage) == 0x000270, "Member 'ARSAutoTestBase::TimesUpMessage' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, TimesUpResult) == 0x000288, "Member 'ARSAutoTestBase::TimesUpResult' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, bIsRunning) == 0x000289, "Member 'ARSAutoTestBase::bIsRunning' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, TotalTime) == 0x00028C, "Member 'ARSAutoTestBase::TotalTime' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, TestArgs) == 0x000290, "Member 'ARSAutoTestBase::TestArgs' has a wrong offset!");

// Class BattlePrototype.HPEventComponent
// 0x0010 (0x00D0 - 0x00C0)
class UHPEventComponent : public UActorComponent
{
public:
	TArray<struct FCharacterHPEventInfo>          HpEventInfos;                                      // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CheckHpEvent(class AActor* Actor, float PreHpRate, float PostHpRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HPEventComponent">();
	}
	static class UHPEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHPEventComponent>();
	}
};
static_assert(alignof(UHPEventComponent) == 0x000008, "Wrong alignment on UHPEventComponent");
static_assert(sizeof(UHPEventComponent) == 0x0000D0, "Wrong size on UHPEventComponent");
static_assert(offsetof(UHPEventComponent, HpEventInfos) == 0x0000C0, "Member 'UHPEventComponent::HpEventInfos' has a wrong offset!");

// Class BattlePrototype.IceConditionComponent
// 0x0030 (0x0190 - 0x0160)
class UIceConditionComponent final : public UConditionComponent
{
public:
	float                                         _iceActionSpeedRate;                               // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _iceDamageRate;                                    // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             _pIceBeginSound;                                   // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             _pIceEndSound;                                     // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AIceConditionEffectActor*               _pEffectActor;                                     // 0x0178(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_180[0x10];                                     // 0x0180(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IceConditionComponent">();
	}
	static class UIceConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIceConditionComponent>();
	}
};
static_assert(alignof(UIceConditionComponent) == 0x000010, "Wrong alignment on UIceConditionComponent");
static_assert(sizeof(UIceConditionComponent) == 0x000190, "Wrong size on UIceConditionComponent");
static_assert(offsetof(UIceConditionComponent, _iceActionSpeedRate) == 0x000160, "Member 'UIceConditionComponent::_iceActionSpeedRate' has a wrong offset!");
static_assert(offsetof(UIceConditionComponent, _iceDamageRate) == 0x000164, "Member 'UIceConditionComponent::_iceDamageRate' has a wrong offset!");
static_assert(offsetof(UIceConditionComponent, _pIceBeginSound) == 0x000168, "Member 'UIceConditionComponent::_pIceBeginSound' has a wrong offset!");
static_assert(offsetof(UIceConditionComponent, _pIceEndSound) == 0x000170, "Member 'UIceConditionComponent::_pIceEndSound' has a wrong offset!");
static_assert(offsetof(UIceConditionComponent, _pEffectActor) == 0x000178, "Member 'UIceConditionComponent::_pEffectActor' has a wrong offset!");

// Class BattlePrototype.RSAnimationFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URSAnimationFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* GetAnimBPGeneratedClassFromPath(class UObject* WorldContextObject, const class FString& Path, bool Load);
	static class UAnimationAsset* GetAnimSequenceFromPath(class UObject* WorldContextObject, const class FString& Path, bool Load, class AResourceManager* ResourceManager);
	static struct FVector GetBoneMoveForAnimSequence(class UAnimSequence* AnimSequence, int32 BoneIndex);
	static struct FTransform GetBoneTransformForAnimMontage(const class UAnimMontage* AnimMontage, float Time, int32 BoneIndex, bool bUseRawData);
	static struct FTransform GetBoneTransformForAnimSequence(const class UAnimSequence* AnimSequence, float Time, int32 BoneIndex, bool bUseRawData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAnimationFunctionLibrary">();
	}
	static class URSAnimationFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAnimationFunctionLibrary>();
	}
};
static_assert(alignof(URSAnimationFunctionLibrary) == 0x000008, "Wrong alignment on URSAnimationFunctionLibrary");
static_assert(sizeof(URSAnimationFunctionLibrary) == 0x000028, "Wrong size on URSAnimationFunctionLibrary");

// Class BattlePrototype.IceConditionEffectActor
// 0x0020 (0x0250 - 0x0230)
class AIceConditionEffectActor final : public AActor
{
public:
	class UParticleSystem*                        _pBeginEffect;                                     // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        _pEndEffect;                                       // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               _pEffectComp;                                      // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _pRootSceneComp;                                   // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FinishEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IceConditionEffectActor">();
	}
	static class AIceConditionEffectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIceConditionEffectActor>();
	}
};
static_assert(alignof(AIceConditionEffectActor) == 0x000008, "Wrong alignment on AIceConditionEffectActor");
static_assert(sizeof(AIceConditionEffectActor) == 0x000250, "Wrong size on AIceConditionEffectActor");
static_assert(offsetof(AIceConditionEffectActor, _pBeginEffect) == 0x000230, "Member 'AIceConditionEffectActor::_pBeginEffect' has a wrong offset!");
static_assert(offsetof(AIceConditionEffectActor, _pEndEffect) == 0x000238, "Member 'AIceConditionEffectActor::_pEndEffect' has a wrong offset!");
static_assert(offsetof(AIceConditionEffectActor, _pEffectComp) == 0x000240, "Member 'AIceConditionEffectActor::_pEffectComp' has a wrong offset!");
static_assert(offsetof(AIceConditionEffectActor, _pRootSceneComp) == 0x000248, "Member 'AIceConditionEffectActor::_pRootSceneComp' has a wrong offset!");

// Class BattlePrototype.PsychicObjectSearchComponent
// 0x01B0 (0x0280 - 0x00D0)
class UPsychicObjectSearchComponent : public URSAsyncTaskActorComponent
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchUpdateSearchObject;                        // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x30];                                      // 0x00E8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FocusParamDistList;                                // 0x0118(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 FocusParamDistPointList;                           // 0x0128(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 FocusParamAngleList;                               // 0x0138(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 FocusParamAnglePointList;                          // 0x0148(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x90];                                     // 0x0158(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PsychicFieldObjectNum;                             // 0x01E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PsychicFieldRadius;                                // 0x01EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DebugPrintPsychicFieldSearch;                      // 0x01F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F1[0x1B];                                     // 0x01F1(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugDispSyncProc;                                // 0x020C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDispSearchProc;                              // 0x020D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDispSearchScore;                             // 0x020E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20F[0x1];                                      // 0x020F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebugDispSearchCount;                              // 0x0210(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DebugDispTraceCount;                               // 0x0214(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_218[0x60];                                     // 0x0218(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugDispSearchEnpc;                              // 0x0278(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckEnpcPsychicObject(bool ChkCapture, bool ChkAttack);
	void DebugDispFocusSearchProc(const struct FVector& Pos);
	class AActor* GetEnpcPsychicObject();
	class AActor* GetSearchResultNrl();
	class AActor* GetSearchResultUnq();
	bool IsFocusSearchEnable();
	void RegisterMapGimmick(class AActor* PActor, float DistMin);
	void SearchEnpcPsychicObject(const struct FVector& ChkPos, struct FPsychicObjectEvaluateData* Result);
	TArray<class AActor*> SearchPsychicFieldObject();
	TArray<class AActor*> SearchPsychicFieldTarget(const struct FVector& SearchPos, class AActor* PTargetActor);
	void SetEnpcSearchParameter(float RadiusMin);
	void SetFocusSearchEnable(bool Flag, class FName TagName);
	void SetFocusSearchHeightParameter(float HeightMin, float HeightMax);
	void SetFocusSearchScoreParameter(const TArray<float>& DistList, const TArray<int32>& DistPointList, const TArray<float>& AngleList, const TArray<int32>& AnglePointList);
	void SetPsychicFieldParameter(float Radius, int32 ObjNum);
	TArray<class AActor*> SortByDistance(const TArray<class AActor*>& ActorList, class AActor* PTargetActor, bool bAscend, bool bIgnoreZ, bool bSearchPos, const struct FVector& CheckPos, float SearchRadius);
	TArray<class AActor*> SortBySize(const TArray<class AActor*>& ActorList, bool bAscend);
	void UnregisterMapGimmick(class AActor* PActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsychicObjectSearchComponent">();
	}
	static class UPsychicObjectSearchComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPsychicObjectSearchComponent>();
	}
};
static_assert(alignof(UPsychicObjectSearchComponent) == 0x000008, "Wrong alignment on UPsychicObjectSearchComponent");
static_assert(sizeof(UPsychicObjectSearchComponent) == 0x000280, "Wrong size on UPsychicObjectSearchComponent");
static_assert(offsetof(UPsychicObjectSearchComponent, DispatchUpdateSearchObject) == 0x0000D8, "Member 'UPsychicObjectSearchComponent::DispatchUpdateSearchObject' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, FocusParamDistList) == 0x000118, "Member 'UPsychicObjectSearchComponent::FocusParamDistList' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, FocusParamDistPointList) == 0x000128, "Member 'UPsychicObjectSearchComponent::FocusParamDistPointList' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, FocusParamAngleList) == 0x000138, "Member 'UPsychicObjectSearchComponent::FocusParamAngleList' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, FocusParamAnglePointList) == 0x000148, "Member 'UPsychicObjectSearchComponent::FocusParamAnglePointList' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, PsychicFieldObjectNum) == 0x0001E8, "Member 'UPsychicObjectSearchComponent::PsychicFieldObjectNum' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, PsychicFieldRadius) == 0x0001EC, "Member 'UPsychicObjectSearchComponent::PsychicFieldRadius' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, DebugPrintPsychicFieldSearch) == 0x0001F0, "Member 'UPsychicObjectSearchComponent::DebugPrintPsychicFieldSearch' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, bDebugDispSyncProc) == 0x00020C, "Member 'UPsychicObjectSearchComponent::bDebugDispSyncProc' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, bDebugDispSearchProc) == 0x00020D, "Member 'UPsychicObjectSearchComponent::bDebugDispSearchProc' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, bDebugDispSearchScore) == 0x00020E, "Member 'UPsychicObjectSearchComponent::bDebugDispSearchScore' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, DebugDispSearchCount) == 0x000210, "Member 'UPsychicObjectSearchComponent::DebugDispSearchCount' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, DebugDispTraceCount) == 0x000214, "Member 'UPsychicObjectSearchComponent::DebugDispTraceCount' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, bDebugDispSearchEnpc) == 0x000278, "Member 'UPsychicObjectSearchComponent::bDebugDispSearchEnpc' has a wrong offset!");

// Class BattlePrototype.ItemCaptureParamExporter
// 0x0000 (0x0028 - 0x0028)
class UItemCaptureParamExporter final : public UBlueprintFunctionLibrary
{
public:
	static void ExportItemDataTableType(const struct FItemDataTableRaw& ItemDataTableRaw, const class FString& OutputJsonPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemCaptureParamExporter">();
	}
	static class UItemCaptureParamExporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemCaptureParamExporter>();
	}
};
static_assert(alignof(UItemCaptureParamExporter) == 0x000008, "Wrong alignment on UItemCaptureParamExporter");
static_assert(sizeof(UItemCaptureParamExporter) == 0x000028, "Wrong size on UItemCaptureParamExporter");

// Class BattlePrototype.ItemCaptureStaticMeshBase
// 0x0018 (0x0248 - 0x0230)
class AItemCaptureStaticMeshBase final : public AActor
{
public:
	TSubclassOf<class AItemCaptureStaticMeshBase> bpClass;                                           // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   M_rootComp;                                        // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            M_staticMesh;                                      // 0x0240(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static bool GenerateStaticMesh(const class UObject* WorldContextObject, TSubclassOf<class AItemCaptureStaticMeshBase> bpClassType, const class FString& MeshPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemCaptureStaticMeshBase">();
	}
	static class AItemCaptureStaticMeshBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemCaptureStaticMeshBase>();
	}
};
static_assert(alignof(AItemCaptureStaticMeshBase) == 0x000008, "Wrong alignment on AItemCaptureStaticMeshBase");
static_assert(sizeof(AItemCaptureStaticMeshBase) == 0x000248, "Wrong size on AItemCaptureStaticMeshBase");
static_assert(offsetof(AItemCaptureStaticMeshBase, bpClass) == 0x000230, "Member 'AItemCaptureStaticMeshBase::bpClass' has a wrong offset!");
static_assert(offsetof(AItemCaptureStaticMeshBase, M_rootComp) == 0x000238, "Member 'AItemCaptureStaticMeshBase::M_rootComp' has a wrong offset!");
static_assert(offsetof(AItemCaptureStaticMeshBase, M_staticMesh) == 0x000240, "Member 'AItemCaptureStaticMeshBase::M_staticMesh' has a wrong offset!");

// Class BattlePrototype.BondsEpisodeDBAsset
// 0x0050 (0x0078 - 0x0028)
class UBondsEpisodeDBAsset final : public UObject
{
public:
	TMap<class FName, struct FBondsEpisodeDBDataCell> DBMap;                                             // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	void Convert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BondsEpisodeDBAsset">();
	}
	static class UBondsEpisodeDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBondsEpisodeDBAsset>();
	}
};
static_assert(alignof(UBondsEpisodeDBAsset) == 0x000008, "Wrong alignment on UBondsEpisodeDBAsset");
static_assert(sizeof(UBondsEpisodeDBAsset) == 0x000078, "Wrong size on UBondsEpisodeDBAsset");
static_assert(offsetof(UBondsEpisodeDBAsset, DBMap) == 0x000028, "Member 'UBondsEpisodeDBAsset::DBMap' has a wrong offset!");

// Class BattlePrototype.ItemData
// 0x00D0 (0x00F8 - 0x0028)
class UItemData final : public UObject
{
public:
	class UDataTable*                             RefItemTable;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             RefArrangeItemTable;                               // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           ItemIDs;                                           // 0x0038(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EPlayerID, struct FItemIDArray>          PresentItemDataM;                                  // 0x0048(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<EPlayerID, struct FItemIDArray>          PresentItemDataF;                                  // 0x0098(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           BattleItemIDs;                                     // 0x00E8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool GetArrangeData(struct FArrangeItemDataCell* ArrangeItemData, class FName ID);
	bool GetData(struct FItemDataCell* ItemData, class FName ID);
	bool GetDataByItemID(struct FItemDataCell* ItemData, int32 ItemId);
	class FString GetDescription(class FName ID);
	EItemFavorability GetFavorability(class FName ID, EPlayerID CharID);
	int32 GetItemIndex(class FName ID);
	class FString GetName(class FName ID);
	int32 GetTradeNumberOfTimes(class FName ID);
	bool LoadItemDataTable(const class FString& ItemTablePath, const class FString& ArrangeItemDataTablePath);

	const TArray<class FName> GetItemIDs() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemData">();
	}
	static class UItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemData>();
	}
};
static_assert(alignof(UItemData) == 0x000008, "Wrong alignment on UItemData");
static_assert(sizeof(UItemData) == 0x0000F8, "Wrong size on UItemData");
static_assert(offsetof(UItemData, RefItemTable) == 0x000028, "Member 'UItemData::RefItemTable' has a wrong offset!");
static_assert(offsetof(UItemData, RefArrangeItemTable) == 0x000030, "Member 'UItemData::RefArrangeItemTable' has a wrong offset!");
static_assert(offsetof(UItemData, ItemIDs) == 0x000038, "Member 'UItemData::ItemIDs' has a wrong offset!");
static_assert(offsetof(UItemData, PresentItemDataM) == 0x000048, "Member 'UItemData::PresentItemDataM' has a wrong offset!");
static_assert(offsetof(UItemData, PresentItemDataF) == 0x000098, "Member 'UItemData::PresentItemDataF' has a wrong offset!");
static_assert(offsetof(UItemData, BattleItemIDs) == 0x0000E8, "Member 'UItemData::BattleItemIDs' has a wrong offset!");

// Class BattlePrototype.ItemDataUtility
// 0x0000 (0x0028 - 0x0028)
class UItemDataUtility final : public UBlueprintFunctionLibrary
{
public:
	static bool GetArrangeItemDataCell(const class UObject* WorldContextObject, struct FArrangeItemDataCell* ItemData, class FName ID);
	static EItemCategory GetItemCategory(int32 ItemId);
	static int32 GetItemCategoryID(int32 ItemId);
	static bool GetItemDataCell(const class UObject* WorldContextObject, struct FItemDataCell* ItemData, class FName ID);
	static bool GetItemDataCellByItemId(const class UObject* WorldContextObject, struct FItemDataCell* ItemData, int32 ItemId);
	static class FText GetItemDataDescription(const class UObject* WorldContextObject, const struct FItemDataCell& ItemDataCell);
	static class FText GetItemDataName(const class UObject* WorldContextObject, const struct FItemDataCell& ItemDataCell);
	static void GetItemIDs(const class UObject* WorldContextObject, TArray<class FName>* ItemIDs);
	static int32 GetItemIndex(const class UObject* WorldContextObject, class FName ID);
	static EItemRarity GetItemRarity(const struct FItemDataCell& ItemDataCell);
	static bool GetLotteryResultItemID(const class UObject* WorldContextObject, const bool IsRare, const struct FArrangeItemDataCell& ArrangeItemDataCell, class FName* ItemId, int32* ItemNum);
	static int32 GetNumOfEquipment(const class UObject* WorldContextObject, const class FName& ItemId);
	static bool IsCategoryAttachment(EItemCategory Category);
	static bool IsInvalidSell(const struct FItemDataCell& ItemDataCell);
	static bool IsValidItemId(int32 ItemId);
	static class FName MakeItemDataName(int32 ItemId);
	static int32 MakeItemID(EItemCategory Category, int32 ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemDataUtility">();
	}
	static class UItemDataUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemDataUtility>();
	}
};
static_assert(alignof(UItemDataUtility) == 0x000008, "Wrong alignment on UItemDataUtility");
static_assert(sizeof(UItemDataUtility) == 0x000028, "Wrong size on UItemDataUtility");

// Class BattlePrototype.PsychicObjectSpawnComponent
// 0x0000 (0x04A0 - 0x04A0)
class UPsychicObjectSpawnComponent final : public UStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsychicObjectSpawnComponent">();
	}
	static class UPsychicObjectSpawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPsychicObjectSpawnComponent>();
	}
};
static_assert(alignof(UPsychicObjectSpawnComponent) == 0x000010, "Wrong alignment on UPsychicObjectSpawnComponent");
static_assert(sizeof(UPsychicObjectSpawnComponent) == 0x0004A0, "Wrong size on UPsychicObjectSpawnComponent");

// Class BattlePrototype.ArrangeItemStageManager
// 0x0020 (0x0048 - 0x0028)
class UArrangeItemStageManager final : public UObject
{
public:
	TArray<TWeakObjectPtr<class AArrangeItemBase>> ArrangeItems;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AArrangeItemBase>> UnvisivleArrangeItemsInEvent;                      // 0x0038(0x0010)(ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ChangeVisibleActorInEvent(const bool IsVisible);
	class AArrangeItemBase* GetArrangeItem(const class FString& ID);
	void Initialize(const class UObject* WorldContextObject);
	void RegisterArrangeItem(class AArrangeItemBase* ArrangeItem);
	void SetVisible(const bool IsVisible, const int32 LevelID, const int32 GroupID);
	void UnregisterArrangeItem(class AArrangeItemBase* ArrangeItem);
	void UnregisterArrangeItemAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrangeItemStageManager">();
	}
	static class UArrangeItemStageManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArrangeItemStageManager>();
	}
};
static_assert(alignof(UArrangeItemStageManager) == 0x000008, "Wrong alignment on UArrangeItemStageManager");
static_assert(sizeof(UArrangeItemStageManager) == 0x000048, "Wrong size on UArrangeItemStageManager");
static_assert(offsetof(UArrangeItemStageManager, ArrangeItems) == 0x000028, "Member 'UArrangeItemStageManager::ArrangeItems' has a wrong offset!");
static_assert(offsetof(UArrangeItemStageManager, UnvisivleArrangeItemsInEvent) == 0x000038, "Member 'UArrangeItemStageManager::UnvisivleArrangeItemsInEvent' has a wrong offset!");

// Class BattlePrototype.MainQuestDBAsset
// 0x0050 (0x0078 - 0x0028)
class UMainQuestDBAsset final : public UObject
{
public:
	TMap<class FName, struct FMainQuestDBDataCell> DBMap;                                             // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	void Convert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainQuestDBAsset">();
	}
	static class UMainQuestDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainQuestDBAsset>();
	}
};
static_assert(alignof(UMainQuestDBAsset) == 0x000008, "Wrong alignment on UMainQuestDBAsset");
static_assert(sizeof(UMainQuestDBAsset) == 0x000078, "Wrong size on UMainQuestDBAsset");
static_assert(offsetof(UMainQuestDBAsset, DBMap) == 0x000028, "Member 'UMainQuestDBAsset::DBMap' has a wrong offset!");

// Class BattlePrototype.JumpComponent
// 0x0020 (0x00E0 - 0x00C0)
class UJumpComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnStartJump;                                       // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InputJump();
	void ReceiveOnGround();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JumpComponent">();
	}
	static class UJumpComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJumpComponent>();
	}
};
static_assert(alignof(UJumpComponent) == 0x000008, "Wrong alignment on UJumpComponent");
static_assert(sizeof(UJumpComponent) == 0x0000E0, "Wrong size on UJumpComponent");
static_assert(offsetof(UJumpComponent, OnStartJump) == 0x0000C0, "Member 'UJumpComponent::OnStartJump' has a wrong offset!");

// Class BattlePrototype.REDLuaScriptComponent
// 0x0058 (0x0118 - 0x00C0)
class UREDLuaScriptComponent final : public UActorComponent
{
public:
	class UObject*                                M_parent;                                          // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      M_PlayerController;                                // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                M_AnimationActor;                                  // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pWaitAnimMontageActor;                           // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           M_pWaitAnimMontageMontage;                         // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            M_pStaticCutsceneBG_ParticleSpeedUpCurveData;      // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UEventAsset*                            M_pWaitLoadAsset;                                  // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool CreateContextRED(class UObject* Parent, bool IsRun);
	void SetAnimationActor(class UObject* Object);
	void SetIsEndMotion(bool IsEndMotion);
	void SetPlayerController(class APlayerController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDLuaScriptComponent">();
	}
	static class UREDLuaScriptComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDLuaScriptComponent>();
	}
};
static_assert(alignof(UREDLuaScriptComponent) == 0x000008, "Wrong alignment on UREDLuaScriptComponent");
static_assert(sizeof(UREDLuaScriptComponent) == 0x000118, "Wrong size on UREDLuaScriptComponent");
static_assert(offsetof(UREDLuaScriptComponent, M_parent) == 0x0000C0, "Member 'UREDLuaScriptComponent::M_parent' has a wrong offset!");
static_assert(offsetof(UREDLuaScriptComponent, M_PlayerController) == 0x0000D0, "Member 'UREDLuaScriptComponent::M_PlayerController' has a wrong offset!");
static_assert(offsetof(UREDLuaScriptComponent, M_AnimationActor) == 0x0000E0, "Member 'UREDLuaScriptComponent::M_AnimationActor' has a wrong offset!");
static_assert(offsetof(UREDLuaScriptComponent, M_pWaitAnimMontageActor) == 0x0000F0, "Member 'UREDLuaScriptComponent::M_pWaitAnimMontageActor' has a wrong offset!");
static_assert(offsetof(UREDLuaScriptComponent, M_pWaitAnimMontageMontage) == 0x0000F8, "Member 'UREDLuaScriptComponent::M_pWaitAnimMontageMontage' has a wrong offset!");
static_assert(offsetof(UREDLuaScriptComponent, M_pStaticCutsceneBG_ParticleSpeedUpCurveData) == 0x000100, "Member 'UREDLuaScriptComponent::M_pStaticCutsceneBG_ParticleSpeedUpCurveData' has a wrong offset!");
static_assert(offsetof(UREDLuaScriptComponent, M_pWaitLoadAsset) == 0x000110, "Member 'UREDLuaScriptComponent::M_pWaitLoadAsset' has a wrong offset!");

// Class BattlePrototype.LevelManager
// 0x0020 (0x0250 - 0x0230)
class ALevelManager : public ARSActorSystemBase
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCompleteUnloadLevelAll;                          // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CallAreaPostLoadFunction(int32 LocationId, int32 AreaId, int32 VariationID, bool IsFirstTry, bool* Initialized);
	bool CallAreaSelectVariationFunction(int32 LocationId, int32 AreaId, int32 VariationID, int32 PortaflID, bool NoChange, int32* OutLocationID, int32* OutAreaID, int32* OutVariationID);
	bool CheckTweakConditionFunc(const struct FAreaInfoTweakCondition& TweakCondition);
	class FName GetAreaBGName(int32 LocationId, int32 AreaId, int32 VariationID);
	bool GetAreaInfoFromNative(class FName AreName, TArray<class FName>& OutLevenName);
	class FName GetAreaName(int32 LocationId, int32 AreaId, int32 VariationID);
	class FName GetShortAreaName(int32 LocationId, int32 AreaId);
	int32 GetStreamingTextureNum();
	void SetStreamingSettings(const struct FRSStreamingSettings& Settings);
	int32 StreamingTextureBlockTillAllRequestsFinished(float TimeLimit, bool bLogResults);
	int32 StreamingTextureLoadAllBlock();
	void SyncUnloadStreamLevels();

	struct FRSStreamingSettings GetCurrentStreamingSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelManager">();
	}
	static class ALevelManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelManager>();
	}
};
static_assert(alignof(ALevelManager) == 0x000008, "Wrong alignment on ALevelManager");
static_assert(sizeof(ALevelManager) == 0x000250, "Wrong size on ALevelManager");
static_assert(offsetof(ALevelManager, OnCompleteUnloadLevelAll) == 0x000238, "Member 'ALevelManager::OnCompleteUnloadLevelAll' has a wrong offset!");

// Class BattlePrototype.BondsLevelupData
// 0x0038 (0x0060 - 0x0028)
class UBondsLevelupData final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBondsLevelupExpData>           ExpListM;                                          // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBondsLevelupExpData>           ExpListF;                                          // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBondsLevelupExpData                   DummyList;                                         // 0x0050(0x0010)(NativeAccessSpecifierPrivate)

public:
	void LoadDataTable();

	const TArray<int32> GetBondsLevelupTable(EPlayerID PlayerId, EPlayerID TargetID) const;
	bool IsValidResource() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BondsLevelupData">();
	}
	static class UBondsLevelupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBondsLevelupData>();
	}
};
static_assert(alignof(UBondsLevelupData) == 0x000008, "Wrong alignment on UBondsLevelupData");
static_assert(sizeof(UBondsLevelupData) == 0x000060, "Wrong size on UBondsLevelupData");
static_assert(offsetof(UBondsLevelupData, ExpListM) == 0x000030, "Member 'UBondsLevelupData::ExpListM' has a wrong offset!");
static_assert(offsetof(UBondsLevelupData, ExpListF) == 0x000040, "Member 'UBondsLevelupData::ExpListF' has a wrong offset!");
static_assert(offsetof(UBondsLevelupData, DummyList) == 0x000050, "Member 'UBondsLevelupData::DummyList' has a wrong offset!");

// Class BattlePrototype.QuestDataUtility
// 0x0020 (0x0048 - 0x0028)
class UQuestDataUtility final : public UBlueprintFunctionLibrary
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CheckDLCQuestContentCheck(const class UObject* WorldContextObject, class FName QuestId);
	static void GetCharStartedDLCBonds(const class UObject* WorldContextObject, class FName DlcBondsID, EPlayerID* StartedCharID);
	static bool KillEnemyDataForSubQuest(const class UObject* WorldContextObject, class FName EnemyName, const struct FHCHitResult& HcResult, EPsychicObjectUniqueType PoType, bool bBrainCrashMulti, EPlayerID HoloPlayerID);
	static void SetDLCBondsStartTargetChar(const class UObject* WorldContextObject, class FName DlcBondsID, EPlayerID StartChar);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestDataUtility">();
	}
	static class UQuestDataUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestDataUtility>();
	}
};
static_assert(alignof(UQuestDataUtility) == 0x000008, "Wrong alignment on UQuestDataUtility");
static_assert(sizeof(UQuestDataUtility) == 0x000048, "Wrong size on UQuestDataUtility");

// Class BattlePrototype.TeamBondsLevelupData
// 0x0018 (0x0040 - 0x0028)
class UTeamBondsLevelupData final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             DataTableM;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableF;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void LoadDataTable();

	class UDataTable* GetTeamBondsLevelupTable(EPlayerID PlayerId) const;
	bool IsValidResource() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamBondsLevelupData">();
	}
	static class UTeamBondsLevelupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamBondsLevelupData>();
	}
};
static_assert(alignof(UTeamBondsLevelupData) == 0x000008, "Wrong alignment on UTeamBondsLevelupData");
static_assert(sizeof(UTeamBondsLevelupData) == 0x000040, "Wrong size on UTeamBondsLevelupData");
static_assert(offsetof(UTeamBondsLevelupData, DataTableM) == 0x000030, "Member 'UTeamBondsLevelupData::DataTableM' has a wrong offset!");
static_assert(offsetof(UTeamBondsLevelupData, DataTableF) == 0x000038, "Member 'UTeamBondsLevelupData::DataTableF' has a wrong offset!");

// Class BattlePrototype.PurposeMessageParamManager
// 0x0028 (0x0050 - 0x0028)
class UPurposeMessageParamManager final : public UObject
{
public:
	class UDataTable*                             DataTable_;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             bondsPurposeTable_;                                // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FName GetBondsPurposeMessage(EPlayerID HeroID, EPlayerID TargetID);
	class FName GetPurposeMessage();
	int32 GetPurposeMessageNum();
	void InitData(class URSGameInstance* GameInst);
	void SetPurposeMessage(const class FString& MessageID);
	void SetPurposeMessageNum(int32 Num);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PurposeMessageParamManager">();
	}
	static class UPurposeMessageParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPurposeMessageParamManager>();
	}
};
static_assert(alignof(UPurposeMessageParamManager) == 0x000008, "Wrong alignment on UPurposeMessageParamManager");
static_assert(sizeof(UPurposeMessageParamManager) == 0x000050, "Wrong size on UPurposeMessageParamManager");
static_assert(offsetof(UPurposeMessageParamManager, DataTable_) == 0x000028, "Member 'UPurposeMessageParamManager::DataTable_' has a wrong offset!");
static_assert(offsetof(UPurposeMessageParamManager, bondsPurposeTable_) == 0x000030, "Member 'UPurposeMessageParamManager::bondsPurposeTable_' has a wrong offset!");

// Class BattlePrototype.LibraryCharacterParam
// 0x0030 (0x0058 - 0x0028)
class ULibraryCharacterParam final : public UObject
{
public:
	struct FFlag                                  LibFlags;                                          // 0x0028(0x0010)(Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           OpenLibList;                                       // 0x0038(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULibraryCharaData*                      DataTable;                                         // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URSGameInstance*                        GameInstance;                                      // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 CheckLibraryOpenByProgresNo(int32 ProgressNo);
	void CloseCharLib(class FName LibName);
	int32 GetDBKeys(TArray<class FName>* Dst);
	bool GetLibraryData(struct FLibraryCharaDataCell* Data, class FName CharaID, bool IsDebugOpen);
	void InitData(class URSGameInstance* GameInstance_0);
	void OffFlag(ELibraryFlagType FlagNo);
	void OnFlag(ELibraryFlagType FlagNo);
	void OpenCharLib(class FName LibName);

	bool CheckFlag(ELibraryFlagType FlagNo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LibraryCharacterParam">();
	}
	static class ULibraryCharacterParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULibraryCharacterParam>();
	}
};
static_assert(alignof(ULibraryCharacterParam) == 0x000008, "Wrong alignment on ULibraryCharacterParam");
static_assert(sizeof(ULibraryCharacterParam) == 0x000058, "Wrong size on ULibraryCharacterParam");
static_assert(offsetof(ULibraryCharacterParam, LibFlags) == 0x000028, "Member 'ULibraryCharacterParam::LibFlags' has a wrong offset!");
static_assert(offsetof(ULibraryCharacterParam, OpenLibList) == 0x000038, "Member 'ULibraryCharacterParam::OpenLibList' has a wrong offset!");
static_assert(offsetof(ULibraryCharacterParam, DataTable) == 0x000048, "Member 'ULibraryCharacterParam::DataTable' has a wrong offset!");
static_assert(offsetof(ULibraryCharacterParam, GameInstance) == 0x000050, "Member 'ULibraryCharacterParam::GameInstance' has a wrong offset!");

// Class BattlePrototype.REDImage
// 0x00D8 (0x02E8 - 0x0210)
class UREDImage final : public UImage
{
public:
	uint8                                         Pad_210[0x8];                                      // 0x0210(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          FlagMouse;                                         // 0x0218(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x3];                                      // 0x0219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MouseHitOffsetPos;                                 // 0x021C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MouseHitOffsetSize;                                // 0x0224(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugMouseHitDisp;                                 // 0x022C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D[0x3];                                      // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRedMouseArgument                      MouseCallArgument;                                 // 0x0230(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             M_ImageFocusMouse;                                 // 0x0240(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             M_ImageUnFocusMouse;                               // 0x0250(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             M_ImageDownMouse;                                  // 0x0260(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          bIsStartTick;                                      // 0x0270(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x17];                                     // 0x0271(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUIBase>                 M_ParentUIBase;                                    // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UREDebugLines*                          M_DebugDraw;                                       // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGeometry                              M_geometry;                                        // 0x0298(0x0038)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector2D                              VectorPixel;                                       // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              VectorSize;                                        // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              VectorPos;                                         // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool CheckCircle();
	bool CheckCircleCore(const struct FVector2D& Position);
	bool CheckRectangle();
	bool CheckRectangleCore(const struct FVector2D& Position);
	struct FVector2D GetAbsolutePosition();
	struct FVector2D GetAbsoluteSize();
	void RedImageDown__DelegateSignature(const struct FRedMouseArgument& Argument, class UObject* PWidget);
	void RedImageFocus__DelegateSignature(const struct FRedMouseArgument& Argument, class UObject* PWidget);
	void RedImageUnFocus__DelegateSignature(const struct FRedMouseArgument& Argument, class UObject* PWidget);
	void SetMouseDisable(bool Flag);
	void SetMouseInputLevel(int32 InputLevel);
	void SetMouseMode(bool Mousemode, int32 InputLevel);
	void SetParentUIBase(class UUIBase* PUiBase);

	bool GetMouseDisable() const;
	int32 GetMouseInputLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDImage">();
	}
	static class UREDImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDImage>();
	}
};
static_assert(alignof(UREDImage) == 0x000008, "Wrong alignment on UREDImage");
static_assert(sizeof(UREDImage) == 0x0002E8, "Wrong size on UREDImage");
static_assert(offsetof(UREDImage, FlagMouse) == 0x000218, "Member 'UREDImage::FlagMouse' has a wrong offset!");
static_assert(offsetof(UREDImage, MouseHitOffsetPos) == 0x00021C, "Member 'UREDImage::MouseHitOffsetPos' has a wrong offset!");
static_assert(offsetof(UREDImage, MouseHitOffsetSize) == 0x000224, "Member 'UREDImage::MouseHitOffsetSize' has a wrong offset!");
static_assert(offsetof(UREDImage, DebugMouseHitDisp) == 0x00022C, "Member 'UREDImage::DebugMouseHitDisp' has a wrong offset!");
static_assert(offsetof(UREDImage, MouseCallArgument) == 0x000230, "Member 'UREDImage::MouseCallArgument' has a wrong offset!");
static_assert(offsetof(UREDImage, M_ImageFocusMouse) == 0x000240, "Member 'UREDImage::M_ImageFocusMouse' has a wrong offset!");
static_assert(offsetof(UREDImage, M_ImageUnFocusMouse) == 0x000250, "Member 'UREDImage::M_ImageUnFocusMouse' has a wrong offset!");
static_assert(offsetof(UREDImage, M_ImageDownMouse) == 0x000260, "Member 'UREDImage::M_ImageDownMouse' has a wrong offset!");
static_assert(offsetof(UREDImage, bIsStartTick) == 0x000270, "Member 'UREDImage::bIsStartTick' has a wrong offset!");
static_assert(offsetof(UREDImage, M_ParentUIBase) == 0x000288, "Member 'UREDImage::M_ParentUIBase' has a wrong offset!");
static_assert(offsetof(UREDImage, M_DebugDraw) == 0x000290, "Member 'UREDImage::M_DebugDraw' has a wrong offset!");
static_assert(offsetof(UREDImage, M_geometry) == 0x000298, "Member 'UREDImage::M_geometry' has a wrong offset!");
static_assert(offsetof(UREDImage, VectorPixel) == 0x0002D0, "Member 'UREDImage::VectorPixel' has a wrong offset!");
static_assert(offsetof(UREDImage, VectorSize) == 0x0002D8, "Member 'UREDImage::VectorSize' has a wrong offset!");
static_assert(offsetof(UREDImage, VectorPos) == 0x0002E0, "Member 'UREDImage::VectorPos' has a wrong offset!");

// Class BattlePrototype.LibraryCharaDBAsset
// 0x0050 (0x0078 - 0x0028)
class ULibraryCharaDBAsset final : public UObject
{
public:
	TMap<class FName, struct FLibraryCharaDBCell> DBMap;                                             // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	void Convert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LibraryCharaDBAsset">();
	}
	static class ULibraryCharaDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULibraryCharaDBAsset>();
	}
};
static_assert(alignof(ULibraryCharaDBAsset) == 0x000008, "Wrong alignment on ULibraryCharaDBAsset");
static_assert(sizeof(ULibraryCharaDBAsset) == 0x000078, "Wrong size on ULibraryCharaDBAsset");
static_assert(offsetof(ULibraryCharaDBAsset, DBMap) == 0x000028, "Member 'ULibraryCharaDBAsset::DBMap' has a wrong offset!");

// Class BattlePrototype.REDScrollBoxSimple
// 0x0020 (0x08A0 - 0x0880)
class UREDScrollBoxSimple final : public UScrollBox
{
public:
	bool                                          DebugMouseHitDisp;                                 // 0x0880(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugMouseHitBarDisp;                              // 0x0881(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_882[0xE];                                      // 0x0882(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	class UREDebugLines*                          M_DebugDraw;                                       // 0x0890(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UREDebugLines*                          M_DebugbarDraw;                                    // 0x0898(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUserWidget* CreateAndAddChildEx(class UClass* ClassInfo);
	bool IsMouseON();
	void ResetScrollOffset();
	bool ScrollDown();
	bool ScrollUp();
	void SetAutoScroll(float Offset);
	void SetScrollSpeed(float Speed);
	void UpdateAutoScroll(float DeltaTime);
	bool UpdateMouse();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDScrollBoxSimple">();
	}
	static class UREDScrollBoxSimple* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDScrollBoxSimple>();
	}
};
static_assert(alignof(UREDScrollBoxSimple) == 0x000008, "Wrong alignment on UREDScrollBoxSimple");
static_assert(sizeof(UREDScrollBoxSimple) == 0x0008A0, "Wrong size on UREDScrollBoxSimple");
static_assert(offsetof(UREDScrollBoxSimple, DebugMouseHitDisp) == 0x000880, "Member 'UREDScrollBoxSimple::DebugMouseHitDisp' has a wrong offset!");
static_assert(offsetof(UREDScrollBoxSimple, DebugMouseHitBarDisp) == 0x000881, "Member 'UREDScrollBoxSimple::DebugMouseHitBarDisp' has a wrong offset!");
static_assert(offsetof(UREDScrollBoxSimple, M_DebugDraw) == 0x000890, "Member 'UREDScrollBoxSimple::M_DebugDraw' has a wrong offset!");
static_assert(offsetof(UREDScrollBoxSimple, M_DebugbarDraw) == 0x000898, "Member 'UREDScrollBoxSimple::M_DebugbarDraw' has a wrong offset!");

// Class BattlePrototype.LibraryEnemyData
// 0x0008 (0x0030 - 0x0028)
class ULibraryEnemyData final : public UObject
{
public:
	class ULibraryEnemyDBAsset*                   Asset;                                             // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool LoadDataAsset(const class FString& AssetPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LibraryEnemyData">();
	}
	static class ULibraryEnemyData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULibraryEnemyData>();
	}
};
static_assert(alignof(ULibraryEnemyData) == 0x000008, "Wrong alignment on ULibraryEnemyData");
static_assert(sizeof(ULibraryEnemyData) == 0x000030, "Wrong size on ULibraryEnemyData");
static_assert(offsetof(ULibraryEnemyData, Asset) == 0x000028, "Member 'ULibraryEnemyData::Asset' has a wrong offset!");

// Class BattlePrototype.LibraryEnemyParam
// 0x00E8 (0x0110 - 0x0028)
class ULibraryEnemyParam final : public UObject
{
public:
	TMap<class FName, struct FLibraryEnemyParamData> ParamMapM;                                         // 0x0028(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FLibraryEnemyParamData> ParamMapF;                                         // 0x0078(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FFlag                                  LibFlagsM;                                         // 0x00C8(0x0010)(Protected, NativeAccessSpecifierProtected)
	struct FFlag                                  LibFlagsF;                                         // 0x00D8(0x0010)(Protected, NativeAccessSpecifierProtected)
	class URSGameInstance*                        GameInst;                                          // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULibraryEnemyData*                      DataTable;                                         // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x18];                                      // 0x00F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetLibraryData(struct FLibraryEnemyDataCell* Data, class FName EnemyID, bool IsPlayerM, int32 ProgressNo, bool IsDebugOpen);
	bool GetLibraryDataFromLibraryID(struct FLibraryEnemyDataCell* Data, class FName LibraryID, bool IsPlayerM, int32 ProgressNo, bool IsDebugOpen);
	void InitData(class URSGameInstance* GameInstance);
	void ResetAll();

	bool IsInitialized() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LibraryEnemyParam">();
	}
	static class ULibraryEnemyParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULibraryEnemyParam>();
	}
};
static_assert(alignof(ULibraryEnemyParam) == 0x000008, "Wrong alignment on ULibraryEnemyParam");
static_assert(sizeof(ULibraryEnemyParam) == 0x000110, "Wrong size on ULibraryEnemyParam");
static_assert(offsetof(ULibraryEnemyParam, ParamMapM) == 0x000028, "Member 'ULibraryEnemyParam::ParamMapM' has a wrong offset!");
static_assert(offsetof(ULibraryEnemyParam, ParamMapF) == 0x000078, "Member 'ULibraryEnemyParam::ParamMapF' has a wrong offset!");
static_assert(offsetof(ULibraryEnemyParam, LibFlagsM) == 0x0000C8, "Member 'ULibraryEnemyParam::LibFlagsM' has a wrong offset!");
static_assert(offsetof(ULibraryEnemyParam, LibFlagsF) == 0x0000D8, "Member 'ULibraryEnemyParam::LibFlagsF' has a wrong offset!");
static_assert(offsetof(ULibraryEnemyParam, GameInst) == 0x0000E8, "Member 'ULibraryEnemyParam::GameInst' has a wrong offset!");
static_assert(offsetof(ULibraryEnemyParam, DataTable) == 0x0000F0, "Member 'ULibraryEnemyParam::DataTable' has a wrong offset!");

// Class BattlePrototype.REDOverlay
// 0x00D8 (0x0208 - 0x0130)
class UREDOverlay final : public UOverlay
{
public:
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          FlagMouse;                                         // 0x0138(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRedMouseArgument                      MouseCallArgument;                                 // 0x013C(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              MouseHitOffsetPos;                                 // 0x0148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MouseHitOffsetSize;                                // 0x0150(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugMouseHitDisp;                                 // 0x0158(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             M_OverlayFocusMouse;                               // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             M_OverlayUnFocusMouse;                             // 0x0170(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             M_OverlayDownMouse;                                // 0x0180(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          bIsStartTick;                                      // 0x0190(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x17];                                     // 0x0191(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUIBase>                 M_ParentUIBase;                                    // 0x01A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UREDebugLines*                          M_DebugDraw;                                       // 0x01B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGeometry                              M_geometry;                                        // 0x01B8(0x0038)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector2D                              VectorPixel;                                       // 0x01F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              VectorSize;                                        // 0x01F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              VectorPos;                                         // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool CheckCircle();
	bool CheckCircleCore(const struct FVector2D& Position);
	bool CheckRectangle();
	bool CheckRectangleCore(const struct FVector2D& Position);
	struct FVector2D GetAbsolutePosition();
	struct FVector2D GetAbsoluteSize();
	void RedOverlayDown__DelegateSignature(const struct FRedMouseArgument& Argument, class UObject* PWidget);
	void RedOverlayFocus__DelegateSignature(const struct FRedMouseArgument& Argument, class UObject* PWidget);
	void RedOverlayUnFocus__DelegateSignature(const struct FRedMouseArgument& Argument, class UObject* PWidget);
	void SetMouseDisable(bool Flag);
	void SetMouseInputLevel(int32 InputLevel);
	void SetMouseMode(bool Mousemode, int32 InputLevel);
	void SetParentUIBase(class UUIBase* PUiBase);

	bool GetMouseDisable() const;
	int32 GetMouseInputLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDOverlay">();
	}
	static class UREDOverlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDOverlay>();
	}
};
static_assert(alignof(UREDOverlay) == 0x000008, "Wrong alignment on UREDOverlay");
static_assert(sizeof(UREDOverlay) == 0x000208, "Wrong size on UREDOverlay");
static_assert(offsetof(UREDOverlay, FlagMouse) == 0x000138, "Member 'UREDOverlay::FlagMouse' has a wrong offset!");
static_assert(offsetof(UREDOverlay, MouseCallArgument) == 0x00013C, "Member 'UREDOverlay::MouseCallArgument' has a wrong offset!");
static_assert(offsetof(UREDOverlay, MouseHitOffsetPos) == 0x000148, "Member 'UREDOverlay::MouseHitOffsetPos' has a wrong offset!");
static_assert(offsetof(UREDOverlay, MouseHitOffsetSize) == 0x000150, "Member 'UREDOverlay::MouseHitOffsetSize' has a wrong offset!");
static_assert(offsetof(UREDOverlay, DebugMouseHitDisp) == 0x000158, "Member 'UREDOverlay::DebugMouseHitDisp' has a wrong offset!");
static_assert(offsetof(UREDOverlay, M_OverlayFocusMouse) == 0x000160, "Member 'UREDOverlay::M_OverlayFocusMouse' has a wrong offset!");
static_assert(offsetof(UREDOverlay, M_OverlayUnFocusMouse) == 0x000170, "Member 'UREDOverlay::M_OverlayUnFocusMouse' has a wrong offset!");
static_assert(offsetof(UREDOverlay, M_OverlayDownMouse) == 0x000180, "Member 'UREDOverlay::M_OverlayDownMouse' has a wrong offset!");
static_assert(offsetof(UREDOverlay, bIsStartTick) == 0x000190, "Member 'UREDOverlay::bIsStartTick' has a wrong offset!");
static_assert(offsetof(UREDOverlay, M_ParentUIBase) == 0x0001A8, "Member 'UREDOverlay::M_ParentUIBase' has a wrong offset!");
static_assert(offsetof(UREDOverlay, M_DebugDraw) == 0x0001B0, "Member 'UREDOverlay::M_DebugDraw' has a wrong offset!");
static_assert(offsetof(UREDOverlay, M_geometry) == 0x0001B8, "Member 'UREDOverlay::M_geometry' has a wrong offset!");
static_assert(offsetof(UREDOverlay, VectorPixel) == 0x0001F0, "Member 'UREDOverlay::VectorPixel' has a wrong offset!");
static_assert(offsetof(UREDOverlay, VectorSize) == 0x0001F8, "Member 'UREDOverlay::VectorSize' has a wrong offset!");
static_assert(offsetof(UREDOverlay, VectorPos) == 0x000200, "Member 'UREDOverlay::VectorPos' has a wrong offset!");

// Class BattlePrototype.LibraryEnemyParamUtility
// 0x0000 (0x0028 - 0x0028)
class ULibraryEnemyParamUtility final : public UBlueprintFunctionLibrary
{
public:
	static bool EnemyLibraryCheckFlag(const class UObject* WorldContextObject, ELibraryFlagType FlagNo);
	static bool EnemyLibraryIsOpenLibrary(const class UObject* WorldContextObject, class FName EnemyID);
	static bool EnemyLibraryOffFlag(const class UObject* WorldContextObject, ELibraryFlagType FlagNo);
	static bool EnemyLibraryOnFlag(const class UObject* WorldContextObject, ELibraryFlagType FlagNo);
	static void EnemyLibraryUpdateGetDropItem(const class UObject* WorldContextObject, class FName EnemyID, class FName ItemId);
	static void EnemyLibraryUpdateIncKillNum(const class UObject* WorldContextObject, class FName EnemyID);
	static int32 GetImageVariationNum(const class UObject* WorldContextObject, class FName EnemyID, bool IsDebugOpen);
	static void GetItemDroppingEnemyList(const class UObject* WorldContextObject, class FName ItemId, TArray<class FName>* OutEnemyList);
	static bool GetLibraryData(const class UObject* WorldContextObject, struct FLibraryEnemyDataCell* Data, class FName EnemyID, bool IsDebugOpen);
	static bool GetLibraryDataFromLibraryID(const class UObject* WorldContextObject, struct FLibraryEnemyDataCell* Data, class FName LibraryID, bool IsDebugOpen);
	static bool OpenEnemyLibray(const class UObject* WorldContextObject, class FName EnemyID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LibraryEnemyParamUtility">();
	}
	static class ULibraryEnemyParamUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULibraryEnemyParamUtility>();
	}
};
static_assert(alignof(ULibraryEnemyParamUtility) == 0x000008, "Wrong alignment on ULibraryEnemyParamUtility");
static_assert(sizeof(ULibraryEnemyParamUtility) == 0x000028, "Wrong size on ULibraryEnemyParamUtility");

// Class BattlePrototype.LoadTipsData
// 0x0010 (0x0038 - 0x0028)
class ULoadTipsData final : public UObject
{
public:
	class UDataTable*                             LoadingTipsDataTable;                              // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             RetryLoadingTipsDataTable;                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadTipsData">();
	}
	static class ULoadTipsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadTipsData>();
	}
};
static_assert(alignof(ULoadTipsData) == 0x000008, "Wrong alignment on ULoadTipsData");
static_assert(sizeof(ULoadTipsData) == 0x000038, "Wrong size on ULoadTipsData");
static_assert(offsetof(ULoadTipsData, LoadingTipsDataTable) == 0x000028, "Member 'ULoadTipsData::LoadingTipsDataTable' has a wrong offset!");
static_assert(offsetof(ULoadTipsData, RetryLoadingTipsDataTable) == 0x000030, "Member 'ULoadTipsData::RetryLoadingTipsDataTable' has a wrong offset!");

// Class BattlePrototype.REDebugLines
// 0x0038 (0x0268 - 0x0230)
class UREDebugLines final : public UUserWidget
{
public:
	struct FVector2D                              M_AbsolutePosition;                                // 0x0230(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              M_AbsoluteSize;                                    // 0x0238(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Topleft;                                           // 0x0240(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Topright;                                          // 0x0248(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              bottomleft;                                        // 0x0250(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              bottomright;                                       // 0x0258(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_Circle;                                          // 0x0260(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCircle(bool Circle);
	void SetClippingZone(const struct FVector2D& Topleft_0, const struct FVector2D& Topright_0, const struct FVector2D& bottomleft_0, const struct FVector2D& bottomright_0);
	void SetHitData(const struct FVector2D& Pos, const struct FVector2D& Size);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDebugLines">();
	}
	static class UREDebugLines* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDebugLines>();
	}
};
static_assert(alignof(UREDebugLines) == 0x000008, "Wrong alignment on UREDebugLines");
static_assert(sizeof(UREDebugLines) == 0x000268, "Wrong size on UREDebugLines");
static_assert(offsetof(UREDebugLines, M_AbsolutePosition) == 0x000230, "Member 'UREDebugLines::M_AbsolutePosition' has a wrong offset!");
static_assert(offsetof(UREDebugLines, M_AbsoluteSize) == 0x000238, "Member 'UREDebugLines::M_AbsoluteSize' has a wrong offset!");
static_assert(offsetof(UREDebugLines, Topleft) == 0x000240, "Member 'UREDebugLines::Topleft' has a wrong offset!");
static_assert(offsetof(UREDebugLines, Topright) == 0x000248, "Member 'UREDebugLines::Topright' has a wrong offset!");
static_assert(offsetof(UREDebugLines, bottomleft) == 0x000250, "Member 'UREDebugLines::bottomleft' has a wrong offset!");
static_assert(offsetof(UREDebugLines, bottomright) == 0x000258, "Member 'UREDebugLines::bottomright' has a wrong offset!");
static_assert(offsetof(UREDebugLines, M_Circle) == 0x000260, "Member 'UREDebugLines::M_Circle' has a wrong offset!");

// Class BattlePrototype.LoadTipsParamManager
// 0x00C8 (0x00F0 - 0x0028)
class ULoadTipsParamManager final : public UObject
{
public:
	TArray<struct FLoadTipsParam>                 LoadTipsParams_;                                   // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FLoadTipsBlockParam>            LoadTipsBlockDataParamsM_;                         // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FLoadTipsBlockParam>            LoadTipsBlockDataParamsF_;                         // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FLoadTipsBlockParam>            LoadTipsBlockDataParamsCommon_;                    // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         beforeSelectTipsID_;                               // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C[0xC];                                       // 0x006C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class URSGameInstance*                        GameInst_;                                         // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULoadTipsData*                          LoadTipsData_;                                     // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, int32>                      DisplayCount_;                                     // 0x0088(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x18];                                      // 0x00D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetBeginningTips(EPlayerID PlayerId, int32 ProgressNo, int32 NextLocation);
	int32 GetNextTips();
	void InitData(class URSGameInstance* GameInst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadTipsParamManager">();
	}
	static class ULoadTipsParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadTipsParamManager>();
	}
};
static_assert(alignof(ULoadTipsParamManager) == 0x000008, "Wrong alignment on ULoadTipsParamManager");
static_assert(sizeof(ULoadTipsParamManager) == 0x0000F0, "Wrong size on ULoadTipsParamManager");
static_assert(offsetof(ULoadTipsParamManager, LoadTipsParams_) == 0x000028, "Member 'ULoadTipsParamManager::LoadTipsParams_' has a wrong offset!");
static_assert(offsetof(ULoadTipsParamManager, LoadTipsBlockDataParamsM_) == 0x000038, "Member 'ULoadTipsParamManager::LoadTipsBlockDataParamsM_' has a wrong offset!");
static_assert(offsetof(ULoadTipsParamManager, LoadTipsBlockDataParamsF_) == 0x000048, "Member 'ULoadTipsParamManager::LoadTipsBlockDataParamsF_' has a wrong offset!");
static_assert(offsetof(ULoadTipsParamManager, LoadTipsBlockDataParamsCommon_) == 0x000058, "Member 'ULoadTipsParamManager::LoadTipsBlockDataParamsCommon_' has a wrong offset!");
static_assert(offsetof(ULoadTipsParamManager, beforeSelectTipsID_) == 0x000068, "Member 'ULoadTipsParamManager::beforeSelectTipsID_' has a wrong offset!");
static_assert(offsetof(ULoadTipsParamManager, GameInst_) == 0x000078, "Member 'ULoadTipsParamManager::GameInst_' has a wrong offset!");
static_assert(offsetof(ULoadTipsParamManager, LoadTipsData_) == 0x000080, "Member 'ULoadTipsParamManager::LoadTipsData_' has a wrong offset!");
static_assert(offsetof(ULoadTipsParamManager, DisplayCount_) == 0x000088, "Member 'ULoadTipsParamManager::DisplayCount_' has a wrong offset!");

// Class BattlePrototype.MainEventLatentActor
// 0x0008 (0x0238 - 0x0230)
class AMainEventLatentActor final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishWait();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainEventLatentActor">();
	}
	static class AMainEventLatentActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMainEventLatentActor>();
	}
};
static_assert(alignof(AMainEventLatentActor) == 0x000008, "Wrong alignment on AMainEventLatentActor");
static_assert(sizeof(AMainEventLatentActor) == 0x000238, "Wrong size on AMainEventLatentActor");

// Class BattlePrototype.LoadingInterludeLatentActor
// 0x0000 (0x0230 - 0x0230)
class ALoadingInterludeLatentActor final : public AActor
{
public:
	void FinishWait();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingInterludeLatentActor">();
	}
	static class ALoadingInterludeLatentActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALoadingInterludeLatentActor>();
	}
};
static_assert(alignof(ALoadingInterludeLatentActor) == 0x000008, "Wrong alignment on ALoadingInterludeLatentActor");
static_assert(sizeof(ALoadingInterludeLatentActor) == 0x000230, "Wrong size on ALoadingInterludeLatentActor");

// Class BattlePrototype.MapGimmickAnimInstance
// 0x0010 (0x0280 - 0x0270)
class UMapGimmickAnimInstance final : public UAnimInstance
{
public:
	bool                                          IsOpen;                                            // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0xF];                                      // 0x0271(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapGimmickAnimInstance">();
	}
	static class UMapGimmickAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapGimmickAnimInstance>();
	}
};
static_assert(alignof(UMapGimmickAnimInstance) == 0x000010, "Wrong alignment on UMapGimmickAnimInstance");
static_assert(sizeof(UMapGimmickAnimInstance) == 0x000280, "Wrong size on UMapGimmickAnimInstance");
static_assert(offsetof(UMapGimmickAnimInstance, IsOpen) == 0x000270, "Member 'UMapGimmickAnimInstance::IsOpen' has a wrong offset!");

// Class BattlePrototype.MapGimmickObject
// 0x03F0 (0x0620 - 0x0230)
class AMapGimmickObject : public AActor
{
public:
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AMapGimmickManager*                     MapGimmickManager;                                 // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapGimmickType                               MapGimmickType;                                    // 0x0248(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             StateDefineTable;                                  // 0x0250(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InitialStateName;                                  // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseWeightGauge;                                    // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseBossGauge;                                      // 0x0261(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOverlapBroadcastToPlayer;                        // 0x0262(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUseGimmickFlag;                                 // 0x0263(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        ModelRootComponent;                                // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurrentStateName;                                  // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentStateStep;                                  // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMapGimmickState                       CurrentState;                                      // 0x0280(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         TimeInState;                                       // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeTimeToActivate;                              // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeCancelingTime;                               // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PsychicCost;                                       // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentChargeTime;                                 // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialChargeTime;                                 // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAdjustPlaceInCharge;                             // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x3];                                      // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LengthPlaceInCharge;                               // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAdjustPlaceInFinish;                             // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x3];                                      // 0x02E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LengthPlaceInFinish;                               // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePlayerTick;                                     // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             PlayerCaptureAnimationInfoDataTable;               // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PlayerCaptureLeftAnimationInfoDataTable;           // 0x0300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PlayerFinishAnimationInfoDataTable;                // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PlayerKasaneCaptureRightAnimationInfoDataTable;    // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PlayerKasaneCaptureLeftAnimationInfoDataTable;     // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PlayerKasaneFinishAnimationInfoDataTable;          // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHCCollisionCommonInfo                 CollisionInfo;                                     // 0x0328(0x0070)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FHCSkillCommonInfo                     CollisionSkillInfo;                                // 0x0398(0x00E8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FMapGimmickState>               States;                                            // 0x0480(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FMapGimmickStateLevelSequence> StateLevelSequences;                               // 0x0490(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, class ARSLevelSequenceActor*> LevelSequenceActors;                               // 0x04E0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsSearchable;                                      // 0x0530(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSearchUnique;                                    // 0x0531(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSearchMapGimmick;                                // 0x0532(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInForceIconArea;                                 // 0x0533(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInLimitIconArea;                                 // 0x0534(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCanceling;                                       // 0x0535(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0536(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSetupSequencePlay;                               // 0x0537(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_538[0x8];                                      // 0x0538(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PlayerTransBeforeSequence;                         // 0x0540(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             CameraTransBeforeSequence;                         // 0x0570(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             CameraTransAfterSequence;                          // 0x05A0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ActivateCameraBeginInterpSec;                      // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ActivateCameraBeginInterpCurve;                    // 0x05D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsEndPlaybackcameraSequence;                       // 0x05E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E1[0x3];                                      // 0x05E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActivateCameraEndInterpSec;                        // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ActivateCameraEndInterpCurve;                      // 0x05E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsNeedTick;                                        // 0x05F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCharging;                                        // 0x05F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUsing;                                           // 0x05F2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ExplodeNeedTick;                                   // 0x05F3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsPlayerInVolume;                                  // 0x05F4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsFinished;                                        // 0x05F5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanReuse;                                          // 0x05F6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F7[0x1];                                      // 0x05F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGimmickTriggerVolume*>          HitVolumes;                                        // 0x05F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AGimmickTriggerVolume>   LastHitVolume;                                     // 0x0608(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMapGimmickFinishDir                          LastHitVolumeDir;                                  // 0x0610(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _CanActivate;                                      // 0x0611(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          StateNeedTick;                                     // 0x0612(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AlreadyExplode;                                    // 0x0613(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsDelayUpdateIconVisible;                          // 0x0614(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ToBeIconVisible;                                   // 0x0615(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_616[0xA];                                      // 0x0616(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CallbackUseThisGimmick(class AMapGimmickObject* Gimmick);
	bool CallFunctionByName(class FName StateName, float DeltaTime, EMapGimmickStatusFunc Func_0);
	bool CallStateBeginFunction(class FName StateName);
	bool CallStateCancelFunction(class FName StateName);
	bool CallStateEndFunction(class FName StateName);
	bool CallStateTickFunction(float DeltaTime, class FName StateName);
	bool CanCharge();
	class FName ChangeState(class FName StateName);
	class FName ChangeToNextInCancelState();
	class FName ChangeToNextState();
	void CustomDelay(class UObject* WorldContextObject_, float Duration, const struct FLatentActionInfo& LatentInfo_);
	float GetCaptureMovementScale(EPlayerID Player);
	float GetFinishMovementScale(EPlayerID Player);
	class UAnimMontage* GetPlayerCancelAnimation(EPlayerCaptureAnimPattern Pattern, EPlayerID Player);
	float GetPlayerCustomDilation();
	float GetPlayerDeltaSecond();
	class UAnimMontage* GetPlayerEndAnimation(EPlayerCaptureAnimPattern Pattern, EPlayerID Player);
	class UAnimMontage* GetPlayerLoopAnimation(EPlayerCaptureAnimPattern Pattern, EPlayerID Player);
	class UAnimMontage* GetPlayerStartAnimation(EPlayerCaptureAnimPattern Pattern, EPlayerID Player);
	const struct FMapGimmickState GetStateByName(class FName StateName);
	void InitializeGimmickStatus();
	bool IsActive();
	bool OnBeginForceIconVisibleOverlap();
	void OnBeginOverlapCallback(class AGimmickTriggerVolume* Volume, class AActor* OverlappedActor, class AActor* OtherActor);
	bool OnBeginTriggerVolumeOverlap();
	bool OnBeginUseLimitIconVisibleOverlap();
	void OnChangeGimmickState(class FName StateName);
	bool OnEndForceIconVisibleOverlap();
	void OnEndOverlapCallback(class AGimmickTriggerVolume* Volume, class AActor* OverlappedActor, class AActor* OtherActor);
	bool OnEndTriggerVolumeOverlap();
	bool OnEndUseLimitIconVisibleOverlap();
	void OnStateBeginFunction(class FName StateName);
	void OnStateEndFunction(class FName StateName);
	void PartnerOnBeginOverlapCallback(class AGimmickTriggerVolume* Volume, class AActor* OverlappedActor, class AActor* OtherActor, ERSPartyPlayerKind PlayerId);
	bool PartnerOnBeginTriggerVolumeOverlap(ERSPartyPlayerKind PlayerId, class AGimmickTriggerVolume* Volume);
	void PartnerOnEndOverlapCallback(class AGimmickTriggerVolume* Volume, class AActor* OverlappedActor, class AActor* OtherActor, ERSPartyPlayerKind PlayerId);
	bool PartnerOnEndTriggerVolumeOverlap(ERSPartyPlayerKind PlayerId, class AGimmickTriggerVolume* Volume);
	bool RequestChangeState(EMapGimmickStateRequest Type);
	void ResetChargeTime();
	bool SetActive(bool Active);
	void SetAlreadyExplode(bool Explode);
	bool SetAttackCollisionActive(bool Active);
	void SetCanActivate(bool CanActivate);
	void SetEnableAttackCollision(bool Enable);
	void SetEnablePhysics(bool Enable);
	void SetEnablePhysicsPerBone(class USkeletalMeshComponent* SkeletalMesh, class FName BoneName, bool Enable);
	void SetExplosionNeedTick(bool Need);
	bool SetIconGaugeEnableProxy(bool Enable);
	bool SetIconVisible(bool Visible, bool IsSuccess, bool IsCancel);
	void SetIsFinished(bool Finished);
	bool SetLimitIconVisible(bool Visible, bool Limit, bool IsSuccess);
	bool SetNeedTick(bool Need);
	void SetStateNeedTick(bool Need);
	void SetUsing(bool Using);
	bool UpdateWidgetGauge();

	bool CanActivate() const;
	bool CanAddDriveGauge() const;
	class UPrimitiveComponent* GetAttackCollisionPrimitive() const;
	class USceneComponent* GetIconComponent() const;
	struct FVector GetIconPosition() const;
	bool GetIsFinished() const;
	class USceneComponent* GetLookAtComponent() const;
	struct FVector GetLookAtPosition() const;
	class FName GetNextCancelStateName() const;
	class FName GetNextStateName() const;
	class USceneComponent* GetPlayerLookAtComponent() const;
	struct FVector GetPlayerLookAtPosition() const;
	class UPrimitiveComponent* GetPrimitive() const;
	float GetPsychicCost() const;
	bool OnMapGimmickChargeCancel(class AMapGimmickObject* GimmickActor) const;
	bool OnMapGimmickChargeEnd(class AMapGimmickObject* GimmickActor) const;
	bool OnMapGimmickChargeStart(class AMapGimmickObject* GimmickActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapGimmickObject">();
	}
	static class AMapGimmickObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapGimmickObject>();
	}
};
static_assert(alignof(AMapGimmickObject) == 0x000010, "Wrong alignment on AMapGimmickObject");
static_assert(sizeof(AMapGimmickObject) == 0x000620, "Wrong size on AMapGimmickObject");
static_assert(offsetof(AMapGimmickObject, MapGimmickManager) == 0x000240, "Member 'AMapGimmickObject::MapGimmickManager' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, MapGimmickType) == 0x000248, "Member 'AMapGimmickObject::MapGimmickType' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, StateDefineTable) == 0x000250, "Member 'AMapGimmickObject::StateDefineTable' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, InitialStateName) == 0x000258, "Member 'AMapGimmickObject::InitialStateName' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, UseWeightGauge) == 0x000260, "Member 'AMapGimmickObject::UseWeightGauge' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, UseBossGauge) == 0x000261, "Member 'AMapGimmickObject::UseBossGauge' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsOverlapBroadcastToPlayer) == 0x000262, "Member 'AMapGimmickObject::IsOverlapBroadcastToPlayer' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CanUseGimmickFlag) == 0x000263, "Member 'AMapGimmickObject::CanUseGimmickFlag' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, ModelRootComponent) == 0x000268, "Member 'AMapGimmickObject::ModelRootComponent' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CurrentStateName) == 0x000270, "Member 'AMapGimmickObject::CurrentStateName' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CurrentStateStep) == 0x000278, "Member 'AMapGimmickObject::CurrentStateStep' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CurrentState) == 0x000280, "Member 'AMapGimmickObject::CurrentState' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, TimeInState) == 0x0002C8, "Member 'AMapGimmickObject::TimeInState' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, ChargeTimeToActivate) == 0x0002CC, "Member 'AMapGimmickObject::ChargeTimeToActivate' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, ChargeCancelingTime) == 0x0002D0, "Member 'AMapGimmickObject::ChargeCancelingTime' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, PsychicCost) == 0x0002D4, "Member 'AMapGimmickObject::PsychicCost' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CurrentChargeTime) == 0x0002D8, "Member 'AMapGimmickObject::CurrentChargeTime' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, InitialChargeTime) == 0x0002DC, "Member 'AMapGimmickObject::InitialChargeTime' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsAdjustPlaceInCharge) == 0x0002E0, "Member 'AMapGimmickObject::IsAdjustPlaceInCharge' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, LengthPlaceInCharge) == 0x0002E4, "Member 'AMapGimmickObject::LengthPlaceInCharge' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsAdjustPlaceInFinish) == 0x0002E8, "Member 'AMapGimmickObject::IsAdjustPlaceInFinish' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, LengthPlaceInFinish) == 0x0002EC, "Member 'AMapGimmickObject::LengthPlaceInFinish' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, UsePlayerTick) == 0x0002F0, "Member 'AMapGimmickObject::UsePlayerTick' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, PlayerCaptureAnimationInfoDataTable) == 0x0002F8, "Member 'AMapGimmickObject::PlayerCaptureAnimationInfoDataTable' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, PlayerCaptureLeftAnimationInfoDataTable) == 0x000300, "Member 'AMapGimmickObject::PlayerCaptureLeftAnimationInfoDataTable' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, PlayerFinishAnimationInfoDataTable) == 0x000308, "Member 'AMapGimmickObject::PlayerFinishAnimationInfoDataTable' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, PlayerKasaneCaptureRightAnimationInfoDataTable) == 0x000310, "Member 'AMapGimmickObject::PlayerKasaneCaptureRightAnimationInfoDataTable' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, PlayerKasaneCaptureLeftAnimationInfoDataTable) == 0x000318, "Member 'AMapGimmickObject::PlayerKasaneCaptureLeftAnimationInfoDataTable' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, PlayerKasaneFinishAnimationInfoDataTable) == 0x000320, "Member 'AMapGimmickObject::PlayerKasaneFinishAnimationInfoDataTable' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CollisionInfo) == 0x000328, "Member 'AMapGimmickObject::CollisionInfo' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CollisionSkillInfo) == 0x000398, "Member 'AMapGimmickObject::CollisionSkillInfo' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, States) == 0x000480, "Member 'AMapGimmickObject::States' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, StateLevelSequences) == 0x000490, "Member 'AMapGimmickObject::StateLevelSequences' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, LevelSequenceActors) == 0x0004E0, "Member 'AMapGimmickObject::LevelSequenceActors' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsSearchable) == 0x000530, "Member 'AMapGimmickObject::IsSearchable' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsSearchUnique) == 0x000531, "Member 'AMapGimmickObject::IsSearchUnique' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsSearchMapGimmick) == 0x000532, "Member 'AMapGimmickObject::IsSearchMapGimmick' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsInForceIconArea) == 0x000533, "Member 'AMapGimmickObject::IsInForceIconArea' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsInLimitIconArea) == 0x000534, "Member 'AMapGimmickObject::IsInLimitIconArea' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsCanceling) == 0x000535, "Member 'AMapGimmickObject::IsCanceling' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, bIsActive) == 0x000536, "Member 'AMapGimmickObject::bIsActive' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsSetupSequencePlay) == 0x000537, "Member 'AMapGimmickObject::IsSetupSequencePlay' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, PlayerTransBeforeSequence) == 0x000540, "Member 'AMapGimmickObject::PlayerTransBeforeSequence' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CameraTransBeforeSequence) == 0x000570, "Member 'AMapGimmickObject::CameraTransBeforeSequence' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CameraTransAfterSequence) == 0x0005A0, "Member 'AMapGimmickObject::CameraTransAfterSequence' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, ActivateCameraBeginInterpSec) == 0x0005D0, "Member 'AMapGimmickObject::ActivateCameraBeginInterpSec' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, ActivateCameraBeginInterpCurve) == 0x0005D8, "Member 'AMapGimmickObject::ActivateCameraBeginInterpCurve' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsEndPlaybackcameraSequence) == 0x0005E0, "Member 'AMapGimmickObject::IsEndPlaybackcameraSequence' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, ActivateCameraEndInterpSec) == 0x0005E4, "Member 'AMapGimmickObject::ActivateCameraEndInterpSec' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, ActivateCameraEndInterpCurve) == 0x0005E8, "Member 'AMapGimmickObject::ActivateCameraEndInterpCurve' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsNeedTick) == 0x0005F0, "Member 'AMapGimmickObject::IsNeedTick' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsCharging) == 0x0005F1, "Member 'AMapGimmickObject::IsCharging' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsUsing) == 0x0005F2, "Member 'AMapGimmickObject::IsUsing' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, ExplodeNeedTick) == 0x0005F3, "Member 'AMapGimmickObject::ExplodeNeedTick' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsPlayerInVolume) == 0x0005F4, "Member 'AMapGimmickObject::IsPlayerInVolume' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsFinished) == 0x0005F5, "Member 'AMapGimmickObject::IsFinished' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CanReuse) == 0x0005F6, "Member 'AMapGimmickObject::CanReuse' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, HitVolumes) == 0x0005F8, "Member 'AMapGimmickObject::HitVolumes' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, LastHitVolume) == 0x000608, "Member 'AMapGimmickObject::LastHitVolume' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, LastHitVolumeDir) == 0x000610, "Member 'AMapGimmickObject::LastHitVolumeDir' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, _CanActivate) == 0x000611, "Member 'AMapGimmickObject::_CanActivate' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, StateNeedTick) == 0x000612, "Member 'AMapGimmickObject::StateNeedTick' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, AlreadyExplode) == 0x000613, "Member 'AMapGimmickObject::AlreadyExplode' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsDelayUpdateIconVisible) == 0x000614, "Member 'AMapGimmickObject::IsDelayUpdateIconVisible' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, ToBeIconVisible) == 0x000615, "Member 'AMapGimmickObject::ToBeIconVisible' has a wrong offset!");

// Class BattlePrototype.MapIconData
// 0x0000 (0x0028 - 0x0028)
class UMapIconData final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapIconData">();
	}
	static class UMapIconData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapIconData>();
	}
};
static_assert(alignof(UMapIconData) == 0x000008, "Wrong alignment on UMapIconData");
static_assert(sizeof(UMapIconData) == 0x000028, "Wrong size on UMapIconData");

// Class BattlePrototype.MapIconExporter
// 0x00C0 (0x02F0 - 0x0230)
class AMapIconExporter final : public AActor
{
public:
	uint8                                         Pad_230[0xC0];                                     // 0x0230(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CurrentArrangeIcon();
	void CurrentMapIcon(int32 LocationId, int32 AreaId);
	void ExportArrangeIconJson();
	void ExportMapIconJson();
	void StartupArrangeItemAtCurrentBegin();
	void StartupMapIconAtCurrentBegin();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapIconExporter">();
	}
	static class AMapIconExporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapIconExporter>();
	}
};
static_assert(alignof(AMapIconExporter) == 0x000008, "Wrong alignment on AMapIconExporter");
static_assert(sizeof(AMapIconExporter) == 0x0002F0, "Wrong size on AMapIconExporter");

// Class BattlePrototype.REDWidgetUtility
// 0x0000 (0x0028 - 0x0028)
class UREDWidgetUtility final : public UBlueprintFunctionLibrary
{
public:
	static void ClearFontAtlas();
	static void ConvertButtonIconPlatform(class UImage* Image);
	static void ConvertImagePathPlatformName(class UImage* Image);
	static void CopyHorizontalBoxProperty(class UHorizontalBox* Source, class UHorizontalBox* Dest);
	static void CopyImageProperty(class UImage* Source, class UImage* Dest);
	static void CopyOverlayProperty(class UOverlay* Source, class UOverlay* Dest);
	static void CopySlotProperty(class UWidget* Source, class UWidget* Dest);
	static void CopySpacerProperty(class USpacer* Source, class USpacer* Dest);
	static void CopyTextBlockProperty(class UTextBlock* Source, class UTextBlock* Dest);
	static void CreateWidgetRED(class UObject* WorldContextObject, TSubclassOf<class UUserWidget> WidgetType, class UUserWidget*& Output);
	static void GetAbsolutePosition(class UWidget* Widget, float* X, float* Y);
	static struct FVector2D GetAbsolutePositionVector2D(class UWidget* Widget);
	static void GetAbsoluteScreenOfffset(class UObject* WorldContextObject, const struct FVector2D& baseOffset, struct FVector2D* CalcOffset);
	static void GetDesiredSizeWithPrepass(class UWidget* Widget, float* Width, float* Height);
	static class UInvalidationBox* GetFirstInvalidationBox(class UUserWidget* Widget);
	static EPlayerID GetMainPlayerID(class UObject* WorldContextObject);
	static void GetRelativePosition(class UWidget* Widget, float* X, float* Y);
	static struct FVector2D GetRelativePositionVector2D(class UWidget* Widget);
	static void GetScreenOffset(class UObject* WorldContextObject, const struct FVector2D& baseOffset, struct FVector2D* CalcOffset);
	static void GetScreenOffsetReverse(class UObject* WorldContextObject, const struct FVector2D& baseOffset, struct FVector2D* CalcOffset);
	static void GetViewportOffset(class UObject* WorldContextObject, const struct FVector2D& AbsolutePosition, struct FVector2D* CalcOffset);
	static bool IsSpoiler(class UObject* WorldContextObject, const class FName& ItemId);
	static bool IsYuitoMode(class UObject* WorldContextObject);
	static void ProjectWorldToScreen2(class UObject* WorldContextObject, const struct FVector& WorldPosition, struct FVector2D* ScreenPosition);
	static void SetCurrentLocationAreaName(class UObject* WorldObject, int32 LocationNo, int32 AreaNo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDWidgetUtility">();
	}
	static class UREDWidgetUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDWidgetUtility>();
	}
};
static_assert(alignof(UREDWidgetUtility) == 0x000008, "Wrong alignment on UREDWidgetUtility");
static_assert(sizeof(UREDWidgetUtility) == 0x000028, "Wrong size on UREDWidgetUtility");

// Class BattlePrototype.MaterialAccessorCompLibrary
// 0x0000 (0x0028 - 0x0028)
class UMaterialAccessorCompLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void SetupMeshListMACParametersNative(class UObject* WorldContextObject, const TArray<class UMeshComponent*>& MeshComps, const TArray<struct FMACVariableFloat>& MACScalars, const TArray<EMaterialAccessorSetupID>& MACScalarSetupIDs, const TArray<struct FMACVariableVector>& MACVectors, const TArray<EMaterialAccessorSetupID>& MACVectorSetupIDs);
	static void SetupMeshMACParametersNative(class UObject* WorldContextObject, class UMeshComponent* MeshComp, const TArray<struct FMACVariableFloat>& MACScalars, const TArray<EMaterialAccessorSetupID>& MACScalarSetupIDs, const TArray<struct FMACVariableVector>& MACVectors, const TArray<EMaterialAccessorSetupID>& MACVectorSetupIDs);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialAccessorCompLibrary">();
	}
	static class UMaterialAccessorCompLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialAccessorCompLibrary>();
	}
};
static_assert(alignof(UMaterialAccessorCompLibrary) == 0x000008, "Wrong alignment on UMaterialAccessorCompLibrary");
static_assert(sizeof(UMaterialAccessorCompLibrary) == 0x000028, "Wrong size on UMaterialAccessorCompLibrary");

// Class BattlePrototype.MessageData
// 0x0060 (0x0088 - 0x0028)
class UMessageData final : public UObject
{
public:
	TArray<class UDataTable*>                     RefDataTableList;                                  // 0x0028(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, class UObject*>           M_PreLoadVoiceMap;                                 // 0x0038(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	bool GetMessage(struct FMessageDataCell* MessageDataCell, class FName ID);
	bool GetMessageFromIndex(struct FMessageDataCell* MessageDataCell, int32 _index);
	bool LoadDataTable(const class FString& _path);
	void RegisterDataTable(class UDataTable* _datatable, const class FString& _path);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageData">();
	}
	static class UMessageData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMessageData>();
	}
};
static_assert(alignof(UMessageData) == 0x000008, "Wrong alignment on UMessageData");
static_assert(sizeof(UMessageData) == 0x000088, "Wrong size on UMessageData");
static_assert(offsetof(UMessageData, RefDataTableList) == 0x000028, "Member 'UMessageData::RefDataTableList' has a wrong offset!");
static_assert(offsetof(UMessageData, M_PreLoadVoiceMap) == 0x000038, "Member 'UMessageData::M_PreLoadVoiceMap' has a wrong offset!");

// Class BattlePrototype.MessageViewerBase
// 0x0070 (0x02A0 - 0x0230)
class AMessageViewerBase final : public AActor
{
public:
	TWeakObjectPtr<class UDataTable>              SettingDataTable;                                  // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETextLanguage                                 CurrentLanguage;                                   // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentCategory;                                   // 0x023C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrentFileName;                                   // 0x0248(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CurrentLabel;                                      // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ETextLanguage>                         LanguageList;                                      // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FMsgViewerData>                 DataFileList;                                      // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           MessageLabelList;                                  // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMsgViewerLoadedData                   LoadedData;                                        // 0x0290(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateFileListBySetting(ETextLanguage Language, class FName Setting);
	void CreateLabelList(const class FString& DispName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageViewerBase">();
	}
	static class AMessageViewerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMessageViewerBase>();
	}
};
static_assert(alignof(AMessageViewerBase) == 0x000008, "Wrong alignment on AMessageViewerBase");
static_assert(sizeof(AMessageViewerBase) == 0x0002A0, "Wrong size on AMessageViewerBase");
static_assert(offsetof(AMessageViewerBase, SettingDataTable) == 0x000230, "Member 'AMessageViewerBase::SettingDataTable' has a wrong offset!");
static_assert(offsetof(AMessageViewerBase, CurrentLanguage) == 0x000238, "Member 'AMessageViewerBase::CurrentLanguage' has a wrong offset!");
static_assert(offsetof(AMessageViewerBase, CurrentCategory) == 0x00023C, "Member 'AMessageViewerBase::CurrentCategory' has a wrong offset!");
static_assert(offsetof(AMessageViewerBase, CurrentFileName) == 0x000248, "Member 'AMessageViewerBase::CurrentFileName' has a wrong offset!");
static_assert(offsetof(AMessageViewerBase, CurrentLabel) == 0x000258, "Member 'AMessageViewerBase::CurrentLabel' has a wrong offset!");
static_assert(offsetof(AMessageViewerBase, LanguageList) == 0x000260, "Member 'AMessageViewerBase::LanguageList' has a wrong offset!");
static_assert(offsetof(AMessageViewerBase, DataFileList) == 0x000270, "Member 'AMessageViewerBase::DataFileList' has a wrong offset!");
static_assert(offsetof(AMessageViewerBase, MessageLabelList) == 0x000280, "Member 'AMessageViewerBase::MessageLabelList' has a wrong offset!");
static_assert(offsetof(AMessageViewerBase, LoadedData) == 0x000290, "Member 'AMessageViewerBase::LoadedData' has a wrong offset!");

// Class BattlePrototype.ModelViewerBase
// 0x0090 (0x02C0 - 0x0230)
class AModelViewerBase final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACameraActor*                           _modelViewerCamera;                                // 0x0238(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARSCharacterBase*                       _modelViewerPlayer;                                // 0x0240(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ANpcBase*                               _modelViewerPlayerNpc;                             // 0x0248(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ANpcSkeletalMeshActor*                  _modelViewerSkeletalNpc;                           // 0x0250(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class ARSCharacterBase>>   CharacterList;                                     // 0x0258(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SelectIndex;                                       // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                _PlayingMotionAsset;                               // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _PlayingMotionAssetLength;                         // 0x0278(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActorReferenceInfo>            ActorReferenceInfoList;                            // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         CharacterNametList;                                // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAssetData>                     AnimationAssetList;                                // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         FaceNameList;                                      // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static int32 CompareFName(class FName Param1, class FName Param2);
	static void GetFolderNameListByPath(TArray<class FString>* FolderNameList, const class FString& SearchFolderPathFromContents);
	static TSoftClassPtr<class UClass> GetNpcBase(const class FString& AssetPath);
	static TSoftClassPtr<class UClass> GetNpcSkeletalMeshActor(const class FString& AssetPath);
	static TSoftClassPtr<class UClass> GetRSCharacterBase(const class FString& AssetPath);

	void AddActorReferenceInfo(TSoftClassPtr<class UClass> CharaActor);
	void AddCharacter(const TArray<TSubclassOf<class ARSCharacterBase>>& List);
	void ChangeNextIndex();
	void ChangePrevIndex();
	bool CompareAssetPath(const class FString& ModelBPDisplayName, const class FString& AnimationPath);
	void CreateAnimationFileList(class FName CharacterIdentifier, class FName CharacterName);
	void CreateCharacterFileList();
	void CreateFaceNameList(class FName CharacterName);
	void CreateWidget();
	void Debug_CreateModelViewerCharacter(TSubclassOf<class ARSCharacterBase> CharacterBP, const class FString& PlayerStartName);
	void Debug_CreateModelViewerCharacterNpc(TSubclassOf<class ANpcBase> CharacterBP, const class FString& PlayerStartName);
	void Debug_CreateModelViewerSkeletalNpc(TSubclassOf<class ANpcSkeletalMeshActor> CharacterBP, const class FString& PlayerStartName);
	class FString GetActorReferenceAssetName(TSoftClassPtr<class UClass> CharaActor);
	class FString GetActorReferencePackageName(TSoftClassPtr<class UClass> CharaActor);
	class FString GetActorReferenceToString(TSoftClassPtr<class UClass> CharaActor);
	float GetCurrentAnimationFrame(const int32 Digit);
	float GetCurrentAnimationTime();
	class FString GetDebugDrawMotionInfo();
	float GetMaxAnimationTime();
	class ACameraActor* GetModelViewerCamera();
	class ARSCharacterBase* GetModelViewerPlayer();
	class ANpcBase* GetModelViewerPlayerNpc();
	class ANpcSkeletalMeshActor* GetModelViewerSkeletalNpc();
	int32 GetSelectAnimationComboboxIndex();
	TSubclassOf<class ARSCharacterBase> GetSelectCharacter();
	int32 GetSelectCharacterComboboxIndex();
	int32 GetSelectFaceComboboxIndex();
	void InitializePlayerInfo();
	bool IsPlayAnimationMontage();
	void LoadCharacter(const int32 Index_0);
	void LoadCharacterRequest(const bool IsReload);
	class USaveGame* ModelViewerLoad(const class FString& SlotName, const int32 UserIndex);
	bool ModelViewerSave(class USaveGame* SaveGameObject, const class FString& SlotName, const int32 UserIndex);
	void OnChangeSelectCharacter(const int32 Index_0);
	bool PauseAnimation();
	bool PlayAnimation(class UObject* MotionAsset, const bool IsReplay, float InTimeToStartMontageAt);
	void SetAnimationComboBox();
	void SetCharacterComboBox();
	void SetFaceComboBox();
	void SetModelViewerCamera(class ACameraActor* CameraActor);
	void SortAssetDatalist(TArray<struct FAssetData>* AssetDataList);
	void SpawnCharacter(const int32 CharacterIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModelViewerBase">();
	}
	static class AModelViewerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AModelViewerBase>();
	}
};
static_assert(alignof(AModelViewerBase) == 0x000008, "Wrong alignment on AModelViewerBase");
static_assert(sizeof(AModelViewerBase) == 0x0002C0, "Wrong size on AModelViewerBase");
static_assert(offsetof(AModelViewerBase, _modelViewerCamera) == 0x000238, "Member 'AModelViewerBase::_modelViewerCamera' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, _modelViewerPlayer) == 0x000240, "Member 'AModelViewerBase::_modelViewerPlayer' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, _modelViewerPlayerNpc) == 0x000248, "Member 'AModelViewerBase::_modelViewerPlayerNpc' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, _modelViewerSkeletalNpc) == 0x000250, "Member 'AModelViewerBase::_modelViewerSkeletalNpc' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, CharacterList) == 0x000258, "Member 'AModelViewerBase::CharacterList' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, SelectIndex) == 0x000268, "Member 'AModelViewerBase::SelectIndex' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, _PlayingMotionAsset) == 0x000270, "Member 'AModelViewerBase::_PlayingMotionAsset' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, _PlayingMotionAssetLength) == 0x000278, "Member 'AModelViewerBase::_PlayingMotionAssetLength' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, ActorReferenceInfoList) == 0x000280, "Member 'AModelViewerBase::ActorReferenceInfoList' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, CharacterNametList) == 0x000290, "Member 'AModelViewerBase::CharacterNametList' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, AnimationAssetList) == 0x0002A0, "Member 'AModelViewerBase::AnimationAssetList' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, FaceNameList) == 0x0002B0, "Member 'AModelViewerBase::FaceNameList' has a wrong offset!");

// Class BattlePrototype.MoveImpulseComponent
// 0x0040 (0x0100 - 0x00C0)
class UMoveImpulseComponent final : public UActorComponent
{
public:
	bool                                          _isDebugDraw;                                      // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _decSpeed;                                         // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _claimantName;                                     // 0x00C8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _nowVelocity;                                      // 0x00D0(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _oldLocation;                                      // 0x00DC(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMoveImpulseComponent* GetMoveImpulseComponent(class AActor* Actor);

	void SetImpulse(const struct FVector& Velocity);
	void UpdateFlying();
	void UpdateFunction(float DeltaTime);

	struct FVector GetVelocity() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveImpulseComponent">();
	}
	static class UMoveImpulseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveImpulseComponent>();
	}
};
static_assert(alignof(UMoveImpulseComponent) == 0x000008, "Wrong alignment on UMoveImpulseComponent");
static_assert(sizeof(UMoveImpulseComponent) == 0x000100, "Wrong size on UMoveImpulseComponent");
static_assert(offsetof(UMoveImpulseComponent, _isDebugDraw) == 0x0000C0, "Member 'UMoveImpulseComponent::_isDebugDraw' has a wrong offset!");
static_assert(offsetof(UMoveImpulseComponent, _decSpeed) == 0x0000C4, "Member 'UMoveImpulseComponent::_decSpeed' has a wrong offset!");
static_assert(offsetof(UMoveImpulseComponent, _claimantName) == 0x0000C8, "Member 'UMoveImpulseComponent::_claimantName' has a wrong offset!");
static_assert(offsetof(UMoveImpulseComponent, _nowVelocity) == 0x0000D0, "Member 'UMoveImpulseComponent::_nowVelocity' has a wrong offset!");
static_assert(offsetof(UMoveImpulseComponent, _oldLocation) == 0x0000DC, "Member 'UMoveImpulseComponent::_oldLocation' has a wrong offset!");

// Class BattlePrototype.RSAccountManager
// 0x01E8 (0x0220 - 0x0038)
class URSAccountManager : public URSTickableManagerBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URSGameInstance*                        _gameInstance;                                     // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_UserAccountID;                                   // 0x0048(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_AssumedDefaultUserAccountID;                     // 0x0058(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isFirstButtonPushCheck;                          // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isFirstCheckSuccessed;                           // 0x0069(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isInvalidPairingCheck;                           // 0x006A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B[0x1];                                       // 0x006B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_DelayCounter;                                    // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDebugInvalidXB1ProfileCheck;                    // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDebugTickOutputLog;                             // 0x0071(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_72[0x16];                                      // 0x0072(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             XboxFirstConnectEvent;                             // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             XboxChangeAccountEvent;                            // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             XboxCuttingAccountEvent;                           // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             XboxReconnectAccountEvent;                         // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             XboxConnectFromInvalidIndexEvent;                  // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x148];                                     // 0x00D8(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool FirstButtonPushCheck();
	bool FirstCheckUserAccount();
	class FString GetControllerProfileID(const int32 _ControllerId);
	int32 GetLocalPlayerControllerID();
	class FString GetLocalPlayerProfileID(const int32 _LocalPlayerIndex);
	class FString GetLocalPlayerUserID();
	void GetLocalPlayerUserInfo();
	void OnAccountChange(const class FString& PrevAccountId, const class FString& NowAccountId);
	void OnAccountConnectFromInvalidIndex(int32 ControllerId, const class FString& AccountId);
	void OnAccountCutting(const class FString& AccountId);
	void OnAccountReconnect(const class FString& AccountId);
	void OnFirstConnect(const class FString& AccountId);
	bool OpenLoginUI(bool IsFirst);
	void OutputAllLoginProfileID();
	void OutputControllerInfo();
	void OutputDebugInfo();
	void OutputLocalPlayerInfo();
	void ResetAccount();
	void SetActiveAllController(const int32 _ControllerId);
	void SetCheckAccountInvalidBitFlag(ECheckAccountFlag Flag, const bool IsInvalid);
	void Test_XboxOneGetUserID();
	bool UpdateController();
	bool UpdateUserAccountID();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAccountManager">();
	}
	static class URSAccountManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAccountManager>();
	}
};
static_assert(alignof(URSAccountManager) == 0x000008, "Wrong alignment on URSAccountManager");
static_assert(sizeof(URSAccountManager) == 0x000220, "Wrong size on URSAccountManager");
static_assert(offsetof(URSAccountManager, _gameInstance) == 0x000040, "Member 'URSAccountManager::_gameInstance' has a wrong offset!");
static_assert(offsetof(URSAccountManager, M_UserAccountID) == 0x000048, "Member 'URSAccountManager::M_UserAccountID' has a wrong offset!");
static_assert(offsetof(URSAccountManager, M_AssumedDefaultUserAccountID) == 0x000058, "Member 'URSAccountManager::M_AssumedDefaultUserAccountID' has a wrong offset!");
static_assert(offsetof(URSAccountManager, M_isFirstButtonPushCheck) == 0x000068, "Member 'URSAccountManager::M_isFirstButtonPushCheck' has a wrong offset!");
static_assert(offsetof(URSAccountManager, M_isFirstCheckSuccessed) == 0x000069, "Member 'URSAccountManager::M_isFirstCheckSuccessed' has a wrong offset!");
static_assert(offsetof(URSAccountManager, M_isInvalidPairingCheck) == 0x00006A, "Member 'URSAccountManager::M_isInvalidPairingCheck' has a wrong offset!");
static_assert(offsetof(URSAccountManager, M_DelayCounter) == 0x00006C, "Member 'URSAccountManager::M_DelayCounter' has a wrong offset!");
static_assert(offsetof(URSAccountManager, M_bDebugInvalidXB1ProfileCheck) == 0x000070, "Member 'URSAccountManager::M_bDebugInvalidXB1ProfileCheck' has a wrong offset!");
static_assert(offsetof(URSAccountManager, M_bDebugTickOutputLog) == 0x000071, "Member 'URSAccountManager::M_bDebugTickOutputLog' has a wrong offset!");
static_assert(offsetof(URSAccountManager, XboxFirstConnectEvent) == 0x000088, "Member 'URSAccountManager::XboxFirstConnectEvent' has a wrong offset!");
static_assert(offsetof(URSAccountManager, XboxChangeAccountEvent) == 0x000098, "Member 'URSAccountManager::XboxChangeAccountEvent' has a wrong offset!");
static_assert(offsetof(URSAccountManager, XboxCuttingAccountEvent) == 0x0000A8, "Member 'URSAccountManager::XboxCuttingAccountEvent' has a wrong offset!");
static_assert(offsetof(URSAccountManager, XboxReconnectAccountEvent) == 0x0000B8, "Member 'URSAccountManager::XboxReconnectAccountEvent' has a wrong offset!");
static_assert(offsetof(URSAccountManager, XboxConnectFromInvalidIndexEvent) == 0x0000C8, "Member 'URSAccountManager::XboxConnectFromInvalidIndexEvent' has a wrong offset!");

// Class BattlePrototype.MoveInputComponent
// 0x0068 (0x0128 - 0x00C0)
class UMoveInputComponent final : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x68];                                      // 0x00C0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearInputVector();
	void SetFixCamera(bool bFix);
	void UpdateMoveInputVector(float AxisValueX, float AxisValueY);

	struct FVector CalcInputWorldVector() const;
	struct FVector CalcWorldVector(const struct FVector& Dir) const;
	struct FVector GetLatestEnableInputDir() const;
	struct FVector GetLatestEnableInputVector() const;
	struct FVector GetLatestEnableInputWorldVector() const;
	struct FVector GetMoveInputDir() const;
	float GetMoveInputLengthTriggerLimit() const;
	struct FVector GetMoveInputVector() const;
	bool IsFixCamera() const;
	bool IsInputOverLimit(float LimitRate) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveInputComponent">();
	}
	static class UMoveInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveInputComponent>();
	}
};
static_assert(alignof(UMoveInputComponent) == 0x000008, "Wrong alignment on UMoveInputComponent");
static_assert(sizeof(UMoveInputComponent) == 0x000128, "Wrong size on UMoveInputComponent");

// Class BattlePrototype.MovementPropertyInterface
// 0x0000 (0x0028 - 0x0028)
class IMovementPropertyInterface final : public IInterface
{
public:
	bool ClearFlyingForceInterface();
	bool ClearFlyingInterface(const class FName& ClaimantName);
	bool SetFlyingInterface(const class FName& ClaimantName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementPropertyInterface">();
	}
	static class IMovementPropertyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMovementPropertyInterface>();
	}
};
static_assert(alignof(IMovementPropertyInterface) == 0x000008, "Wrong alignment on IMovementPropertyInterface");
static_assert(sizeof(IMovementPropertyInterface) == 0x000028, "Wrong size on IMovementPropertyInterface");

// Class BattlePrototype.RSActorComponentUIBase
// 0x0000 (0x00C0 - 0x00C0)
class URSActorComponentUIBase final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorComponentUIBase">();
	}
	static class URSActorComponentUIBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSActorComponentUIBase>();
	}
};
static_assert(alignof(URSActorComponentUIBase) == 0x000008, "Wrong alignment on URSActorComponentUIBase");
static_assert(sizeof(URSActorComponentUIBase) == 0x0000C0, "Wrong size on URSActorComponentUIBase");

// Class BattlePrototype.MovementPropertyMediator
// 0x0280 (0x0340 - 0x00C0)
class UMovementPropertyMediator final : public UActorComponent
{
public:
	float                                         ActionSpeedRateMin;                                // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMaxWalkSpeed;                               // 0x00C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMaxFlySpeed;                                // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeedRateMin;                               // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeedRateMax;                               // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _defaultStepStartSpeed;                            // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _defaultStepDeclaration;                           // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _stepSpeedRateMin;                                 // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _stepSpeedRateMax;                                 // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             OwnerCharacter;                                    // 0x00E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterMovementComponent*            OwnerMovement;                                     // 0x00F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x248];                                     // 0x00F8(0x0248)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMovementPropertyMediator* GetMovementPropertyMediatorComponentFromActor(class AActor* Actor);

	void ClearActionSpeedRate(const class FName& ClaimantName);
	void ClearFlying(const class FName& ClaimantName);
	void ClearFlyingForce();
	void ClearMaxFlySpeedRate(const class FName& ClaimantName);
	void ClearMaxWalkSpeedRate(const class FName& ClaimantName);
	void ClearMovementCollisionIgnorePawn(const class FName& ClaimantName);
	void ClearStepSpeedRate(const class FName& ClaimantName);
	void DisableMovement(const class FName& ClaimantName);
	void EnableMovement(const class FName& ClaimantName);
	void SetActionSpeedRate(const class FName& ClaimantName, float SpeedRate);
	void SetFlying(const class FName& ClaimantName);
	void SetMaxFlySpeed(const class FName& ClaimantName, float Speed);
	void SetMaxFlySpeedRate(const class FName& ClaimantName, float Rate);
	void SetMaxWalkSpeed(const class FName& ClaimantName, float Speed);
	void SetMaxWalkSpeedRate(const class FName& ClaimantName, float Rate);
	void SetMovementCollisionIgnorePawn(const class FName& ClaimantName);
	void SetStepSpeedRate(const class FName& ClaimantName, float Rate);

	float CalcDistanceToGround() const;
	bool CheckTouchGround() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementPropertyMediator">();
	}
	static class UMovementPropertyMediator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovementPropertyMediator>();
	}
};
static_assert(alignof(UMovementPropertyMediator) == 0x000008, "Wrong alignment on UMovementPropertyMediator");
static_assert(sizeof(UMovementPropertyMediator) == 0x000340, "Wrong size on UMovementPropertyMediator");
static_assert(offsetof(UMovementPropertyMediator, ActionSpeedRateMin) == 0x0000C0, "Member 'UMovementPropertyMediator::ActionSpeedRateMin' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, DefaultMaxWalkSpeed) == 0x0000C4, "Member 'UMovementPropertyMediator::DefaultMaxWalkSpeed' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, DefaultMaxFlySpeed) == 0x0000C8, "Member 'UMovementPropertyMediator::DefaultMaxFlySpeed' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, MaxWalkSpeedRateMin) == 0x0000CC, "Member 'UMovementPropertyMediator::MaxWalkSpeedRateMin' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, MaxWalkSpeedRateMax) == 0x0000D0, "Member 'UMovementPropertyMediator::MaxWalkSpeedRateMax' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, _defaultStepStartSpeed) == 0x0000D4, "Member 'UMovementPropertyMediator::_defaultStepStartSpeed' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, _defaultStepDeclaration) == 0x0000D8, "Member 'UMovementPropertyMediator::_defaultStepDeclaration' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, _stepSpeedRateMin) == 0x0000DC, "Member 'UMovementPropertyMediator::_stepSpeedRateMin' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, _stepSpeedRateMax) == 0x0000E0, "Member 'UMovementPropertyMediator::_stepSpeedRateMax' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, OwnerCharacter) == 0x0000E8, "Member 'UMovementPropertyMediator::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, OwnerMovement) == 0x0000F0, "Member 'UMovementPropertyMediator::OwnerMovement' has a wrong offset!");

// Class BattlePrototype.MovementUtilityFunctions
// 0x0000 (0x0028 - 0x0028)
class UMovementUtilityFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void MoveAndSlideUpdatedComponent(class UMovementComponent* Target, const struct FVector& DesiredMovementThisFrame);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementUtilityFunctions">();
	}
	static class UMovementUtilityFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovementUtilityFunctions>();
	}
};
static_assert(alignof(UMovementUtilityFunctions) == 0x000008, "Wrong alignment on UMovementUtilityFunctions");
static_assert(sizeof(UMovementUtilityFunctions) == 0x000028, "Wrong size on UMovementUtilityFunctions");

// Class BattlePrototype.MultiLanguageTextData
// 0x0050 (0x0078 - 0x0028)
class UMultiLanguageTextData final : public UObject
{
public:
	TMap<ETextLanguage, class UTextData*>         TextDataMap;                                       // 0x0028(0x0050)(NativeAccessSpecifierPrivate)

public:
	class FString GetText(ETextLanguage LanguageID, class FName MessageID);
	bool LoadTexts();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiLanguageTextData">();
	}
	static class UMultiLanguageTextData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiLanguageTextData>();
	}
};
static_assert(alignof(UMultiLanguageTextData) == 0x000008, "Wrong alignment on UMultiLanguageTextData");
static_assert(sizeof(UMultiLanguageTextData) == 0x000078, "Wrong size on UMultiLanguageTextData");
static_assert(offsetof(UMultiLanguageTextData, TextDataMap) == 0x000028, "Member 'UMultiLanguageTextData::TextDataMap' has a wrong offset!");

// Class BattlePrototype.ResourceManager
// 0x01D0 (0x0400 - 0x0230)
class AResourceManager : public ARSActorSystemBase
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FNpcMergeMeshResource>     NpcMergeMesh;                                      // 0x0238(0x0050)(NativeAccessSpecifierPrivate)
	class UDataTable*                             MipPrestreamMeshDataTable;                         // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, int32>                      MipPrestreams;                                     // 0x0290(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class UTexture2D*>                     MipPrestreamTextures;                              // 0x02E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             NotExistsAssets;                                   // 0x0300(0x0050)(NativeAccessSpecifierPrivate)
	TSet<class FName>                             ExistsAssets;                                      // 0x0350(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<class UTexture2D*, int32>                ReleaseTransientTextures;                          // 0x03A0(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x10];                                     // 0x03F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddNotExistsList(class FName Name_0);
	void AddReleaseTransientTexture(class UTexture2D* Texture);
	bool CheckExists(class FName Name_0);
	bool CheckNotExists(class FName Name_0);
	void ClearNotExistsList();
	void DumpMipPrestream();
	void DumpNPCMergeMesh();
	int32 GetMipPrestreamLockMeshNum();
	int32 GetMipPrestreamMeshNum();
	int32 GetMipPrestreamTextureNum();
	void GetSnowCaptures(TArray<class ASnowCaptureBase*>* OutSnowCaptures);
	bool IsReadyAllMipPrestream();
	bool IsReadyMipPrestreamMesh(class FName MeshName);
	void LockMipPrestreamMesh(const TArray<class FName>& MeshNames);
	void ProtectedGetMipPrestreamPlayerMeshes(TArray<class USkeletalMesh*>* SkeletalMeshes, TArray<class UStaticMesh*>* StaticMeshes, EPlayerID PlayerId, bool bLoad);
	void ProtectedGetMipPrestreamPlayerSoftMeshes(TArray<TSoftObjectPtr<class USkeletalMesh>>* SkeletalMeshes, TArray<TSoftObjectPtr<class UObject>>* Attachment1Meshes, TArray<TSoftObjectPtr<class UMaterialInstance>>* Attachment1Materials, TArray<TSoftObjectPtr<class UObject>>* Attachment2Meshes, TArray<TSoftObjectPtr<class UMaterialInstance>>* Attachment2Materials, TArray<TSoftObjectPtr<class UObject>>* Attachment3Meshes, TArray<TSoftObjectPtr<class UMaterialInstance>>* Attachment3Materials, EPlayerID PlayerId);
	void ResetAllLockMipPrestreamMesh();
	void ResetAllMipPrestream();
	void ResetMipPrestreamEvent(const struct FResourceMipPrestreamEventTable& EventData, bool bForce);
	void ResetMipPrestreamMesh(class FName MeshName, bool bForce);
	void SetMipPrestreamEvent(const struct FResourceMipPrestreamEventTable& EventData, bool bLoad);
	void SetMipPrestreamMesh(class FName MeshName, bool bLoad, bool HighPriority);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResourceManager">();
	}
	static class AResourceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AResourceManager>();
	}
};
static_assert(alignof(AResourceManager) == 0x000008, "Wrong alignment on AResourceManager");
static_assert(sizeof(AResourceManager) == 0x000400, "Wrong size on AResourceManager");
static_assert(offsetof(AResourceManager, NpcMergeMesh) == 0x000238, "Member 'AResourceManager::NpcMergeMesh' has a wrong offset!");
static_assert(offsetof(AResourceManager, MipPrestreamMeshDataTable) == 0x000288, "Member 'AResourceManager::MipPrestreamMeshDataTable' has a wrong offset!");
static_assert(offsetof(AResourceManager, MipPrestreams) == 0x000290, "Member 'AResourceManager::MipPrestreams' has a wrong offset!");
static_assert(offsetof(AResourceManager, MipPrestreamTextures) == 0x0002E0, "Member 'AResourceManager::MipPrestreamTextures' has a wrong offset!");
static_assert(offsetof(AResourceManager, NotExistsAssets) == 0x000300, "Member 'AResourceManager::NotExistsAssets' has a wrong offset!");
static_assert(offsetof(AResourceManager, ExistsAssets) == 0x000350, "Member 'AResourceManager::ExistsAssets' has a wrong offset!");
static_assert(offsetof(AResourceManager, ReleaseTransientTextures) == 0x0003A0, "Member 'AResourceManager::ReleaseTransientTextures' has a wrong offset!");

// Class BattlePrototype.NormalCaptureComponent
// 0x0038 (0x00F8 - 0x00C0)
class UNormalCaptureComponent final : public UActorComponent
{
public:
	bool                                          bInitialize;                                       // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             TargetTexture;                                     // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x28];                                      // 0x00D0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinalizeTexture();
	class UTexture2D* GetTexture();
	void InitializeTexture(int32 TextureSizeW, int32 TextureSizeH);
	void WriteBoneData(int32 StartPixelX, int32 CharacterIndex, class USkeletalMeshComponent* SkeletalMeshComponent);
	void WriteBoneDataFromAnim(int32 StartPixelX, int32 CharacterIndex, class USkeletalMeshComponent* SkeletalMeshComponent, class UAnimSequence* AnimSequence, float AnimTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NormalCaptureComponent">();
	}
	static class UNormalCaptureComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNormalCaptureComponent>();
	}
};
static_assert(alignof(UNormalCaptureComponent) == 0x000008, "Wrong alignment on UNormalCaptureComponent");
static_assert(sizeof(UNormalCaptureComponent) == 0x0000F8, "Wrong size on UNormalCaptureComponent");
static_assert(offsetof(UNormalCaptureComponent, bInitialize) == 0x0000C0, "Member 'UNormalCaptureComponent::bInitialize' has a wrong offset!");
static_assert(offsetof(UNormalCaptureComponent, TargetTexture) == 0x0000C8, "Member 'UNormalCaptureComponent::TargetTexture' has a wrong offset!");

// Class BattlePrototype.RSActorComponentPsychicObjectBase
// 0x0000 (0x00C0 - 0x00C0)
class URSActorComponentPsychicObjectBase final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorComponentPsychicObjectBase">();
	}
	static class URSActorComponentPsychicObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSActorComponentPsychicObjectBase>();
	}
};
static_assert(alignof(URSActorComponentPsychicObjectBase) == 0x000008, "Wrong alignment on URSActorComponentPsychicObjectBase");
static_assert(sizeof(URSActorComponentPsychicObjectBase) == 0x0000C0, "Wrong size on URSActorComponentPsychicObjectBase");

// Class BattlePrototype.NpcTownPeople
// 0x00C0 (0x0460 - 0x03A0)
#pragma pack(push, 0x1)
class alignas(0x10) ANpcTownPeople : public ANpcTownPeopleBase
{
public:
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchTick;                                      // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   CurrentSubQuestId;                                 // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SubQuestIdList;                                    // 0x03C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleStartInSubQuest;                            // 0x03D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleAfterSubQuestCompleted;                     // 0x03D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuestProgressState                           SubQuestStatus;                                    // 0x03D2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D3[0x1];                                      // 0x03D3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsTalk;                                            // 0x03D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D5[0x3];                                      // 0x03D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class URSNpcAnimInstance*                     NpcABPNative;                                      // 0x03D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RipSyncAnimMontageNative;                          // 0x03E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BaseFacialAnimMontageNative;                       // 0x03E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          ShowBoxComponent;                                  // 0x03F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          EventBoxComponent;                                 // 0x03F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AMakeEventActor>            MakeEventActorClass;                               // 0x0400(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 MakeEventActorBPPath;                              // 0x0408(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMakeEventActor*                        MakeEventActor;                                    // 0x0418(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_420[0x8];                                      // 0x0420(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UChildActorComponent*                   ChildActionIcon;                                   // 0x0428(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ActionIconWorldPositionOffset;                     // 0x0430(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionIconType                               ActionIconType;                                    // 0x043C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionIconSubQuestState                      ActionIconSubQuestState;                           // 0x043D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_43E[0x1A];                                     // 0x043E(0x001A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdjustIconOffsetByHeadHeight();
	const EQuestProgressState GetSubQuestProgress(int32 SubQuestNumber);
	bool IsDefaultRipSyncType();
	bool IsTalkEnablePlayer();
	void OnEndEventActor(class AActor* DestroyedMakeEventActor);
	void OnStartEventActor();
	void StartRipSyncMontageNative();
	void StopRipSyncMontageNative();
	void TurnToPlayer(float Speed);
	void UnregisterTownPeopleAction();
	void UpdateRipSyncNative();
	void UpdateSubQuestActionIcon();
	void UpdateSubQuestId();
	void UpdateSubQuestStatus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcTownPeople">();
	}
	static class ANpcTownPeople* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcTownPeople>();
	}
};
#pragma pack(pop)
static_assert(alignof(ANpcTownPeople) == 0x000010, "Wrong alignment on ANpcTownPeople");
static_assert(sizeof(ANpcTownPeople) == 0x000460, "Wrong size on ANpcTownPeople");
static_assert(offsetof(ANpcTownPeople, DispatchTick) == 0x0003A8, "Member 'ANpcTownPeople::DispatchTick' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, CurrentSubQuestId) == 0x0003B8, "Member 'ANpcTownPeople::CurrentSubQuestId' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, SubQuestIdList) == 0x0003C0, "Member 'ANpcTownPeople::SubQuestIdList' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, VisibleStartInSubQuest) == 0x0003D0, "Member 'ANpcTownPeople::VisibleStartInSubQuest' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, VisibleAfterSubQuestCompleted) == 0x0003D1, "Member 'ANpcTownPeople::VisibleAfterSubQuestCompleted' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, SubQuestStatus) == 0x0003D2, "Member 'ANpcTownPeople::SubQuestStatus' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, IsTalk) == 0x0003D4, "Member 'ANpcTownPeople::IsTalk' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, NpcABPNative) == 0x0003D8, "Member 'ANpcTownPeople::NpcABPNative' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, RipSyncAnimMontageNative) == 0x0003E0, "Member 'ANpcTownPeople::RipSyncAnimMontageNative' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, BaseFacialAnimMontageNative) == 0x0003E8, "Member 'ANpcTownPeople::BaseFacialAnimMontageNative' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, ShowBoxComponent) == 0x0003F0, "Member 'ANpcTownPeople::ShowBoxComponent' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, EventBoxComponent) == 0x0003F8, "Member 'ANpcTownPeople::EventBoxComponent' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, MakeEventActorClass) == 0x000400, "Member 'ANpcTownPeople::MakeEventActorClass' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, MakeEventActorBPPath) == 0x000408, "Member 'ANpcTownPeople::MakeEventActorBPPath' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, MakeEventActor) == 0x000418, "Member 'ANpcTownPeople::MakeEventActor' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, ChildActionIcon) == 0x000428, "Member 'ANpcTownPeople::ChildActionIcon' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, ActionIconWorldPositionOffset) == 0x000430, "Member 'ANpcTownPeople::ActionIconWorldPositionOffset' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, ActionIconType) == 0x00043C, "Member 'ANpcTownPeople::ActionIconType' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, ActionIconSubQuestState) == 0x00043D, "Member 'ANpcTownPeople::ActionIconSubQuestState' has a wrong offset!");

// Class BattlePrototype.RSAtomCuePlayNotifyStateBase
// 0x0008 (0x0038 - 0x0030)
class URSAtomCuePlayNotifyStateBase : public UAnimNotifyState
{
public:
	class USoundAtomCue*                          M_pSound;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnSetEditorSound(class USoundAtomCue* Sound) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAtomCuePlayNotifyStateBase">();
	}
	static class URSAtomCuePlayNotifyStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAtomCuePlayNotifyStateBase>();
	}
};
static_assert(alignof(URSAtomCuePlayNotifyStateBase) == 0x000008, "Wrong alignment on URSAtomCuePlayNotifyStateBase");
static_assert(sizeof(URSAtomCuePlayNotifyStateBase) == 0x000038, "Wrong size on URSAtomCuePlayNotifyStateBase");
static_assert(offsetof(URSAtomCuePlayNotifyStateBase, M_pSound) == 0x000030, "Member 'URSAtomCuePlayNotifyStateBase::M_pSound' has a wrong offset!");

// Class BattlePrototype.NpcAjitoPeople
// 0x0000 (0x0460 - 0x0460)
class ANpcAjitoPeople : public ANpcTownPeople
{
public:
	int32                                         PlaceID;                                           // 0x0458(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45C[0x4];                                      // 0x045C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcAjitoPeople">();
	}
	static class ANpcAjitoPeople* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcAjitoPeople>();
	}
};
static_assert(alignof(ANpcAjitoPeople) == 0x000010, "Wrong alignment on ANpcAjitoPeople");
static_assert(sizeof(ANpcAjitoPeople) == 0x000460, "Wrong size on ANpcAjitoPeople");
static_assert(offsetof(ANpcAjitoPeople, PlaceID) == 0x000458, "Member 'ANpcAjitoPeople::PlaceID' has a wrong offset!");

// Class BattlePrototype.NpcBase
// 0x0060 (0x0290 - 0x0230)
class ANpcBase : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NpcMeshDataTableID;                                // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NpcMaterialDataTableID;                            // 0x023C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      CharacterCapsuleComponent;                         // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNpcSkeletalMeshComponent*              SkeletalMeshComponent;                             // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalBody;                                      // 0x0258(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalBodyLower;                                 // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalFace;                                      // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalHair;                                      // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USkeletalMeshComponent*>         SkeletalParts;                                     // 0x0278(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          EventBoxComponent;                                 // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void RefreshMesh();
	void SetLightChannnel(bool Channel0, bool Channel1, bool Channel2);
	void SetRenderLayer(uint8 NewRenderLayer);
	void SetScalarParameterValue(class FName ParameterName, float ParameterValue);
	void SetVectorParameterValue(class FName ParameterName, const struct FVector& ParameterValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcBase">();
	}
	static class ANpcBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcBase>();
	}
};
static_assert(alignof(ANpcBase) == 0x000008, "Wrong alignment on ANpcBase");
static_assert(sizeof(ANpcBase) == 0x000290, "Wrong size on ANpcBase");
static_assert(offsetof(ANpcBase, NpcMeshDataTableID) == 0x000238, "Member 'ANpcBase::NpcMeshDataTableID' has a wrong offset!");
static_assert(offsetof(ANpcBase, NpcMaterialDataTableID) == 0x00023C, "Member 'ANpcBase::NpcMaterialDataTableID' has a wrong offset!");
static_assert(offsetof(ANpcBase, CharacterCapsuleComponent) == 0x000248, "Member 'ANpcBase::CharacterCapsuleComponent' has a wrong offset!");
static_assert(offsetof(ANpcBase, SkeletalMeshComponent) == 0x000250, "Member 'ANpcBase::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ANpcBase, SkeletalBody) == 0x000258, "Member 'ANpcBase::SkeletalBody' has a wrong offset!");
static_assert(offsetof(ANpcBase, SkeletalBodyLower) == 0x000260, "Member 'ANpcBase::SkeletalBodyLower' has a wrong offset!");
static_assert(offsetof(ANpcBase, SkeletalFace) == 0x000268, "Member 'ANpcBase::SkeletalFace' has a wrong offset!");
static_assert(offsetof(ANpcBase, SkeletalHair) == 0x000270, "Member 'ANpcBase::SkeletalHair' has a wrong offset!");
static_assert(offsetof(ANpcBase, SkeletalParts) == 0x000278, "Member 'ANpcBase::SkeletalParts' has a wrong offset!");
static_assert(offsetof(ANpcBase, EventBoxComponent) == 0x000288, "Member 'ANpcBase::EventBoxComponent' has a wrong offset!");

// Class BattlePrototype.NpcHomingMoveComponent
// 0x00C0 (0x02C0 - 0x0200)
class UNpcHomingMoveComponent final : public USceneComponent
{
public:
	class USplineComponent*                       SplinePath;                                        // 0x0200(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UShapeComponent*                        TargetShape;                                       // 0x0208(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetPosition;                                    // 0x0210(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotOnTargetSpline;                                 // 0x021C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TargetEndPosition;                                 // 0x0228(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CurRot;                                            // 0x0234(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               PrevRot;                                           // 0x0240(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CurMoveSpeed;                                      // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurRotSpeed;                                       // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMoveSpeed;                                   // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRot;                                         // 0x0258(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TargetMoveVec;                                     // 0x0264(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalDistance;                                     // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathTotalDistance;                                 // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMoving;                                          // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTargetMoving;                                    // 0x0279(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A[0x2];                                      // 0x027A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundOffsetZ;                                     // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundTestDiff;                                    // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpTestDiff;                                        // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpTestForwardDistance;                             // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownTestForwardDistance;                           // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetStopDistance;                                // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDebug;                                           // 0x0294(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnSplineMove;                                    // 0x0295(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_296[0x2];                                      // 0x0296(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SplineMoveForwardDistance;                         // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineMoveUpDownSpeedMax;                          // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedSeconds;                                    // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFadingAsMovemet;                                 // 0x02A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A5[0x3];                                      // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TracingSpeherRadius;                               // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeCheckDistFront;                               // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeCheckDistRear;                                // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadingInterpolateSeconds;                          // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceMove(float DistanceRate);
	void ResetNpcTransform();
	void SetElapsedTime(float Time);
	void SetSpline(class USplineComponent* Spline);
	void SetTargetPosition(const struct FVector& Target);
	void StartMove();
	void StopMove();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcHomingMoveComponent">();
	}
	static class UNpcHomingMoveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNpcHomingMoveComponent>();
	}
};
static_assert(alignof(UNpcHomingMoveComponent) == 0x000010, "Wrong alignment on UNpcHomingMoveComponent");
static_assert(sizeof(UNpcHomingMoveComponent) == 0x0002C0, "Wrong size on UNpcHomingMoveComponent");
static_assert(offsetof(UNpcHomingMoveComponent, SplinePath) == 0x000200, "Member 'UNpcHomingMoveComponent::SplinePath' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, TargetShape) == 0x000208, "Member 'UNpcHomingMoveComponent::TargetShape' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, TargetPosition) == 0x000210, "Member 'UNpcHomingMoveComponent::TargetPosition' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, RotOnTargetSpline) == 0x00021C, "Member 'UNpcHomingMoveComponent::RotOnTargetSpline' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, TargetEndPosition) == 0x000228, "Member 'UNpcHomingMoveComponent::TargetEndPosition' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, CurRot) == 0x000234, "Member 'UNpcHomingMoveComponent::CurRot' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, PrevRot) == 0x000240, "Member 'UNpcHomingMoveComponent::PrevRot' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, CurMoveSpeed) == 0x00024C, "Member 'UNpcHomingMoveComponent::CurMoveSpeed' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, CurRotSpeed) == 0x000250, "Member 'UNpcHomingMoveComponent::CurRotSpeed' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, TargetMoveSpeed) == 0x000254, "Member 'UNpcHomingMoveComponent::TargetMoveSpeed' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, TargetRot) == 0x000258, "Member 'UNpcHomingMoveComponent::TargetRot' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, TargetMoveVec) == 0x000264, "Member 'UNpcHomingMoveComponent::TargetMoveVec' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, LocalDistance) == 0x000270, "Member 'UNpcHomingMoveComponent::LocalDistance' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, PathTotalDistance) == 0x000274, "Member 'UNpcHomingMoveComponent::PathTotalDistance' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, IsMoving) == 0x000278, "Member 'UNpcHomingMoveComponent::IsMoving' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, IsTargetMoving) == 0x000279, "Member 'UNpcHomingMoveComponent::IsTargetMoving' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, GroundOffsetZ) == 0x00027C, "Member 'UNpcHomingMoveComponent::GroundOffsetZ' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, GroundTestDiff) == 0x000280, "Member 'UNpcHomingMoveComponent::GroundTestDiff' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, UpTestDiff) == 0x000284, "Member 'UNpcHomingMoveComponent::UpTestDiff' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, UpTestForwardDistance) == 0x000288, "Member 'UNpcHomingMoveComponent::UpTestForwardDistance' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, DownTestForwardDistance) == 0x00028C, "Member 'UNpcHomingMoveComponent::DownTestForwardDistance' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, TargetStopDistance) == 0x000290, "Member 'UNpcHomingMoveComponent::TargetStopDistance' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, IsDebug) == 0x000294, "Member 'UNpcHomingMoveComponent::IsDebug' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, IsOnSplineMove) == 0x000295, "Member 'UNpcHomingMoveComponent::IsOnSplineMove' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, SplineMoveForwardDistance) == 0x000298, "Member 'UNpcHomingMoveComponent::SplineMoveForwardDistance' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, SplineMoveUpDownSpeedMax) == 0x00029C, "Member 'UNpcHomingMoveComponent::SplineMoveUpDownSpeedMax' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, ElapsedSeconds) == 0x0002A0, "Member 'UNpcHomingMoveComponent::ElapsedSeconds' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, IsFadingAsMovemet) == 0x0002A4, "Member 'UNpcHomingMoveComponent::IsFadingAsMovemet' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, TracingSpeherRadius) == 0x0002A8, "Member 'UNpcHomingMoveComponent::TracingSpeherRadius' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, SlopeCheckDistFront) == 0x0002AC, "Member 'UNpcHomingMoveComponent::SlopeCheckDistFront' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, SlopeCheckDistRear) == 0x0002B0, "Member 'UNpcHomingMoveComponent::SlopeCheckDistRear' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, FadingInterpolateSeconds) == 0x0002B4, "Member 'UNpcHomingMoveComponent::FadingInterpolateSeconds' has a wrong offset!");

// Class BattlePrototype.RSActorComponentPlayerBase
// 0x0000 (0x00C0 - 0x00C0)
class URSActorComponentPlayerBase final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorComponentPlayerBase">();
	}
	static class URSActorComponentPlayerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSActorComponentPlayerBase>();
	}
};
static_assert(alignof(URSActorComponentPlayerBase) == 0x000008, "Wrong alignment on URSActorComponentPlayerBase");
static_assert(sizeof(URSActorComponentPlayerBase) == 0x0000C0, "Wrong size on URSActorComponentPlayerBase");

// Class BattlePrototype.NpcManager
// 0x0048 (0x0070 - 0x0028)
class UNpcManager final : public UObject
{
public:
	TArray<class ANpcBase*>                       Npcs;                                              // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ANpcTownPeopleBase*>             NpcTowns;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ASavePointBase*>                 SavePoints;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ANpcShopBase*>                   ShopNpcs;                                          // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATownPeopleManager*                     TownPeopleTickManager;                             // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Initialize(const class UObject* WorldContextObject);
	void OnBattleModeChange(class URSGameInstance* GameInstance, const bool bBattle);
	void RegisterNpc(class ANpcBase* NPC);
	void RegisterNpcTown(class ANpcTownPeopleBase* NPC);
	void RegisterSavePoint(class ASavePointBase* SavePoint);
	void RegisterShopNpc(class ANpcShopBase* ShopNpc);
	void SetVisibleAndTickNpcTopwnAll(bool bVisible);
	void UnregisterNpc(class ANpcBase* NPC);
	void UnregisterNpcAll();
	void UnregisterNpcTown(class ANpcTownPeopleBase* NPC);
	void UnregisterNpcTownAll();
	void UnregisterSavePoint(class ASavePointBase* SavePoint);
	void UnregisterSavePointAll();
	void UnregisterShopNpc(class ANpcShopBase* ShopNpc);
	void UnregisterShopNpcAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcManager">();
	}
	static class UNpcManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNpcManager>();
	}
};
static_assert(alignof(UNpcManager) == 0x000008, "Wrong alignment on UNpcManager");
static_assert(sizeof(UNpcManager) == 0x000070, "Wrong size on UNpcManager");
static_assert(offsetof(UNpcManager, Npcs) == 0x000028, "Member 'UNpcManager::Npcs' has a wrong offset!");
static_assert(offsetof(UNpcManager, NpcTowns) == 0x000038, "Member 'UNpcManager::NpcTowns' has a wrong offset!");
static_assert(offsetof(UNpcManager, SavePoints) == 0x000048, "Member 'UNpcManager::SavePoints' has a wrong offset!");
static_assert(offsetof(UNpcManager, ShopNpcs) == 0x000058, "Member 'UNpcManager::ShopNpcs' has a wrong offset!");
static_assert(offsetof(UNpcManager, TownPeopleTickManager) == 0x000068, "Member 'UNpcManager::TownPeopleTickManager' has a wrong offset!");

// Class BattlePrototype.NpcShopBase
// 0x0098 (0x02C8 - 0x0230)
class ANpcShopBase : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          ShowBoxComponent;                                  // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      CollisionCapsuleComponent;                         // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          EventBoxComponent;                                 // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AMakeEventActor>            MakeEventActorClass;                               // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMakeEventActor*                        MakeEventActor;                                    // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   ChildActionIcon;                                   // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActionIconWorldPositionOffset;                     // 0x0270(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionIconType                               ActionIconType;                                    // 0x027C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D[0x3];                                      // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUIMapIconAdjust                       MapIconAdjust;                                     // 0x0280(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASavePointBase*                         PairActor;                                         // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShopParam;                                         // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TradeParam;                                        // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFitGround;                                       // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0xF];                                      // 0x02B9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UChildActorComponent* GetChildActionIcon();
	void RegisterPairActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcShopBase">();
	}
	static class ANpcShopBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcShopBase>();
	}
};
static_assert(alignof(ANpcShopBase) == 0x000008, "Wrong alignment on ANpcShopBase");
static_assert(sizeof(ANpcShopBase) == 0x0002C8, "Wrong size on ANpcShopBase");
static_assert(offsetof(ANpcShopBase, StaticMeshComponent) == 0x000238, "Member 'ANpcShopBase::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, ShowBoxComponent) == 0x000240, "Member 'ANpcShopBase::ShowBoxComponent' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, CollisionCapsuleComponent) == 0x000248, "Member 'ANpcShopBase::CollisionCapsuleComponent' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, EventBoxComponent) == 0x000250, "Member 'ANpcShopBase::EventBoxComponent' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, MakeEventActorClass) == 0x000258, "Member 'ANpcShopBase::MakeEventActorClass' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, MakeEventActor) == 0x000260, "Member 'ANpcShopBase::MakeEventActor' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, ChildActionIcon) == 0x000268, "Member 'ANpcShopBase::ChildActionIcon' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, ActionIconWorldPositionOffset) == 0x000270, "Member 'ANpcShopBase::ActionIconWorldPositionOffset' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, ActionIconType) == 0x00027C, "Member 'ANpcShopBase::ActionIconType' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, MapIconAdjust) == 0x000280, "Member 'ANpcShopBase::MapIconAdjust' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, PairActor) == 0x0002A8, "Member 'ANpcShopBase::PairActor' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, ShopParam) == 0x0002B0, "Member 'ANpcShopBase::ShopParam' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, TradeParam) == 0x0002B4, "Member 'ANpcShopBase::TradeParam' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, IsFitGround) == 0x0002B8, "Member 'ANpcShopBase::IsFitGround' has a wrong offset!");

// Class BattlePrototype.RSCapsuleComponent
// 0x0000 (0x0430 - 0x0430)
class URSCapsuleComponent final : public UCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCapsuleComponent">();
	}
	static class URSCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSCapsuleComponent>();
	}
};
static_assert(alignof(URSCapsuleComponent) == 0x000010, "Wrong alignment on URSCapsuleComponent");
static_assert(sizeof(URSCapsuleComponent) == 0x000430, "Wrong size on URSCapsuleComponent");

// Class BattlePrototype.NpcTalker
// 0x0058 (0x02E8 - 0x0290)
class ANpcTalker final : public ANpcBase
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_messageTableName;                                // 0x0298(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          ShowBoxComponent;                                  // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UREDLuaScriptComponent*                 M_pLuaScriptComponent;                             // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AMakeEventActor>            M_MakeEventActorClass;                             // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMakeEventActor*                        M_makeEventActor;                                  // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UChildActorComponent*                   M_pChildActionIcon;                                // 0x02D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_actionIconWorldPositionOffset;                   // 0x02D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionIconType                               M_actionIconType;                                  // 0x02E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionIconSubQuestState                      M_actionIconSubQuestState;                         // 0x02E5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E6[0x2];                                      // 0x02E6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMessageTableName(const class FString& TableName);

	class FString GetMessageTableName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcTalker">();
	}
	static class ANpcTalker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcTalker>();
	}
};
static_assert(alignof(ANpcTalker) == 0x000008, "Wrong alignment on ANpcTalker");
static_assert(sizeof(ANpcTalker) == 0x0002E8, "Wrong size on ANpcTalker");
static_assert(offsetof(ANpcTalker, M_messageTableName) == 0x000298, "Member 'ANpcTalker::M_messageTableName' has a wrong offset!");
static_assert(offsetof(ANpcTalker, ShowBoxComponent) == 0x0002A8, "Member 'ANpcTalker::ShowBoxComponent' has a wrong offset!");
static_assert(offsetof(ANpcTalker, M_pLuaScriptComponent) == 0x0002B0, "Member 'ANpcTalker::M_pLuaScriptComponent' has a wrong offset!");
static_assert(offsetof(ANpcTalker, M_MakeEventActorClass) == 0x0002B8, "Member 'ANpcTalker::M_MakeEventActorClass' has a wrong offset!");
static_assert(offsetof(ANpcTalker, M_makeEventActor) == 0x0002C0, "Member 'ANpcTalker::M_makeEventActor' has a wrong offset!");
static_assert(offsetof(ANpcTalker, M_pChildActionIcon) == 0x0002D0, "Member 'ANpcTalker::M_pChildActionIcon' has a wrong offset!");
static_assert(offsetof(ANpcTalker, M_actionIconWorldPositionOffset) == 0x0002D8, "Member 'ANpcTalker::M_actionIconWorldPositionOffset' has a wrong offset!");
static_assert(offsetof(ANpcTalker, M_actionIconType) == 0x0002E4, "Member 'ANpcTalker::M_actionIconType' has a wrong offset!");
static_assert(offsetof(ANpcTalker, M_actionIconSubQuestState) == 0x0002E5, "Member 'ANpcTalker::M_actionIconSubQuestState' has a wrong offset!");

// Class BattlePrototype.NpcTownPeopleCrowd
// 0x0060 (0x0400 - 0x03A0)
class ANpcTownPeopleCrowd : public ANpcTownPeopleBase
{
public:
	class UFixPoseActorComponent*                 FixPoseActorComponent;                             // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNpcHomingMoveComponent*                NpcHomingMoveComponent;                            // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       SplineMovePath;                                    // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurMoveVec;                                        // 0x03B8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x03C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CurMoveRot;                                        // 0x03C8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RotSpeed;                                          // 0x03D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowAnimationDistance;                              // 0x03D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCollisionOffByDistance;                          // 0x03DC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DD[0x3];                                      // 0x03DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NoCollisionDistance;                               // 0x03E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowAnimationTickValue;                             // 0x03E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraNearDistance;                                // 0x03E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedTransparent;                                   // 0x03EC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3ED[0x3];                                      // 0x03ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransparentRate;                                   // 0x03F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransparentSpeed;                                  // 0x03F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerNearDistance;                                // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFadingAsMovement;                                // 0x03FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FD[0x3];                                      // 0x03FD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSpline(class USplineComponent* Spline);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcTownPeopleCrowd">();
	}
	static class ANpcTownPeopleCrowd* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcTownPeopleCrowd>();
	}
};
static_assert(alignof(ANpcTownPeopleCrowd) == 0x000010, "Wrong alignment on ANpcTownPeopleCrowd");
static_assert(sizeof(ANpcTownPeopleCrowd) == 0x000400, "Wrong size on ANpcTownPeopleCrowd");
static_assert(offsetof(ANpcTownPeopleCrowd, FixPoseActorComponent) == 0x0003A0, "Member 'ANpcTownPeopleCrowd::FixPoseActorComponent' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, NpcHomingMoveComponent) == 0x0003A8, "Member 'ANpcTownPeopleCrowd::NpcHomingMoveComponent' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, SplineMovePath) == 0x0003B0, "Member 'ANpcTownPeopleCrowd::SplineMovePath' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, CurMoveVec) == 0x0003B8, "Member 'ANpcTownPeopleCrowd::CurMoveVec' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, MoveSpeed) == 0x0003C4, "Member 'ANpcTownPeopleCrowd::MoveSpeed' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, CurMoveRot) == 0x0003C8, "Member 'ANpcTownPeopleCrowd::CurMoveRot' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, RotSpeed) == 0x0003D4, "Member 'ANpcTownPeopleCrowd::RotSpeed' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, LowAnimationDistance) == 0x0003D8, "Member 'ANpcTownPeopleCrowd::LowAnimationDistance' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, IsCollisionOffByDistance) == 0x0003DC, "Member 'ANpcTownPeopleCrowd::IsCollisionOffByDistance' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, NoCollisionDistance) == 0x0003E0, "Member 'ANpcTownPeopleCrowd::NoCollisionDistance' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, LowAnimationTickValue) == 0x0003E4, "Member 'ANpcTownPeopleCrowd::LowAnimationTickValue' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, CameraNearDistance) == 0x0003E8, "Member 'ANpcTownPeopleCrowd::CameraNearDistance' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, NeedTransparent) == 0x0003EC, "Member 'ANpcTownPeopleCrowd::NeedTransparent' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, TransparentRate) == 0x0003F0, "Member 'ANpcTownPeopleCrowd::TransparentRate' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, TransparentSpeed) == 0x0003F4, "Member 'ANpcTownPeopleCrowd::TransparentSpeed' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, PlayerNearDistance) == 0x0003F8, "Member 'ANpcTownPeopleCrowd::PlayerNearDistance' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, IsFadingAsMovement) == 0x0003FC, "Member 'ANpcTownPeopleCrowd::IsFadingAsMovement' has a wrong offset!");

// Class BattlePrototype.OnlineTestCreateSession
// 0x0078 (0x00A8 - 0x0030)
class UOnlineTestCreateSession final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x58];                                      // 0x0050(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOnlineTestCreateSession* OnlineTestCreateSession(class UObject* WorldContextObject, class APlayerController* PlayerController, int32 PubblicConections, bool UseLAN, const class FString& LevelName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineTestCreateSession">();
	}
	static class UOnlineTestCreateSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineTestCreateSession>();
	}
};
static_assert(alignof(UOnlineTestCreateSession) == 0x000008, "Wrong alignment on UOnlineTestCreateSession");
static_assert(sizeof(UOnlineTestCreateSession) == 0x0000A8, "Wrong size on UOnlineTestCreateSession");
static_assert(offsetof(UOnlineTestCreateSession, OnSuccess) == 0x000030, "Member 'UOnlineTestCreateSession::OnSuccess' has a wrong offset!");
static_assert(offsetof(UOnlineTestCreateSession, OnFailure) == 0x000040, "Member 'UOnlineTestCreateSession::OnFailure' has a wrong offset!");

// Class BattlePrototype.OnlineTestFindSessions
// 0x0060 (0x0090 - 0x0030)
class UOnlineTestFindSessions final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x40];                                      // 0x0050(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOnlineTestFindSessions* OnlineTestFindSessions(class UObject* WorldContextObject, class APlayerController* PlayerController, int32 MaxResults, bool bIsLAN);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineTestFindSessions">();
	}
	static class UOnlineTestFindSessions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineTestFindSessions>();
	}
};
static_assert(alignof(UOnlineTestFindSessions) == 0x000008, "Wrong alignment on UOnlineTestFindSessions");
static_assert(sizeof(UOnlineTestFindSessions) == 0x000090, "Wrong size on UOnlineTestFindSessions");
static_assert(offsetof(UOnlineTestFindSessions, OnSuccess) == 0x000030, "Member 'UOnlineTestFindSessions::OnSuccess' has a wrong offset!");
static_assert(offsetof(UOnlineTestFindSessions, OnFailure) == 0x000040, "Member 'UOnlineTestFindSessions::OnFailure' has a wrong offset!");

// Class BattlePrototype.OnlineTestGameSession
// 0x0110 (0x0358 - 0x0248)
class AOnlineTestGameSession final : public AGameSession
{
public:
	uint8                                         Pad_248[0x110];                                    // 0x0248(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineTestGameSession">();
	}
	static class AOnlineTestGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOnlineTestGameSession>();
	}
};
static_assert(alignof(AOnlineTestGameSession) == 0x000008, "Wrong alignment on AOnlineTestGameSession");
static_assert(sizeof(AOnlineTestGameSession) == 0x000358, "Wrong size on AOnlineTestGameSession");

// Class BattlePrototype.RSBootManager
// 0x0060 (0x0290 - 0x0230)
class ARSBootManager final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             M_OnEventSaveLoadError;                            // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x9];                                      // 0x0248(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	EBootLevelFlow                                M_BootFlow;                                        // 0x0251(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_252[0x6];                                      // 0x0252(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSHUDBase*                             M_pRSHudBase;                                      // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URSSaveGame*                            M_pSaveGameSystem;                                 // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserParamManager*                      UserParamManager;                                  // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDatabaseManager*                       DatabaseManager;                                   // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pSaveLoadSystemParamManager;                     // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EBootLevelFlow GetBootFlow();
	bool IsCheckStorageSpace();
	bool IsExistSaveData();
	void SetBootFlow(EBootLevelFlow Flow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSBootManager">();
	}
	static class ARSBootManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSBootManager>();
	}
};
static_assert(alignof(ARSBootManager) == 0x000008, "Wrong alignment on ARSBootManager");
static_assert(sizeof(ARSBootManager) == 0x000290, "Wrong size on ARSBootManager");
static_assert(offsetof(ARSBootManager, M_OnEventSaveLoadError) == 0x000238, "Member 'ARSBootManager::M_OnEventSaveLoadError' has a wrong offset!");
static_assert(offsetof(ARSBootManager, M_BootFlow) == 0x000251, "Member 'ARSBootManager::M_BootFlow' has a wrong offset!");
static_assert(offsetof(ARSBootManager, M_pRSHudBase) == 0x000258, "Member 'ARSBootManager::M_pRSHudBase' has a wrong offset!");
static_assert(offsetof(ARSBootManager, M_pSaveGameSystem) == 0x000260, "Member 'ARSBootManager::M_pSaveGameSystem' has a wrong offset!");
static_assert(offsetof(ARSBootManager, UserParamManager) == 0x000268, "Member 'ARSBootManager::UserParamManager' has a wrong offset!");
static_assert(offsetof(ARSBootManager, DatabaseManager) == 0x000270, "Member 'ARSBootManager::DatabaseManager' has a wrong offset!");
static_assert(offsetof(ARSBootManager, M_pSaveLoadSystemParamManager) == 0x000278, "Member 'ARSBootManager::M_pSaveLoadSystemParamManager' has a wrong offset!");

// Class BattlePrototype.OptimizeSwitchMaterialComponent
// 0x01D0 (0x0290 - 0x00C0)
class UOptimizeSwitchMaterialComponent : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x98];                                      // 0x00C0(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOptimizeMaterialSettingMesh>   MeshBaseSettings;                                  // 0x0158(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0x110];                                    // 0x0168(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOptimizeMaterialSetting>       Settings;                                          // 0x0278(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRuntime;                                        // 0x0288(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddMesh(class UMeshComponent* InTargetMesh);
	int32 AddSwitchSetting2(const TArray<struct FOptimizeMaterialMultiCondition>& MultiConditions, const TMap<class FString, struct FOptimizeMaterialOverrideSetting>& SlotMaterials, const struct FOptimizeMaterialOverrideSetting& OtherSlotMaterial);
	void ChangeMeshLayer(class UMeshComponent* InTargetMesh, int32 MeshLayerID);
	int32 CheckNowParameters();
	int32 CheckScalarArrayParameter(const TArray<class FName>& ParameterName, const TArray<float>& ParameterValue);
	int32 CheckScalarParameter(class FName ParameterName, float ParameterValue);
	void Reset();
	void RevertBaseMaterial();
	void SetMesh(class UMeshComponent* InTargetMesh);
	void SetSwitchActivate(bool Active);

	bool IsSwitchActivate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimizeSwitchMaterialComponent">();
	}
	static class UOptimizeSwitchMaterialComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimizeSwitchMaterialComponent>();
	}
};
static_assert(alignof(UOptimizeSwitchMaterialComponent) == 0x000008, "Wrong alignment on UOptimizeSwitchMaterialComponent");
static_assert(sizeof(UOptimizeSwitchMaterialComponent) == 0x000290, "Wrong size on UOptimizeSwitchMaterialComponent");
static_assert(offsetof(UOptimizeSwitchMaterialComponent, MeshBaseSettings) == 0x000158, "Member 'UOptimizeSwitchMaterialComponent::MeshBaseSettings' has a wrong offset!");
static_assert(offsetof(UOptimizeSwitchMaterialComponent, Settings) == 0x000278, "Member 'UOptimizeSwitchMaterialComponent::Settings' has a wrong offset!");
static_assert(offsetof(UOptimizeSwitchMaterialComponent, bIsRuntime) == 0x000288, "Member 'UOptimizeSwitchMaterialComponent::bIsRuntime' has a wrong offset!");

// Class BattlePrototype.RSCheckCollision
// 0x0000 (0x0028 - 0x0028)
class URSCheckCollision final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckCollisionBoxVsBoxByComponent(class UBoxComponent* Box0, class UBoxComponent* box1);
	static bool CheckCollisionBoxVsCapsuleByComponent(class UBoxComponent* Box0, class UCapsuleComponent* Capsule0);
	static bool CheckCollisionCapsule(struct FRSResultCapsule* Result, const struct FVector& StartLocation0, const struct FVector& EndLocation0, float Radius0, const struct FVector& StartLocation1, const struct FVector& EndLocation1, float Radius1);
	static bool CheckCollisionCapsuleByComponent(struct FRSResultCapsule* Result, class UCapsuleComponent* Capsule0, class UCapsuleComponent* Capsule1);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCheckCollision">();
	}
	static class URSCheckCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSCheckCollision>();
	}
};
static_assert(alignof(URSCheckCollision) == 0x000008, "Wrong alignment on URSCheckCollision");
static_assert(sizeof(URSCheckCollision) == 0x000028, "Wrong size on URSCheckCollision");

// Class BattlePrototype.OptionParam
// 0x00E8 (0x0110 - 0x0028)
class UOptionParam final : public UObject
{
public:
	uint8                                         Pad_28[0xE8];                                      // 0x0028(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitData(class URSGameInstance* GameInst);
	bool ReflectControllerParam();
	void ReflectParamAll();
	void ReflectParamAllConfig();
	void ReflectParamAllGraphic();
	void ReflectParamImmediate();
	void SetAntiAliasingQuality(const EOptionAAQuality& AntiAliasingQuality);
	void SetAntiAliasingQualityImmediate(const EOptionAAQuality& AntiAliasingQuality);
	void SetAttackAutoLockOn(EAttackAutoLockOn Type);
	void SetAttackAutoLockOnImmediate(EAttackAutoLockOn Type);
	void SetBGMVolume(uint8 Volume);
	void SetCameraAfterMoveType(ECameraAfterMoveType Type);
	void SetCameraAfterMoveTypeImmediate(ECameraAfterMoveType Type);
	void SetCameraPitch(EOptionCameraPitch Type);
	void SetCameraSpeed(uint8 SpeedType);
	void SetCameraYaw(EOptionCameraYaw Type);
	void SetControllerParamValue(EChangeableControllerKey TargetKey, ERSGamepadInputName NewKey);
	void SetControllerVibration(EOptionControllerVibration Type);
	void SetDefaultAll(bool IsConstruct, bool SetUeDefault);
	void SetDefaultAllConfig();
	void SetDefaultAllController();
	void SetDefaultAllGraphic(bool IsConstruct, bool SetUeDefault);
	void SetDifficulty(EHCGameDifficulty Type);
	void SetDisplayEnemyDamage(EOptionDisplayEnemyDamage Type);
	void SetDisplayLanguage(ETextLanguage Type);
	void SetDisplayLanguageImmediate(ETextLanguage Type);
	void SetEventMessageAutoPlay(EEventMessageAutoPlay Type);
	void SetEventMessageAutoPlayImmediate(EEventMessageAutoPlay Type);
	void SetFPSType(const EFPSType& FpsType);
	void SetFPSTypeImmediate(const EFPSType FpsType);
	void SetLockonActionType(ELockonActionType Type);
	void SetLockonActionTypeImmediate(ELockonActionType Type);
	void SetMinimapDisplay(EOptionMinimapDisplay Type);
	void SetMinimapRotation(EOptionMinimapRotation Type);
	void SetMinimapScaling(EOptionMinimapScaling Type);
	void SetOldScreenResolution(const struct FScreenResolutionSetting& ScreenResolution);
	void SetPostQuality(const EGradualQuality& PostQuality);
	void SetPostQualityImmediate(const EGradualQuality& PostQuality, bool IsApply);
	void SetScreenBrightness(float Param);
	void SetScreenResolution(const struct FScreenResolutionSetting& ScreenResolution);
	void SetScreenResolutionFromUserSettings();
	void SetScreenResolutionImmediate(const struct FScreenResolutionSetting& ScreenResolution, bool IsApply);
	void SetSeVolume(uint8 Volume);
	void SetShadowQuality(const EGradualQuality& ShadowQuality);
	void SetShadowQualityImmediate(const EGradualQuality& ShadowQuality, bool IsApply);
	void SetSoundOutput(EOptionSoundOutput Type);
	void SetTargetAutoChange(ETargetAutoChange Type);
	void SetTargetAutoChangeImmediate(ETargetAutoChange Type);
	void SetTargetCameraTrace(ETargetCameraTrace Type);
	void SetTargetCameraTraceImmediate(ETargetCameraTrace Type);
	void SetTextureQuality(const EGradualQuality& TextureQuality);
	void SetTextureQualityImmediate(const EGradualQuality& TextureAuality, bool IsApply);
	void SetUseBrainCrash(bool SetValue);
	void SetUseVerticalSync(bool UseVert);
	void SetUseVerticalSyncImmediate(bool UseVert, bool IsApply);
	void SetVoiceLanguage(ETextLanguage Type);
	void SetVoiceVolume(uint8 Volume);
	void SetWindowMode(const EWindowMode& WindowMode);
	void SetWindowModeImmediate(const EWindowMode& WindowMode, bool IsApply);

	EOptionAAQuality GetAntiAliasingQuality() const;
	EAttackAutoLockOn GetAttackAutoLockOn() const;
	uint8 GetBgmVolume() const;
	ECameraAfterMoveType GetCameraAfterMoveType() const;
	EOptionCameraPitch GetCameraPitch() const;
	uint8 GetCameraSpeed() const;
	EOptionCameraYaw GetCameraYaw() const;
	ERSGamepadInputName GetControllerDefaultKey(EChangeableControllerKey TargetKey) const;
	ERSGamepadInputName GetControllerParamValue(EChangeableControllerKey TargetKey) const;
	EOptionControllerVibration GetControllerVibration() const;
	EHCGameDifficulty GetDifficulty() const;
	EOptionDisplayEnemyDamage GetDisplayEnemyDamage() const;
	ETextLanguage GetDisplayLanguage() const;
	EEventMessageAutoPlay GetEventMessageAutoPlay() const;
	EFPSType GetFPSType() const;
	ELockonActionType GetLockonActionType() const;
	EOptionMinimapDisplay GetMinimapDisplay() const;
	EOptionMinimapRotation GetMinimapRotation() const;
	EOptionMinimapScaling GetMinimapScaling() const;
	struct FScreenResolutionSetting GetOldScreenResolution() const;
	EGradualQuality GetPostQuality() const;
	float GetScreenBrightness() const;
	struct FScreenResolutionSetting GetScreenResolution() const;
	ETargetCameraTrace GetSetTargetCameraTrace() const;
	uint8 GetSeVolume() const;
	EGradualQuality GetShadowQuality() const;
	EOptionSoundOutput GetSoundOutput() const;
	ETargetAutoChange GetTargetAutoChange() const;
	EGradualQuality GetTextureQuality() const;
	bool GetUseVerticalSync() const;
	ETextLanguage GetVoiceLanguage() const;
	uint8 GetVoiceVolume() const;
	EWindowMode GetWindowMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptionParam">();
	}
	static class UOptionParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptionParam>();
	}
};
static_assert(alignof(UOptionParam) == 0x000008, "Wrong alignment on UOptionParam");
static_assert(sizeof(UOptionParam) == 0x000110, "Wrong size on UOptionParam");

// Class BattlePrototype.OutgameDebuggingStartupObject
// 0x0010 (0x0038 - 0x0028)
class UOutgameDebuggingStartupObject final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USaveLoadScreenParamManager*            M_pDebugSystemSaveLoadScreenParamManager;          // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnActivityReleaseAccordingToTheMaximumProgressThatHasBeenReached(const class ADebuggingItemEvent* Item);
	void OnChangeLoadLevel(const class ADebuggingItemStringArray* Item);
	void OnCosmosWebManagerHttpLastErrorCodeLog(const class ADebuggingItemEvent* Item);
	void OnDispMouseRectangle(const class ADebuggingItemBool* Item);
	void OnDispUserTag(const class ADebuggingItemBool* Item);
	void OnExecuteLoadLevel(const class ADebuggingItemEvent* Item);
	void OnForcedChangeOfExecutionResultReportList(const class ADebuggingItemStringArray* Item);
	void OnReloadLevel(const class ADebuggingItemEvent* Item);
	void OnSavedataDelete(const class ADebuggingItemEvent* Item);
	void OnSavedataDownload(const class ADebuggingItemEvent* Item);
	void OnSavedataUpload(const class ADebuggingItemEvent* Item);
	void OnSystemChangeClearFlag(const class ADebuggingItemBool* Item);
	void OnSystemChangeZeroEpClearFlag(const class ADebuggingItemBool* Item);
	void OnSystemDataCorrupt(const class ADebuggingItemBool* Item);
	void OnSystemDummyBuffer(const class ADebuggingItemBool* Item);
	void OnSystemFastFlowSkip(const class ADebuggingItemBool* Item);
	void OnSystemForcedChangeOfExecutionResultReport(const class ADebuggingItemBool* Item);
	void OnSystemMaximumProgressDisplayThatHasBeenReached(const class ADebuggingItemBool* Item);
	void OnUseMouseCursor(const class ADebuggingItemBool* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutgameDebuggingStartupObject">();
	}
	static class UOutgameDebuggingStartupObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutgameDebuggingStartupObject>();
	}
};
static_assert(alignof(UOutgameDebuggingStartupObject) == 0x000008, "Wrong alignment on UOutgameDebuggingStartupObject");
static_assert(sizeof(UOutgameDebuggingStartupObject) == 0x000038, "Wrong size on UOutgameDebuggingStartupObject");
static_assert(offsetof(UOutgameDebuggingStartupObject, M_pDebugSystemSaveLoadScreenParamManager) == 0x000030, "Member 'UOutgameDebuggingStartupObject::M_pDebugSystemSaveLoadScreenParamManager' has a wrong offset!");

// Class BattlePrototype.ParticleComponentListManager
// 0x0010 (0x0038 - 0x0028)
class UParticleComponentListManager final : public UObject
{
public:
	TArray<class URSParticleSystemComponentBase*> ParticleSystemComponentBases;                      // 0x0028(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleComponentListManager">();
	}
	static class UParticleComponentListManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleComponentListManager>();
	}
};
static_assert(alignof(UParticleComponentListManager) == 0x000008, "Wrong alignment on UParticleComponentListManager");
static_assert(sizeof(UParticleComponentListManager) == 0x000038, "Wrong size on UParticleComponentListManager");
static_assert(offsetof(UParticleComponentListManager, ParticleSystemComponentBases) == 0x000028, "Member 'UParticleComponentListManager::ParticleSystemComponentBases' has a wrong offset!");

// Class BattlePrototype.PhantomAnimInstance
// 0x0020 (0x0640 - 0x0620)
class UPhantomAnimInstance final : public UASAnimInstance
{
public:
	FMulticastInlineDelegateProperty_             DispatchMontageBlendingOut;                        // 0x0620(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchMontageEnded;                              // 0x0630(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void RecvOnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void RecvOnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhantomAnimInstance">();
	}
	static class UPhantomAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhantomAnimInstance>();
	}
};
static_assert(alignof(UPhantomAnimInstance) == 0x000010, "Wrong alignment on UPhantomAnimInstance");
static_assert(sizeof(UPhantomAnimInstance) == 0x000640, "Wrong size on UPhantomAnimInstance");
static_assert(offsetof(UPhantomAnimInstance, DispatchMontageBlendingOut) == 0x000620, "Member 'UPhantomAnimInstance::DispatchMontageBlendingOut' has a wrong offset!");
static_assert(offsetof(UPhantomAnimInstance, DispatchMontageEnded) == 0x000630, "Member 'UPhantomAnimInstance::DispatchMontageEnded' has a wrong offset!");

// Class BattlePrototype.PhantomSpawnerComponent
// 0x0000 (0x00C0 - 0x00C0)
class UPhantomSpawnerComponent final : public UActorComponent
{
public:
	static class UPhantomSpawnerComponent* GetPhantomSpawner(class AActor* Actor);

	class APhantomBase* SpawnPhantom(TSubclassOf<class APhantomBase> PhantomClass, const struct FVector& RelativeLocation, const struct FRotator& RelativeRotation, class UAnimMontage* Montage, float FadeInSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhantomSpawnerComponent">();
	}
	static class UPhantomSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhantomSpawnerComponent>();
	}
};
static_assert(alignof(UPhantomSpawnerComponent) == 0x000008, "Wrong alignment on UPhantomSpawnerComponent");
static_assert(sizeof(UPhantomSpawnerComponent) == 0x0000C0, "Wrong size on UPhantomSpawnerComponent");

// Class BattlePrototype.PlatformGameActivityFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UPlatformGameActivityFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformGameActivityFunctionLibrary">();
	}
	static class UPlatformGameActivityFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformGameActivityFunctionLibrary>();
	}
};
static_assert(alignof(UPlatformGameActivityFunctionLibrary) == 0x000008, "Wrong alignment on UPlatformGameActivityFunctionLibrary");
static_assert(sizeof(UPlatformGameActivityFunctionLibrary) == 0x000028, "Wrong size on UPlatformGameActivityFunctionLibrary");

// Class BattlePrototype.PlatformUserIdFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UPlatformUserIdFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetGamerTag(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformUserIdFunctionLibrary">();
	}
	static class UPlatformUserIdFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformUserIdFunctionLibrary>();
	}
};
static_assert(alignof(UPlatformUserIdFunctionLibrary) == 0x000008, "Wrong alignment on UPlatformUserIdFunctionLibrary");
static_assert(sizeof(UPlatformUserIdFunctionLibrary) == 0x000028, "Wrong size on UPlatformUserIdFunctionLibrary");

// Class BattlePrototype.PlayerAIEvaluateLocationComponent
// 0x0528 (0x05F8 - 0x00D0)
class UPlayerAIEvaluateLocationComponent : public URSAsyncTaskActorComponent
{
public:
	EAIBattleRange                                Range_Type;                                        // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RANGE_NEAR;                                        // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range_Middle;                                      // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RANGE_FAR;                                         // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width_Near;                                        // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width_Far;                                         // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_Init;                                     // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_TargetActor;                              // 0x00EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_NotTargetActor;                           // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_AttackActor;                              // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_Friend;                                   // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_TargetFront;                              // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_TargetSide;                               // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_TargetBack;                               // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_TargetActorBehind;                        // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_TargetActorInfront;                       // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_CurrentLocation;                          // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchUpdateEvaluateLocation;                    // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x4D0];                                    // 0x0128(0x04D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginEvaluate();
	bool CheckKeepOutArea(const struct FVector& Location);
	void ClearActorData();
	void DebugDrawEvaluationLocation();
	void EndEvaluate();
	bool GetHighPriorityLocation(struct FVector* OutLocation);
	bool GetHighPriorityLocationByRange(struct FVector* OutLocation, EAIBattleRange battleRange);
	bool GetLocationPriorityRank(int32* OutRank, struct FVector* OutLocation, const struct FVector& Location);
	bool GetNearLocation(struct FVector* OutLocation, const struct FVector& Location);
	bool GetOtherHighPriorityLocation(struct FVector* OutLocation, int32 Rank);
	void RegisterActorData(EEvaluateActorType ActorType, EEvaluateActorStatus ActorStatus, const struct FVector& Location, const struct FVector& ForwardDir, float Radius, bool bLockOn);
	void SetIgnoreKeepOutArea(bool bIgnore);
	void SetParameter(const struct FPlayerAIParameter& Parameter);

	float GetAIBattleRange(EAIBattleRange Range) const;
	EAIBattleRange GetAIBattleRangeType() const;
	EAIBattleRange GetLocationRangeType(const struct FVector& Location) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerAIEvaluateLocationComponent">();
	}
	static class UPlayerAIEvaluateLocationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerAIEvaluateLocationComponent>();
	}
};
static_assert(alignof(UPlayerAIEvaluateLocationComponent) == 0x000008, "Wrong alignment on UPlayerAIEvaluateLocationComponent");
static_assert(sizeof(UPlayerAIEvaluateLocationComponent) == 0x0005F8, "Wrong size on UPlayerAIEvaluateLocationComponent");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Range_Type) == 0x0000D0, "Member 'UPlayerAIEvaluateLocationComponent::Range_Type' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, RANGE_NEAR) == 0x0000D4, "Member 'UPlayerAIEvaluateLocationComponent::RANGE_NEAR' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Range_Middle) == 0x0000D8, "Member 'UPlayerAIEvaluateLocationComponent::Range_Middle' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, RANGE_FAR) == 0x0000DC, "Member 'UPlayerAIEvaluateLocationComponent::RANGE_FAR' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Width_Near) == 0x0000E0, "Member 'UPlayerAIEvaluateLocationComponent::Width_Near' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Width_Far) == 0x0000E4, "Member 'UPlayerAIEvaluateLocationComponent::Width_Far' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_Init) == 0x0000E8, "Member 'UPlayerAIEvaluateLocationComponent::Priority_Init' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_TargetActor) == 0x0000EC, "Member 'UPlayerAIEvaluateLocationComponent::Priority_TargetActor' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_NotTargetActor) == 0x0000F0, "Member 'UPlayerAIEvaluateLocationComponent::Priority_NotTargetActor' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_AttackActor) == 0x0000F4, "Member 'UPlayerAIEvaluateLocationComponent::Priority_AttackActor' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_Friend) == 0x0000F8, "Member 'UPlayerAIEvaluateLocationComponent::Priority_Friend' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_TargetFront) == 0x0000FC, "Member 'UPlayerAIEvaluateLocationComponent::Priority_TargetFront' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_TargetSide) == 0x000100, "Member 'UPlayerAIEvaluateLocationComponent::Priority_TargetSide' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_TargetBack) == 0x000104, "Member 'UPlayerAIEvaluateLocationComponent::Priority_TargetBack' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_TargetActorBehind) == 0x000108, "Member 'UPlayerAIEvaluateLocationComponent::Priority_TargetActorBehind' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_TargetActorInfront) == 0x00010C, "Member 'UPlayerAIEvaluateLocationComponent::Priority_TargetActorInfront' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_CurrentLocation) == 0x000110, "Member 'UPlayerAIEvaluateLocationComponent::Priority_CurrentLocation' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, DispatchUpdateEvaluateLocation) == 0x000118, "Member 'UPlayerAIEvaluateLocationComponent::DispatchUpdateEvaluateLocation' has a wrong offset!");

// Class BattlePrototype.REDScrollBox
// 0x0108 (0x0988 - 0x0880)
class UREDScrollBox final : public UScrollBox
{
public:
	bool                                          DebugMouseHitDisp;                                 // 0x0880(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugMouseHitBarDisp;                              // 0x0881(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_882[0x6];                                      // 0x0882(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 M_pElementClass;                                   // 0x0888(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_890[0x10];                                     // 0x0890(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UREDScrollBoxElement*>           M_elementList;                                     // 0x08A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8B0[0x8];                                      // 0x08B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRedScrollBoxWork>              M_elementWork;                                     // 0x08B8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C8[0x8];                                      // 0x08C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 M_elementClass;                                    // 0x08D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D8[0x40];                                     // 0x08D8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             M_updateElement;                                   // 0x0918(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             M_focus;                                           // 0x0928(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             M_unFocus;                                         // 0x0938(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             M_FocusMouse;                                      // 0x0948(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             M_unFocusMouse;                                    // 0x0958(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             M_LeftDownMouse;                                   // 0x0968(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	class UREDebugLines*                          M_DebugDraw;                                       // 0x0978(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UREDebugLines*                          M_DebugbarDraw;                                    // 0x0980(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddElement();
	void CleanUpList();
	void CloseDrawAreaWidget();
	void CorrectCursorDrawArea(bool IsScroll, bool InitcursorTop);
	void DecrementWorkWeightAll();
	class UUserWidget* GetCurrentWidget();
	class UUserWidget* GetSimpleCurrentWidget();
	class UUserWidget* GetWorkWidget(int32 Index_0, bool IsSetFreeWork, bool NotupdateElement);
	void IncrementWorkWeight(int32 CursorPosition);
	bool IsScrollAnimation();
	void ReleaseList();
	void ResetList();
	void SetCursorPosition(int32 Index_0, bool Mouseflag, bool MouseScrollflag);
	void SetDebugDraw(bool IsDraw);
	void SetDrawTop(int32 Pos);
	void SetMouseDisable(bool Flag, ESlateVisibility Lockvisibility);
	void SetMouseInputDisable(bool Flag);
	void SetMouseInputLevel(int32 InputLevel);
	void SetScrollOffsetRED(float Offset);
	void SetScrollSpeed(float Speed);
	void SetupList(class UClass* ElementClass, int32 ElementNum, const struct FVector2D& ElementSize, float OffsetSize, int32 Initcursor, bool IsCursorTop);
	void UpdateDrawAreaWidget();
	void UpdateList(float DeltaSeconds);

	int32 GetCurrentIndex() const;
	int32 GetDrawTop() const;
	int32 GetDrawTopGoal() const;
	bool GetIsSetUp() const;
	int32 GetMouseBackUpCursor() const;
	bool GetMouseDisable() const;
	bool GetMouseInputDisable() const;
	int32 GetMouseInputLevel() const;
	int32 GetPageDrawNum() const;
	bool IsRedrawScroll() const;
	bool IsScrollBarClicking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDScrollBox">();
	}
	static class UREDScrollBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDScrollBox>();
	}
};
static_assert(alignof(UREDScrollBox) == 0x000008, "Wrong alignment on UREDScrollBox");
static_assert(sizeof(UREDScrollBox) == 0x000988, "Wrong size on UREDScrollBox");
static_assert(offsetof(UREDScrollBox, DebugMouseHitDisp) == 0x000880, "Member 'UREDScrollBox::DebugMouseHitDisp' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, DebugMouseHitBarDisp) == 0x000881, "Member 'UREDScrollBox::DebugMouseHitBarDisp' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_pElementClass) == 0x000888, "Member 'UREDScrollBox::M_pElementClass' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_elementList) == 0x0008A0, "Member 'UREDScrollBox::M_elementList' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_elementWork) == 0x0008B8, "Member 'UREDScrollBox::M_elementWork' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_elementClass) == 0x0008D0, "Member 'UREDScrollBox::M_elementClass' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_updateElement) == 0x000918, "Member 'UREDScrollBox::M_updateElement' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_focus) == 0x000928, "Member 'UREDScrollBox::M_focus' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_unFocus) == 0x000938, "Member 'UREDScrollBox::M_unFocus' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_FocusMouse) == 0x000948, "Member 'UREDScrollBox::M_FocusMouse' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_unFocusMouse) == 0x000958, "Member 'UREDScrollBox::M_unFocusMouse' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_LeftDownMouse) == 0x000968, "Member 'UREDScrollBox::M_LeftDownMouse' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_DebugDraw) == 0x000978, "Member 'UREDScrollBox::M_DebugDraw' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_DebugbarDraw) == 0x000980, "Member 'UREDScrollBox::M_DebugbarDraw' has a wrong offset!");

// Class BattlePrototype.PlayerAsyncScriptComponent
// 0x0F18 (0x0FE8 - 0x00D0)
class UPlayerAsyncScriptComponent final : public URSAsyncTaskActorComponent
{
public:
	float                                         CheckMoveWallHeight;                               // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CheckMoveWall_CheckForwardLength;                  // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CheckMoveWall_CheckBackLength;                     // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CheckMoveWall_CheckSideLengthShort;                // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CheckMoveWall_CheckSideLength;                     // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0xEDC];                                     // 0x00E4(0x0EDC)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     TempOutHitResultAsync;                             // 0x0FC0(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FHitResult>                     TempOutHitResultAsyncSubFunc;                      // 0x0FD0(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FE0[0x8];                                      // 0x0FE0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAsyncResult();
	void DebugDispResult(const TArray<EPlayerCollisionCheckType>& DispList);
	const struct FPlayerCollisionCheckResult GetAsyncResult(EPlayerCollisionCheckType Type);
	bool IsFallAbleGround();
	void SetCheckParameter(const struct FPlayerAsyncParameter& InParameter);
	void SetEnableAsync(bool bAsync);
	bool SyncResult();

	struct FVector GetAssyncResult_PlayerAICheckGoalLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerAsyncScriptComponent">();
	}
	static class UPlayerAsyncScriptComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerAsyncScriptComponent>();
	}
};
static_assert(alignof(UPlayerAsyncScriptComponent) == 0x000008, "Wrong alignment on UPlayerAsyncScriptComponent");
static_assert(sizeof(UPlayerAsyncScriptComponent) == 0x000FE8, "Wrong size on UPlayerAsyncScriptComponent");
static_assert(offsetof(UPlayerAsyncScriptComponent, CheckMoveWallHeight) == 0x0000D0, "Member 'UPlayerAsyncScriptComponent::CheckMoveWallHeight' has a wrong offset!");
static_assert(offsetof(UPlayerAsyncScriptComponent, CheckMoveWall_CheckForwardLength) == 0x0000D4, "Member 'UPlayerAsyncScriptComponent::CheckMoveWall_CheckForwardLength' has a wrong offset!");
static_assert(offsetof(UPlayerAsyncScriptComponent, CheckMoveWall_CheckBackLength) == 0x0000D8, "Member 'UPlayerAsyncScriptComponent::CheckMoveWall_CheckBackLength' has a wrong offset!");
static_assert(offsetof(UPlayerAsyncScriptComponent, CheckMoveWall_CheckSideLengthShort) == 0x0000DC, "Member 'UPlayerAsyncScriptComponent::CheckMoveWall_CheckSideLengthShort' has a wrong offset!");
static_assert(offsetof(UPlayerAsyncScriptComponent, CheckMoveWall_CheckSideLength) == 0x0000E0, "Member 'UPlayerAsyncScriptComponent::CheckMoveWall_CheckSideLength' has a wrong offset!");
static_assert(offsetof(UPlayerAsyncScriptComponent, TempOutHitResultAsync) == 0x000FC0, "Member 'UPlayerAsyncScriptComponent::TempOutHitResultAsync' has a wrong offset!");
static_assert(offsetof(UPlayerAsyncScriptComponent, TempOutHitResultAsyncSubFunc) == 0x000FD0, "Member 'UPlayerAsyncScriptComponent::TempOutHitResultAsyncSubFunc' has a wrong offset!");

// Class BattlePrototype.PlayerCopyInterface
// 0x0000 (0x0028 - 0x0028)
class IPlayerCopyInterface final : public IInterface
{
public:
	bool IsExistPlayerCopy();
	bool IsPlayerCopy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCopyInterface">();
	}
	static class IPlayerCopyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerCopyInterface>();
	}
};
static_assert(alignof(IPlayerCopyInterface) == 0x000008, "Wrong alignment on IPlayerCopyInterface");
static_assert(sizeof(IPlayerCopyInterface) == 0x000028, "Wrong size on IPlayerCopyInterface");

// Class BattlePrototype.PlayerDamageReactionInfoBase
// 0x0050 (0x0110 - 0x00C0)
class UPlayerDamageReactionInfoBase : public UActorComponent
{
public:
	class ARSCharacterBase*                       OwnerCharacter;                                    // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerScriptComponent*                 OwnerPlayerScript;                                 // 0x00C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerDamageKind                             DamageKind;                                        // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerDamageKind                             DamageKindNow;                                     // 0x00D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D2[0x2];                                       // 0x00D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DamageDir;                                         // 0x00D4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAddDamage;                                        // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  DamageAttacker;                                    // 0x00E4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  Attacker;                                          // 0x00EC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHCHitStopCauseType                           HitStopCauseType;                                  // 0x00F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FloatingPower;                                     // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               FloatingAngle;                                     // 0x00FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EHCSkillAttackType                            AttackType;                                        // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BadStateFlag;                                      // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool BrainCrashAccess_CallFromCPP();
	bool CheckBadStateDamageCPP(int32 Flag, EHCBadState BadState);
	bool CheckFinishMetamorphosis_BPImplement(class UPlayerENpcBaseComponent* ENpcComp, EPlayerDamageKind InDamageKind, bool bFront);
	bool IsAttackerPlayerCPP();
	bool IsKnockbackLongNowCPP();
	bool StartEnemyAddDamageShake_BPImplement(bool bTriggerAttack);
	bool StartEnpcDamageMove_BPImplement(const struct FVector& DamageDir_0, float Power, bool DeadMove);
	void UpdateDamageReactionCPP(const struct FHCHitResult& HitResult);

	bool IsAerialDamageCPP() const;
	bool IsExistDamageCPP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerDamageReactionInfoBase">();
	}
	static class UPlayerDamageReactionInfoBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerDamageReactionInfoBase>();
	}
};
static_assert(alignof(UPlayerDamageReactionInfoBase) == 0x000008, "Wrong alignment on UPlayerDamageReactionInfoBase");
static_assert(sizeof(UPlayerDamageReactionInfoBase) == 0x000110, "Wrong size on UPlayerDamageReactionInfoBase");
static_assert(offsetof(UPlayerDamageReactionInfoBase, OwnerCharacter) == 0x0000C0, "Member 'UPlayerDamageReactionInfoBase::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, OwnerPlayerScript) == 0x0000C8, "Member 'UPlayerDamageReactionInfoBase::OwnerPlayerScript' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, DamageKind) == 0x0000D0, "Member 'UPlayerDamageReactionInfoBase::DamageKind' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, DamageKindNow) == 0x0000D1, "Member 'UPlayerDamageReactionInfoBase::DamageKindNow' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, DamageDir) == 0x0000D4, "Member 'UPlayerDamageReactionInfoBase::DamageDir' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, bAddDamage) == 0x0000E0, "Member 'UPlayerDamageReactionInfoBase::bAddDamage' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, DamageAttacker) == 0x0000E4, "Member 'UPlayerDamageReactionInfoBase::DamageAttacker' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, Attacker) == 0x0000EC, "Member 'UPlayerDamageReactionInfoBase::Attacker' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, HitStopCauseType) == 0x0000F4, "Member 'UPlayerDamageReactionInfoBase::HitStopCauseType' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, FloatingPower) == 0x0000F8, "Member 'UPlayerDamageReactionInfoBase::FloatingPower' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, FloatingAngle) == 0x0000FC, "Member 'UPlayerDamageReactionInfoBase::FloatingAngle' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, AttackType) == 0x000108, "Member 'UPlayerDamageReactionInfoBase::AttackType' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, BadStateFlag) == 0x00010C, "Member 'UPlayerDamageReactionInfoBase::BadStateFlag' has a wrong offset!");

// Class BattlePrototype.REDStringUtility
// 0x0000 (0x0028 - 0x0028)
class UREDStringUtility final : public UBlueprintFunctionLibrary
{
public:
	static void AutoScale(class UTextBlock* TextBlock, float Width);
	static ETextLanguage DecrementTextLanguageEnum(ETextLanguage OldLanguage);
	static ETextLanguage GetCurrentTextLanguageEnum();
	static class FString GetDateString(int32 Year, int32 Month, int32 Day);
	static struct FLinearColor GetFontColor(ETextColor TextColor);
	static class FString GetStringWithoutREDTag(class UObject* WorldObject, const class FString& Source);
	static class FString GetTextLanguageName(ETextLanguage Language);
	static ETextLanguage IncrementTextLanguageEnum(ETextLanguage OldLanguage);
	static bool IsFullCharacter(ETextLanguage Language);
	static void ReplaceOneCharacter(class FString& String, int32 Index_0, const class FString& To);
	static void SetActionTagSingle(class UObject* PWorld, class UImage* IconImage, const class FString& ActionName);
	static void SetActionTagSingleBIG(class UObject* PWorld, class UImage* IconImage, const class FString& ActionName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDStringUtility">();
	}
	static class UREDStringUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDStringUtility>();
	}
};
static_assert(alignof(UREDStringUtility) == 0x000008, "Wrong alignment on UREDStringUtility");
static_assert(sizeof(UREDStringUtility) == 0x000028, "Wrong size on UREDStringUtility");

// Class BattlePrototype.HardenStartParameter
// 0x0010 (0x0040 - 0x0030)
class UHardenStartParameter final : public UDataAsset
{
public:
	struct FLinearColor                           EmissiveColor;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HardenStartParameter">();
	}
	static class UHardenStartParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHardenStartParameter>();
	}
};
static_assert(alignof(UHardenStartParameter) == 0x000008, "Wrong alignment on UHardenStartParameter");
static_assert(sizeof(UHardenStartParameter) == 0x000040, "Wrong size on UHardenStartParameter");
static_assert(offsetof(UHardenStartParameter, EmissiveColor) == 0x000030, "Member 'UHardenStartParameter::EmissiveColor' has a wrong offset!");

// Class BattlePrototype.PlayerDriveComponent
// 0x0208 (0x02C8 - 0x00C0)
class UPlayerDriveComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             DispatchBeginDrive;                                // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchEndDrive;                                  // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchSetDriveGauge;                             // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchDriveGaugeMax;                             // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRegenerateHP;                              // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchNotifyBrainFieldStock;                     // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchNotifyParameterMax;                        // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x60];                                     // 0x0130(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DisableDriveClaimantList;                          // 0x0190(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0x128];                                    // 0x01A0(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBrainCrashDefeatedEnemy(int32 DefeatedNum, bool bUniqueBrainCrash);
	void AddBrainFieldCount(bool bItemUse, bool bNoEffect);
	void AddDefeatedEnemy(int32 DefeatedNum);
	void BeginDriveMode(bool bDelayTimerTick, bool bDisableTimer, bool bNpcDrive);
	void BeginDriveTimer();
	bool CheckNpcDrive(ENpcDriveCheckType CheckType, int32 bondsLevel, float PlayerDriveRate, float PlayerHpRate);
	void ClearReserveNpcDrive();
	void DirectDriveTimeSetting(float CurrentTime, float ExtendTime);
	void DisableDrive(bool bDisable, class FName ClaimantName);
	void EndDriveMode(bool bInterruption, bool bLocationChange);
	void ForceBeginNpcDriveInterval();
	void OnNotifyDriveEvent(ENotifyDriveEvent Type, int32 Param);
	void ReserveNpcDrive();
	void ResetBrainFieldCount();
	void ResetDriveGauge();
	void ResetNpcDriveInterval();
	void RestrictDriveBegin(bool bRestrict);
	void SetDriveCommonParameter(const struct FPlayerDriveCommonParameter& Parameter);
	void SetDriveGaugeDirect(float Value);
	void SetDriveGaugeIncreaseRate(float Rate);
	void SetDriveGaugeParameter(const struct FPlayerDriveGaugeParameter& Parameter);
	void SetDriveParameter(const struct FPlayerDriveParameter& Parameter);
	void SetExtendTimeBrainCrash(float ExtendTime);
	void SetNpcDriveData(struct FNpcDriveData& InData);
	void SetPauseDriveTimer(bool bPause);
	void SetRecoveryBadStatus(bool bEnable);
	void SetRegenerate(bool bEnable);
	void SetRegenerateHPRate(float Rate);
	void SetRegenerateInterval(float Interval);
	void SetSASCharge(bool bEnable);
	void UpdateDriveTick(float DeltaSeconds);
	void UpdateNpcDriveInterval(float DeltaSeconds);

	float GetAttackAnimationPlayRate() const;
	float GetAttackRate() const;
	int32 GetBrainFieldCount() const;
	float GetCrashRate() const;
	float GetCurrentDriveTime() const;
	float GetCurrentDriveTimeRate() const;
	float GetCurrentParameterRate() const;
	float GetDisableDriveLastEnemyHpRate() const;
	float GetDriveGauge() const;
	float GetDriveGaugeRate() const;
	float GetDriveTimerRemain() const;
	float GetMaxDriveGauge() const;
	float GetMaxDriveTime() const;
	float GetMoveSpeedRate() const;
	float GetNpcDriveIntervalTimerRemain() const;
	float GetParameterMaxTime() const;
	float GetPsychicGaugeRate() const;
	float GetPsychicWaitGaugeRate() const;
	bool IsDebugAlwaysDrive() const;
	bool IsDebugInfiniteDrive() const;
	bool IsDriveMode() const;
	bool IsEnableBrainField() const;
	bool IsEnableDrive() const;
	bool IsEnableDriveNpc() const;
	bool IsRecoveryBadStatus() const;
	bool IsReservedNpcDrive() const;
	bool IsSASCharge() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerDriveComponent">();
	}
	static class UPlayerDriveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerDriveComponent>();
	}
};
static_assert(alignof(UPlayerDriveComponent) == 0x000008, "Wrong alignment on UPlayerDriveComponent");
static_assert(sizeof(UPlayerDriveComponent) == 0x0002C8, "Wrong size on UPlayerDriveComponent");
static_assert(offsetof(UPlayerDriveComponent, DispatchBeginDrive) == 0x0000C0, "Member 'UPlayerDriveComponent::DispatchBeginDrive' has a wrong offset!");
static_assert(offsetof(UPlayerDriveComponent, DispatchEndDrive) == 0x0000D0, "Member 'UPlayerDriveComponent::DispatchEndDrive' has a wrong offset!");
static_assert(offsetof(UPlayerDriveComponent, DispatchSetDriveGauge) == 0x0000E0, "Member 'UPlayerDriveComponent::DispatchSetDriveGauge' has a wrong offset!");
static_assert(offsetof(UPlayerDriveComponent, DispatchDriveGaugeMax) == 0x0000F0, "Member 'UPlayerDriveComponent::DispatchDriveGaugeMax' has a wrong offset!");
static_assert(offsetof(UPlayerDriveComponent, DispatchRegenerateHP) == 0x000100, "Member 'UPlayerDriveComponent::DispatchRegenerateHP' has a wrong offset!");
static_assert(offsetof(UPlayerDriveComponent, DispatchNotifyBrainFieldStock) == 0x000110, "Member 'UPlayerDriveComponent::DispatchNotifyBrainFieldStock' has a wrong offset!");
static_assert(offsetof(UPlayerDriveComponent, DispatchNotifyParameterMax) == 0x000120, "Member 'UPlayerDriveComponent::DispatchNotifyParameterMax' has a wrong offset!");
static_assert(offsetof(UPlayerDriveComponent, DisableDriveClaimantList) == 0x000190, "Member 'UPlayerDriveComponent::DisableDriveClaimantList' has a wrong offset!");

// Class BattlePrototype.REDRetainerBox
// 0x0000 (0x0158 - 0x0158)
class UREDRetainerBox final : public URetainerBox
{
public:
	void SetPhase(int32 _phase);
	void SetPhaseCount(int32 _count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDRetainerBox">();
	}
	static class UREDRetainerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDRetainerBox>();
	}
};
static_assert(alignof(UREDRetainerBox) == 0x000008, "Wrong alignment on UREDRetainerBox");
static_assert(sizeof(UREDRetainerBox) == 0x000158, "Wrong size on UREDRetainerBox");

// Class BattlePrototype.PlayerENpcBaseComponent
// 0x0008 (0x00C8 - 0x00C0)
class UPlayerENpcBaseComponent : public UActorComponent
{
public:
	bool                                          bReactionChance;                                   // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool SetHitTrigger_CallFromCPP(bool bIsHitTrigger);
	bool StartReactionChance_CallFromCPP();

	bool IsReactionChanceCPP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerENpcBaseComponent">();
	}
	static class UPlayerENpcBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerENpcBaseComponent>();
	}
};
static_assert(alignof(UPlayerENpcBaseComponent) == 0x000008, "Wrong alignment on UPlayerENpcBaseComponent");
static_assert(sizeof(UPlayerENpcBaseComponent) == 0x0000C8, "Wrong size on UPlayerENpcBaseComponent");
static_assert(offsetof(UPlayerENpcBaseComponent, bReactionChance) == 0x0000C0, "Member 'UPlayerENpcBaseComponent::bReactionChance' has a wrong offset!");

// Class BattlePrototype.PlayerHeightGradationComponent
// 0x0010 (0x00D0 - 0x00C0)
class UPlayerHeightGradationComponent final : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddGradation(class UMeshComponent* Mesh, const TArray<struct FHeightGradationSettings>& SettingsArray);
	void ResetGradation(class UMeshComponent* Mesh, const TArray<struct FHeightGradationSettings>& SettingsArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerHeightGradationComponent">();
	}
	static class UPlayerHeightGradationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerHeightGradationComponent>();
	}
};
static_assert(alignof(UPlayerHeightGradationComponent) == 0x000008, "Wrong alignment on UPlayerHeightGradationComponent");
static_assert(sizeof(UPlayerHeightGradationComponent) == 0x0000D0, "Wrong size on UPlayerHeightGradationComponent");

// Class BattlePrototype.PlayerInputBaseComponent
// 0x0480 (0x0540 - 0x00C0)
class UPlayerInputBaseComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             DispatchTrigger_Attack;                            // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_AttackLongPress;                   // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_Attack;                            // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_AttackSub;                         // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_AttackSubLongPress;                // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_AttackSub;                         // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_LaunchAttack;                      // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_LaunchAttack;                      // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_BackStepAttack;                    // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_BackStepAttack;                    // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_Dodge;                             // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_Jump;                              // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_TargetLock;                        // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_TargetChange;                      // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_TargetChangeLeft;                  // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_TargetChangeRight;                 // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_ReadySAS;                          // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_ReadySAS;                          // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Dispatch_ReadySAS;                                 // 0x01E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Dispatch_SasSelectSlow;                            // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_UpSAS;                             // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_DownSAS;                           // 0x0210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_LeftSAS;                           // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_RightSAS;                          // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_OffSAS;                            // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_SASHologramAttack;                 // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_SASHologramAttack;                 // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_UpCombinationVision;               // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_DownCombinationVision;             // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_LeftCombinationVision;             // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_RightCombinationVision;            // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_ChangeSASSet;                      // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_Psychic;                           // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_Psychic;                           // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_SpecialPsychic;                    // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_SpecialPsychic;                    // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_BrainFieldPsychicUp;               // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_BrainFieldPsychicLeft;             // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_BrainFieldPsychicRight;            // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_BrainFieldPsychicRight;            // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_PsychicField;                      // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_PsychicField;                      // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_BrainCrash;                        // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_MapGimmick;                        // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_MapGimmick;                        // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_BrainField;                        // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_Intercept;                         // 0x03A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_UseItem;                           // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_ItemSelectLeft;                    // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_ItemSelectRight;                   // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_Ressurect;                         // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_Ressurect;                         // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_ResetCamera;                       // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         LONG_ATTACK_INPUT_TIME;                            // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LONG_ATTACK_INPUT_TIME_AERIAL;                     // 0x0414(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DOUBLE_INPUT_INTERVAL;                             // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SAS_SELECT_SLOW_DELAY_TIME;                        // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SAS_SELECT_SLOW_TIME;                              // 0x0420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_424[0x11C];                                    // 0x0424(0x011C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddRestriction(EPlayerInputRestrictionType Restriction);
	void CheckChangeSasSetOption();
	void ClearInput(bool bButtonOnly);
	void ClearPrecedeInput();
	void ClearPrecedeInputDodge();
	void ForceEndSasSelectSlow();
	struct FVector2D GetLeftStickPrevInputDiff();
	void ReleaseButton(ERSGamepadInputName Button);
	void ResetChangeSasSetDoubleInput();
	void SetAI(bool bAI);
	void SetBrainFieldMode(bool bBrainField);
	void SetButton(ERSGamepadInputName Button);
	void SetEnableSasSelectSlow(bool bEnable);
	void SetInputType(EPlayerInputType Type);
	void SetLeftStick(float X, float Y);
	void SetRightStick(float X, float Y);
	void SetTalkMode(bool bTalk);
	void SetTutorial(bool bTutorial);
	void SubRestriction(EPlayerInputRestrictionType Restriction);
	void TutorialRestrictAttackAll(bool bRestrict);
	void TutorialRestrictAttackSub(bool bRestrict);
	void TutorialRestrictLaunchAttack(bool bRestrict);
	void TutorialRestrictPsychic(bool bRestrict);
	void Update(float DeltaSeconds);

	EPlayerInputType GetInputType() const;
	float GetLeftStickX(bool bRaw) const;
	float GetLeftStickY(bool bRaw) const;
	float GetLongPressAttackInputTime() const;
	void GetMoveStick(float* OutX, float* OutY, float* OutPower) const;
	struct FVector GetPrecedeInputDodgeStick() const;
	float GetPrevLeftStickX(bool bRaw) const;
	float GetPrevLeftStickY(bool bRaw) const;
	float GetRightStickX(bool bRaw) const;
	float GetRightStickY(bool bRaw) const;
	EPlayerInputSASReadyType GetSasReadyType() const;
	bool IsKeyboard() const;
	bool IsLeftStickInput(float Power, bool bRaw) const;
	bool IsLeftStickRun() const;
	bool IsLeftStickZero(bool bRaw) const;
	bool IsOn(ERSGamepadInputName Button) const;
	bool IsOnAttack() const;
	bool IsOnAttackSub() const;
	bool IsOnDodge() const;
	bool IsOnJump() const;
	bool IsOnPsychicObjectUnique() const;
	bool IsOnReadyCombinationVision() const;
	bool IsOnReadySAS() const;
	bool IsOnReadyTargetChange() const;
	bool IsOnResurrect() const;
	bool IsOnRideAccel() const;
	bool IsOnUniqueCharge() const;
	bool IsOnUniqueCircle() const;
	bool IsOnWakeUp() const;
	bool IsPrecedeInputDodge() const;
	bool IsPrecedeInputJump() const;
	bool IsPrecedeInputPsychic() const;
	bool IsPrecedeInputUseItem() const;
	bool IsRelease(ERSGamepadInputName Button) const;
	bool IsReleaseAttack() const;
	bool IsReleaseAttackSub() const;
	bool IsReleaseBackStepAttack() const;
	bool IsReleaseBrainFieldPsychicRight() const;
	bool IsReleaseDodge() const;
	bool IsReleaseJump() const;
	bool IsReleaseLaunchAttack() const;
	bool IsReleaseMapGimmick() const;
	bool IsReleaseReadySAS() const;
	bool IsReleaseSASHologramAttack() const;
	bool IsRestriction(EPlayerInputRestrictionType Restriction) const;
	bool IsRightStickInput(float Power, bool bRaw) const;
	bool IsRightStickZero(bool bRaw) const;
	bool IsTrg(ERSGamepadInputName Button) const;
	bool IsTrgAttack() const;
	bool IsTrgAttackSub() const;
	bool IsTrgBackStepAttack() const;
	bool IsTrgBrainCrash() const;
	bool IsTrgBrainField() const;
	bool IsTrgBrainFieldPsychicLeft() const;
	bool IsTrgBrainFieldPsychicRight() const;
	bool IsTrgBrainFieldPsychicUp() const;
	bool IsTrgChangeSASSet() const;
	bool IsTrgDodge() const;
	bool IsTrgDownCombinationVision() const;
	bool IsTrgDownSAS() const;
	bool IsTrgIntercept() const;
	bool IsTrgItemSelectLeft() const;
	bool IsTrgItemSelectRight() const;
	bool IsTrgItemUse() const;
	bool IsTrgJump() const;
	bool IsTrgLaunchAttack() const;
	bool IsTrgLeftCombinationVision() const;
	bool IsTrgLeftSAS() const;
	bool IsTrgMapGimmick() const;
	bool IsTrgPsychicObjectNormal() const;
	bool IsTrgPsychicObjectUnique() const;
	bool IsTrgReadySAS() const;
	bool IsTrgRecovery() const;
	bool IsTrgResetCamera() const;
	bool IsTrgResurrect() const;
	bool IsTrgRideAccel() const;
	bool IsTrgRideAttack() const;
	bool IsTrgRightCombinationVision() const;
	bool IsTrgRightSAS() const;
	bool IsTrgSASHologramAttack() const;
	bool IsTrgSASOffAll() const;
	bool IsTrgTargetChange() const;
	bool IsTrgTargetChangeLeft() const;
	bool IsTrgTargetChangeRight() const;
	bool IsTrgTargetLock() const;
	bool IsTrgUniqueCharge() const;
	bool IsTrgUniqueCircle() const;
	bool IsTrgUniqueDischarge() const;
	bool IsTrgUniqueTriangle() const;
	bool IsTrgUpCombinationVision() const;
	bool IsTrgUpSAS() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInputBaseComponent">();
	}
	static class UPlayerInputBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInputBaseComponent>();
	}
};
static_assert(alignof(UPlayerInputBaseComponent) == 0x000008, "Wrong alignment on UPlayerInputBaseComponent");
static_assert(sizeof(UPlayerInputBaseComponent) == 0x000540, "Wrong size on UPlayerInputBaseComponent");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_Attack) == 0x0000C0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_Attack' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_AttackLongPress) == 0x0000D0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_AttackLongPress' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_Attack) == 0x0000E0, "Member 'UPlayerInputBaseComponent::DispatchRelease_Attack' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_AttackSub) == 0x0000F0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_AttackSub' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_AttackSubLongPress) == 0x000100, "Member 'UPlayerInputBaseComponent::DispatchTrigger_AttackSubLongPress' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_AttackSub) == 0x000110, "Member 'UPlayerInputBaseComponent::DispatchRelease_AttackSub' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_LaunchAttack) == 0x000120, "Member 'UPlayerInputBaseComponent::DispatchTrigger_LaunchAttack' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_LaunchAttack) == 0x000130, "Member 'UPlayerInputBaseComponent::DispatchRelease_LaunchAttack' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_BackStepAttack) == 0x000140, "Member 'UPlayerInputBaseComponent::DispatchTrigger_BackStepAttack' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_BackStepAttack) == 0x000150, "Member 'UPlayerInputBaseComponent::DispatchRelease_BackStepAttack' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_Dodge) == 0x000160, "Member 'UPlayerInputBaseComponent::DispatchTrigger_Dodge' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_Jump) == 0x000170, "Member 'UPlayerInputBaseComponent::DispatchTrigger_Jump' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_TargetLock) == 0x000180, "Member 'UPlayerInputBaseComponent::DispatchTrigger_TargetLock' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_TargetChange) == 0x000190, "Member 'UPlayerInputBaseComponent::DispatchTrigger_TargetChange' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_TargetChangeLeft) == 0x0001A0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_TargetChangeLeft' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_TargetChangeRight) == 0x0001B0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_TargetChangeRight' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_ReadySAS) == 0x0001C0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_ReadySAS' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_ReadySAS) == 0x0001D0, "Member 'UPlayerInputBaseComponent::DispatchRelease_ReadySAS' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, Dispatch_ReadySAS) == 0x0001E0, "Member 'UPlayerInputBaseComponent::Dispatch_ReadySAS' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, Dispatch_SasSelectSlow) == 0x0001F0, "Member 'UPlayerInputBaseComponent::Dispatch_SasSelectSlow' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_UpSAS) == 0x000200, "Member 'UPlayerInputBaseComponent::DispatchTrigger_UpSAS' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_DownSAS) == 0x000210, "Member 'UPlayerInputBaseComponent::DispatchTrigger_DownSAS' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_LeftSAS) == 0x000220, "Member 'UPlayerInputBaseComponent::DispatchTrigger_LeftSAS' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_RightSAS) == 0x000230, "Member 'UPlayerInputBaseComponent::DispatchTrigger_RightSAS' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_OffSAS) == 0x000240, "Member 'UPlayerInputBaseComponent::DispatchTrigger_OffSAS' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_SASHologramAttack) == 0x000250, "Member 'UPlayerInputBaseComponent::DispatchTrigger_SASHologramAttack' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_SASHologramAttack) == 0x000260, "Member 'UPlayerInputBaseComponent::DispatchRelease_SASHologramAttack' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_UpCombinationVision) == 0x000270, "Member 'UPlayerInputBaseComponent::DispatchTrigger_UpCombinationVision' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_DownCombinationVision) == 0x000280, "Member 'UPlayerInputBaseComponent::DispatchTrigger_DownCombinationVision' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_LeftCombinationVision) == 0x000290, "Member 'UPlayerInputBaseComponent::DispatchTrigger_LeftCombinationVision' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_RightCombinationVision) == 0x0002A0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_RightCombinationVision' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_ChangeSASSet) == 0x0002B0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_ChangeSASSet' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_Psychic) == 0x0002C0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_Psychic' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_Psychic) == 0x0002D0, "Member 'UPlayerInputBaseComponent::DispatchRelease_Psychic' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_SpecialPsychic) == 0x0002E0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_SpecialPsychic' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_SpecialPsychic) == 0x0002F0, "Member 'UPlayerInputBaseComponent::DispatchRelease_SpecialPsychic' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_BrainFieldPsychicUp) == 0x000300, "Member 'UPlayerInputBaseComponent::DispatchTrigger_BrainFieldPsychicUp' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_BrainFieldPsychicLeft) == 0x000310, "Member 'UPlayerInputBaseComponent::DispatchTrigger_BrainFieldPsychicLeft' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_BrainFieldPsychicRight) == 0x000320, "Member 'UPlayerInputBaseComponent::DispatchTrigger_BrainFieldPsychicRight' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_BrainFieldPsychicRight) == 0x000330, "Member 'UPlayerInputBaseComponent::DispatchRelease_BrainFieldPsychicRight' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_PsychicField) == 0x000340, "Member 'UPlayerInputBaseComponent::DispatchTrigger_PsychicField' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_PsychicField) == 0x000350, "Member 'UPlayerInputBaseComponent::DispatchRelease_PsychicField' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_BrainCrash) == 0x000360, "Member 'UPlayerInputBaseComponent::DispatchTrigger_BrainCrash' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_MapGimmick) == 0x000370, "Member 'UPlayerInputBaseComponent::DispatchTrigger_MapGimmick' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_MapGimmick) == 0x000380, "Member 'UPlayerInputBaseComponent::DispatchRelease_MapGimmick' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_BrainField) == 0x000390, "Member 'UPlayerInputBaseComponent::DispatchTrigger_BrainField' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_Intercept) == 0x0003A0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_Intercept' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_UseItem) == 0x0003B0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_UseItem' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_ItemSelectLeft) == 0x0003C0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_ItemSelectLeft' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_ItemSelectRight) == 0x0003D0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_ItemSelectRight' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_Ressurect) == 0x0003E0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_Ressurect' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_Ressurect) == 0x0003F0, "Member 'UPlayerInputBaseComponent::DispatchRelease_Ressurect' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_ResetCamera) == 0x000400, "Member 'UPlayerInputBaseComponent::DispatchTrigger_ResetCamera' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, LONG_ATTACK_INPUT_TIME) == 0x000410, "Member 'UPlayerInputBaseComponent::LONG_ATTACK_INPUT_TIME' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, LONG_ATTACK_INPUT_TIME_AERIAL) == 0x000414, "Member 'UPlayerInputBaseComponent::LONG_ATTACK_INPUT_TIME_AERIAL' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DOUBLE_INPUT_INTERVAL) == 0x000418, "Member 'UPlayerInputBaseComponent::DOUBLE_INPUT_INTERVAL' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, SAS_SELECT_SLOW_DELAY_TIME) == 0x00041C, "Member 'UPlayerInputBaseComponent::SAS_SELECT_SLOW_DELAY_TIME' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, SAS_SELECT_SLOW_TIME) == 0x000420, "Member 'UPlayerInputBaseComponent::SAS_SELECT_SLOW_TIME' has a wrong offset!");

// Class BattlePrototype.PlayerJustDodgeComponent
// 0x0018 (0x00D8 - 0x00C0)
class UPlayerJustDodgeComponent : public UActorComponent
{
public:
	float                                         JUST_DODGE_TIME;                                   // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JUST_DODGE_GAMESPEED_RATE;                         // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JUST_DODGE_INVINSIBLE_TIME;                        // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JUST_DODGE_RADIUS;                                 // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JUST_DODGE_RADIUS_RANGEATTACK;                     // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CalcJustDodge(class UCapsuleComponent* BaseCapsule, class UHitCheckComponent* HitCheck, const struct FVector& Offset, float CheckScale, float CheckRangeScale);
	bool CalcJustDodgeByLocation(const struct FVector& Location, const struct FVector& UpDir, const struct FVector& Offset, float Height, float Radius, class UHitCheckComponent* HitCheck, float CheckScale, float CheckRangeScale);
	bool CheckJustDodge();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerJustDodgeComponent">();
	}
	static class UPlayerJustDodgeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerJustDodgeComponent>();
	}
};
static_assert(alignof(UPlayerJustDodgeComponent) == 0x000008, "Wrong alignment on UPlayerJustDodgeComponent");
static_assert(sizeof(UPlayerJustDodgeComponent) == 0x0000D8, "Wrong size on UPlayerJustDodgeComponent");
static_assert(offsetof(UPlayerJustDodgeComponent, JUST_DODGE_TIME) == 0x0000C0, "Member 'UPlayerJustDodgeComponent::JUST_DODGE_TIME' has a wrong offset!");
static_assert(offsetof(UPlayerJustDodgeComponent, JUST_DODGE_GAMESPEED_RATE) == 0x0000C4, "Member 'UPlayerJustDodgeComponent::JUST_DODGE_GAMESPEED_RATE' has a wrong offset!");
static_assert(offsetof(UPlayerJustDodgeComponent, JUST_DODGE_INVINSIBLE_TIME) == 0x0000C8, "Member 'UPlayerJustDodgeComponent::JUST_DODGE_INVINSIBLE_TIME' has a wrong offset!");
static_assert(offsetof(UPlayerJustDodgeComponent, JUST_DODGE_RADIUS) == 0x0000CC, "Member 'UPlayerJustDodgeComponent::JUST_DODGE_RADIUS' has a wrong offset!");
static_assert(offsetof(UPlayerJustDodgeComponent, JUST_DODGE_RADIUS_RANGEATTACK) == 0x0000D0, "Member 'UPlayerJustDodgeComponent::JUST_DODGE_RADIUS_RANGEATTACK' has a wrong offset!");

// Class BattlePrototype.PlayerManager
// 0x0168 (0x0398 - 0x0230)
class APlayerManager : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARSCharacterBase*>               _playerList;                                       // 0x0238(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ARSCharacterBase*>               _extraPlayerList;                                  // 0x0248(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_258[0x1];                                      // 0x0258(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EPlayerID                                     _BattleMemberMain;                                 // 0x0259(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPlayerID                                     _BattleMemberLeft;                                 // 0x025A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPlayerID                                     _BattleMemberRight;                                // 0x025B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerInfo>                    _partyInfoList;                                    // 0x0260(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FCharactersParameterTable>      _partyParameterTableList;                          // 0x0270(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDelayLoadPlayerEquipData>      _delayLoadList;                                    // 0x0280(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             DispatchEquipWeaponDelegate;                       // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchEquipCostumeDelegate;                      // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FPartyPlayerCacheData>          _partyPlayerCache;                                 // 0x02B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             DispatchChangeDisableBattleActionFlag;             // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x3C];                                     // 0x02D0(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bNpcThinkAssistAttack;                             // 0x030C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30D[0x8B];                                     // 0x030D(0x008B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPartyMember(const struct FPlayerInfo& Info, const bool IsSaveDataLoadFlow);
	void AddPartyMemberByPreset(const struct FAddPartyPresetData& Preset, const bool IsCheckBattleMemberMain, bool bNotEquipSAS);
	void AllDestroyPlayerCharacter();
	void AllPlayerCharacterTickStop();
	float CalcLevelDifferentExpRate(int32 DifferentLevel);
	void ChangePlayerCharacter(ERSPartyPlayerKind Type, TSubclassOf<class ARSCharacterBase> PlayerClass);
	bool CheckRareArrangeItem();
	void ClearPartyMember();
	void ClearPlayerInfoBadStatus(EPlayerID ID);
	void ClearPlayerInfoDrive(EPlayerID ID);
	void ClearPlayerUseInfo();
	class ARSCharacterBase* CreatePlayerCharacter(ERSPartyPlayerKind Type, TSubclassOf<class ARSCharacterBase> PlayerClass, const struct FVector& Location, const struct FRotator& Rotation);
	class ARSCharacterBase* CreatePlayerCharacterFromID(ERSPartyPlayerKind Type, EPlayerID ID, const struct FVector& Location, const struct FRotator& Rotation);
	void CreatePlayerCharacters(const class FString& PlayerStartName);
	void DebugDrawKeepOutArea();
	void DelayLoadPlayerEquip();
	void DestroyPlayerCharacter(ERSPartyPlayerKind Type);
	void DestroyPlayerCharacters();
	void EquipAccessory(EPlayerID ID, EPlayerAccessory Index_0, int32 AccessoryId, bool bTempEquip);
	void EquipAttachment(EPlayerID ID, EPlayerAttachment Index_0, int32 AttachmentId);
	void EquipCostume(EPlayerID ID, int32 CostumeId);
	void EquipWeapon(EPlayerID ID, int32 WeaponId, bool bTempEquip);
	void EventCutSceneAfterFunc();
	void EventRemvoeMembers(const TArray<EPlayerID>& IgnoreActorList, bool bDisableSAS);
	void EventReviveBattleMember();
	bool GetAccessoryEffect(float* OutValue, EPlayerID ID, EEffecacyType EffectType);
	int32 GetAccessoryEquipNum(EPlayerID PlayerId);
	class ARSCharacterBase* GetBattleMemberActorFromID(EPlayerID ID);
	class ARSCharacterBase* GetBattleMemberActorFromKind(ERSPartyPlayerKind Kind);
	EPlayerID GetBattleMemberPlayerID(ERSPartyPlayerKind Kind);
	TArray<class ARSCharacterBase*> GetExtraPlayerList();
	int32 GetNpcAssistCountBadStatus();
	int32 GetNpcAssistCountHP();
	int32 GetNpcAssistCountRevive();
	TArray<struct FPlayerInfo> GetPartyInfoList();
	struct FPartyPlayerCacheData GetPartyPlayerCache(EPlayerID ID);
	TSoftClassPtr<class UClass> GetPlayerBPSoftRef(EPlayerID PlayerId, bool bENPC, bool bMetamorphosis);
	bool GetPlayerCharacterParam(ERSPartyPlayerKind Type, struct FVector* Location, struct FRotator* Rotation);
	void GetPlayerWeaponActorListFromNative(class AActor* OwnerPlayer, EGetPlayerWeaponType Type, TArray<class AActor*>* WeaponList);
	void InitializeAll(const bool IsNoResetPartyInfo);
	bool IsCreatePlayerCharacters();
	bool IsDriveUsedFlag();
	bool IsExistBattleMember(EPlayerID ID);
	bool IsPlayerInputTrgBrainField();
	bool IsPlayerStatus(ERSPartyPlayerKind Kind, EPlayerCommonStatus PlayerStatus);
	void KpiAddNpcSupportAttack(EPlayerID ID);
	void KpiAddNpcSupportBrainField(EPlayerID ID);
	void KpiAddNpcSupportCover(EPlayerID ID);
	void KpiAddNpcSupportRevive(EPlayerID ID);
	void LocationChangeParameterReset();
	void MainPlayerAccessoryBackup(EPlayerID PlayerId);
	void PlayerSetting(ERSPartyPlayerKind Kind, class ARSCharacterBase* Player);
	class ARSCharacterBase* ProtectedSpawnNotPartyPlayer(TSubclassOf<class ARSCharacterBase> PlayerClass, const struct FTransform& Transform, class AActor* CreateOwner);
	int32 ReCalcRemainingSkillPoint(EPlayerID ID);
	void RecoveryReserveMemberBadStatus();
	void RecoveryReserveMemberHP();
	void ReflectBattleMemberParameter();
	void ReflectBattleMemberParameterPersonal(EPlayerID PlayerId);
	void RegisterExtraPlayer(class ARSCharacterBase* ExtraPlayer);
	void RegisterKeepOutAreaBox(int32* OutRegisterId, const struct FVector& InMin, const struct FVector& InMax);
	void RegisterKeepOutAreaCircle(int32* OutRegisterId, const struct FVector& Location, float Radius);
	void RemovePartyMember(EPlayerID ID, bool bDestroy, bool bDequipAttachment, bool bDefaultCostume);
	void ReturnEventRemvoeMembers();
	void ReturnPartyMember(EPlayerID ID, const bool IsCheckBattleMemberMain);
	void SetBattleEndReserveMemberStatus(float ReviveHPRate);
	void SetBattleMember(ERSPartyPlayerKind Kind, EPlayerID ID, bool bSpawn);
	bool SetBattleMemberCore(ERSPartyPlayerKind Kind, EPlayerID ID, bool bSpawn);
	void SetBattleMemberToEmpty(EPlayerID ID);
	void SetDisableBattleActionFlag(bool bDisable);
	void SetDriveUsedFlag(bool bFlag);
	void SetLevelDifferentExpRate(const struct FLevelDifferentExpRateData& Data);
	void SetPartyMemberInfo(EPlayerID ID, const struct FPlayerInfo& Info, bool bDelayLoad);
	void SetPlayerAIOrder(EPlayerID ID, EPlayerAIOrder Order);
	void SetPlayerParameter(EPlayerID ID, const struct FCharactersParameterTable& Table, bool bMaxHP);
	void SwapPartyMemberInfo(int32 First, int32 Second);
	void UnregisterExtraPlayer(class ARSCharacterBase* ExtraPlayer);
	void UnregisterKeepOutArea(int32 RegisterId);
	void UpdateLastSallyTime(EPlayerID ID, const int32 PlayBrainTalkTimeMin);
	void UpdateLastUseSasTime(EPlayerID ID, const bool IsPlayBrainTalk);
	struct FCharactersParameterTable UpdatePlayerParameter(EPlayerID PlayerId, bool bMaxHP);
	void UpdatLastNoSallyTime(EPlayerID ID, const int32 PlayBrainTalkTimeMin);

	struct FCharactersParameterTable GetCharactersParameterTable(EPlayerID ID) const;
	struct FPlayerInfo GetPartyMemberInfo(EPlayerID ID) const;
	class ARSCharacterBase* GetPlayer(ERSPartyPlayerKind Kind) const;
	const TArray<class ARSCharacterBase*> GetPlayerList() const;
	int32 GetPlayerNum() const;
	int32 GetPlayerUseCount(EPlayerID ID) const;
	float GetPlayerUseTime(EPlayerID ID) const;
	bool IsDisableBattleActionFlag() const;
	bool IsExecNpcReviveDirection_CallFromCPP() const;
	bool IsExecResurrect_CallFromCPP() const;
	bool IsExistPartyMember(EPlayerID ID) const;
	bool IsNpcThinkAssistAttackCPP() const;
	bool IsPlayingDead_CallFromCPP() const;
	bool IsPlayingDeadRecover_CallFromCPP() const;
	bool IsPlayingRecover_CallFromCPP() const;
	bool NeedsStatusAssist() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerManager">();
	}
	static class APlayerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerManager>();
	}
};
static_assert(alignof(APlayerManager) == 0x000008, "Wrong alignment on APlayerManager");
static_assert(sizeof(APlayerManager) == 0x000398, "Wrong size on APlayerManager");
static_assert(offsetof(APlayerManager, _playerList) == 0x000238, "Member 'APlayerManager::_playerList' has a wrong offset!");
static_assert(offsetof(APlayerManager, _extraPlayerList) == 0x000248, "Member 'APlayerManager::_extraPlayerList' has a wrong offset!");
static_assert(offsetof(APlayerManager, _BattleMemberMain) == 0x000259, "Member 'APlayerManager::_BattleMemberMain' has a wrong offset!");
static_assert(offsetof(APlayerManager, _BattleMemberLeft) == 0x00025A, "Member 'APlayerManager::_BattleMemberLeft' has a wrong offset!");
static_assert(offsetof(APlayerManager, _BattleMemberRight) == 0x00025B, "Member 'APlayerManager::_BattleMemberRight' has a wrong offset!");
static_assert(offsetof(APlayerManager, _partyInfoList) == 0x000260, "Member 'APlayerManager::_partyInfoList' has a wrong offset!");
static_assert(offsetof(APlayerManager, _partyParameterTableList) == 0x000270, "Member 'APlayerManager::_partyParameterTableList' has a wrong offset!");
static_assert(offsetof(APlayerManager, _delayLoadList) == 0x000280, "Member 'APlayerManager::_delayLoadList' has a wrong offset!");
static_assert(offsetof(APlayerManager, DispatchEquipWeaponDelegate) == 0x000290, "Member 'APlayerManager::DispatchEquipWeaponDelegate' has a wrong offset!");
static_assert(offsetof(APlayerManager, DispatchEquipCostumeDelegate) == 0x0002A0, "Member 'APlayerManager::DispatchEquipCostumeDelegate' has a wrong offset!");
static_assert(offsetof(APlayerManager, _partyPlayerCache) == 0x0002B0, "Member 'APlayerManager::_partyPlayerCache' has a wrong offset!");
static_assert(offsetof(APlayerManager, DispatchChangeDisableBattleActionFlag) == 0x0002C0, "Member 'APlayerManager::DispatchChangeDisableBattleActionFlag' has a wrong offset!");
static_assert(offsetof(APlayerManager, bNpcThinkAssistAttack) == 0x00030C, "Member 'APlayerManager::bNpcThinkAssistAttack' has a wrong offset!");

// Class BattlePrototype.PlayerMaterialAccessorComponent
// 0x0000 (0x0360 - 0x0360)
class UPlayerMaterialAccessorComponent : public UMaterialAccessorComponent
{
public:
	void SetCable(class AActor* Player);
	void SetPlayerMesh(class USkeletalMeshComponent* PlayerMesh);
	void SetupDefaultParameter(class ACharacter* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerMaterialAccessorComponent">();
	}
	static class UPlayerMaterialAccessorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerMaterialAccessorComponent>();
	}
};
static_assert(alignof(UPlayerMaterialAccessorComponent) == 0x000008, "Wrong alignment on UPlayerMaterialAccessorComponent");
static_assert(sizeof(UPlayerMaterialAccessorComponent) == 0x000360, "Wrong size on UPlayerMaterialAccessorComponent");

// Class BattlePrototype.PlayerMeshSetupComponent
// 0x0010 (0x00D0 - 0x00C0)
class UPlayerMeshSetupComponent final : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoSetup(class UMeshComponent* Mesh, TSubclassOf<class UPlayerRenderSettings> RenderSettingsClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerMeshSetupComponent">();
	}
	static class UPlayerMeshSetupComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerMeshSetupComponent>();
	}
};
static_assert(alignof(UPlayerMeshSetupComponent) == 0x000008, "Wrong alignment on UPlayerMeshSetupComponent");
static_assert(sizeof(UPlayerMeshSetupComponent) == 0x0000D0, "Wrong size on UPlayerMeshSetupComponent");

// Class BattlePrototype.PlayerRessurectComponent
// 0x0048 (0x0108 - 0x00C0)
class UPlayerRessurectComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             DispatchResurrectSuccess;                          // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         RessurectTime;                                     // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreaseTimeRate;                                  // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RessurectRange;                                    // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RessurectHeight;                                   // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RessurectAngle;                                    // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IconOffsetZ;                                       // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x20];                                      // 0x00E8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateRessurectIcon(class AActor* DeadPlayer);
	void BeginRessurect(float TimeRate);
	void DeactivateRessurectIcon();
	float GetDistanceSquared2D();
	class UUIResurrectionGauge* GetUI();
	bool IsEnableRessurect();
	bool IsExecRessurect();
	void SetVisibleWidget(bool Visible);
	void SuspendRessurect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerRessurectComponent">();
	}
	static class UPlayerRessurectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerRessurectComponent>();
	}
};
static_assert(alignof(UPlayerRessurectComponent) == 0x000008, "Wrong alignment on UPlayerRessurectComponent");
static_assert(sizeof(UPlayerRessurectComponent) == 0x000108, "Wrong size on UPlayerRessurectComponent");
static_assert(offsetof(UPlayerRessurectComponent, DispatchResurrectSuccess) == 0x0000C0, "Member 'UPlayerRessurectComponent::DispatchResurrectSuccess' has a wrong offset!");
static_assert(offsetof(UPlayerRessurectComponent, RessurectTime) == 0x0000D0, "Member 'UPlayerRessurectComponent::RessurectTime' has a wrong offset!");
static_assert(offsetof(UPlayerRessurectComponent, DecreaseTimeRate) == 0x0000D4, "Member 'UPlayerRessurectComponent::DecreaseTimeRate' has a wrong offset!");
static_assert(offsetof(UPlayerRessurectComponent, RessurectRange) == 0x0000D8, "Member 'UPlayerRessurectComponent::RessurectRange' has a wrong offset!");
static_assert(offsetof(UPlayerRessurectComponent, RessurectHeight) == 0x0000DC, "Member 'UPlayerRessurectComponent::RessurectHeight' has a wrong offset!");
static_assert(offsetof(UPlayerRessurectComponent, RessurectAngle) == 0x0000E0, "Member 'UPlayerRessurectComponent::RessurectAngle' has a wrong offset!");
static_assert(offsetof(UPlayerRessurectComponent, IconOffsetZ) == 0x0000E4, "Member 'UPlayerRessurectComponent::IconOffsetZ' has a wrong offset!");

// Class BattlePrototype.PlayerScriptComponent
// 0x0630 (0x06F0 - 0x00C0)
class UPlayerScriptComponent final : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x90];                                      // 0x00C0(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSASEffectState                        SAS_Fire;                                          // 0x0150(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_Metal;                                         // 0x0168(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_SeeThrough;                                    // 0x0180(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_Telepo;                                        // 0x0198(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_Stealth;                                       // 0x01B0(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_Electric;                                      // 0x01C8(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_Copy;                                          // 0x01E0(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_Accelerator;                                   // 0x01F8(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_Psychic_ch0100;                                // 0x0210(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_Psychic_ch0200;                                // 0x0228(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_Invalid;                                       // 0x0240(0x0018)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0x80];                                     // 0x0258(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        _LocationHistroy;                                  // 0x02D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ConfusionStickParam_InputTimeMin;                  // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionStickParam_InputTimeMax;                  // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionStickParam_IntervalMin;                   // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionStickParam_IntervalMax;                   // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionAttackParam_IntervalMin;                  // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionAttackParam_IntervalMax;                  // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionAttackParam_Rate;                         // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionPsychicParam_Rate;                        // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x28];                                     // 0x0308(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchSkillRegenerateHP;                         // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_340[0x18];                                     // 0x0340(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NeonNotifyTimeMax;                                 // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URSParticleSystemComponentBase> NeonNotifyParticleComponentClass;                  // 0x0360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        NeonNotifyParticle_DriveMax;                       // 0x0368(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        NeonNotifyParticle_Dying;                          // 0x0370(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        NeonNotifyParticle_ActionFailed;                   // 0x0378(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NeonNotifyParticleAttach_SocketName;               // 0x0380(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NeonNotifyParticleAttach_Offset;                   // 0x0388(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_394[0x14];                                     // 0x0394(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchUpdateBrainField;                          // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchBrainFieldState;                           // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchBrainFieldIntervalEnd;                     // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchLunaticBrainTalk;                          // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchBrainFieldPsychicGaugeChange;              // 0x03E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F8[0x168];                                    // 0x03F8(0x0168)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBrainFieldPsychicGaugeDirectionData> PsychicGaugeDirectionData;                         // 0x0560(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_570[0x10];                                     // 0x0570(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPlayerID>                             BrainFieldHelpedPlayerList;                        // 0x0580(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_590[0xF8];                                     // 0x0590(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchBrainTalkHitCount;                         // 0x0688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         Param_BrainTalkHitCount;                           // 0x0698(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param_BrainTalkHitCountClearIntarval;              // 0x069C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<E_SASKindNative>                       BrainTalkHitCountCheckSASList;                     // 0x06A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B0[0x10];                                     // 0x06B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AvoidWallCountMax;                                 // 0x06C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StagnationCheckLocationThreshold;                  // 0x06C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StagnationResetTime;                               // 0x06C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6CC[0x24];                                     // 0x06CC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ActionState_CommonTransition(EPlayerActionKind* NextAction, int32* NextParam);
	void AddActionStatus(EPlayerActionStatus Status);
	void AddBrainFieldHelpExtraTime();
	void AddFlyingDodgeCount();
	void AddPlayerStatus(EPlayerCommonStatus Status);
	void AddUpperActionStatus(EPlayerUpperActionStatus Status);
	void ApplySASEffectActive(E_SASKindNative Kind, bool bActivate);
	void ApplySASEffectPassive(E_SASKindNative Kind);
	void ApplySASEffectPassiveAll();
	void ApplySASEffectPassiveAllLinkAble();
	void BeginBrainField();
	void BeginConfusionStick();
	void BeginNeonNotify(EPlayerNeonNotifyType Type);
	void BrainTalk_AddHitCount(bool bNoDamage);
	void BrainTalk_CheckSASHitCount(bool bCheck, E_SASKindNative Kind);
	void BrainTalk_ClearHitCount();
	bool CalcAccumulationByAttack_ForPlayer(float& RefWince, float& RefKnockback, float& RefDown, float& RefLaunch, float& RefFlame, float& RefElectric, float& RefFlooded, float& RefOil, float& RefConfusion, float& RefCrashScale, class AActor* DefenseActor, EHCSkillAttackType AttackType, bool bCopyActor, float COPY_REACTION_RATE, float COPY_BADSTATUS_RATE);
	bool CalcAccumulationByDefence_ForPlayer(float& RefWince, float& RefKnockback, float& RefDown, float& RefLaunch, float& RefFlame, float& RefElectric, float& RefFlooded, float& RefOil, float& RefConfusion, float& RefCrashScale, class AActor* AttackActor, bool IsSuperArmor);
	float CalcCritical_ForPlayer(float Critical, class AActor* DefenseActor, bool IsEnpc, class AActor* TargetActor);
	bool CalcDamageByAttack_ForHero(float& RefPhysicsDamage, float& RefObjDamage, float& RefFlameDamage, float& RefElectricDamage, float& RefCriticalDamageRate, class AActor* DefenseActor);
	float CalcFinalDamageByAttack_ForHero(float Damage, class AActor* DefenseActor, const struct FHCSkillCommonInfo& SkillInfo, bool bSkill_PinchStatusUp, float Skill_DownDamageUp, float Skill_PinchAttackUpRate);
	float CalcFinalDamageByAttack_ForPlayer(float Damage, class AActor* DefenseActor, const struct FHCSkillCommonInfo& SkillInfo, float COPY_ATTACK_RATE, float NPC_ATTACK_DAMAGE_RATE);
	float CalcFinalDamageByDefence_ForHero(float Damage, class AActor* AttackActor, bool bSkill_PinchStatusUp, float Skill_PinchDamageDownRate, float Skill_BrainFieldDamageCut);
	float CalcFinalDamageByDefence_ForPlayer(float Damage, class AActor* AttackActor, float NPC_DEFENCE_DAMAGE_RATE);
	EPlayerID CheckBrainFieldHelpPlayer();
	TArray<EFindTargetBrainTalkType> CheckFindBrainTalk(class ARSCharacterBase* TargetActor);
	void ClearActionStatus();
	void ClearExcludeLotPlayer(EFriendLotType LotType);
	void ClearFlyingDodgeCount();
	void ClearPlayerStatus();
	void ClearUpperActionStatus();
	void DebugBrainFieldHelpForceSuccess(bool bSet);
	void DebugBrainFieldHelpPlayerFix(EPlayerID FixPlayerID);
	void DebugCoverDamagePrintLog(bool bOutput);
	void DebugInfiniteBrainField(bool bSet);
	void DebugLotPlayerTest(EFriendLotType LotType, int32 Count);
	void DebugNoBrainFieldHelp(bool bSet);
	void DisableBrainFieldLunaticBrainTalk(bool bDisable);
	void DisableRegenerateHP();
	void EnableRegenerateHP(float RegenerateHPRate, float IntervalTime);
	void EndBrainField();
	void EndConfusionStick();
	void EndNeonNotify();
	void EventDirectBrainFieldWarning();
	void ExcludeLotPlayer(EPlayerID ID, EFriendLotType LotType);
	void ForceSettingConfusionStick(float InputTime);
	float GetBrainFieldGameOverTimeRate();
	class FName GetBrainFieldHelpBrainTalkID();
	float GetBrainFieldRemainTime();
	float GetBrainFieldTimeRate();
	int32 GetBrainFieldWarningCount();
	void GetConfusionStickInput(bool* bOverwriteInput, struct FVector2D* StickInput);
	bool GetIsDead_Native();
	TArray<struct FVector> GetLocationHistory();
	struct FSASEffectState GetSASEffectState(E_SASKindNative Kind);
	void Initialize(bool bNpc, class UCharacterMovementComponent* CharaMoveComp, class UPlayerAnimControllerComponent* AnimControllerComp, class UCharactersParameterComponent* CharactersParameterComp, class URSStateManageComponent* StateManageComp, class URSStateManageComponent* UpperStateManageComp, class UPlayerInputBaseComponent* PlayerInputComp, class UAttackInputComponent* AttackInputComp, class UPlayerAsyncScriptComponent* PlayerAsyncComp, class UMoveInputComponent* MoveInputComp, class UPlayerCameraComponent* PlayerCameraComp);
	bool IsActiveBrainFieldGameOverTimer();
	bool LotAssassinAttackLevelOffset(EAssassinAttackHit EffectiveType, int32 OwnerLevel, int32 TargetLevel, bool bSeeThrough, const struct FAssassinAttackData& CalcData);
	EPlayerID LotFriendPlayer(EFriendLotType LotType, bool bDebugSuccess);
	void MainTick(float DeltaSeconds);
	void NextBrainFieldState();
	void OnBeginAvoidWall(const struct FVector& InLocation);
	bool OverwriteAttackCollisionInfo_ForHero(struct FHCCollisionCommonInfo& RefCommonInfo, struct FHCSkillCommonInfo& RefSkill, float SkillWeaponCrashScale, float SkillPsychicCrashScale, float SkillDriveCrashScale, float NPC_HERO_CRASH_RATE, bool bExJustDodgeFlag, float ExJustDodgeAttackRate, float ExJustDodgeCrashRate, float Skill_AerialAttackPsychicGaugeUp);
	bool OverwriteAttackCollisionInfo_ForPlayer(struct FHCCollisionCommonInfo& RefCommonInfo, struct FHCSkillCommonInfo& RefSkill, bool bAddTelepoAttack);
	void PauseBrainFieldTimer(bool bPause);
	void PostTick(float DeltaSeconds);
	void PreTick(float DeltaSeconds);
	void ResetHistory();
	void ResetStagnation();
	void SetAttackFlyingEnd();
	void SetBattling(bool bBattle);
	void SetBrainFieldData(const struct FPlayerBrainFieldData& InData, const struct FPlayerBrainFieldData& InFirstBrainFieldData, const struct FPlayerBrainFieldHelpData& InHelpData, const TArray<struct FBrainFieldPsychicGaugeDirectionData>& PsychicGaugeData);
	void SetBrainFieldExtraTime(float ExtraTime);
	void SetBrainFieldState(EPlayerBrainFieldState State);
	void SetFlyingActionLimitDistance(float LimitDistance);
	void SetIgnoreFallTimer(float IgnoreTime);
	void SetLotFriendData(EFriendLotType LotType, const struct FFriendLotData& Data);
	void SetMaxFlyingDodgeCount(int32 Count);
	void SetPauseTimer(bool bPause);
	void SetRestrictStagnationCheck(bool bRestrict);
	void SetRunSpeedRate(float InRate);
	void SubActionStatus(EPlayerActionStatus Status);
	void SubPlayerStatus(EPlayerCommonStatus Status);
	void SubUpperActionStatus(EPlayerUpperActionStatus Status);
	void UpdateBrainField(float DeltaSeconds);
	void UpdateBrainFieldInterval(float DeltaSeconds);
	void UpdateCameraRotate(float DeltaSeconds, const struct FVector2D& FixCameraLeftStick, bool bLockTarget, bool bDisableCameraControl, bool bUseCutCamera, bool bUniqueObjectInput);
	void UpdateDisableAction();
	void UpdateEnableActionCommon();
	void UpdateMoveInputTrigger(bool bEnableAddMove, float MaxSpeedScale, float MoveInputScale, float MoveDeadEndDistance);

	float CalcAccessoryBadStatusRate(float Value, float Rate) const;
	EPlayerBrainFieldDanger GetBrainFieldDangerLV() const;
	EPlayerID GetBrainFieldHelpPlayer() const;
	EPlayerBrainFieldState GetBrainFieldState() const;
	struct FRotator GetCameraRotation() const;
	void GetPlayerAccessoryEffect(EEffecacyType EffectType, bool* bOutEquip, float* OutParam) const;
	class UPlayerAnimControllerComponent* GetPlayerAnimController() const;
	struct FVector GetRecentAverageVelocity() const;
	const struct FSASEffectState GetSASEffectStateConst(E_SASKindNative Kind) const;
	bool IsActionStatus(EPlayerActionStatus Status) const;
	bool IsActiveSAS(E_SASKindNative Kind) const;
	bool IsBattling() const;
	bool IsBossBattle() const;
	bool IsBrainFieldInterval() const;
	bool IsDisableAction() const;
	bool IsDisableActionDodge(bool bIgnoreBadStatus) const;
	bool IsEnableActionAttack() const;
	bool IsEnableActionBrainCrash() const;
	bool IsEnableActionBrainFieldClose() const;
	bool IsEnableActionBrainFieldOpen() const;
	bool IsEnableActionChangeBattle() const;
	bool IsEnableActionCommon() const;
	bool IsEnableActionDamage() const;
	bool IsEnableActionDodge(bool bIgnoreBadStatus) const;
	bool IsEnableActionIdleWalkRun(bool bIgnoreExecTelepo) const;
	bool IsEnableActionJump() const;
	bool IsEnableActionPsychic(bool bPsychicEx) const;
	bool IsEnableActionSprint() const;
	bool IsEnableActionUseItem() const;
	bool IsEnableDriveFullDirection() const;
	bool IsEnableNpcAssist() const;
	bool IsEnableSAS() const;
	void IsEnableSASEffect(E_SASKindNative Kind, ESASEffect Effect, bool* OutEnable, float* OutParam0, float* OutParam1, float* OutParam2, float* OutParam3) const;
	bool IsInitializedSASEffectFixParam(E_SASKindNative Kind) const;
	bool IsPlayerInAerial() const;
	bool IsPlayerStatus(EPlayerCommonStatus Status) const;
	bool IsRestrictStagnationCheck() const;
	bool IsRunningAnimStateForAIMove() const;
	bool IsRunOrSprint() const;
	bool IsSearchAbleActionIcon() const;
	bool IsStagnation(bool bCheckLocation, const struct FVector& InCurrentLocation) const;
	bool IsUpperActionStatus(EPlayerUpperActionStatus Status) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerScriptComponent">();
	}
	static class UPlayerScriptComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerScriptComponent>();
	}
};
static_assert(alignof(UPlayerScriptComponent) == 0x000008, "Wrong alignment on UPlayerScriptComponent");
static_assert(sizeof(UPlayerScriptComponent) == 0x0006F0, "Wrong size on UPlayerScriptComponent");
static_assert(offsetof(UPlayerScriptComponent, SAS_Fire) == 0x000150, "Member 'UPlayerScriptComponent::SAS_Fire' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_Metal) == 0x000168, "Member 'UPlayerScriptComponent::SAS_Metal' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_SeeThrough) == 0x000180, "Member 'UPlayerScriptComponent::SAS_SeeThrough' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_Telepo) == 0x000198, "Member 'UPlayerScriptComponent::SAS_Telepo' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_Stealth) == 0x0001B0, "Member 'UPlayerScriptComponent::SAS_Stealth' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_Electric) == 0x0001C8, "Member 'UPlayerScriptComponent::SAS_Electric' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_Copy) == 0x0001E0, "Member 'UPlayerScriptComponent::SAS_Copy' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_Accelerator) == 0x0001F8, "Member 'UPlayerScriptComponent::SAS_Accelerator' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_Psychic_ch0100) == 0x000210, "Member 'UPlayerScriptComponent::SAS_Psychic_ch0100' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_Psychic_ch0200) == 0x000228, "Member 'UPlayerScriptComponent::SAS_Psychic_ch0200' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_Invalid) == 0x000240, "Member 'UPlayerScriptComponent::SAS_Invalid' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, _LocationHistroy) == 0x0002D8, "Member 'UPlayerScriptComponent::_LocationHistroy' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, ConfusionStickParam_InputTimeMin) == 0x0002E8, "Member 'UPlayerScriptComponent::ConfusionStickParam_InputTimeMin' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, ConfusionStickParam_InputTimeMax) == 0x0002EC, "Member 'UPlayerScriptComponent::ConfusionStickParam_InputTimeMax' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, ConfusionStickParam_IntervalMin) == 0x0002F0, "Member 'UPlayerScriptComponent::ConfusionStickParam_IntervalMin' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, ConfusionStickParam_IntervalMax) == 0x0002F4, "Member 'UPlayerScriptComponent::ConfusionStickParam_IntervalMax' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, ConfusionAttackParam_IntervalMin) == 0x0002F8, "Member 'UPlayerScriptComponent::ConfusionAttackParam_IntervalMin' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, ConfusionAttackParam_IntervalMax) == 0x0002FC, "Member 'UPlayerScriptComponent::ConfusionAttackParam_IntervalMax' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, ConfusionAttackParam_Rate) == 0x000300, "Member 'UPlayerScriptComponent::ConfusionAttackParam_Rate' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, ConfusionPsychicParam_Rate) == 0x000304, "Member 'UPlayerScriptComponent::ConfusionPsychicParam_Rate' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, DispatchSkillRegenerateHP) == 0x000330, "Member 'UPlayerScriptComponent::DispatchSkillRegenerateHP' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, NeonNotifyTimeMax) == 0x000358, "Member 'UPlayerScriptComponent::NeonNotifyTimeMax' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, NeonNotifyParticleComponentClass) == 0x000360, "Member 'UPlayerScriptComponent::NeonNotifyParticleComponentClass' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, NeonNotifyParticle_DriveMax) == 0x000368, "Member 'UPlayerScriptComponent::NeonNotifyParticle_DriveMax' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, NeonNotifyParticle_Dying) == 0x000370, "Member 'UPlayerScriptComponent::NeonNotifyParticle_Dying' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, NeonNotifyParticle_ActionFailed) == 0x000378, "Member 'UPlayerScriptComponent::NeonNotifyParticle_ActionFailed' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, NeonNotifyParticleAttach_SocketName) == 0x000380, "Member 'UPlayerScriptComponent::NeonNotifyParticleAttach_SocketName' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, NeonNotifyParticleAttach_Offset) == 0x000388, "Member 'UPlayerScriptComponent::NeonNotifyParticleAttach_Offset' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, DispatchUpdateBrainField) == 0x0003A8, "Member 'UPlayerScriptComponent::DispatchUpdateBrainField' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, DispatchBrainFieldState) == 0x0003B8, "Member 'UPlayerScriptComponent::DispatchBrainFieldState' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, DispatchBrainFieldIntervalEnd) == 0x0003C8, "Member 'UPlayerScriptComponent::DispatchBrainFieldIntervalEnd' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, DispatchLunaticBrainTalk) == 0x0003D8, "Member 'UPlayerScriptComponent::DispatchLunaticBrainTalk' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, DispatchBrainFieldPsychicGaugeChange) == 0x0003E8, "Member 'UPlayerScriptComponent::DispatchBrainFieldPsychicGaugeChange' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, PsychicGaugeDirectionData) == 0x000560, "Member 'UPlayerScriptComponent::PsychicGaugeDirectionData' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, BrainFieldHelpedPlayerList) == 0x000580, "Member 'UPlayerScriptComponent::BrainFieldHelpedPlayerList' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, DispatchBrainTalkHitCount) == 0x000688, "Member 'UPlayerScriptComponent::DispatchBrainTalkHitCount' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, Param_BrainTalkHitCount) == 0x000698, "Member 'UPlayerScriptComponent::Param_BrainTalkHitCount' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, Param_BrainTalkHitCountClearIntarval) == 0x00069C, "Member 'UPlayerScriptComponent::Param_BrainTalkHitCountClearIntarval' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, BrainTalkHitCountCheckSASList) == 0x0006A0, "Member 'UPlayerScriptComponent::BrainTalkHitCountCheckSASList' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, AvoidWallCountMax) == 0x0006C0, "Member 'UPlayerScriptComponent::AvoidWallCountMax' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, StagnationCheckLocationThreshold) == 0x0006C4, "Member 'UPlayerScriptComponent::StagnationCheckLocationThreshold' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, StagnationResetTime) == 0x0006C8, "Member 'UPlayerScriptComponent::StagnationResetTime' has a wrong offset!");

// Class BattlePrototype.PlayerWeaponChargeComponent
// 0x0030 (0x00F0 - 0x00C0)
class UPlayerWeaponChargeComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             DispatchChangeLevel;                               // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<float>                                 ChargeTimeList;                                    // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndCharge();
	void ResetCharge();
	void StartCharge(TArray<float>& TimeList);

	int32 GetChargeLevel() const;
	bool IsCharge() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerWeaponChargeComponent">();
	}
	static class UPlayerWeaponChargeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerWeaponChargeComponent>();
	}
};
static_assert(alignof(UPlayerWeaponChargeComponent) == 0x000008, "Wrong alignment on UPlayerWeaponChargeComponent");
static_assert(sizeof(UPlayerWeaponChargeComponent) == 0x0000F0, "Wrong size on UPlayerWeaponChargeComponent");
static_assert(offsetof(UPlayerWeaponChargeComponent, DispatchChangeLevel) == 0x0000C0, "Member 'UPlayerWeaponChargeComponent::DispatchChangeLevel' has a wrong offset!");
static_assert(offsetof(UPlayerWeaponChargeComponent, ChargeTimeList) == 0x0000D0, "Member 'UPlayerWeaponChargeComponent::ChargeTimeList' has a wrong offset!");

// Class BattlePrototype.DebuggingItemPlayTimeGroup
// 0x0030 (0x0300 - 0x02D0)
class ADebuggingItemPlayTimeGroup final : public ADebuggingItemGroup
{
public:
	TWeakObjectPtr<class ADebuggingItemInt>       TimeInt;                                           // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemInt>       TimeHour;                                          // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemInt>       TimeMinute;                                        // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemInt>       TimeSecond;                                        // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemLabel>     Label;                                             // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserParamManager*                      ParamMan;                                          // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnChangePlayTime(const class ADebuggingItemInt* Item);
	void OnChangePlayTimePartial(const class ADebuggingItemInt* Item);
	void OnExecChangePlayTime(const class ADebuggingItemEvent* Item);
	void UpdateDebugParam();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemPlayTimeGroup">();
	}
	static class ADebuggingItemPlayTimeGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemPlayTimeGroup>();
	}
};
static_assert(alignof(ADebuggingItemPlayTimeGroup) == 0x000008, "Wrong alignment on ADebuggingItemPlayTimeGroup");
static_assert(sizeof(ADebuggingItemPlayTimeGroup) == 0x000300, "Wrong size on ADebuggingItemPlayTimeGroup");
static_assert(offsetof(ADebuggingItemPlayTimeGroup, TimeInt) == 0x0002D0, "Member 'ADebuggingItemPlayTimeGroup::TimeInt' has a wrong offset!");
static_assert(offsetof(ADebuggingItemPlayTimeGroup, TimeHour) == 0x0002D8, "Member 'ADebuggingItemPlayTimeGroup::TimeHour' has a wrong offset!");
static_assert(offsetof(ADebuggingItemPlayTimeGroup, TimeMinute) == 0x0002E0, "Member 'ADebuggingItemPlayTimeGroup::TimeMinute' has a wrong offset!");
static_assert(offsetof(ADebuggingItemPlayTimeGroup, TimeSecond) == 0x0002E8, "Member 'ADebuggingItemPlayTimeGroup::TimeSecond' has a wrong offset!");
static_assert(offsetof(ADebuggingItemPlayTimeGroup, Label) == 0x0002F0, "Member 'ADebuggingItemPlayTimeGroup::Label' has a wrong offset!");
static_assert(offsetof(ADebuggingItemPlayTimeGroup, ParamMan) == 0x0002F8, "Member 'ADebuggingItemPlayTimeGroup::ParamMan' has a wrong offset!");

// Class BattlePrototype.PostProcessManager
// 0x0008 (0x0238 - 0x0230)
class APostProcessManager : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterPostProcess(class UPostProcessComponent* InComponent);
	void UnregisterPostProcess(class UPostProcessComponent* InComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessManager">();
	}
	static class APostProcessManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<APostProcessManager>();
	}
};
static_assert(alignof(APostProcessManager) == 0x000008, "Wrong alignment on APostProcessManager");
static_assert(sizeof(APostProcessManager) == 0x000238, "Wrong size on APostProcessManager");

// Class BattlePrototype.PostProcessParam
// 0x0020 (0x0050 - 0x0030)
class UPostProcessParam final : public UDataAsset
{
public:
	float                                         VisionFogSeeThroughFog;                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionFogSeeThroughFogList_em1020;                 // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionFogSeeThroughFogList_em1200;                 // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionFogSeeThroughFogList_em1210;                 // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionFogSeeThroughFogList_em1300;                 // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionFogSeeThroughFogList_em1400;                 // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionFogSeeThroughFogList_em8300;                 // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionFogSeeThroughFogList_np1100;                 // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessParam">();
	}
	static class UPostProcessParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPostProcessParam>();
	}
};
static_assert(alignof(UPostProcessParam) == 0x000008, "Wrong alignment on UPostProcessParam");
static_assert(sizeof(UPostProcessParam) == 0x000050, "Wrong size on UPostProcessParam");
static_assert(offsetof(UPostProcessParam, VisionFogSeeThroughFog) == 0x000030, "Member 'UPostProcessParam::VisionFogSeeThroughFog' has a wrong offset!");
static_assert(offsetof(UPostProcessParam, VisionFogSeeThroughFogList_em1020) == 0x000034, "Member 'UPostProcessParam::VisionFogSeeThroughFogList_em1020' has a wrong offset!");
static_assert(offsetof(UPostProcessParam, VisionFogSeeThroughFogList_em1200) == 0x000038, "Member 'UPostProcessParam::VisionFogSeeThroughFogList_em1200' has a wrong offset!");
static_assert(offsetof(UPostProcessParam, VisionFogSeeThroughFogList_em1210) == 0x00003C, "Member 'UPostProcessParam::VisionFogSeeThroughFogList_em1210' has a wrong offset!");
static_assert(offsetof(UPostProcessParam, VisionFogSeeThroughFogList_em1300) == 0x000040, "Member 'UPostProcessParam::VisionFogSeeThroughFogList_em1300' has a wrong offset!");
static_assert(offsetof(UPostProcessParam, VisionFogSeeThroughFogList_em1400) == 0x000044, "Member 'UPostProcessParam::VisionFogSeeThroughFogList_em1400' has a wrong offset!");
static_assert(offsetof(UPostProcessParam, VisionFogSeeThroughFogList_em8300) == 0x000048, "Member 'UPostProcessParam::VisionFogSeeThroughFogList_em8300' has a wrong offset!");
static_assert(offsetof(UPostProcessParam, VisionFogSeeThroughFogList_np1100) == 0x00004C, "Member 'UPostProcessParam::VisionFogSeeThroughFogList_np1100' has a wrong offset!");

// Class BattlePrototype.PresentInfoParam
// 0x00A8 (0x00D0 - 0x0028)
class UPresentInfoParam final : public UObject
{
public:
	TMap<EPlayerID, struct FPresentCheckArray>    PresentInfoData_ch0100;                            // 0x0028(0x0050)(NativeAccessSpecifierPrivate)
	TMap<EPlayerID, struct FPresentCheckArray>    PresentInfoData_ch0200;                            // 0x0078(0x0050)(NativeAccessSpecifierPrivate)
	class URSGameInstance*                        GameInstance;                                      // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GetPresentInfoList(EPlayerID SendCharId, EPlayerID RecvCharID, TArray<struct FPresentInfoData>* GetList, bool IncludeEvent);
	bool IsPresentedFirstTime(EPlayerID SendCharId, EPlayerID RecvCharID, class FName ItemId, bool* IsFirstTime);
	void Reset();
	bool UpdatePresentInfo(EPlayerID SendCharId, EPlayerID RecvCharID, class FName ItemId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresentInfoParam">();
	}
	static class UPresentInfoParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPresentInfoParam>();
	}
};
static_assert(alignof(UPresentInfoParam) == 0x000008, "Wrong alignment on UPresentInfoParam");
static_assert(sizeof(UPresentInfoParam) == 0x0000D0, "Wrong size on UPresentInfoParam");
static_assert(offsetof(UPresentInfoParam, PresentInfoData_ch0100) == 0x000028, "Member 'UPresentInfoParam::PresentInfoData_ch0100' has a wrong offset!");
static_assert(offsetof(UPresentInfoParam, PresentInfoData_ch0200) == 0x000078, "Member 'UPresentInfoParam::PresentInfoData_ch0200' has a wrong offset!");
static_assert(offsetof(UPresentInfoParam, GameInstance) == 0x0000C8, "Member 'UPresentInfoParam::GameInstance' has a wrong offset!");

// Class BattlePrototype.ProjectiveGeomBPFunctions
// 0x0000 (0x0028 - 0x0028)
class UProjectiveGeomBPFunctions final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector4 GetDeprojectionMatrix(class APlayerController* PlayerController);
	static struct FVector4 GetViewRect(class APlayerController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectiveGeomBPFunctions">();
	}
	static class UProjectiveGeomBPFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectiveGeomBPFunctions>();
	}
};
static_assert(alignof(UProjectiveGeomBPFunctions) == 0x000008, "Wrong alignment on UProjectiveGeomBPFunctions");
static_assert(sizeof(UProjectiveGeomBPFunctions) == 0x000028, "Wrong size on UProjectiveGeomBPFunctions");

// Class BattlePrototype.PsychicObjectInterface
// 0x0000 (0x0028 - 0x0028)
class IPsychicObjectInterface final : public IInterface
{
public:
	bool CheckPsychicObjectIdC(BattlePrototype::EPsychicObjectID CheckId);
	bool CheckPsychicObjectSimulateC(const struct FVector& PosPly);
	bool GetDebrisEffect(EEffectObjectDebrisType* Type, class UMaterialInterface** OverrideMaterial);
	bool GetDebrisEffectData(class UParticleSystem** ParticleTemplate, class UMaterialInterface** OverrideMaterial);
	bool GetPsychicObjectSimulateControlDistanceSqC(float* DistSq);
	EPsychicObjectSizeType GetPsychicObjectSize();
	struct FVector GetUniqueObjectCameraLookAtPos(float LookAtRate);
	struct FRotator GetUniqueObjectCameraOwnerRotation();
	struct FVector GetUnqObjCamTargetPos();
	struct FVector GetUnqObjMoveVelocity();
	bool InitializeCopyPsychicObject();
	bool IsBrainFieldObjectC();
	bool IsCopyPsychicObject();
	bool IsFloatObjectC();
	bool IsPsychicObjectActiveC();
	bool IsPsychicObjectInUseC();
	bool IsPsychicObjectRegisterableC();
	bool IsPsychicObjectRenderC();
	bool IsPsychicObjectSimulateC();
	bool IsPsychicObjectSimulateControlEnableC();
	bool IsPsychicObjectTickC();
	bool IsSwingType();
	bool IsSwingTypeC();
	bool IsUniqueObject();
	bool IsUniqueObjectC();
	bool RequestEndUniqueObjectState(class AActor* PActor);
	bool ResetPsychicObjectArrangeTransformC();
	bool SetBrainFieldObjectC(bool Flag);
	bool SetDuelPoleType(bool bDuelType);
	void SetMaterialParameter(class FName ParamName, float ParamValue);
	bool SetPsychicObjectActiveC(bool Flag);
	bool SetPsychicObjectEventC(bool bStart, bool bTick, bool bVisibility);
	bool SetPsychicObjectInUseC(bool Flag);
	bool SetPsychicObjectRenderC(bool Flag);
	bool SetPsychicObjectSimulateControlC(bool Flag);
	bool SetPsychicObjectTickC(class FName RefName, bool Flag);
	bool SetSwingTypeC(bool Flag);
	void SetTownSetting(bool Flag);
	bool SetUniqueObjectC(bool Flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsychicObjectInterface">();
	}
	static class IPsychicObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPsychicObjectInterface>();
	}
};
static_assert(alignof(IPsychicObjectInterface) == 0x000008, "Wrong alignment on IPsychicObjectInterface");
static_assert(sizeof(IPsychicObjectInterface) == 0x000028, "Wrong size on IPsychicObjectInterface");

// Class BattlePrototype.PsychicObjectManager
// 0x0248 (0x0478 - 0x0230)
class APsychicObjectManager : public AActor
{
public:
	uint8                                         Pad_230[0x18];                                     // 0x0230(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UClass*>                         PsychicObjectClassList_S;                          // 0x0248(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UClass*>                         PsychicObjectClassList_M;                          // 0x0258(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UClass*>                         PsychicObjectClassList_L;                          // 0x0268(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UClass*>                         PsychicObjectClassList_XL;                         // 0x0278(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UClass*>                         PsychicObjectClassList_XXL;                        // 0x0288(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UClass*>                         PsychicObjectClassList_Swing;                      // 0x0298(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSizeListSkipSwingType;                            // 0x02B8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x1F];                                     // 0x02B9(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UClass*>                         PsychicObjectClassList_Unknown;                    // 0x02D8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FPsychicObjectListInfo> PsychicObjectListByLevel;                          // 0x02F0(0x0050)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_340[0xC];                                      // 0x0340(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchDistanceMinEnemy;                            // 0x034C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSearchCheckTraceEnemy;                            // 0x0350(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0x3];                                      // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchDistanceMinNpc;                              // 0x0354(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSearchCheckTraceNpc;                              // 0x0358(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_359[0x37];                                     // 0x0359(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FocusParamDistList;                                // 0x0390(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 FocusParamDistPointList;                           // 0x03A0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 FocusParamAngleList;                               // 0x03B0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 FocusParamAnglePointList;                          // 0x03C0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D0[0x28];                                     // 0x03D0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugDispSearchScore;                             // 0x03F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDispSearchParam;                             // 0x03F9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDispSearchNpc;                               // 0x03FA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FB[0x7D];                                     // 0x03FB(0x007D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckEnemyObject(bool bUnqObj, bool ChkCapture, bool ChkAttack);
	bool CheckNpcObject(bool bUnqObj, bool bEnemy, bool ChkCapture, bool ChkAttack);
	void ClearPsychicObjectList();
	void DebugCheckPsychicObjectSizeListNum();
	void DebugLog(const class FString& LogString);
	void DebugMultiSphereTraceForObject(TArray<struct FHitResult>* ResultList, const struct FVector& PosS, const struct FVector& Pose, float Radius, bool bDbDraw, bool bDbPrint);
	void DebugPrintPsychicObjectSizeList();
	void DebugPrintRegisterInfo();
	void DebugPrintString(const class FString& LogString);
	TArray<EPsychicObjectSizeType> GetAvailableRegisterSizeArray(int32 Len, const TArray<EPsychicObjectSizeType>& RequestSize);
	class AActor* GetEnemyObject(bool bUnqObj);
	void GetFocusPsychicObject(struct FPsychicObjectFocusResult* Result);
	class AActor* GetNpcObject(bool bUnqObj, bool bEnemy);
	TArray<class AActor*> GetPsychicObjectListByLevelName(const class FName LevelName);
	int32 GetPsychicObjectNumByLevelName(const class FName LevelName);
	class AActor* GetPsychicObjectRegisterActor(int32 Idx);
	int32 GetPsychicObjectRegisterNum();
	class UClass* GetRandomPsychicObjectRegisterClass(EPsychicObjectSizeType ObjSize);
	class UClass* GetRandomSwingTypeObjectRegisterClass();
	bool IsFloatObjectExist();
	bool IsFocusSearchEnable();
	bool IsFocusSearchPause();
	void RegisterMapGimmick(class AActor* PActor, float DistMin);
	void RegisterPsychicObject(class AActor* PsyObjActor);
	void ResetNpcObject(bool bUnqObj, bool bEnemy);
	void ResetPsychicObjectArrangeTransform();
	void SearchEnemyPsychicObject(bool bUnqObj, const struct FVector& ChkPos, struct FPsychicObjectFocusResult* Result);
	void SearchFocusPsychicObject(const struct FVector& ChkPos, const struct FVector& ChkDir, struct FPsychicObjectFocusResult* Result);
	void SearchNpcPsychicObject(bool bUnqObj, bool bEnemy, const struct FVector& ChkPos, struct FPsychicObjectFocusResult* Result);
	bool SetDuelPoleType(bool bDuelType);
	bool SetEnablePsychicObjectRegister(const class FString& RefName, bool Flag);
	void SetEnemySearchID(BattlePrototype::EPsychicObjectID SearchId);
	void SetFocusParameter(const TArray<float>& DistList, const TArray<int32>& DistPointList, const TArray<float>& AngleList, const TArray<int32>& AnglePointList);
	void SetFocusSearchEnable(bool Flag, class FName TagName);
	void SetFocusSearchPause(bool Flag, class FName TagName, bool bResetResult);
	void SetNpcSearchDistanceMin(float Dist);
	void SetPsychicObjectListEventC(bool bStart, bool bTick, bool bVisibility);
	void SetPsychicObjectMaterialDitherParameter(bool bChkDist, float ApplyRadius);
	void SetPsychicObjectMaterialDitherParameterOnce(bool bChkOnce, float ApplyRadius);
	void SetPsychicObjectMaterialValueDither(bool bRestore, float Rate);
	void SetPsychicObjectRegisterSkip(bool Flag);
	void SetPsychicObjectTownSetting(bool Flag);
	void SetSearchComponent(class UPsychicObjectSearchComponent* Comp);
	void SetSearchFocus(bool Flag);
	void UnregisterMapGimmick(class AActor* PActor);
	void UnregisterPsychicObject(class AActor* PsyObjActor);

	bool IsSetSearchComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsychicObjectManager">();
	}
	static class APsychicObjectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<APsychicObjectManager>();
	}
};
static_assert(alignof(APsychicObjectManager) == 0x000008, "Wrong alignment on APsychicObjectManager");
static_assert(sizeof(APsychicObjectManager) == 0x000478, "Wrong size on APsychicObjectManager");
static_assert(offsetof(APsychicObjectManager, PsychicObjectClassList_S) == 0x000248, "Member 'APsychicObjectManager::PsychicObjectClassList_S' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, PsychicObjectClassList_M) == 0x000258, "Member 'APsychicObjectManager::PsychicObjectClassList_M' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, PsychicObjectClassList_L) == 0x000268, "Member 'APsychicObjectManager::PsychicObjectClassList_L' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, PsychicObjectClassList_XL) == 0x000278, "Member 'APsychicObjectManager::PsychicObjectClassList_XL' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, PsychicObjectClassList_XXL) == 0x000288, "Member 'APsychicObjectManager::PsychicObjectClassList_XXL' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, PsychicObjectClassList_Swing) == 0x000298, "Member 'APsychicObjectManager::PsychicObjectClassList_Swing' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, bSizeListSkipSwingType) == 0x0002B8, "Member 'APsychicObjectManager::bSizeListSkipSwingType' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, PsychicObjectClassList_Unknown) == 0x0002D8, "Member 'APsychicObjectManager::PsychicObjectClassList_Unknown' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, PsychicObjectListByLevel) == 0x0002F0, "Member 'APsychicObjectManager::PsychicObjectListByLevel' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, SearchDistanceMinEnemy) == 0x00034C, "Member 'APsychicObjectManager::SearchDistanceMinEnemy' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, bSearchCheckTraceEnemy) == 0x000350, "Member 'APsychicObjectManager::bSearchCheckTraceEnemy' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, SearchDistanceMinNpc) == 0x000354, "Member 'APsychicObjectManager::SearchDistanceMinNpc' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, bSearchCheckTraceNpc) == 0x000358, "Member 'APsychicObjectManager::bSearchCheckTraceNpc' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, FocusParamDistList) == 0x000390, "Member 'APsychicObjectManager::FocusParamDistList' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, FocusParamDistPointList) == 0x0003A0, "Member 'APsychicObjectManager::FocusParamDistPointList' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, FocusParamAngleList) == 0x0003B0, "Member 'APsychicObjectManager::FocusParamAngleList' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, FocusParamAnglePointList) == 0x0003C0, "Member 'APsychicObjectManager::FocusParamAnglePointList' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, bDebugDispSearchScore) == 0x0003F8, "Member 'APsychicObjectManager::bDebugDispSearchScore' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, bDebugDispSearchParam) == 0x0003F9, "Member 'APsychicObjectManager::bDebugDispSearchParam' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, bDebugDispSearchNpc) == 0x0003FA, "Member 'APsychicObjectManager::bDebugDispSearchNpc' has a wrong offset!");

// Class BattlePrototype.PsychicObjectManagerAsyncComponent
// 0x00C8 (0x0198 - 0x00D0)
class UPsychicObjectManagerAsyncComponent : public URSAsyncTaskActorComponent
{
public:
	bool                                          bAsyncTack;                                        // 0x00D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x6F];                                      // 0x00D1(0x006F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTickControlEnable;                                // 0x0140(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSimulateControl;                                  // 0x0141(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTickControlPrevAsync;                             // 0x0142(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTickControlTickAsync;                             // 0x0143(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TickControlDistanceSq;                             // 0x0144(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TickControlActorNum;                               // 0x0148(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TickControlChangeNum;                              // 0x014C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBrainField;                                       // 0x0150(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActorNum;                                          // 0x0154(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ActorIndex;                                        // 0x0158(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15C[0x34];                                     // 0x015C(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRenderCheckEnable;                                // 0x0190(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRenderCheckPrevAsync;                             // 0x0191(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRenderCheckTickAsync;                             // 0x0192(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugPrintTickControl;                            // 0x0193(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* GetRenderCheckActor(int32 Index_0);
	int32 GetRenderCheckActorListLen();
	void RenderCheckPrevAsync();
	void RenderCheckTickAsync();
	void SetRenderCheckActor(bool Flag, class AActor* PActor);
	void SetRenderCheckEnable(bool Flag);
	void SetTickControlBrainField(bool Flag);
	void SetTickControlEnable(bool Flag);
	void SetTickControlParameter(float ActiveDistance, int32 ActorNumPerFrame, int32 ChangeNumPerFrame);
	void SetTickReference(const class FString& RefName, bool Flag);
	void TickControlPrevAsync();
	void TickControlTickAsync();
	void UpdatePlayerPos();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsychicObjectManagerAsyncComponent">();
	}
	static class UPsychicObjectManagerAsyncComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPsychicObjectManagerAsyncComponent>();
	}
};
static_assert(alignof(UPsychicObjectManagerAsyncComponent) == 0x000008, "Wrong alignment on UPsychicObjectManagerAsyncComponent");
static_assert(sizeof(UPsychicObjectManagerAsyncComponent) == 0x000198, "Wrong size on UPsychicObjectManagerAsyncComponent");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bAsyncTack) == 0x0000D0, "Member 'UPsychicObjectManagerAsyncComponent::bAsyncTack' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bTickControlEnable) == 0x000140, "Member 'UPsychicObjectManagerAsyncComponent::bTickControlEnable' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bSimulateControl) == 0x000141, "Member 'UPsychicObjectManagerAsyncComponent::bSimulateControl' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bTickControlPrevAsync) == 0x000142, "Member 'UPsychicObjectManagerAsyncComponent::bTickControlPrevAsync' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bTickControlTickAsync) == 0x000143, "Member 'UPsychicObjectManagerAsyncComponent::bTickControlTickAsync' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, TickControlDistanceSq) == 0x000144, "Member 'UPsychicObjectManagerAsyncComponent::TickControlDistanceSq' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, TickControlActorNum) == 0x000148, "Member 'UPsychicObjectManagerAsyncComponent::TickControlActorNum' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, TickControlChangeNum) == 0x00014C, "Member 'UPsychicObjectManagerAsyncComponent::TickControlChangeNum' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bBrainField) == 0x000150, "Member 'UPsychicObjectManagerAsyncComponent::bBrainField' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, ActorNum) == 0x000154, "Member 'UPsychicObjectManagerAsyncComponent::ActorNum' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, ActorIndex) == 0x000158, "Member 'UPsychicObjectManagerAsyncComponent::ActorIndex' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bRenderCheckEnable) == 0x000190, "Member 'UPsychicObjectManagerAsyncComponent::bRenderCheckEnable' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bRenderCheckPrevAsync) == 0x000191, "Member 'UPsychicObjectManagerAsyncComponent::bRenderCheckPrevAsync' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bRenderCheckTickAsync) == 0x000192, "Member 'UPsychicObjectManagerAsyncComponent::bRenderCheckTickAsync' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bDebugPrintTickControl) == 0x000193, "Member 'UPsychicObjectManagerAsyncComponent::bDebugPrintTickControl' has a wrong offset!");

// Class BattlePrototype.PsychicObjectSearchInterface
// 0x0000 (0x0028 - 0x0028)
class IPsychicObjectSearchInterface final : public IInterface
{
public:
	bool GetSearchHeight(float* HeightMin, float* HeightMax);
	int32 GetSearchPoint();
	struct FVector GetSearchPos();
	float GetSearchRadius();
	float GetSearchSizeValue();
	bool IsSearchable();
	bool IsSearchMapGimmick();
	bool IsSearchUnique();
	bool IsSkipCheckRendered();
	bool SetEffectFocus(bool Flag);
	void SetSearchPoint(int32 Point);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsychicObjectSearchInterface">();
	}
	static class IPsychicObjectSearchInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPsychicObjectSearchInterface>();
	}
};
static_assert(alignof(IPsychicObjectSearchInterface) == 0x000008, "Wrong alignment on IPsychicObjectSearchInterface");
static_assert(sizeof(IPsychicObjectSearchInterface) == 0x000028, "Wrong size on IPsychicObjectSearchInterface");

// Class BattlePrototype.PsychokinesisedComponent
// 0x0000 (0x00C0 - 0x00C0)
class UPsychokinesisedComponent final : public UActorComponent
{
public:
	static void GetAxisAndAngleFromRotator(struct FVector* Axis, float* AngleDegree, const struct FRotator& Rot);
	static void MakeRotatorAxisAndAngle(struct FRotator* OutRot, const struct FVector& Axis, float AngleDegree);

	void CalcAngularVelocityToTarget(struct FVector* AngularVelocity, class USceneComponent* DirectionComp, const struct FVector& TargetLocation);
	void DebugDrawRotator(const struct FRotator& Rot, const struct FVector& CenterPos, float Radius);
	void MoveRootComponent(const struct FVector& Delta, struct FHitResult* OutHit, bool bSweep, bool bTeleport);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsychokinesisedComponent">();
	}
	static class UPsychokinesisedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPsychokinesisedComponent>();
	}
};
static_assert(alignof(UPsychokinesisedComponent) == 0x000008, "Wrong alignment on UPsychokinesisedComponent");
static_assert(sizeof(UPsychokinesisedComponent) == 0x0000C0, "Wrong size on UPsychokinesisedComponent");

// Class BattlePrototype.QuestData
// 0x0030 (0x0058 - 0x0028)
class UQuestData final : public UObject
{
public:
	class UDataTable*                             RefMainDataAsset;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             RefSubDataAsset;                                   // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             RefBondsDataAsset;                                 // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDataTable>                 FinderMain;                                        // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMainQuestDBAsset*                      MainQuestDataAsset;                                // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBondsEpisodeDBAsset*                   BondsQuestDataAsset;                               // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool LoadDataAsset(const class FString& MainDTPath, const class FString& SubDTPath, const class FString& bondsDTPath);
	bool LoadDataAsset_Bonds(const class FString& DataPath);
	bool LoadDataAsset_Main(const class FString& DataPath);
	bool LoadDataAsset_Sub(const class FString& DataPath);
	bool UnloadDataTable();
	bool UnloadDataTable_Bonds();
	bool UnloadDataTable_Main();
	bool UnloadDataTable_Sub();

	class UBondsEpisodeDBAsset* GetBondsEpisodeData() const;
	int32 GetBondsEpisodeDataNum() const;
	class UMainQuestDBAsset* GetMainQuestData() const;
	int32 GetMainQuestDataNum() const;
	class UDataTable* GetSubQuestData() const;
	int32 GetSubQuestDataNum() const;
	bool IsValidBondsDB() const;
	bool IsValidDB() const;
	bool IsValidMainDB() const;
	bool IsValidSubDB() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestData">();
	}
	static class UQuestData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestData>();
	}
};
static_assert(alignof(UQuestData) == 0x000008, "Wrong alignment on UQuestData");
static_assert(sizeof(UQuestData) == 0x000058, "Wrong size on UQuestData");
static_assert(offsetof(UQuestData, RefMainDataAsset) == 0x000028, "Member 'UQuestData::RefMainDataAsset' has a wrong offset!");
static_assert(offsetof(UQuestData, RefSubDataAsset) == 0x000030, "Member 'UQuestData::RefSubDataAsset' has a wrong offset!");
static_assert(offsetof(UQuestData, RefBondsDataAsset) == 0x000038, "Member 'UQuestData::RefBondsDataAsset' has a wrong offset!");
static_assert(offsetof(UQuestData, FinderMain) == 0x000040, "Member 'UQuestData::FinderMain' has a wrong offset!");
static_assert(offsetof(UQuestData, MainQuestDataAsset) == 0x000048, "Member 'UQuestData::MainQuestDataAsset' has a wrong offset!");
static_assert(offsetof(UQuestData, BondsQuestDataAsset) == 0x000050, "Member 'UQuestData::BondsQuestDataAsset' has a wrong offset!");

// Class BattlePrototype.SubQuestDBAsset
// 0x0050 (0x0078 - 0x0028)
class USubQuestDBAsset final : public UObject
{
public:
	TMap<class FName, struct FSubQuestDBDataCell> DBMap;                                             // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	void Convert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubQuestDBAsset">();
	}
	static class USubQuestDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubQuestDBAsset>();
	}
};
static_assert(alignof(USubQuestDBAsset) == 0x000008, "Wrong alignment on USubQuestDBAsset");
static_assert(sizeof(USubQuestDBAsset) == 0x000078, "Wrong size on USubQuestDBAsset");
static_assert(offsetof(USubQuestDBAsset, DBMap) == 0x000028, "Member 'USubQuestDBAsset::DBMap' has a wrong offset!");

// Class BattlePrototype.QuestParamManager
// 0x0108 (0x0130 - 0x0028)
class UQuestParamManager final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnChangeNoticeUiStateDelegate_;                    // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeQuestActiveUiStateDelegate_;               // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FQuestParams>                   QuestParams_;                                      // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FConditionQuestParams>          SubQuestParams_;                                   // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FProgressRateQuestParams>       bondsQuestParams_;                                 // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ActiveMainQuest_;                                  // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ActiveSubQuest_;                                   // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ActiveSubQuestKasane_;                             // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 NeedItemSubQuestNumber_;                           // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int32>                                 NeedKillEnemySubQuestNumber_;                      // 0x0098(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SubQuestRowNames_;                                 // 0x00B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           bondsQuestRowNames_;                               // 0x00C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x20];                                      // 0x00D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDrivemode_;                                       // 0x00F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x37];                                      // 0x00F9(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeToProgressAllQuest();
	bool CheckDLCQuestContentCheck(class FName QuestId);
	bool CheckNeedItem(class FName ItemId);
	bool CheckPlayingDLCBondsNow();
	void CheckSubQuestsStateNotOrder();
	bool CheckSubQuestSuitableNowPlayer(int32 QuestNumber);
	int32 GetActiveSubQuestNumber();
	class FName GetBondsEpisodeIDFromNumber(int32 Number);
	int32 GetBondsQuestNumberFromID(class FName QuestId);
	int32 GetBondsQuestProgressRate(int32 QuestNumber);
	EQuestProgressState GetBondsQuestState(int32 QuestNumber);
	class FName GetIDFromSubQuestNumber(int32 QuestNumber);
	void GetItem(class FName ItemName, int32 ItemNum);
	class FName GetMainQuestIDFromNumber(int32 QuestNumber);
	int32 GetMainQuestNumberFromID(class FName QuestId);
	EQuestProgressState GetMainQuestState(int32 QuestNumber);
	TArray<int32> GetQuestSortID(EQuestType QuestTyp, ESortType SortType, int32 ActiveNumber);
	int32 GetSubQuestNumberAchieved(const class FName& QuestId, const class FName& TargetID);
	int32 GetSubQuestNumberFromID(class FName QuestId);
	EQuestProgressState GetSubQuestState(int32 QuestNumber);
	void InitAtExNewGame(EPlayerID MainPlayerID);
	void InitData(class URSGameInstance* GameInst);
	void InProgressBondsQuest(int32 bondsQuestNumber);
	void InProgressSubQuest(int32 SubQuestNumber);
	bool IsBondsQuestRelatedToThePlayer(int32 QuestNumber);
	bool IsQuestEnemy(class FName EnemyName);
	bool IsSubQuestRelatedToThePlayer(int32 QuestNumber);
	bool IsTargetEnemyForActiveSubQuest(const class FString& EnemyName);
	bool IsUnlockContentBondsEpisode(class FName Key, int32 ContentNumber);
	bool IsUnlockContentMainQuest(class FName Key, int32 ContentNumber);
	void KillEnemy(class FName EnemyName, const struct FHCHitResult& HcResult, EPsychicObjectUniqueType PoType, int32 KillNum, bool bBrainCrashMulti, EPlayerID HoloPlayerID);
	void SetActiveSubQuestNumber(int32 SubQuestNumber);
	void SetBondsQuestProgressRate(int32 QuestNumber, int32 Rate);
	void SetBondsQuestState(int32 QuestNumber, EQuestProgressState State);
	void SetMainQuestState(int32 QuestNumber, EQuestProgressState State);
	void SetNewIcon(EQuestType QType, int32 QuestNumber, bool Flg);
	void SetSubQuestState(int32 QuestNumber, EQuestProgressState State);
	void ThrowSubQuestNotification(class FName QuestId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestParamManager">();
	}
	static class UQuestParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestParamManager>();
	}
};
static_assert(alignof(UQuestParamManager) == 0x000008, "Wrong alignment on UQuestParamManager");
static_assert(sizeof(UQuestParamManager) == 0x000130, "Wrong size on UQuestParamManager");
static_assert(offsetof(UQuestParamManager, OnChangeNoticeUiStateDelegate_) == 0x000028, "Member 'UQuestParamManager::OnChangeNoticeUiStateDelegate_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, OnChangeQuestActiveUiStateDelegate_) == 0x000038, "Member 'UQuestParamManager::OnChangeQuestActiveUiStateDelegate_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, QuestParams_) == 0x000048, "Member 'UQuestParamManager::QuestParams_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, SubQuestParams_) == 0x000058, "Member 'UQuestParamManager::SubQuestParams_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, bondsQuestParams_) == 0x000068, "Member 'UQuestParamManager::bondsQuestParams_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, ActiveMainQuest_) == 0x000078, "Member 'UQuestParamManager::ActiveMainQuest_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, ActiveSubQuest_) == 0x00007C, "Member 'UQuestParamManager::ActiveSubQuest_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, ActiveSubQuestKasane_) == 0x000080, "Member 'UQuestParamManager::ActiveSubQuestKasane_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, NeedItemSubQuestNumber_) == 0x000088, "Member 'UQuestParamManager::NeedItemSubQuestNumber_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, NeedKillEnemySubQuestNumber_) == 0x000098, "Member 'UQuestParamManager::NeedKillEnemySubQuestNumber_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, SubQuestRowNames_) == 0x0000B8, "Member 'UQuestParamManager::SubQuestRowNames_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, bondsQuestRowNames_) == 0x0000C8, "Member 'UQuestParamManager::bondsQuestRowNames_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, bDrivemode_) == 0x0000F8, "Member 'UQuestParamManager::bDrivemode_' has a wrong offset!");

// Class BattlePrototype.RadialBlurManager
// 0x0070 (0x02A0 - 0x0230)
class ARadialBlurManager : public AActor
{
public:
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsPlaying;                                         // 0x0240(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRadialBlurData                        AdditionalBlurParameter;                           // 0x0248(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	class UMaterialParameterCollection*           MPC;                                               // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialParameterCollection*           MPCC;                                              // 0x0288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetPlaying();
	void Play(int32 Priority, class UCurveVector* CurveData, const struct FVector& Location, const struct FLinearColor& ColorModuate, bool Force);
	void PlayPresetColorModulate(int32 Priority, class UCurveVector* CurveData, const struct FVector& Location, ENotifyRadialBlurModulateType PresetColorType, bool Force);
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadialBlurManager">();
	}
	static class ARadialBlurManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARadialBlurManager>();
	}
};
static_assert(alignof(ARadialBlurManager) == 0x000008, "Wrong alignment on ARadialBlurManager");
static_assert(sizeof(ARadialBlurManager) == 0x0002A0, "Wrong size on ARadialBlurManager");
static_assert(offsetof(ARadialBlurManager, IsPlaying) == 0x000240, "Member 'ARadialBlurManager::IsPlaying' has a wrong offset!");
static_assert(offsetof(ARadialBlurManager, AdditionalBlurParameter) == 0x000248, "Member 'ARadialBlurManager::AdditionalBlurParameter' has a wrong offset!");
static_assert(offsetof(ARadialBlurManager, MPC) == 0x000280, "Member 'ARadialBlurManager::MPC' has a wrong offset!");
static_assert(offsetof(ARadialBlurManager, MPCC) == 0x000288, "Member 'ARadialBlurManager::MPCC' has a wrong offset!");

// Class BattlePrototype.UITitleFirstConfirmChildBase
// 0x0018 (0x03A0 - 0x0388)
class UUITitleFirstConfirmChildBase : public UUIBase
{
public:
	uint8                                         Pad_388[0x10];                                     // 0x0388(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSTitleManager*                        TitleManager;                                      // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleFirstConfirmChildBase">();
	}
	static class UUITitleFirstConfirmChildBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleFirstConfirmChildBase>();
	}
};
static_assert(alignof(UUITitleFirstConfirmChildBase) == 0x000008, "Wrong alignment on UUITitleFirstConfirmChildBase");
static_assert(sizeof(UUITitleFirstConfirmChildBase) == 0x0003A0, "Wrong size on UUITitleFirstConfirmChildBase");
static_assert(offsetof(UUITitleFirstConfirmChildBase, TitleManager) == 0x000398, "Member 'UUITitleFirstConfirmChildBase::TitleManager' has a wrong offset!");

// Class BattlePrototype.REDHorizonFlipbookWidget
// 0x00D0 (0x0308 - 0x0238)
class UREDHorizonFlipbookWidget final : public UHorizonFlipbookWidget
{
public:
	bool                                          FlagMouse;                                         // 0x0238(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRedMouseArgument                      MouseCallArgument;                                 // 0x023C(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              MouseHitOffsetPos;                                 // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MouseHitOffsetSize;                                // 0x0250(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugMouseHitDisp;                                 // 0x0258(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             M_FlipBookFocusMouse;                              // 0x0260(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             M_FlipBookUnFocusMouse;                            // 0x0270(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             M_FlipBookDownMouse;                               // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x18];                                     // 0x0290(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUIBase>                 M_ParentUIBase;                                    // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UREDebugLines*                          M_DebugDraw;                                       // 0x02B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x50];                                     // 0x02B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckRectangle();
	bool CheckRectangleCore(const struct FVector2D& Position);
	struct FVector2D GetAbsolutePosition();
	struct FVector2D GetAbsoluteSize();
	void RedFlipBookDown__DelegateSignature(const struct FRedMouseArgument& Argument, class UObject* PWidget);
	void RedFlipBookFocus__DelegateSignature(const struct FRedMouseArgument& Argument, class UObject* PWidget);
	void RedFlipBookUnFocus__DelegateSignature(const struct FRedMouseArgument& Argument, class UObject* PWidget);
	void SetMouseDisable(bool Flag);
	void SetMouseInputLevel(int32 InputLevel);
	void SetMouseMode(bool Mousemode, int32 InputLevel);
	void SetParentUIBase(class UUIBase* PUiBase);

	bool GetMouseDisable() const;
	int32 GetMouseInputLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDHorizonFlipbookWidget">();
	}
	static class UREDHorizonFlipbookWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDHorizonFlipbookWidget>();
	}
};
static_assert(alignof(UREDHorizonFlipbookWidget) == 0x000008, "Wrong alignment on UREDHorizonFlipbookWidget");
static_assert(sizeof(UREDHorizonFlipbookWidget) == 0x000308, "Wrong size on UREDHorizonFlipbookWidget");
static_assert(offsetof(UREDHorizonFlipbookWidget, FlagMouse) == 0x000238, "Member 'UREDHorizonFlipbookWidget::FlagMouse' has a wrong offset!");
static_assert(offsetof(UREDHorizonFlipbookWidget, MouseCallArgument) == 0x00023C, "Member 'UREDHorizonFlipbookWidget::MouseCallArgument' has a wrong offset!");
static_assert(offsetof(UREDHorizonFlipbookWidget, MouseHitOffsetPos) == 0x000248, "Member 'UREDHorizonFlipbookWidget::MouseHitOffsetPos' has a wrong offset!");
static_assert(offsetof(UREDHorizonFlipbookWidget, MouseHitOffsetSize) == 0x000250, "Member 'UREDHorizonFlipbookWidget::MouseHitOffsetSize' has a wrong offset!");
static_assert(offsetof(UREDHorizonFlipbookWidget, DebugMouseHitDisp) == 0x000258, "Member 'UREDHorizonFlipbookWidget::DebugMouseHitDisp' has a wrong offset!");
static_assert(offsetof(UREDHorizonFlipbookWidget, M_FlipBookFocusMouse) == 0x000260, "Member 'UREDHorizonFlipbookWidget::M_FlipBookFocusMouse' has a wrong offset!");
static_assert(offsetof(UREDHorizonFlipbookWidget, M_FlipBookUnFocusMouse) == 0x000270, "Member 'UREDHorizonFlipbookWidget::M_FlipBookUnFocusMouse' has a wrong offset!");
static_assert(offsetof(UREDHorizonFlipbookWidget, M_FlipBookDownMouse) == 0x000280, "Member 'UREDHorizonFlipbookWidget::M_FlipBookDownMouse' has a wrong offset!");
static_assert(offsetof(UREDHorizonFlipbookWidget, M_ParentUIBase) == 0x0002A8, "Member 'UREDHorizonFlipbookWidget::M_ParentUIBase' has a wrong offset!");
static_assert(offsetof(UREDHorizonFlipbookWidget, M_DebugDraw) == 0x0002B0, "Member 'UREDHorizonFlipbookWidget::M_DebugDraw' has a wrong offset!");

// Class BattlePrototype.REDImageBase
// 0x0028 (0x0238 - 0x0210)
class UREDImageBase final : public UImage
{
public:
	TArray<struct FREDLocalizeImageParam>         LocalizedParamList;                                // 0x0210(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FREDLocalizeImageParam                 DefaultParam;                                      // 0x0220(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDImageBase">();
	}
	static class UREDImageBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDImageBase>();
	}
};
static_assert(alignof(UREDImageBase) == 0x000008, "Wrong alignment on UREDImageBase");
static_assert(sizeof(UREDImageBase) == 0x000238, "Wrong size on UREDImageBase");
static_assert(offsetof(UREDImageBase, LocalizedParamList) == 0x000210, "Member 'UREDImageBase::LocalizedParamList' has a wrong offset!");
static_assert(offsetof(UREDImageBase, DefaultParam) == 0x000220, "Member 'UREDImageBase::DefaultParam' has a wrong offset!");

// Class BattlePrototype.REDScrollBoxElement
// 0x0040 (0x0270 - 0x0230)
class UREDScrollBoxElement : public UUserWidget
{
public:
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            Widget;                                            // 0x0240(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_248[0x28];                                     // 0x0248(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector2D GetAbsolutePosition();
	struct FVector2D GetAbsoluteSize();
	bool GetHitWidget();
	class UREDScrollBoxElement* GetThis();
	void InitializeThis(class UOverlay* Overlay, class USpacer* Spacer);
	void SelfInitialize();
	void SetMouseDisable(bool Flag);
	void SetMouseInputDisable(bool Flag);
	void SetMouseInputLevel(int32 InputLevel);

	bool GetMouseDisable() const;
	bool GetMouseInputDisable() const;
	int32 GetMouseInputLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDScrollBoxElement">();
	}
	static class UREDScrollBoxElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDScrollBoxElement>();
	}
};
static_assert(alignof(UREDScrollBoxElement) == 0x000008, "Wrong alignment on UREDScrollBoxElement");
static_assert(sizeof(UREDScrollBoxElement) == 0x000270, "Wrong size on UREDScrollBoxElement");
static_assert(offsetof(UREDScrollBoxElement, Widget) == 0x000240, "Member 'UREDScrollBoxElement::Widget' has a wrong offset!");

// Class BattlePrototype.UITutoTipsParts
// 0x00C8 (0x0450 - 0x0388)
class UUITutoTipsParts : public UUIBase
{
public:
	bool                                          bMovieStopFlag;                                    // 0x0388(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHelpImageType                                ImageType;                                         // 0x0389(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38A[0x6];                                      // 0x038A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Pathname;                                          // 0x0390(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Load;                                              // 0x03A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Failure;                                           // 0x03A1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A2[0x2];                                      // 0x03A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PathData;                                          // 0x03A4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETutoMoviePlayType                            PlaySelect;                                        // 0x03AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AD[0x53];                                     // 0x03AD(0x0053)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UTexture2D*, int32>                ReleaseTipsTextures;                               // 0x0400(0x0050)(NativeAccessSpecifierPrivate)

public:
	void InitializeAnime(class UWidgetAnimation* Default1_, class UWidgetAnimation* Default2_, class UWidgetAnimation* Default_none);
	void InitializeArrow(int32 Index_0, class UUIHelpParts* Arrow);
	bool InitializeMovie();
	void InitializeText(class UTextBlock* TextTitle, class UTextBlock* TextMain, class UTextBlock* TextPage1, class UTextBlock* TextPage2, class UTextBlock* TextSlash);
	bool IsLoad();
	bool IsLoadFailure();
	bool IsMovieStop();
	bool IsPlayMovie();
	class UTexture2D* LoadTipsTexture(const class FString& Path);
	void SetImageType(const class FString& Pathname_0, EHelpImageType ImageType_0);
	void SetPageText(const class FString& MainText, const class FString& TitleText, int32 PageNo, int32 PageMax);
	void SetVisiblePageUI(bool Flag);
	void StopMovieForce();
	void TextureRelease();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITutoTipsParts">();
	}
	static class UUITutoTipsParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITutoTipsParts>();
	}
};
static_assert(alignof(UUITutoTipsParts) == 0x000008, "Wrong alignment on UUITutoTipsParts");
static_assert(sizeof(UUITutoTipsParts) == 0x000450, "Wrong size on UUITutoTipsParts");
static_assert(offsetof(UUITutoTipsParts, bMovieStopFlag) == 0x000388, "Member 'UUITutoTipsParts::bMovieStopFlag' has a wrong offset!");
static_assert(offsetof(UUITutoTipsParts, ImageType) == 0x000389, "Member 'UUITutoTipsParts::ImageType' has a wrong offset!");
static_assert(offsetof(UUITutoTipsParts, Pathname) == 0x000390, "Member 'UUITutoTipsParts::Pathname' has a wrong offset!");
static_assert(offsetof(UUITutoTipsParts, Load) == 0x0003A0, "Member 'UUITutoTipsParts::Load' has a wrong offset!");
static_assert(offsetof(UUITutoTipsParts, Failure) == 0x0003A1, "Member 'UUITutoTipsParts::Failure' has a wrong offset!");
static_assert(offsetof(UUITutoTipsParts, PathData) == 0x0003A4, "Member 'UUITutoTipsParts::PathData' has a wrong offset!");
static_assert(offsetof(UUITutoTipsParts, PlaySelect) == 0x0003AC, "Member 'UUITutoTipsParts::PlaySelect' has a wrong offset!");
static_assert(offsetof(UUITutoTipsParts, ReleaseTipsTextures) == 0x000400, "Member 'UUITutoTipsParts::ReleaseTipsTextures' has a wrong offset!");

// Class BattlePrototype.RedSettings
// 0x0030 (0x0058 - 0x0028)
class URedSettings final : public UObject
{
public:
	class FString                                 Purpose;                                           // 0x0028(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SampleFloatRequireRestart;                         // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClampedIntSetting;                                 // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        StringMaterialAssetReference;                      // 0x0040(0x0018)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RedSettings">();
	}
	static class URedSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<URedSettings>();
	}
};
static_assert(alignof(URedSettings) == 0x000008, "Wrong alignment on URedSettings");
static_assert(sizeof(URedSettings) == 0x000058, "Wrong size on URedSettings");
static_assert(offsetof(URedSettings, Purpose) == 0x000028, "Member 'URedSettings::Purpose' has a wrong offset!");
static_assert(offsetof(URedSettings, SampleFloatRequireRestart) == 0x000038, "Member 'URedSettings::SampleFloatRequireRestart' has a wrong offset!");
static_assert(offsetof(URedSettings, ClampedIntSetting) == 0x00003C, "Member 'URedSettings::ClampedIntSetting' has a wrong offset!");
static_assert(offsetof(URedSettings, StringMaterialAssetReference) == 0x000040, "Member 'URedSettings::StringMaterialAssetReference' has a wrong offset!");

// Class BattlePrototype.REDTextBlock
// 0x0028 (0x02C8 - 0x02A0)
class UREDTextBlock final : public UTextBlock
{
public:
	TArray<struct FREDLocalizeTextParam>          FontSizeParamList;                                 // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FREDLocalizeTextParam                  DefaultParam;                                      // 0x02B0(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDTextBlock">();
	}
	static class UREDTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDTextBlock>();
	}
};
static_assert(alignof(UREDTextBlock) == 0x000008, "Wrong alignment on UREDTextBlock");
static_assert(sizeof(UREDTextBlock) == 0x0002C8, "Wrong size on UREDTextBlock");
static_assert(offsetof(UREDTextBlock, FontSizeParamList) == 0x0002A0, "Member 'UREDTextBlock::FontSizeParamList' has a wrong offset!");
static_assert(offsetof(UREDTextBlock, DefaultParam) == 0x0002B0, "Member 'UREDTextBlock::DefaultParam' has a wrong offset!");

// Class BattlePrototype.UIPresent
// 0x0018 (0x03A0 - 0x0388)
class UUIPresent : public UUIBase
{
public:
	EPlayerID                                     M_Target;                                          // 0x0388(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_FlagSelect;                                      // 0x0389(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38A[0x2];                                      // 0x038A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_ItemID;                                          // 0x038C(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0xC];                                      // 0x0394(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeScrollBox(class UREDScrollBox* ScrollBox);
	void SetTarget(EPlayerID Target);
	void UpdatePresentListMouseFocus();

	class FName GetItemID() const;
	bool GetSelectFlag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPresent">();
	}
	static class UUIPresent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPresent>();
	}
};
static_assert(alignof(UUIPresent) == 0x000008, "Wrong alignment on UUIPresent");
static_assert(sizeof(UUIPresent) == 0x0003A0, "Wrong size on UUIPresent");
static_assert(offsetof(UUIPresent, M_Target) == 0x000388, "Member 'UUIPresent::M_Target' has a wrong offset!");
static_assert(offsetof(UUIPresent, M_FlagSelect) == 0x000389, "Member 'UUIPresent::M_FlagSelect' has a wrong offset!");
static_assert(offsetof(UUIPresent, M_ItemID) == 0x00038C, "Member 'UUIPresent::M_ItemID' has a wrong offset!");

// Class BattlePrototype.REDWidgetBPLibrary
// 0x0000 (0x0028 - 0x0028)
class UREDWidgetBPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class ARSHUDBase* GetRSHudBase(class UObject* WorldContextObject);
	static void SetIcon(class UObject* WorldContextObject, class UImage* Image, EUI_UV_BUtton_N1 Button);
	static void SetIconBaseGamePad(class UObject* WorldContextObject, class UImage* Image, ERSGamepadInputName Button);
	static void SetIconGamePadL(class UObject* WorldContextObject, class UImage* Image, ERSGamepadInputName Button);
	static void SetIconGamePadM(class UObject* WorldContextObject, class UImage* Image, ERSGamepadInputName Button);
	static void UI_SetColorAction(class UImage* Image, int32 Index_0);
	static void UI_SetThumbnail_Action(class UImage* Image, EActionIconType Index_0, bool IsActive);
	static int32 UIGetIdIconSas(E_SASKindNative Sas);
	static int32 UIGetIdIconSasStatus(E_SASKindNative Sas, E_SASIconStatus Status);
	static void UISetThumbnailIconSas(class UImage* Image, int32 ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDWidgetBPLibrary">();
	}
	static class UREDWidgetBPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDWidgetBPLibrary>();
	}
};
static_assert(alignof(UREDWidgetBPLibrary) == 0x000008, "Wrong alignment on UREDWidgetBPLibrary");
static_assert(sizeof(UREDWidgetBPLibrary) == 0x000028, "Wrong size on UREDWidgetBPLibrary");

// Class BattlePrototype.RequestParticleEffectArgs
// 0x0038 (0x0060 - 0x0028)
class URequestParticleEffectArgs final : public UObject
{
public:
	class FName                                   _CustomName;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _MeshComponent;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        _PSTemplate;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _SocketName;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _LocationOffset;                                   // 0x0048(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               _RotationOffset;                                   // 0x0054(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void Setup(class FName CustomName, class USceneComponent* MeshComponent, class UParticleSystem* PSTemplate, class FName SocketName, const struct FVector& LocationOffset, const struct FRotator& RotationOffset);
	class UParticleSystemComponent* StartParticleEffect();

	bool EqualsCustomName(class FName Name_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RequestParticleEffectArgs">();
	}
	static class URequestParticleEffectArgs* GetDefaultObj()
	{
		return GetDefaultObjImpl<URequestParticleEffectArgs>();
	}
};
static_assert(alignof(URequestParticleEffectArgs) == 0x000008, "Wrong alignment on URequestParticleEffectArgs");
static_assert(sizeof(URequestParticleEffectArgs) == 0x000060, "Wrong size on URequestParticleEffectArgs");
static_assert(offsetof(URequestParticleEffectArgs, _CustomName) == 0x000028, "Member 'URequestParticleEffectArgs::_CustomName' has a wrong offset!");
static_assert(offsetof(URequestParticleEffectArgs, _MeshComponent) == 0x000030, "Member 'URequestParticleEffectArgs::_MeshComponent' has a wrong offset!");
static_assert(offsetof(URequestParticleEffectArgs, _PSTemplate) == 0x000038, "Member 'URequestParticleEffectArgs::_PSTemplate' has a wrong offset!");
static_assert(offsetof(URequestParticleEffectArgs, _SocketName) == 0x000040, "Member 'URequestParticleEffectArgs::_SocketName' has a wrong offset!");
static_assert(offsetof(URequestParticleEffectArgs, _LocationOffset) == 0x000048, "Member 'URequestParticleEffectArgs::_LocationOffset' has a wrong offset!");
static_assert(offsetof(URequestParticleEffectArgs, _RotationOffset) == 0x000054, "Member 'URequestParticleEffectArgs::_RotationOffset' has a wrong offset!");

// Class BattlePrototype.UIQuestListIndex
// 0x0158 (0x04E0 - 0x0388)
class UUIQuestListIndex : public UUIBase
{
public:
	struct FSlateColor                            ActiveColorMain;                                   // 0x0388(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           ActiveOutlineColorMain;                            // 0x03B0(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            ActiveColorSub;                                    // 0x03C0(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           ActiveOutlineColorSub;                             // 0x03E8(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            ActiveColorBonds;                                  // 0x03F8(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           ActiveOutlineColorBonds;                           // 0x0420(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            InactiveColor;                                     // 0x0430(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           InactiveOutlineColor;                              // 0x0458(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_468[0x78];                                     // 0x0468(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimDefaultLock, class UWidgetAnimation* AnimSelectLock, class UWidgetAnimation* AnimSelectLockIn, class UImage* ImageNewIcon, class UImage* ImageBlackPattern1, class UImage* ImageBlackPattern2, class UOverlay* OverlayYuito, class UOverlay* OverlayKasane, class UTextBlock* TextQuestName);
	void SetInfo(EQuestDataType QuestType, const class FName& ID, int32 Progress, int32 Index_0, bool IsActive);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestListIndex">();
	}
	static class UUIQuestListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestListIndex>();
	}
};
static_assert(alignof(UUIQuestListIndex) == 0x000008, "Wrong alignment on UUIQuestListIndex");
static_assert(sizeof(UUIQuestListIndex) == 0x0004E0, "Wrong size on UUIQuestListIndex");
static_assert(offsetof(UUIQuestListIndex, ActiveColorMain) == 0x000388, "Member 'UUIQuestListIndex::ActiveColorMain' has a wrong offset!");
static_assert(offsetof(UUIQuestListIndex, ActiveOutlineColorMain) == 0x0003B0, "Member 'UUIQuestListIndex::ActiveOutlineColorMain' has a wrong offset!");
static_assert(offsetof(UUIQuestListIndex, ActiveColorSub) == 0x0003C0, "Member 'UUIQuestListIndex::ActiveColorSub' has a wrong offset!");
static_assert(offsetof(UUIQuestListIndex, ActiveOutlineColorSub) == 0x0003E8, "Member 'UUIQuestListIndex::ActiveOutlineColorSub' has a wrong offset!");
static_assert(offsetof(UUIQuestListIndex, ActiveColorBonds) == 0x0003F8, "Member 'UUIQuestListIndex::ActiveColorBonds' has a wrong offset!");
static_assert(offsetof(UUIQuestListIndex, ActiveOutlineColorBonds) == 0x000420, "Member 'UUIQuestListIndex::ActiveOutlineColorBonds' has a wrong offset!");
static_assert(offsetof(UUIQuestListIndex, InactiveColor) == 0x000430, "Member 'UUIQuestListIndex::InactiveColor' has a wrong offset!");
static_assert(offsetof(UUIQuestListIndex, InactiveOutlineColor) == 0x000458, "Member 'UUIQuestListIndex::InactiveOutlineColor' has a wrong offset!");

// Class BattlePrototype.RevisionData
// 0x0020 (0x0048 - 0x0028)
class URevisionData final : public UObject
{
public:
	class FString                                 Revision;                                          // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 BuildDate;                                         // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class FString GetBuildConfigStr() const;
	class FString GetBuildDateStr() const;
	class FString GetRevisionStr() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RevisionData">();
	}
	static class URevisionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URevisionData>();
	}
};
static_assert(alignof(URevisionData) == 0x000008, "Wrong alignment on URevisionData");
static_assert(sizeof(URevisionData) == 0x000048, "Wrong size on URevisionData");
static_assert(offsetof(URevisionData, Revision) == 0x000028, "Member 'URevisionData::Revision' has a wrong offset!");
static_assert(offsetof(URevisionData, BuildDate) == 0x000038, "Member 'URevisionData::BuildDate' has a wrong offset!");

// Class BattlePrototype.RSActorPlayerBase
// 0x0000 (0x0230 - 0x0230)
class ARSActorPlayerBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorPlayerBase">();
	}
	static class ARSActorPlayerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSActorPlayerBase>();
	}
};
static_assert(alignof(ARSActorPlayerBase) == 0x000008, "Wrong alignment on ARSActorPlayerBase");
static_assert(sizeof(ARSActorPlayerBase) == 0x000230, "Wrong size on ARSActorPlayerBase");

// Class BattlePrototype.RSActorComponentSystemBase
// 0x0000 (0x00C0 - 0x00C0)
class URSActorComponentSystemBase final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorComponentSystemBase">();
	}
	static class URSActorComponentSystemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSActorComponentSystemBase>();
	}
};
static_assert(alignof(URSActorComponentSystemBase) == 0x000008, "Wrong alignment on URSActorComponentSystemBase");
static_assert(sizeof(URSActorComponentSystemBase) == 0x0000C0, "Wrong size on URSActorComponentSystemBase");

// Class BattlePrototype.RSActorComponentEnemyBase
// 0x0000 (0x00C0 - 0x00C0)
class URSActorComponentEnemyBase final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorComponentEnemyBase">();
	}
	static class URSActorComponentEnemyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSActorComponentEnemyBase>();
	}
};
static_assert(alignof(URSActorComponentEnemyBase) == 0x000008, "Wrong alignment on URSActorComponentEnemyBase");
static_assert(sizeof(URSActorComponentEnemyBase) == 0x0000C0, "Wrong size on URSActorComponentEnemyBase");

// Class BattlePrototype.RSActorComponentBackgroundBase
// 0x0000 (0x00C0 - 0x00C0)
class URSActorComponentBackgroundBase final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorComponentBackgroundBase">();
	}
	static class URSActorComponentBackgroundBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSActorComponentBackgroundBase>();
	}
};
static_assert(alignof(URSActorComponentBackgroundBase) == 0x000008, "Wrong alignment on URSActorComponentBackgroundBase");
static_assert(sizeof(URSActorComponentBackgroundBase) == 0x0000C0, "Wrong size on URSActorComponentBackgroundBase");

// Class BattlePrototype.RSAjitoAnimInstanceInterface
// 0x0000 (0x0028 - 0x0028)
class IRSAjitoAnimInstanceInterface final : public IInterface
{
public:
	bool RequestState(EAjitoMemberState State);
	bool ResetState();
	bool SetASAnimationSet(class UASAnimationSet* AnimationSet);
	bool SetASStateMachine(class UASStateMachine* StateMachine);
	bool SetLookAtPlayer(bool IsLookAt);
	bool SetPlayerFacePos(const struct FVector& PlayerFacePos);
	bool UseOverrideAnim(bool IsOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAjitoAnimInstanceInterface">();
	}
	static class IRSAjitoAnimInstanceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRSAjitoAnimInstanceInterface>();
	}
};
static_assert(alignof(IRSAjitoAnimInstanceInterface) == 0x000008, "Wrong alignment on IRSAjitoAnimInstanceInterface");
static_assert(sizeof(IRSAjitoAnimInstanceInterface) == 0x000028, "Wrong size on IRSAjitoAnimInstanceInterface");

// Class BattlePrototype.RSArrangeEventPlaneActor
// 0x0000 (0x0230 - 0x0230)
class ARSArrangeEventPlaneActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSArrangeEventPlaneActor">();
	}
	static class ARSArrangeEventPlaneActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSArrangeEventPlaneActor>();
	}
};
static_assert(alignof(ARSArrangeEventPlaneActor) == 0x000008, "Wrong alignment on ARSArrangeEventPlaneActor");
static_assert(sizeof(ARSArrangeEventPlaneActor) == 0x000230, "Wrong size on ARSArrangeEventPlaneActor");

// Class BattlePrototype.RSAtomCuePlayNotifyBase
// 0x0008 (0x0040 - 0x0038)
class URSAtomCuePlayNotifyBase : public UAnimNotify
{
public:
	class USoundAtomCue*                          M_pSound;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnSetEditorSound(class USoundAtomCue* Sound) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAtomCuePlayNotifyBase">();
	}
	static class URSAtomCuePlayNotifyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAtomCuePlayNotifyBase>();
	}
};
static_assert(alignof(URSAtomCuePlayNotifyBase) == 0x000008, "Wrong alignment on URSAtomCuePlayNotifyBase");
static_assert(sizeof(URSAtomCuePlayNotifyBase) == 0x000040, "Wrong size on URSAtomCuePlayNotifyBase");
static_assert(offsetof(URSAtomCuePlayNotifyBase, M_pSound) == 0x000038, "Member 'URSAtomCuePlayNotifyBase::M_pSound' has a wrong offset!");

// Class BattlePrototype.RSAutoTestMeasurePerfLevel
// 0x0000 (0x02A0 - 0x02A0)
class ARSAutoTestMeasurePerfLevel final : public ARSAutoTestBase
{
public:
	void AddCheckpointRecord(const class FString& LocationName);
	void BeginUnitRecording(const class FString& CheckpointName, int32 Angle);
	void EndUnitRecording();
	bool WriteCsvFile(const class FString& LogFileName);
	bool WriteErrorCsvFile(const class FString& LogFileName, const class FString& LocationName, const class FString& ErrorMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAutoTestMeasurePerfLevel">();
	}
	static class ARSAutoTestMeasurePerfLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSAutoTestMeasurePerfLevel>();
	}
};
static_assert(alignof(ARSAutoTestMeasurePerfLevel) == 0x000008, "Wrong alignment on ARSAutoTestMeasurePerfLevel");
static_assert(sizeof(ARSAutoTestMeasurePerfLevel) == 0x0002A0, "Wrong size on ARSAutoTestMeasurePerfLevel");

// Class BattlePrototype.RSCableAnimInstance
// 0x0090 (0x0300 - 0x0270)
class URSCableAnimInstance : public UAnimInstance
{
public:
	struct FVector                                Gravity;                                           // 0x0270(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimNode_RigidBodyRedCustomInterpolateInfo RigidBodyInterplateInfo;                           // 0x0280(0x0018)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TimeDilation;                                      // 0x0298(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCableAdditiveBoneParam                AdditiveBoneParam;                                 // 0x02A0(0x0028)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	float                                         IdleRigidBlendSpeed;                               // 0x02C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleRigidBlendRate;                                // 0x02CC(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRotator>                       BoneRotator;                                       // 0x02D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoneNum;                                           // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERSCableAnimationState                        AnimationState;                                    // 0x02E4(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E5[0x3];                                      // 0x02E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RigidIdlingSec;                                    // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x14];                                     // 0x02EC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BeginOverrideGravity(ERSCableGravityType Type);
	bool EndOverrideGravity(ERSCableGravityType Type);
	void SetActive(bool NewActive);
	void SetBoneParam(const struct FCableAdditiveBoneParam& Param);
	void SetState(ERSCableAnimationState State);
	void Update(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCableAnimInstance">();
	}
	static class URSCableAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSCableAnimInstance>();
	}
};
static_assert(alignof(URSCableAnimInstance) == 0x000010, "Wrong alignment on URSCableAnimInstance");
static_assert(sizeof(URSCableAnimInstance) == 0x000300, "Wrong size on URSCableAnimInstance");
static_assert(offsetof(URSCableAnimInstance, Gravity) == 0x000270, "Member 'URSCableAnimInstance::Gravity' has a wrong offset!");
static_assert(offsetof(URSCableAnimInstance, RigidBodyInterplateInfo) == 0x000280, "Member 'URSCableAnimInstance::RigidBodyInterplateInfo' has a wrong offset!");
static_assert(offsetof(URSCableAnimInstance, TimeDilation) == 0x000298, "Member 'URSCableAnimInstance::TimeDilation' has a wrong offset!");
static_assert(offsetof(URSCableAnimInstance, AdditiveBoneParam) == 0x0002A0, "Member 'URSCableAnimInstance::AdditiveBoneParam' has a wrong offset!");
static_assert(offsetof(URSCableAnimInstance, IdleRigidBlendSpeed) == 0x0002C8, "Member 'URSCableAnimInstance::IdleRigidBlendSpeed' has a wrong offset!");
static_assert(offsetof(URSCableAnimInstance, IdleRigidBlendRate) == 0x0002CC, "Member 'URSCableAnimInstance::IdleRigidBlendRate' has a wrong offset!");
static_assert(offsetof(URSCableAnimInstance, BoneRotator) == 0x0002D0, "Member 'URSCableAnimInstance::BoneRotator' has a wrong offset!");
static_assert(offsetof(URSCableAnimInstance, BoneNum) == 0x0002E0, "Member 'URSCableAnimInstance::BoneNum' has a wrong offset!");
static_assert(offsetof(URSCableAnimInstance, AnimationState) == 0x0002E4, "Member 'URSCableAnimInstance::AnimationState' has a wrong offset!");
static_assert(offsetof(URSCableAnimInstance, RigidIdlingSec) == 0x0002E8, "Member 'URSCableAnimInstance::RigidIdlingSec' has a wrong offset!");

// Class BattlePrototype.RSCameraShake
// 0x0000 (0x0160 - 0x0160)
class URSCameraShake : public UCameraShake
{
public:
	bool                                          bNoEffectGlobalTimeDilation;                       // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCameraShake">();
	}
	static class URSCameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSCameraShake>();
	}
};
static_assert(alignof(URSCameraShake) == 0x000010, "Wrong alignment on URSCameraShake");
static_assert(sizeof(URSCameraShake) == 0x000160, "Wrong size on URSCameraShake");
static_assert(offsetof(URSCameraShake, bNoEffectGlobalTimeDilation) == 0x000158, "Member 'URSCameraShake::bNoEffectGlobalTimeDilation' has a wrong offset!");

// Class BattlePrototype.RSCharaAnimationAccessor
// 0x0008 (0x0238 - 0x0230)
class ARSCharaAnimationAccessor final : public AActor
{
public:
	bool                                          IsSettingFaceAnimation;                            // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCharaAnimationAccessor">();
	}
	static class ARSCharaAnimationAccessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSCharaAnimationAccessor>();
	}
};
static_assert(alignof(ARSCharaAnimationAccessor) == 0x000008, "Wrong alignment on ARSCharaAnimationAccessor");
static_assert(sizeof(ARSCharaAnimationAccessor) == 0x000238, "Wrong size on ARSCharaAnimationAccessor");
static_assert(offsetof(ARSCharaAnimationAccessor, IsSettingFaceAnimation) == 0x000230, "Member 'ARSCharaAnimationAccessor::IsSettingFaceAnimation' has a wrong offset!");

// Class BattlePrototype.RSCharacterAnimInstance
// 0x0000 (0x0620 - 0x0620)
class URSCharacterAnimInstance : public UASAnimInstance
{
public:
	void ForceStopAllMontage(float BlendOut);
	class UAnimMontage* GetAnimMontageFromSlot(class FName SlotName);

	class FName DebugGetCurrentASNodeAssetName() const;
	bool DebugIsCurrentASNodeRootMotion() const;
	float GetCurrentASNodeAssetLength() const;
	float GetCurrentASNodeAssetPlayRate() const;
	float GetCurrentASNodeAssetTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCharacterAnimInstance">();
	}
	static class URSCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSCharacterAnimInstance>();
	}
};
static_assert(alignof(URSCharacterAnimInstance) == 0x000010, "Wrong alignment on URSCharacterAnimInstance");
static_assert(sizeof(URSCharacterAnimInstance) == 0x000620, "Wrong size on URSCharacterAnimInstance");

// Class BattlePrototype.RSCharacterBase
// 0x02C0 (0x08F0 - 0x0630)
class ARSCharacterBase : public AASCharacter
{
public:
	uint8                                         Pad_628[0x20];                                     // 0x0628(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchTick;                                      // 0x0648(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchStealth;                                   // 0x0658(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ECharacterHitPriority                         CharacterHitPriority;                              // 0x0668(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_669[0x3];                                      // 0x0669(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterHitTimeSliceNum;                          // 0x066C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHCHitResult>                   DamageDataArray;                                   // 0x0670(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDirectAttackDamageParam>       DirectDamageDataArray;                             // 0x0680(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHCHitResult>                   DamageData_Temp;                                   // 0x0690(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A0[0x20];                                     // 0x06A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class URSUniqueIdComponent*                   UniqueIdComponent;                                 // 0x06C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterItemDropId;                               // 0x06C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CoreDropId;                                        // 0x06CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTestCurveMoveCharacterMovement;                   // 0x06D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAnimationCurveMovement;                        // 0x06D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D2[0x2];                                      // 0x06D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimationCurveMovementSlotName;                    // 0x06D4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6DC[0x14];                                     // 0x06DC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UFootStepComponent*                     FootStepComponent;                                 // 0x06F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageArrayComponent*                  DamageArrayComponent;                              // 0x06F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageResponseComponent*               DamageResponseComponent;                           // 0x0700(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_708[0x20];                                     // 0x0708(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	EFHitEffectPriority                           PriorityHitEffect;                                 // 0x0728(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_729[0x7];                                      // 0x0729(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           MLoopSeKeyList;                                    // 0x0730(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_740[0x11];                                     // 0x0740(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDisableNpcTarget;                                 // 0x0751(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnRestrictFlag;                               // 0x0752(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLockOnRestrictTarget;                       // 0x0753(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_754[0x4];                                      // 0x0754(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           NotTargetableList;                                 // 0x0758(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_768[0x10];                                     // 0x0768(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MCh0200CvEffect_BoneName;                          // 0x0778(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MCh0200CvEffect_Scale;                             // 0x0780(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MCh0200CvEffect_CameraOffset;                      // 0x078C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ARSCharacterBase*>               MTargetingList;                                    // 0x0790(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ARSCharacterBase*>               MAttackingList;                                    // 0x07A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEnemyGrade                                   MEnemyGrade;                                       // 0x07B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B1[0x17];                                     // 0x07B1(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECharacterAttribute>                   CharacterAttributeList;                            // 0x07C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D8[0x2];                                      // 0x07D8(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDeadBrainCrashOnly;                               // 0x07DA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInfinityCrashChance;                              // 0x07DB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotAbleBrainCrashTarget;                          // 0x07DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseGuts;                                          // 0x07DD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7DE[0x1];                                      // 0x07DE(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDeadPsychicObjComboOnly;                          // 0x07DF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeadChaseAttackOnly;                              // 0x07E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeadLaunchAttackOnly;                             // 0x07E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeadPhysicsAttackOnly;                            // 0x07E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeadPsychicObjOnly;                               // 0x07E3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoDeadTutorial;                                   // 0x07E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoDeadEvent;                                      // 0x07E5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoCrashChanceEvent;                               // 0x07E6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEmphasisCrashGauge;                             // 0x07E7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HPPercentOfDamageBefore;                           // 0x07E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableDamageAddReaction;                         // 0x07EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableDamageAddShake;                            // 0x07ED(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7EE[0x1];                                      // 0x07EE(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsHitInvincibleParts;                             // 0x07EF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7F0[0x1];                                      // 0x07F0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EEnemyAttractType                             AttractType;                                       // 0x07F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7F2[0x2];                                      // 0x07F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PsychicFieldDamageRateToBoss;                      // 0x07F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MDownCapusleInterpSpeed;                           // 0x07F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MDownCapsuleOriginalAttachName;                    // 0x07FC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MDownCapsuleInterpAttachName;                      // 0x0804(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDownCapsuleOriginalHalfHeight;                    // 0x080C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDownCapsuleInterpHalfHeight;                      // 0x0810(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDownCapsuleOriginalRadius;                        // 0x0814(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDownCapsuleInterpRadius;                          // 0x0818(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MDownCapsuleOriginalRelativeLocation;              // 0x081C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MDownCapsuleInterpRelativeLocation;                // 0x0828(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MDownCapsuleOriginalRelativeRotation;              // 0x0834(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               MDownCapsuleInterpRelativeRotation;                // 0x0840(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_84C[0x18];                                     // 0x084C(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableUro;                                        // 0x0864(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_865[0x3];                                      // 0x0865(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 MUroThesholds;                                     // 0x0868(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URSParticleSystemComponentBase*> MCameraDitherParticlArray;                         // 0x0878(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UCapsuleComponent*>              MCameraDitherCheckComponentArray;                  // 0x0888(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterDitherDataAsset*              MCameraDitherDataAsset;                            // 0x0898(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDitherValue;                                      // 0x08A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A4[0x4];                                      // 0x08A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerScriptComponent*                 PlayerScriptCache;                                 // 0x08A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerAsyncScriptComponent*            PlayerAsyncScriptCache;                            // 0x08B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerDriveComponent*                  PlayerDriveCache;                                  // 0x08B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnemyScriptComponent*                  EnemyScriptCache;                                  // 0x08C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMoveInputComponent*                    MoveInputCache;                                    // 0x08C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTargetSearchComponent*                 TargetSearchCache;                                 // 0x08D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHateTargetComponent*                   HateTargetCache;                                   // 0x08D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHPEventComponent*                      HPEventCache;                                      // 0x08E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitCheckReceiverComponent*             HitCheckReceiverCache;                             // 0x08E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddAttackingList(class ARSCharacterBase* AddCharacter);
	void AddTargetingList(class ARSCharacterBase* AddCharacter);
	float CalcUniqueDamage(const struct FHCHitResult& HitResult, float BaseDamage);
	bool CheckAttractSelf(const struct FHCHitResult& HitResult);
	bool CheckStrongCharacter(class ARSCharacterBase* CheckCharacter);
	bool CheckTargetableCharacter(const class ARSCharacterBase* Chara);
	bool CheckTargetableCharacterReason(ETargetFailedReason* OutReason, const class ARSCharacterBase* Chara);
	void ClearDamageDataArray();
	void ClearLoopSeKeyList();
	void DisableCharacterHit();
	void DisableDamageHit();
	void EnableAbsoluteVisibilityTrace(bool bEnable);
	void EnableCharacterHit(float Time);
	void EnableDamageHit();
	void EndInterruptTelepoEffect();
	void EndInterruptTelepoEffectImmediately();
	void EndMotionEffect();
	void EndMotionEffectImmediately();
	void ForceApplyCameraDither(bool bMesh, bool bParticle);
	void ForceEndInterpDownCapsule(class UCapsuleComponent* CharaCapsule);
	bool GetAssumptionDataNamesNative(class UDataTable* DataTable, const class FString& LevelName, TArray<class FName>& ResultRowNames);
	TArray<class ARSCharacterBase*> GetAttackingList();
	class UPlayerScriptComponent* GetCachedPlayerScript();
	TArray<ECharacterAttribute> GetCharacterAttribute();
	TArray<class FName> GetLoopSeKeyList();
	float GetPsychicFieldDamageRateToBoss();
	TArray<class ARSCharacterBase*> GetTargetingList();
	bool IsRegistLoopSe(class FName Name_0);
	bool IsTargetRendered();
	bool OnAddedBattleMemberFromMenu();
	void OnBeLockOn();
	void OnDamageCalcArray();
	void OnFellOutOfWorld();
	void OnFinishSpawnWaitDelayTimer();
	bool PauseLoopSe(class FName Name_0, float FadeTime, float FadeVolume);
	bool PlayLoopSe(class FName Name_0, class USoundAtomCue* AtomCue, const struct FVector& Location, const struct FRotator& Rotation, float FadeTime, float FadeVolume, bool ForceFirstStart);
	void ProcDamageActorHit(const struct FHCHitResult& HitResult);
	void ProcDamageAfter(const TArray<struct FHCHitResult>& Result);
	struct FHCHitResult ProcDamageAssassinAttack(const struct FHCHitResult& HitResult);
	void ProcDamageBefore();
	void RegistCameraDitherParticlehandle(class URSParticleSystemComponentBase* Particle);
	void RegisterSignificanceManager();
	void RegisterSpecialDamageEffect(class URSParticleSystemComponentBase* Particle);
	void RequestApplyCameraDither(bool bMesh, bool bParticle);
	void ReserveDamageDirectAttack(bool bUseFixDamage, int32 FixDamage, const struct FHCHitResult& HitResult, bool IsForceCritical);
	void ResetCharacterHitOffset();
	void ResetInterruptTelepoEffectList();
	void ResetMotionEffectList();
	bool ResumeLoopSe(class FName Name_0, float FadeTime, float FadeVolume);
	void SetAttractSelf(bool bAttract);
	void SetBrainCrashReceivePossible(bool Flag);
	void SetCameraDitherToMeshAndParticles(float DeitherValue, bool bIgnorMesh);
	void SetCameraStabilizeParameter(float DistLockHz, float DistRestoreHz, float DistLockVt, float DistRestoreVt);
	void SetDeadBrainCrashOnly(bool bEnable);
	void SetDisableDamageAddReaction(bool bDisable);
	void SetDisableDamageAddShake(bool bDisable);
	void SetDisableTarget(bool bDisable, const class FName& ClaimantName);
	void SetEnableLockOnRestrictTarget(bool bEnable);
	void SetEventCondition(bool bEvent);
	void SetGaugeDisappearInstantly(bool DisappearInstantly);
	void SetInfinityCrashChance(bool bEnable);
	void SetInterruptTelepoEffect(class URSParticleSystemComponentBase* Effect);
	void SetInVisionFog(bool bInFog);
	void SetLockOnRestrict(bool bRestrict);
	void SetMotionEffect(class URSParticleSystemComponentBase* Effect);
	void SetNoCollisionAndStopAiFade(bool bNoColAndStopAi, bool* Dummy);
	void SetNoCrashChanceByUseGuts(bool bEnable);
	void SetRootMotionScale(float Scale);
	void SetSkipRecoverHpAnime(bool bEnable);
	void SetStealthMode(bool bStealth);
	void SetTargetAbleStealthActor(bool bSearchAble);
	void SetUpdateRepop(bool UpdateRepop);
	void SetUseGuts(bool bUse);
	void StartInterpDownCapsule(float InterpSpeed, class FName InterpAttachName, float InterpHalfHeight, float InterpRadius, const struct FVector& RelativeLocation, const struct FRotator& RelativeRotation, const class UCapsuleComponent* CharaCapsule);
	void StartRestoreInterpDownCapsule(float InterpSpeed, const class UCapsuleComponent* CharaCapsule);
	bool StopLoopSe(class FName Name_0, float FadeTime, float FadeVolume);
	void StopLoopSeAll(float FadeTime, float FadeVolume);
	void SubAttackingList(class ARSCharacterBase* SubCharacter);
	void SubTargetingList(class ARSCharacterBase* SubCharacter);
	void UnregisterSignificanceManager();
	void UpdateAnimationCurveMovement();
	float UpdateCameraDitherInner(float DeltaSeconds, bool UseDither, const class UCapsuleComponent* CheckComponent, float CheckDistance);
	void UpdateInterpDownCapsule(class UCapsuleComponent* CharaCapsule, float DeltaSec);

	bool CanAddAttackingList(const class ARSCharacterBase* NewCharacter) const;
	bool CanAddTargetingList(const class ARSCharacterBase* NewCharacter) const;
	TArray<class USkeletalMeshSocket*> GetActiveSocketList() const;
	float GetActorDeltaSecondsCPP() const;
	EAssassinAttackHit GetAssasinAttackHitType() const;
	EEnemyAttractType GetAttractType() const;
	float GetBrainCrashRange() const;
	class FName GetCh0200CvEffect_BoneName() const;
	float GetCh0200CvEffect_CameraOffset() const;
	struct FVector GetCh0200CvEffect_Scale() const;
	bool GetCharacterMovementGroundInfoSimple(struct FHitResult* Result) const;
	struct FVector GetCharacterMovementLocationSimple() const;
	class UCharactersParameterComponent* GetCharactersParameterComponent() const;
	const TArray<class ARSCharacterBase*> GetConstAttackingList() const;
	const TArray<class ARSCharacterBase*> GetConstTargetingList() const;
	int32 GetDamageDataArrayNum() const;
	int32 GetDirectDamageDataArrayNum() const;
	class FName GetEnemyDeadReplaceLogName() const;
	struct FEnemyFindChangeParam GetEnemyFindChangeParam() const;
	struct FVector GetEyePosition() const;
	struct FVector GetGroundLocationSimple(bool bIncludeObject) const;
	int32 GetGroupID() const;
	float GetSignificanceResult() const;
	TArray<class FName> GetSkeletonSlotNames() const;
	ESpecialDamageTableType GetSpecialDamageTableType() const;
	int32 GetUniqueId() const;
	class FName GetUniqueName() const;
	bool IsAbsoluteVisibilityTrace() const;
	bool IsAttractSelf() const;
	bool IsBrainCrashAccess() const;
	bool IsBrainCrashReceivePossible() const;
	bool IsBrainCrashSuccess() const;
	bool IsCharacterBadStatusAttribute(EHCSkillAttribute Attr) const;
	bool IsCharacterBadStatusConfusion() const;
	bool IsCharacterBadStatusElectric() const;
	bool IsCharacterBadStatusFlame() const;
	bool IsCharacterBadStatusFlooded() const;
	bool IsCharacterBadStatusOil() const;
	bool IsCharacterDead() const;
	bool IsCrashMaxWithGuts() const;
	bool IsDeadBrainCrashOnly() const;
	bool IsDisableDamageAddReaction() const;
	bool IsDisableDamageAddShake() const;
	bool IsEnableCharacterHit() const;
	bool IsEnableDamageHit() const;
	bool IsEnableMetalMode() const;
	bool IsEventCondition() const;
	bool IsFallingCPP() const;
	bool IsFinishActorBeginPlay() const;
	bool IsFlyingCPP() const;
	bool IsFriendTeam(class UTeamComponent* Team) const;
	bool IsGaugeDisappearInstantly() const;
	bool IsGuardBadCondition(EHCSkillAttribute Attr) const;
	bool IsHitInvincibleParts() const;
	bool IsIgnoreVisionFog() const;
	bool IsInfinityCrashChance() const;
	bool IsInVisionFog() const;
	bool IsNoCrashChanceByUseGuts() const;
	bool IsNotAbleBrainCrashTarget() const;
	bool IsRivalTeam(class UTeamComponent* Team) const;
	bool IsSeeTarget(const class ARSCharacterBase* Target) const;
	bool IsSkipRecoverHpAnime() const;
	bool IsStealthMode() const;
	bool IsTargetable() const;
	bool IsTargetAbleStealthActor() const;
	bool IsUpdateRepop() const;
	bool IsUseGuts() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCharacterBase">();
	}
	static class ARSCharacterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSCharacterBase>();
	}
};
static_assert(alignof(ARSCharacterBase) == 0x000010, "Wrong alignment on ARSCharacterBase");
static_assert(sizeof(ARSCharacterBase) == 0x0008F0, "Wrong size on ARSCharacterBase");
static_assert(offsetof(ARSCharacterBase, DispatchTick) == 0x000648, "Member 'ARSCharacterBase::DispatchTick' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, DispatchStealth) == 0x000658, "Member 'ARSCharacterBase::DispatchStealth' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, CharacterHitPriority) == 0x000668, "Member 'ARSCharacterBase::CharacterHitPriority' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, CharacterHitTimeSliceNum) == 0x00066C, "Member 'ARSCharacterBase::CharacterHitTimeSliceNum' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, DamageDataArray) == 0x000670, "Member 'ARSCharacterBase::DamageDataArray' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, DirectDamageDataArray) == 0x000680, "Member 'ARSCharacterBase::DirectDamageDataArray' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, DamageData_Temp) == 0x000690, "Member 'ARSCharacterBase::DamageData_Temp' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, UniqueIdComponent) == 0x0006C0, "Member 'ARSCharacterBase::UniqueIdComponent' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, CharacterItemDropId) == 0x0006C8, "Member 'ARSCharacterBase::CharacterItemDropId' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, CoreDropId) == 0x0006CC, "Member 'ARSCharacterBase::CoreDropId' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bTestCurveMoveCharacterMovement) == 0x0006D0, "Member 'ARSCharacterBase::bTestCurveMoveCharacterMovement' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bUseAnimationCurveMovement) == 0x0006D1, "Member 'ARSCharacterBase::bUseAnimationCurveMovement' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, AnimationCurveMovementSlotName) == 0x0006D4, "Member 'ARSCharacterBase::AnimationCurveMovementSlotName' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, FootStepComponent) == 0x0006F0, "Member 'ARSCharacterBase::FootStepComponent' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, DamageArrayComponent) == 0x0006F8, "Member 'ARSCharacterBase::DamageArrayComponent' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, DamageResponseComponent) == 0x000700, "Member 'ARSCharacterBase::DamageResponseComponent' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, PriorityHitEffect) == 0x000728, "Member 'ARSCharacterBase::PriorityHitEffect' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MLoopSeKeyList) == 0x000730, "Member 'ARSCharacterBase::MLoopSeKeyList' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bDisableNpcTarget) == 0x000751, "Member 'ARSCharacterBase::bDisableNpcTarget' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bLockOnRestrictFlag) == 0x000752, "Member 'ARSCharacterBase::bLockOnRestrictFlag' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bEnableLockOnRestrictTarget) == 0x000753, "Member 'ARSCharacterBase::bEnableLockOnRestrictTarget' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, NotTargetableList) == 0x000758, "Member 'ARSCharacterBase::NotTargetableList' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MCh0200CvEffect_BoneName) == 0x000778, "Member 'ARSCharacterBase::MCh0200CvEffect_BoneName' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MCh0200CvEffect_Scale) == 0x000780, "Member 'ARSCharacterBase::MCh0200CvEffect_Scale' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MCh0200CvEffect_CameraOffset) == 0x00078C, "Member 'ARSCharacterBase::MCh0200CvEffect_CameraOffset' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MTargetingList) == 0x000790, "Member 'ARSCharacterBase::MTargetingList' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MAttackingList) == 0x0007A0, "Member 'ARSCharacterBase::MAttackingList' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MEnemyGrade) == 0x0007B0, "Member 'ARSCharacterBase::MEnemyGrade' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, CharacterAttributeList) == 0x0007C8, "Member 'ARSCharacterBase::CharacterAttributeList' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bDeadBrainCrashOnly) == 0x0007DA, "Member 'ARSCharacterBase::bDeadBrainCrashOnly' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bInfinityCrashChance) == 0x0007DB, "Member 'ARSCharacterBase::bInfinityCrashChance' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bNotAbleBrainCrashTarget) == 0x0007DC, "Member 'ARSCharacterBase::bNotAbleBrainCrashTarget' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bUseGuts) == 0x0007DD, "Member 'ARSCharacterBase::bUseGuts' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bDeadPsychicObjComboOnly) == 0x0007DF, "Member 'ARSCharacterBase::bDeadPsychicObjComboOnly' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bDeadChaseAttackOnly) == 0x0007E0, "Member 'ARSCharacterBase::bDeadChaseAttackOnly' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bDeadLaunchAttackOnly) == 0x0007E1, "Member 'ARSCharacterBase::bDeadLaunchAttackOnly' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bDeadPhysicsAttackOnly) == 0x0007E2, "Member 'ARSCharacterBase::bDeadPhysicsAttackOnly' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bDeadPsychicObjOnly) == 0x0007E3, "Member 'ARSCharacterBase::bDeadPsychicObjOnly' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bNoDeadTutorial) == 0x0007E4, "Member 'ARSCharacterBase::bNoDeadTutorial' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bNoDeadEvent) == 0x0007E5, "Member 'ARSCharacterBase::bNoDeadEvent' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bNoCrashChanceEvent) == 0x0007E6, "Member 'ARSCharacterBase::bNoCrashChanceEvent' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bIsEmphasisCrashGauge) == 0x0007E7, "Member 'ARSCharacterBase::bIsEmphasisCrashGauge' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, HPPercentOfDamageBefore) == 0x0007E8, "Member 'ARSCharacterBase::HPPercentOfDamageBefore' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bDisableDamageAddReaction) == 0x0007EC, "Member 'ARSCharacterBase::bDisableDamageAddReaction' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bDisableDamageAddShake) == 0x0007ED, "Member 'ARSCharacterBase::bDisableDamageAddShake' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bIsHitInvincibleParts) == 0x0007EF, "Member 'ARSCharacterBase::bIsHitInvincibleParts' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, AttractType) == 0x0007F1, "Member 'ARSCharacterBase::AttractType' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, PsychicFieldDamageRateToBoss) == 0x0007F4, "Member 'ARSCharacterBase::PsychicFieldDamageRateToBoss' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapusleInterpSpeed) == 0x0007F8, "Member 'ARSCharacterBase::MDownCapusleInterpSpeed' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleOriginalAttachName) == 0x0007FC, "Member 'ARSCharacterBase::MDownCapsuleOriginalAttachName' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleInterpAttachName) == 0x000804, "Member 'ARSCharacterBase::MDownCapsuleInterpAttachName' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleOriginalHalfHeight) == 0x00080C, "Member 'ARSCharacterBase::MDownCapsuleOriginalHalfHeight' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleInterpHalfHeight) == 0x000810, "Member 'ARSCharacterBase::MDownCapsuleInterpHalfHeight' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleOriginalRadius) == 0x000814, "Member 'ARSCharacterBase::MDownCapsuleOriginalRadius' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleInterpRadius) == 0x000818, "Member 'ARSCharacterBase::MDownCapsuleInterpRadius' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleOriginalRelativeLocation) == 0x00081C, "Member 'ARSCharacterBase::MDownCapsuleOriginalRelativeLocation' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleInterpRelativeLocation) == 0x000828, "Member 'ARSCharacterBase::MDownCapsuleInterpRelativeLocation' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleOriginalRelativeRotation) == 0x000834, "Member 'ARSCharacterBase::MDownCapsuleOriginalRelativeRotation' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleInterpRelativeRotation) == 0x000840, "Member 'ARSCharacterBase::MDownCapsuleInterpRelativeRotation' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bEnableUro) == 0x000864, "Member 'ARSCharacterBase::bEnableUro' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MUroThesholds) == 0x000868, "Member 'ARSCharacterBase::MUroThesholds' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MCameraDitherParticlArray) == 0x000878, "Member 'ARSCharacterBase::MCameraDitherParticlArray' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MCameraDitherCheckComponentArray) == 0x000888, "Member 'ARSCharacterBase::MCameraDitherCheckComponentArray' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MCameraDitherDataAsset) == 0x000898, "Member 'ARSCharacterBase::MCameraDitherDataAsset' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDitherValue) == 0x0008A0, "Member 'ARSCharacterBase::MDitherValue' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, PlayerScriptCache) == 0x0008A8, "Member 'ARSCharacterBase::PlayerScriptCache' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, PlayerAsyncScriptCache) == 0x0008B0, "Member 'ARSCharacterBase::PlayerAsyncScriptCache' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, PlayerDriveCache) == 0x0008B8, "Member 'ARSCharacterBase::PlayerDriveCache' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, EnemyScriptCache) == 0x0008C0, "Member 'ARSCharacterBase::EnemyScriptCache' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MoveInputCache) == 0x0008C8, "Member 'ARSCharacterBase::MoveInputCache' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, TargetSearchCache) == 0x0008D0, "Member 'ARSCharacterBase::TargetSearchCache' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, HateTargetCache) == 0x0008D8, "Member 'ARSCharacterBase::HateTargetCache' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, HPEventCache) == 0x0008E0, "Member 'ARSCharacterBase::HPEventCache' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, HitCheckReceiverCache) == 0x0008E8, "Member 'ARSCharacterBase::HitCheckReceiverCache' has a wrong offset!");

// Class BattlePrototype.RSCheatManager
// 0x0008 (0x0080 - 0x0078)
class URSCheatManager final : public UCheatManager
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 GetWidgetLayoutDispFlag();
	static bool IsHudDisp();
	static bool IsPerfMeterDisp();
	static bool IsPerfMeterValuePercentage();
	static bool IsPerfMeterWithStat();
	static bool IsSASParticleDisp();
	static bool IsTargetCursorDisp();

	void RSCAutoTest(const class FString& Args);
	void RSCDumpLevelActorStat(bool bWarningInvalidActor);
	void RSCDumpParticleInfo();
	void RSCDumpTopLevelWidget();
	void RSCHudInvisibleAll(bool bInvisible);
	void RSCSetAILevel(const class FString& Name_0);
	void RSCSetBarrier(const class FString& Name_0);
	void RSCSetBarrierInvincible(const class FString& Name_0);
	void RSCSetBattlePlayerAIMode(const class FString& Name_0);
	void RSCSetCombo(const class FString& Name_0);
	void RSCToggleFreeCamera();
	void RSCWarp(const class FString& Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCheatManager">();
	}
	static class URSCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSCheatManager>();
	}
};
static_assert(alignof(URSCheatManager) == 0x000008, "Wrong alignment on URSCheatManager");
static_assert(sizeof(URSCheatManager) == 0x000080, "Wrong size on URSCheatManager");

// Class BattlePrototype.RSClassFinder
// 0x0008 (0x0030 - 0x0028)
class URSClassFinder final : public UObject
{
public:
	TSubclassOf<class AActor>                     SpawnClass;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void SetNextAsset(class FName ClassName, class FName AssetName);

	TSubclassOf<class AActor> GetClass() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSClassFinder">();
	}
	static class URSClassFinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSClassFinder>();
	}
};
static_assert(alignof(URSClassFinder) == 0x000008, "Wrong alignment on URSClassFinder");
static_assert(sizeof(URSClassFinder) == 0x000030, "Wrong size on URSClassFinder");
static_assert(offsetof(URSClassFinder, SpawnClass) == 0x000028, "Member 'URSClassFinder::SpawnClass' has a wrong offset!");

// Class BattlePrototype.RSCreditEventManager
// 0x0000 (0x0230 - 0x0230)
class ARSCreditEventManager final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCreditEventManager">();
	}
	static class ARSCreditEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSCreditEventManager>();
	}
};
static_assert(alignof(ARSCreditEventManager) == 0x000008, "Wrong alignment on ARSCreditEventManager");
static_assert(sizeof(ARSCreditEventManager) == 0x000230, "Wrong size on ARSCreditEventManager");

// Class BattlePrototype.RSCrossSaveManager
// 0x0078 (0x00A8 - 0x0030)
class URSCrossSaveManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x78];                                      // 0x0030(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCrossSaveManager">();
	}
	static class URSCrossSaveManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSCrossSaveManager>();
	}
};
static_assert(alignof(URSCrossSaveManager) == 0x000008, "Wrong alignment on URSCrossSaveManager");
static_assert(sizeof(URSCrossSaveManager) == 0x0000A8, "Wrong size on URSCrossSaveManager");

// Class BattlePrototype.UIEnemyInfoWindow
// 0x00A0 (0x0428 - 0x0388)
class UUIEnemyInfoWindow : public UUIBase
{
public:
	TSubclassOf<class UUIEnemyDropItem>           M_pDropItemClass;                                  // 0x0388(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x98];                                     // 0x0390(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault1, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimDefault1_2, class UWidgetAnimation* AnimDefault2_1, class UVerticalBox* VerticalBoxDropItem, class UUIEnemyDropItem* ChildDropItem, class UVerticalBox* VerticalBoxHabitat, class UTextBlock* TextHabitat, class UOverlay* OverlayDetails, class UTextBlock* TextDetailsTitle, class UImage* EnemyImage, class UTextBlock* TextEnemyName, class UTextBlock* TextDropItemTitle, class UTextBlock* TextHabitatTitle, class UREDScrollBoxSimple* ScrollBox1, class UREDScrollBoxSimple* ScrollBox2, class UREDOverlay* Mousehitthubnail);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEnemyInfoWindow">();
	}
	static class UUIEnemyInfoWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEnemyInfoWindow>();
	}
};
static_assert(alignof(UUIEnemyInfoWindow) == 0x000008, "Wrong alignment on UUIEnemyInfoWindow");
static_assert(sizeof(UUIEnemyInfoWindow) == 0x000428, "Wrong size on UUIEnemyInfoWindow");
static_assert(offsetof(UUIEnemyInfoWindow, M_pDropItemClass) == 0x000388, "Member 'UUIEnemyInfoWindow::M_pDropItemClass' has a wrong offset!");

// Class BattlePrototype.RSCustomOperatorLib
// 0x0000 (0x0028 - 0x0028)
class URSCustomOperatorLib final : public UBlueprintFunctionLibrary
{
public:
	static int32 BitShiftLeft(int32 Value, int32 Shift);
	static int32 BitShiftRight(int32 Value, int32 Shift);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCustomOperatorLib">();
	}
	static class URSCustomOperatorLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSCustomOperatorLib>();
	}
};
static_assert(alignof(URSCustomOperatorLib) == 0x000008, "Wrong alignment on URSCustomOperatorLib");
static_assert(sizeof(URSCustomOperatorLib) == 0x000028, "Wrong size on URSCustomOperatorLib");

// Class BattlePrototype.RSCvManager
// 0x0090 (0x0150 - 0x00C0)
class URSCvManager : public UActorComponent
{
public:
	class ARSSoundManager*                        M_pSoundManager;                                   // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCueSheetManager*                  M_pCueSheetManager;                                // 0x00C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayingEventType                             M_playingEventType;                                // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_playingChapterTag;                               // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_lastChapterTag;                                  // 0x00E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_playingBondsEpisodeTag;                          // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_lastBondsEpisodeTag;                             // 0x0108(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_standbyTag;                                      // 0x0118(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_lastStandbyTag;                                  // 0x0128(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_voiceLanguage;                                   // 0x0138(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isInit;                                          // 0x0148(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isTitle;                                         // 0x0149(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14A[0x6];                                      // 0x014A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Finalize();
	class FString GetChapterStringFromProgressId(int32 ProgressId);
	class FString GetCueSheetName(class USoundAtomCue* Cue);
	class FString GetCueSheetNameFromCueSheet(class USoundAtomCueSheet* CueSheet);
	class USoundAtomCueSheet* GetFitLanguageCueSheetFromCueSheetManager(class USoundAtomCue* Sound);
	void Initialize();
	bool LoadCmnCueSheets();
	bool LoadCueSheet(class USoundAtomCueSheet* CueSheet);
	bool LoadCueSheetFromDtRef(const class FString& RowName);
	bool LoadSenarioCueSheet();
	void OnChangeEventStat();
	void OnChangeVoiceLanguage();
	void OnStartTitle();
	class URSAtomComponentBase* PlayVoice(class USoundAtomCue* Sound, bool IsAttache, bool IsAutoActivate, class USceneComponent* AttachToComponent, class FName AttachPointName, EFilterCallbackType FilterCallbackType);
	void SetMVarPlayingEventType();
	bool UnLoadCueSheet(class USoundAtomCueSheet* CueSheet);
	bool UnLoadCueSheetAll();
	bool UnLoadCueSheetFromDtRef(const class FString& RowName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCvManager">();
	}
	static class URSCvManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSCvManager>();
	}
};
static_assert(alignof(URSCvManager) == 0x000008, "Wrong alignment on URSCvManager");
static_assert(sizeof(URSCvManager) == 0x000150, "Wrong size on URSCvManager");
static_assert(offsetof(URSCvManager, M_pSoundManager) == 0x0000C0, "Member 'URSCvManager::M_pSoundManager' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_pCueSheetManager) == 0x0000C8, "Member 'URSCvManager::M_pCueSheetManager' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_playingEventType) == 0x0000D0, "Member 'URSCvManager::M_playingEventType' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_playingChapterTag) == 0x0000D8, "Member 'URSCvManager::M_playingChapterTag' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_lastChapterTag) == 0x0000E8, "Member 'URSCvManager::M_lastChapterTag' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_playingBondsEpisodeTag) == 0x0000F8, "Member 'URSCvManager::M_playingBondsEpisodeTag' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_lastBondsEpisodeTag) == 0x000108, "Member 'URSCvManager::M_lastBondsEpisodeTag' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_standbyTag) == 0x000118, "Member 'URSCvManager::M_standbyTag' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_lastStandbyTag) == 0x000128, "Member 'URSCvManager::M_lastStandbyTag' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_voiceLanguage) == 0x000138, "Member 'URSCvManager::M_voiceLanguage' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_isInit) == 0x000148, "Member 'URSCvManager::M_isInit' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_isTitle) == 0x000149, "Member 'URSCvManager::M_isTitle' has a wrong offset!");

// Class BattlePrototype.RSDPICustomScalingRule
// 0x0000 (0x0028 - 0x0028)
class URSDPICustomScalingRule final : public UDPICustomScalingRule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSDPICustomScalingRule">();
	}
	static class URSDPICustomScalingRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSDPICustomScalingRule>();
	}
};
static_assert(alignof(URSDPICustomScalingRule) == 0x000008, "Wrong alignment on URSDPICustomScalingRule");
static_assert(sizeof(URSDPICustomScalingRule) == 0x000028, "Wrong size on URSDPICustomScalingRule");

// Class BattlePrototype.UIFade
// 0x0030 (0x03B8 - 0x0388)
class UUIFade : public UUIBase
{
public:
	uint8                                         Pad_388[0x30];                                     // 0x0388(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UImage* ImageBG);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFade">();
	}
	static class UUIFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFade>();
	}
};
static_assert(alignof(UUIFade) == 0x000008, "Wrong alignment on UUIFade");
static_assert(sizeof(UUIFade) == 0x0003B8, "Wrong size on UUIFade");

// Class BattlePrototype.RSEditorCallbackActor
// 0x0000 (0x0230 - 0x0230)
class ARSEditorCallbackActor : public AActor
{
public:
	void EventPostEditChangeProperty();
	void EventPostEditMove(bool bFinished);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSEditorCallbackActor">();
	}
	static class ARSEditorCallbackActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSEditorCallbackActor>();
	}
};
static_assert(alignof(ARSEditorCallbackActor) == 0x000008, "Wrong alignment on ARSEditorCallbackActor");
static_assert(sizeof(ARSEditorCallbackActor) == 0x000230, "Wrong size on ARSEditorCallbackActor");

// Class BattlePrototype.RSEditorTickedActor
// 0x0008 (0x0238 - 0x0230)
class ARSEditorTickedActor final : public AActor
{
public:
	bool                                          bEnableEditorTick;                                 // 0x0230(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EventPostEditChangeProperty();
	void EventPostEditMove(bool bFinished);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSEditorTickedActor">();
	}
	static class ARSEditorTickedActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSEditorTickedActor>();
	}
};
static_assert(alignof(ARSEditorTickedActor) == 0x000008, "Wrong alignment on ARSEditorTickedActor");
static_assert(sizeof(ARSEditorTickedActor) == 0x000238, "Wrong size on ARSEditorTickedActor");
static_assert(offsetof(ARSEditorTickedActor, bEnableEditorTick) == 0x000230, "Member 'ARSEditorTickedActor::bEnableEditorTick' has a wrong offset!");

// Class BattlePrototype.RSEffectFuncLibraryCPP
// 0x0000 (0x0028 - 0x0028)
class URSEffectFuncLibraryCPP final : public UBlueprintFunctionLibrary
{
public:
	static struct FRotator CalcDamageHitEffectRotation(class AActor* InActor, const struct FHCHitResult& InHitResult, const struct FVector& InEffectSpawnLocation);
	static void SpawnDamageHitEffectCPP(class AActor* Actor, const struct FHCHitResult& HitResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSEffectFuncLibraryCPP">();
	}
	static class URSEffectFuncLibraryCPP* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSEffectFuncLibraryCPP>();
	}
};
static_assert(alignof(URSEffectFuncLibraryCPP) == 0x000008, "Wrong alignment on URSEffectFuncLibraryCPP");
static_assert(sizeof(URSEffectFuncLibraryCPP) == 0x000028, "Wrong size on URSEffectFuncLibraryCPP");

// Class BattlePrototype.RSEnemyAnimInstance
// 0x00F0 (0x0710 - 0x0620)
class URSEnemyAnimInstance final : public URSCharacterAnimInstance
{
public:
	EnemyAliveAnimKind                            _aliveAnimKind;                                    // 0x0620(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyMoveAnimKind                             _MoveAnimKind;                                     // 0x0621(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyAttackAnimKind                           _attackAnimKind;                                   // 0x0622(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyActionAnimKind                           _actionAnimKind;                                   // 0x0623(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemySwitchAnimKind                           _switchAnimKind;                                   // 0x0624(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyDamageAnimKind                           _damageAnimKind;                                   // 0x0625(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyDamageDownAnimKind                       _damageDownAnimKind;                               // 0x0626(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyBrainCrashAnimKind                       _brainCrashAnimKind;                               // 0x0627(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyDeadAnimKind                             _deadAnimKind;                                     // 0x0628(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyInitLayoutAnimKind                       _initLayoutAnimKind;                               // 0x0629(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyEventAnimKind                            _eventAnimKind;                                    // 0x062A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyCrashChanceAnimKind                      _crashChanceAnimKind;                              // 0x062B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyKind                                     _EnemyKind;                                        // 0x062C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62D[0x3];                                      // 0x062D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _walkSpeed;                                        // 0x0630(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bBackMove;                                        // 0x0634(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bExcite;                                          // 0x0635(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bLanded;                                          // 0x0636(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bDamageAnimStateB;                                // 0x0637(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bDamageAnimLight2;                                // 0x0638(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bRequestFaintWakeup;                              // 0x0639(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bAttackFlg;                                       // 0x063A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63B[0x1];                                      // 0x063B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _blendSpaceData;                                   // 0x063C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _animRigidBodyIdlingSec;                           // 0x0648(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _animDynamicsIdlingSec;                            // 0x064C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bEvent;                                           // 0x0650(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_651[0x3];                                      // 0x0651(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _addDamageBlendWeightDefault;                      // 0x0654(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _addDamageBlendWeightCurrent;                      // 0x0658(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_65C[0x4];                                      // 0x065C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchMontageBlendingOut;                        // 0x0660(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          _bEnableLookAt;                                    // 0x0670(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bFinishLookAtRotateZero;                          // 0x0671(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bLookFront;                                       // 0x0672(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_673[0x1];                                      // 0x0673(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _lrRotateLimit;                                    // 0x0674(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _upRotateLimit;                                    // 0x0678(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _downRotateLimit;                                  // 0x067C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lookAtFollowSpeed;                                // 0x0680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _lookAtLocation;                                   // 0x0684(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               _lookAtRotation;                                   // 0x0690(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          _bEnableIK;                                        // 0x069C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69D[0x3];                                      // 0x069D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _IKAlpha;                                          // 0x06A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _IKDstAlpha;                                       // 0x06A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _IKAlphaChangeRate;                                // 0x06A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6AC[0x4];                                      // 0x06AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTinyIKInfo>                    _tinyIKArray;                                      // 0x06B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LeftFootIKBoneName;                                // 0x06C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RightFootIKBoneName;                               // 0x06C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FootIKBlendRate;                                   // 0x06D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FootIKOffset_Left;                                 // 0x06D4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FootIKOffset_Right;                                // 0x06E0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FootIKJointTargetLocation_Left;                    // 0x06EC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FootIKJointTargetLocation_Right;                   // 0x06F8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bEnableBrainCrashEvent;                           // 0x0704(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_705[0xB];                                      // 0x0705(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttackEnd(EnemyAttackAnimKind Attack);
	bool CheckGoToIdleMove(bool bEndAnim);
	void DisableBrainCrashEvent();
	void DisableEnemyIK();
	void EnableBrainCrashEvent();
	void EnableEnemyIK();
	void FinishLookAt(bool bRotateZero);
	void RecvOnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void ResetDefaultAddDamageBlendWeight();
	void SetAddDamageBlendWeight(float Value);
	void SetIKAlpha(float Value);
	void SetIKDstAlpha(float Value);
	void StartLookAt(bool bResetRotate);
	void UpdateSpineRotateNative(struct FRotator& SpineRot, bool& UpdateSpineRot, bool EnableSpineRot, class ARSCharacterBase* TargetCharacter, class ARSCharacterBase* Owner, float RotateUpDownMin, float RotateUpDownMax, float RotateLRMax, float DeltaSeconds, float RotateSpeed);

	float GetAddDamageBlendWeight() const;
	float GetIKAlpha() const;
	float GetIKDstAlpha() const;
	bool IsEnableBrainCrashEvent() const;
	bool IsEnableEnemyIK() const;
	bool IsEnableLookAt() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSEnemyAnimInstance">();
	}
	static class URSEnemyAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSEnemyAnimInstance>();
	}
};
static_assert(alignof(URSEnemyAnimInstance) == 0x000010, "Wrong alignment on URSEnemyAnimInstance");
static_assert(sizeof(URSEnemyAnimInstance) == 0x000710, "Wrong size on URSEnemyAnimInstance");
static_assert(offsetof(URSEnemyAnimInstance, _aliveAnimKind) == 0x000620, "Member 'URSEnemyAnimInstance::_aliveAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _MoveAnimKind) == 0x000621, "Member 'URSEnemyAnimInstance::_MoveAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _attackAnimKind) == 0x000622, "Member 'URSEnemyAnimInstance::_attackAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _actionAnimKind) == 0x000623, "Member 'URSEnemyAnimInstance::_actionAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _switchAnimKind) == 0x000624, "Member 'URSEnemyAnimInstance::_switchAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _damageAnimKind) == 0x000625, "Member 'URSEnemyAnimInstance::_damageAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _damageDownAnimKind) == 0x000626, "Member 'URSEnemyAnimInstance::_damageDownAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _brainCrashAnimKind) == 0x000627, "Member 'URSEnemyAnimInstance::_brainCrashAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _deadAnimKind) == 0x000628, "Member 'URSEnemyAnimInstance::_deadAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _initLayoutAnimKind) == 0x000629, "Member 'URSEnemyAnimInstance::_initLayoutAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _eventAnimKind) == 0x00062A, "Member 'URSEnemyAnimInstance::_eventAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _crashChanceAnimKind) == 0x00062B, "Member 'URSEnemyAnimInstance::_crashChanceAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _EnemyKind) == 0x00062C, "Member 'URSEnemyAnimInstance::_EnemyKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _walkSpeed) == 0x000630, "Member 'URSEnemyAnimInstance::_walkSpeed' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bBackMove) == 0x000634, "Member 'URSEnemyAnimInstance::_bBackMove' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bExcite) == 0x000635, "Member 'URSEnemyAnimInstance::_bExcite' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bLanded) == 0x000636, "Member 'URSEnemyAnimInstance::_bLanded' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bDamageAnimStateB) == 0x000637, "Member 'URSEnemyAnimInstance::_bDamageAnimStateB' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bDamageAnimLight2) == 0x000638, "Member 'URSEnemyAnimInstance::_bDamageAnimLight2' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bRequestFaintWakeup) == 0x000639, "Member 'URSEnemyAnimInstance::_bRequestFaintWakeup' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bAttackFlg) == 0x00063A, "Member 'URSEnemyAnimInstance::_bAttackFlg' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _blendSpaceData) == 0x00063C, "Member 'URSEnemyAnimInstance::_blendSpaceData' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _animRigidBodyIdlingSec) == 0x000648, "Member 'URSEnemyAnimInstance::_animRigidBodyIdlingSec' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _animDynamicsIdlingSec) == 0x00064C, "Member 'URSEnemyAnimInstance::_animDynamicsIdlingSec' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bEvent) == 0x000650, "Member 'URSEnemyAnimInstance::_bEvent' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _addDamageBlendWeightDefault) == 0x000654, "Member 'URSEnemyAnimInstance::_addDamageBlendWeightDefault' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _addDamageBlendWeightCurrent) == 0x000658, "Member 'URSEnemyAnimInstance::_addDamageBlendWeightCurrent' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, DispatchMontageBlendingOut) == 0x000660, "Member 'URSEnemyAnimInstance::DispatchMontageBlendingOut' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bEnableLookAt) == 0x000670, "Member 'URSEnemyAnimInstance::_bEnableLookAt' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bFinishLookAtRotateZero) == 0x000671, "Member 'URSEnemyAnimInstance::_bFinishLookAtRotateZero' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bLookFront) == 0x000672, "Member 'URSEnemyAnimInstance::_bLookFront' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _lrRotateLimit) == 0x000674, "Member 'URSEnemyAnimInstance::_lrRotateLimit' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _upRotateLimit) == 0x000678, "Member 'URSEnemyAnimInstance::_upRotateLimit' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _downRotateLimit) == 0x00067C, "Member 'URSEnemyAnimInstance::_downRotateLimit' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _lookAtFollowSpeed) == 0x000680, "Member 'URSEnemyAnimInstance::_lookAtFollowSpeed' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _lookAtLocation) == 0x000684, "Member 'URSEnemyAnimInstance::_lookAtLocation' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _lookAtRotation) == 0x000690, "Member 'URSEnemyAnimInstance::_lookAtRotation' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bEnableIK) == 0x00069C, "Member 'URSEnemyAnimInstance::_bEnableIK' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _IKAlpha) == 0x0006A0, "Member 'URSEnemyAnimInstance::_IKAlpha' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _IKDstAlpha) == 0x0006A4, "Member 'URSEnemyAnimInstance::_IKDstAlpha' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _IKAlphaChangeRate) == 0x0006A8, "Member 'URSEnemyAnimInstance::_IKAlphaChangeRate' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _tinyIKArray) == 0x0006B0, "Member 'URSEnemyAnimInstance::_tinyIKArray' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, LeftFootIKBoneName) == 0x0006C0, "Member 'URSEnemyAnimInstance::LeftFootIKBoneName' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, RightFootIKBoneName) == 0x0006C8, "Member 'URSEnemyAnimInstance::RightFootIKBoneName' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, FootIKBlendRate) == 0x0006D0, "Member 'URSEnemyAnimInstance::FootIKBlendRate' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, FootIKOffset_Left) == 0x0006D4, "Member 'URSEnemyAnimInstance::FootIKOffset_Left' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, FootIKOffset_Right) == 0x0006E0, "Member 'URSEnemyAnimInstance::FootIKOffset_Right' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, FootIKJointTargetLocation_Left) == 0x0006EC, "Member 'URSEnemyAnimInstance::FootIKJointTargetLocation_Left' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, FootIKJointTargetLocation_Right) == 0x0006F8, "Member 'URSEnemyAnimInstance::FootIKJointTargetLocation_Right' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bEnableBrainCrashEvent) == 0x000704, "Member 'URSEnemyAnimInstance::_bEnableBrainCrashEvent' has a wrong offset!");

// Class BattlePrototype.RSEnemyNavArea
// 0x0000 (0x00C8 - 0x00C8)
class URSEnemyNavArea final : public UNavAreaMeta_SwitchByAgent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSEnemyNavArea">();
	}
	static class URSEnemyNavArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSEnemyNavArea>();
	}
};
static_assert(alignof(URSEnemyNavArea) == 0x000008, "Wrong alignment on URSEnemyNavArea");
static_assert(sizeof(URSEnemyNavArea) == 0x0000C8, "Wrong size on URSEnemyNavArea");

// Class BattlePrototype.RSEnemyNavModifierVolume
// 0x0000 (0x0278 - 0x0278)
class ARSEnemyNavModifierVolume final : public ANavModifierVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSEnemyNavModifierVolume">();
	}
	static class ARSEnemyNavModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSEnemyNavModifierVolume>();
	}
};
static_assert(alignof(ARSEnemyNavModifierVolume) == 0x000008, "Wrong alignment on ARSEnemyNavModifierVolume");
static_assert(sizeof(ARSEnemyNavModifierVolume) == 0x000278, "Wrong size on ARSEnemyNavModifierVolume");

// Class BattlePrototype.RSFishSplineBase
// 0x0090 (0x02C0 - 0x0230)
class ARSFishSplineBase final : public AActor
{
public:
	TArray<class UStaticMeshComponent*>           FishMeshes;                                        // 0x0230(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       FishMaterials;                                     // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        Offset;                                            // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        OffsetStart;                                       // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        OffsetEnd;                                         // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 TailRandom;                                        // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 PositionRandom;                                    // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableHalfUpdate;                                 // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x1F];                                     // 0x02A1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CopyParamBPtoCPP(int32 LoopsPerMinute, float TailSpeed, float FishScale, float RandomiseOffset, int32 NumberOfFish);
	void RandomiseOffsetsCPP();
	void UpdateFishCPP(float Position, int32 FishIndex);
	void UpdateOffsetCPP(float Lerp);
	void UpdatePositionLoopCPP(float Lerp, float Tail, bool bForceUpdateAll);

	class USplineComponent* GetSplineComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSFishSplineBase">();
	}
	static class ARSFishSplineBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSFishSplineBase>();
	}
};
static_assert(alignof(ARSFishSplineBase) == 0x000008, "Wrong alignment on ARSFishSplineBase");
static_assert(sizeof(ARSFishSplineBase) == 0x0002C0, "Wrong size on ARSFishSplineBase");
static_assert(offsetof(ARSFishSplineBase, FishMeshes) == 0x000230, "Member 'ARSFishSplineBase::FishMeshes' has a wrong offset!");
static_assert(offsetof(ARSFishSplineBase, FishMaterials) == 0x000240, "Member 'ARSFishSplineBase::FishMaterials' has a wrong offset!");
static_assert(offsetof(ARSFishSplineBase, Offset) == 0x000250, "Member 'ARSFishSplineBase::Offset' has a wrong offset!");
static_assert(offsetof(ARSFishSplineBase, OffsetStart) == 0x000260, "Member 'ARSFishSplineBase::OffsetStart' has a wrong offset!");
static_assert(offsetof(ARSFishSplineBase, OffsetEnd) == 0x000270, "Member 'ARSFishSplineBase::OffsetEnd' has a wrong offset!");
static_assert(offsetof(ARSFishSplineBase, TailRandom) == 0x000280, "Member 'ARSFishSplineBase::TailRandom' has a wrong offset!");
static_assert(offsetof(ARSFishSplineBase, PositionRandom) == 0x000290, "Member 'ARSFishSplineBase::PositionRandom' has a wrong offset!");
static_assert(offsetof(ARSFishSplineBase, bEnableHalfUpdate) == 0x0002A0, "Member 'ARSFishSplineBase::bEnableHalfUpdate' has a wrong offset!");

// Class BattlePrototype.UIVitalityPL01
// 0x0000 (0x0468 - 0x0468)
class UUIVitalityPL01 : public UUIVitalityPLBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVitalityPL01">();
	}
	static class UUIVitalityPL01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVitalityPL01>();
	}
};
static_assert(alignof(UUIVitalityPL01) == 0x000008, "Wrong alignment on UUIVitalityPL01");
static_assert(sizeof(UUIVitalityPL01) == 0x000468, "Wrong size on UUIVitalityPL01");

// Class BattlePrototype.RSFrameGrabberActor
// 0x0008 (0x0238 - 0x0230)
class ARSFrameGrabberActor final : public AActor
{
public:
	class URSFrameGrabberComponent*               FrameGrabberComponent;                             // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSFrameGrabberActor">();
	}
	static class ARSFrameGrabberActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSFrameGrabberActor>();
	}
};
static_assert(alignof(ARSFrameGrabberActor) == 0x000008, "Wrong alignment on ARSFrameGrabberActor");
static_assert(sizeof(ARSFrameGrabberActor) == 0x000238, "Wrong size on ARSFrameGrabberActor");
static_assert(offsetof(ARSFrameGrabberActor, FrameGrabberComponent) == 0x000230, "Member 'ARSFrameGrabberActor::FrameGrabberComponent' has a wrong offset!");

// Class BattlePrototype.RSFrameGrabberComponent
// 0x0010 (0x00D0 - 0x00C0)
class URSFrameGrabberComponent final : public UActorComponent
{
public:
	class UTextureRenderTarget2D*                 TextureTarget;                                     // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndGrab();
	class UTextureRenderTarget2D* GetTextureTarget();
	void GrabFrame(EFrameGrabType Type);
	void SetTextureTarget(class UTextureRenderTarget2D* Target);
	void StartGrab(EFrameGrabType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSFrameGrabberComponent">();
	}
	static class URSFrameGrabberComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSFrameGrabberComponent>();
	}
};
static_assert(alignof(URSFrameGrabberComponent) == 0x000008, "Wrong alignment on URSFrameGrabberComponent");
static_assert(sizeof(URSFrameGrabberComponent) == 0x0000D0, "Wrong size on URSFrameGrabberComponent");
static_assert(offsetof(URSFrameGrabberComponent, TextureTarget) == 0x0000C0, "Member 'URSFrameGrabberComponent::TextureTarget' has a wrong offset!");

// Class BattlePrototype.RSAutomationPerformaceHelper
// 0x0038 (0x0060 - 0x0028)
class URSAutomationPerformaceHelper final : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginRecording(const class FString& RecordName, float InGPUBudget, float InRenderThreadBudget, float InGameThreadBudget);
	void BeginRecordingBaseline(const class FString& RecordName);
	void BeginStatsFile(const class FString& RecordName);
	void EndRecording();
	void EndRecordingBaseline();
	void EndStatsFile();
	void OnAllTestsComplete();
	void OnBeginTests();
	void Sample(float DeltaSeconds);
	void StartCPUProfiling();
	void StopCPUProfiling();
	void Tick(float DeltaSeconds);
	void TriggerGPUTraceIfRecordFallsBelowBudget();
	void WriteLogFile(const class FString& CaptureDir, const class FString& CaptureExtension);

	bool IsCurrentRecordWithinGameThreadBudget() const;
	bool IsCurrentRecordWithinGPUBudget() const;
	bool IsCurrentRecordWithinRenderThreadBudget() const;
	bool IsRecording() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAutomationPerformaceHelper">();
	}
	static class URSAutomationPerformaceHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAutomationPerformaceHelper>();
	}
};
static_assert(alignof(URSAutomationPerformaceHelper) == 0x000008, "Wrong alignment on URSAutomationPerformaceHelper");
static_assert(sizeof(URSAutomationPerformaceHelper) == 0x000060, "Wrong size on URSAutomationPerformaceHelper");

// Class BattlePrototype.RSGameAccountManager
// 0x0020 (0x0050 - 0x0030)
class URSGameAccountManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSGameAccountManager">();
	}
	static class URSGameAccountManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSGameAccountManager>();
	}
};
static_assert(alignof(URSGameAccountManager) == 0x000008, "Wrong alignment on URSGameAccountManager");
static_assert(sizeof(URSGameAccountManager) == 0x000050, "Wrong size on URSGameAccountManager");

// Class BattlePrototype.UIWishList
// 0x0018 (0x03A0 - 0x0388)
class UUIWishList : public UUIBase
{
public:
	uint8                                         Pad_388[0x18];                                     // 0x0388(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseWishList();
	void InitializeCommonParts(class UTextBlock* TextHelp, class UUIGuide* UiKeyGuide);
	void InitializeThis(class UUIItemTrade* UiTrade, class UUIShopItemDetails* UiItemDetail, class UUIShopPartyStatus* UiPartyStatus);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWishList">();
	}
	static class UUIWishList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWishList>();
	}
};
static_assert(alignof(UUIWishList) == 0x000008, "Wrong alignment on UUIWishList");
static_assert(sizeof(UUIWishList) == 0x0003A0, "Wrong size on UUIWishList");

// Class BattlePrototype.RSGameInstance
// 0x0280 (0x0418 - 0x0198)
class URSGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_198[0x28];                                     // 0x0198(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ARSCharacterBase>           _mainPlayerClass;                                  // 0x01C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ARSCharacterBase>           _leftPlayerClass;                                  // 0x01C8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ARSCharacterBase>           _rightPlayerClass;                                 // 0x01D0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _hitManagerClass;                                  // 0x01D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABrainCrashManager>         _brainCrashManagerClass;                           // 0x01E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ASASManager>                _sasManagerClass;                                  // 0x01E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APsychicObjectManager>      _psychicObjectManagerClass;                        // 0x01F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URSAccountManager>          _accountManagerClass;                              // 0x01F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ARSSoundManager>            _soundManagerClass;                                // 0x0200(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ARSParticleSystemManager>   _particleManagerClass;                             // 0x0208(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABlendableVolumeManager>    _StageSettingVolumeManagerClass;                   // 0x0210(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AEnemyManager>              _enemyManagerClass;                                // 0x0218(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _postProcessManagerClass;                          // 0x0220(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _renderTargetManagerClass;                         // 0x0228(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _brainFieldManagerClass;                           // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _radialBlurManagerClass;                           // 0x0238(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _eventManagerClass;                                // 0x0240(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APlayerManager>             _playerManagerClass;                               // 0x0248(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _sceneManagerClass;                                // 0x0250(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _levelManagerClass;                                // 0x0258(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _resourceManagerClass;                             // 0x0260(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABattleManager>             _battleManagerClass;                               // 0x0268(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABattlefieldManager>        _battlefieldManagerClass;                          // 0x0270(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AStageManager>              _stageManagerClass;                                // 0x0278(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ARSMovieManager>            _movieManagerClass;                                // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AInputManager>              _inputManagerClass;                                // 0x0288(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABrainTalkManager>          _brainTalkManagerClass;                            // 0x0290(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGameMainManager>           _GameMainManagerClass;                             // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _gameSystemManagerClass;                           // 0x02A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _inGameFlowClass;                                  // 0x02A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AMapGimmickManager>         _mapGimmickManagerClass;                           // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ALC21MapGimmickManager>     _lc21MapGimmickManagerClass;                       // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _cosmosWebManagerClass;                            // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _triggerEffectManagerClass;                        // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _debuggingGameActivityManagerClass;                // 0x02D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        _Managers;                                         // 0x02D8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x18];                                     // 0x02E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     _finishMoveActorManager;                           // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_ReloadLevelName;                                 // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isUsesSteam;                                     // 0x0310(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInfoAtRetry                           M_retryParam;                                      // 0x0318(0x0020)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x50];                                     // 0x0338(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             M_PlBPClassList;                                   // 0x0388(0x0010)(ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AActor>                     _debuggingManagerClass;                            // 0x0398(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _OutgameDebuggingManagerClass;                     // 0x03A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AModelViewerBase>           _ModelViewerClass;                                 // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _phychicObjectBaseClass;                           // 0x03B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URevisionData*                          _RevisionData;                                     // 0x03B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isForceCrcCheckError;                            // 0x03C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C1[0x7];                                      // 0x03C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CosmosBaseURLBody;                                 // 0x03C8(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCosmosGetBaseURL;                                // 0x03D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCosmosTimeout;                                   // 0x03D9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DA[0x6];                                      // 0x03DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CosmosUserID;                                      // 0x03E0(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CosmosSessionID;                                   // 0x03F0(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCosmosSysKpiParam>             CosmosSysKpiParam;                                 // 0x0400(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCosmosEnvInitialized;                            // 0x0410(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCosmosAgreeKpi;                                  // 0x0411(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCosmosSendAgreeKpi;                              // 0x0412(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputDeviceType                              _inputDeviceType;                                  // 0x0413(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_414[0x4];                                      // 0x0414(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void PrintLogBlueprintCallstack();

	void CreateAllManagers();
	void CreateEnemyManager();
	void CreateGameManagers();
	void CreateModelViewerManagers();
	void CreateOutGameManagers();
	void CreateResidentManagers();
	void CreateResidentSystem();
	void CreateSystem();
	void CreateSystemGameManager();
	void DestroyAllManagers();
	void DestroyGameManagers();
	void DestroyModelViewerManagers();
	void DestroyOutGameManagers();
	void DestroyResidentManagers();
	void DestroyResidentSystem();
	void DestroySystem();
	void EndInitializeCallback(EManagerTypeID ID, EManagerProcTiming Timing);
	void FinalizeAllManagers(EManagerProcTiming Timing);
	void FinalizeManagers(EManagerProcTiming Timing);
	class AActionManager* GetActionManager();
	class UAddContentManager* GetAddContentManager();
	class UAnimeInterlockingManager* GetAnimeInterlockingManager();
	class UDatabaseManager* GetDatabaseManager();
	class ADebuggingGameActivityManager* GetDebuggingGameActivityManager();
	class AIntroTutorialManager* GetIntroTutorialManager();
	class AStageManager* GetStageManager();
	bool InitializeAllManagers(EManagerProcTiming Timing);
	void InitializeAllManagersForPersistentLevel();
	void InitializeManagers(EManagerProcTiming Timing);
	bool IsForceCrcCheckError();
	bool IsReadyManagers();
	bool IsUsesSteam();
	void LoadLevel(const class FName LevelName);
	void OnLoadLevelCompleteUnloadLevel(const class UObject* WorldContext);
	void ReloadLevel();
	void ResetIntroTutorialManager();
	void ResetRenderTarget();
	void SetIntroTutorialManager(class AIntroTutorialManager* PManager);
	void SetIsForceCrcCheckError(const bool Flag);
	void SetIsUsesSteam(const bool Flag);
	void StartGameFlow();

	class UAchievementManager* GetAchievementManager() const;
	class UActivityManager* GetActivityManager() const;
	class UAddContentManager* GetAddContentManagerConst() const;
	class UAnimeInterlockingManager* GetAnimeInterlockingManagerConst() const;
	class AArrangeItemManager* GetArrangeItemManager() const;
	class ABattlefieldManager* GetBattlefieldManager() const;
	class ABattleManager* GetBattleManager() const;
	class ABrainCrashManager* GetBrainCrashManager() const;
	class AActor* GetBrainFieldManager() const;
	class ABrainTalkManager* GetBrainTalkManager() const;
	class UCalcMemoryManager* GetCalcMemoryManager() const;
	class UClearGetterManager* GetClearGetterManager() const;
	class AActor* GetCosmosWebManager() const;
	class UDatabaseManager* GetDatabaseManagerConst() const;
	class AActor* GetDebuggingManager() const;
	class ADropItemManager* GetDropItemManager() const;
	class AEnemyManager* GetEnemyManager() const;
	class AActor* GetEventManager() const;
	class AActor* GetFinishMoveActorManager() const;
	class UFlagManager* GetFlagManager() const;
	class AGameMainManager* GetGameMainManager() const;
	class AActor* GetGameSystemManager() const;
	class AActor* GetHitManager() const;
	class AActor* GetInputManager() const;
	class ALC21MapGimmickManager* GetLC21MapGimmickManager() const;
	class AActor* GetLevelManager() const;
	class AMapGimmickManager* GetMapGimmickManager() const;
	class AMessageHudManager* GetMessageHudManager() const;
	class AModelViewerBase* GetModelViewerBase() const;
	class AActor* GetMovieManager() const;
	class AActor* GetOutgameDebuggingManager() const;
	class ARSParallelObjectManager* GetParallelObjectManager() const;
	class ARSParticleSystemManager* GetParticleManager() const;
	class APlayerManager* GetPlayerManager() const;
	class AActor* GetPostProcessManager() const;
	class APsychicObjectManager* GetPsychicObjectManager() const;
	class AActor* GetRadialBlurManager() const;
	class AActor* GetRenderTargetManager() const;
	class AActor* GetResourceManager() const;
	class URevisionData* GetRevisionData() const;
	class URSAccountManager* GetRSAccountManager() const;
	class ARSInGameFlow* GetRSInGameFlow() const;
	class ASASManager* GetSASManager() const;
	class USaveLoadParamClassManager* GetSaveLoadParamClassManager() const;
	class AActor* GetSceneManager() const;
	class ARSSoundManager* GetSoundManager() const;
	class AStageManager* GetStageManagerConst() const;
	class ABlendableVolumeManager* GetStageSettingVolumeManager() const;
	class ATriggerEffectManager* GetTriggerEffectManager() const;
	class UUserParamManager* GetUserParamManager() const;
	class UXGameStreamingManager* GetXGameStreamingManager() const;
	bool IsCreatedGameManagers() const;
	bool IsCreatedManagers() const;
	bool IsCreatedResidentManagers() const;
	bool IsCreatedResidentSystem() const;
	bool IsCreatedSystem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSGameInstance">();
	}
	static class URSGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSGameInstance>();
	}
};
static_assert(alignof(URSGameInstance) == 0x000008, "Wrong alignment on URSGameInstance");
static_assert(sizeof(URSGameInstance) == 0x000418, "Wrong size on URSGameInstance");
static_assert(offsetof(URSGameInstance, _mainPlayerClass) == 0x0001C0, "Member 'URSGameInstance::_mainPlayerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _leftPlayerClass) == 0x0001C8, "Member 'URSGameInstance::_leftPlayerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _rightPlayerClass) == 0x0001D0, "Member 'URSGameInstance::_rightPlayerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _hitManagerClass) == 0x0001D8, "Member 'URSGameInstance::_hitManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _brainCrashManagerClass) == 0x0001E0, "Member 'URSGameInstance::_brainCrashManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _sasManagerClass) == 0x0001E8, "Member 'URSGameInstance::_sasManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _psychicObjectManagerClass) == 0x0001F0, "Member 'URSGameInstance::_psychicObjectManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _accountManagerClass) == 0x0001F8, "Member 'URSGameInstance::_accountManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _soundManagerClass) == 0x000200, "Member 'URSGameInstance::_soundManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _particleManagerClass) == 0x000208, "Member 'URSGameInstance::_particleManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _StageSettingVolumeManagerClass) == 0x000210, "Member 'URSGameInstance::_StageSettingVolumeManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _enemyManagerClass) == 0x000218, "Member 'URSGameInstance::_enemyManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _postProcessManagerClass) == 0x000220, "Member 'URSGameInstance::_postProcessManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _renderTargetManagerClass) == 0x000228, "Member 'URSGameInstance::_renderTargetManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _brainFieldManagerClass) == 0x000230, "Member 'URSGameInstance::_brainFieldManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _radialBlurManagerClass) == 0x000238, "Member 'URSGameInstance::_radialBlurManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _eventManagerClass) == 0x000240, "Member 'URSGameInstance::_eventManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _playerManagerClass) == 0x000248, "Member 'URSGameInstance::_playerManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _sceneManagerClass) == 0x000250, "Member 'URSGameInstance::_sceneManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _levelManagerClass) == 0x000258, "Member 'URSGameInstance::_levelManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _resourceManagerClass) == 0x000260, "Member 'URSGameInstance::_resourceManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _battleManagerClass) == 0x000268, "Member 'URSGameInstance::_battleManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _battlefieldManagerClass) == 0x000270, "Member 'URSGameInstance::_battlefieldManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _stageManagerClass) == 0x000278, "Member 'URSGameInstance::_stageManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _movieManagerClass) == 0x000280, "Member 'URSGameInstance::_movieManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _inputManagerClass) == 0x000288, "Member 'URSGameInstance::_inputManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _brainTalkManagerClass) == 0x000290, "Member 'URSGameInstance::_brainTalkManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _GameMainManagerClass) == 0x000298, "Member 'URSGameInstance::_GameMainManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _gameSystemManagerClass) == 0x0002A0, "Member 'URSGameInstance::_gameSystemManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _inGameFlowClass) == 0x0002A8, "Member 'URSGameInstance::_inGameFlowClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _mapGimmickManagerClass) == 0x0002B0, "Member 'URSGameInstance::_mapGimmickManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _lc21MapGimmickManagerClass) == 0x0002B8, "Member 'URSGameInstance::_lc21MapGimmickManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _cosmosWebManagerClass) == 0x0002C0, "Member 'URSGameInstance::_cosmosWebManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _triggerEffectManagerClass) == 0x0002C8, "Member 'URSGameInstance::_triggerEffectManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _debuggingGameActivityManagerClass) == 0x0002D0, "Member 'URSGameInstance::_debuggingGameActivityManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _Managers) == 0x0002D8, "Member 'URSGameInstance::_Managers' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _finishMoveActorManager) == 0x000300, "Member 'URSGameInstance::_finishMoveActorManager' has a wrong offset!");
static_assert(offsetof(URSGameInstance, M_ReloadLevelName) == 0x000308, "Member 'URSGameInstance::M_ReloadLevelName' has a wrong offset!");
static_assert(offsetof(URSGameInstance, M_isUsesSteam) == 0x000310, "Member 'URSGameInstance::M_isUsesSteam' has a wrong offset!");
static_assert(offsetof(URSGameInstance, M_retryParam) == 0x000318, "Member 'URSGameInstance::M_retryParam' has a wrong offset!");
static_assert(offsetof(URSGameInstance, M_PlBPClassList) == 0x000388, "Member 'URSGameInstance::M_PlBPClassList' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _debuggingManagerClass) == 0x000398, "Member 'URSGameInstance::_debuggingManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _OutgameDebuggingManagerClass) == 0x0003A0, "Member 'URSGameInstance::_OutgameDebuggingManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _ModelViewerClass) == 0x0003A8, "Member 'URSGameInstance::_ModelViewerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _phychicObjectBaseClass) == 0x0003B0, "Member 'URSGameInstance::_phychicObjectBaseClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _RevisionData) == 0x0003B8, "Member 'URSGameInstance::_RevisionData' has a wrong offset!");
static_assert(offsetof(URSGameInstance, M_isForceCrcCheckError) == 0x0003C0, "Member 'URSGameInstance::M_isForceCrcCheckError' has a wrong offset!");
static_assert(offsetof(URSGameInstance, CosmosBaseURLBody) == 0x0003C8, "Member 'URSGameInstance::CosmosBaseURLBody' has a wrong offset!");
static_assert(offsetof(URSGameInstance, IsCosmosGetBaseURL) == 0x0003D8, "Member 'URSGameInstance::IsCosmosGetBaseURL' has a wrong offset!");
static_assert(offsetof(URSGameInstance, IsCosmosTimeout) == 0x0003D9, "Member 'URSGameInstance::IsCosmosTimeout' has a wrong offset!");
static_assert(offsetof(URSGameInstance, CosmosUserID) == 0x0003E0, "Member 'URSGameInstance::CosmosUserID' has a wrong offset!");
static_assert(offsetof(URSGameInstance, CosmosSessionID) == 0x0003F0, "Member 'URSGameInstance::CosmosSessionID' has a wrong offset!");
static_assert(offsetof(URSGameInstance, CosmosSysKpiParam) == 0x000400, "Member 'URSGameInstance::CosmosSysKpiParam' has a wrong offset!");
static_assert(offsetof(URSGameInstance, IsCosmosEnvInitialized) == 0x000410, "Member 'URSGameInstance::IsCosmosEnvInitialized' has a wrong offset!");
static_assert(offsetof(URSGameInstance, IsCosmosAgreeKpi) == 0x000411, "Member 'URSGameInstance::IsCosmosAgreeKpi' has a wrong offset!");
static_assert(offsetof(URSGameInstance, IsCosmosSendAgreeKpi) == 0x000412, "Member 'URSGameInstance::IsCosmosSendAgreeKpi' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _inputDeviceType) == 0x000413, "Member 'URSGameInstance::_inputDeviceType' has a wrong offset!");

// Class BattlePrototype.RSGameModeBase
// 0x0010 (0x0328 - 0x0318)
class ARSGameModeBase : public AGameMode
{
public:
	uint8                                         Pad_318[0x10];                                     // 0x0318(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void LogFlowCheck(const class FString& LogString);
	static void LogFlowCheck_IsValid(bool IsValid, const class FString& ValidString, const class FString& InvalidString);

	class AActor* FindPlayerStartByName(const class FString& TagName);
	bool IsDevelopment();
	bool IsGameFlowLevel(const class UObject* WorldContextObject);
	void OnPostInitGame(const class FString& CurrentLevelName);
	void OnPreStartPlay(const class FString& CurrentLevelName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSGameModeBase">();
	}
	static class ARSGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSGameModeBase>();
	}
};
static_assert(alignof(ARSGameModeBase) == 0x000008, "Wrong alignment on ARSGameModeBase");
static_assert(sizeof(ARSGameModeBase) == 0x000328, "Wrong size on ARSGameModeBase");

// Class BattlePrototype.RSGameMode
// 0x0010 (0x0338 - 0x0328)
class ARSGameMode : public ARSGameModeBase
{
public:
	uint8                                         Pad_328[0x10];                                     // 0x0328(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTimerReleaseLoadingScreen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSGameMode">();
	}
	static class ARSGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSGameMode>();
	}
};
static_assert(alignof(ARSGameMode) == 0x000008, "Wrong alignment on ARSGameMode");
static_assert(sizeof(ARSGameMode) == 0x000338, "Wrong size on ARSGameMode");

// Class BattlePrototype.RSGamepadEvent
// 0x0020 (0x0048 - 0x0028)
class URSGamepadEvent final : public UObject
{
public:
	uint8                                         Pad_28[0x2];                                       // 0x0028(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          RawOn;                                             // 0x002A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOn;                                              // 0x002B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnTrigger;                                       // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnRepTrigger;                                    // 0x002D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOffTrigger;                                      // 0x002E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F[0x1];                                       // 0x002F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AxisValue;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AxisMouseWheelValue;                               // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timer;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepeatSec;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstRepeatSec;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSGamepadEvent">();
	}
	static class URSGamepadEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSGamepadEvent>();
	}
};
static_assert(alignof(URSGamepadEvent) == 0x000008, "Wrong alignment on URSGamepadEvent");
static_assert(sizeof(URSGamepadEvent) == 0x000048, "Wrong size on URSGamepadEvent");
static_assert(offsetof(URSGamepadEvent, RawOn) == 0x00002A, "Member 'URSGamepadEvent::RawOn' has a wrong offset!");
static_assert(offsetof(URSGamepadEvent, IsOn) == 0x00002B, "Member 'URSGamepadEvent::IsOn' has a wrong offset!");
static_assert(offsetof(URSGamepadEvent, IsOnTrigger) == 0x00002C, "Member 'URSGamepadEvent::IsOnTrigger' has a wrong offset!");
static_assert(offsetof(URSGamepadEvent, IsOnRepTrigger) == 0x00002D, "Member 'URSGamepadEvent::IsOnRepTrigger' has a wrong offset!");
static_assert(offsetof(URSGamepadEvent, IsOffTrigger) == 0x00002E, "Member 'URSGamepadEvent::IsOffTrigger' has a wrong offset!");
static_assert(offsetof(URSGamepadEvent, AxisValue) == 0x000030, "Member 'URSGamepadEvent::AxisValue' has a wrong offset!");
static_assert(offsetof(URSGamepadEvent, AxisMouseWheelValue) == 0x000034, "Member 'URSGamepadEvent::AxisMouseWheelValue' has a wrong offset!");
static_assert(offsetof(URSGamepadEvent, Timer) == 0x000038, "Member 'URSGamepadEvent::Timer' has a wrong offset!");
static_assert(offsetof(URSGamepadEvent, RepeatSec) == 0x00003C, "Member 'URSGamepadEvent::RepeatSec' has a wrong offset!");
static_assert(offsetof(URSGamepadEvent, FirstRepeatSec) == 0x000040, "Member 'URSGamepadEvent::FirstRepeatSec' has a wrong offset!");

// Class BattlePrototype.UserParameterUtility
// 0x0000 (0x0028 - 0x0028)
class UUserParameterUtility final : public UBlueprintFunctionLibrary
{
public:
	static void AddBattleLogBuffer(class UObject* WorldContextObject, const struct FBattleLogParam& Param);
	static void AddBrainMessageIgnorConditions(class UObject* WorldContextObject, const int32 ThreadNumber, const int32 MessageNum);
	static bool AddItemNum(class UObject* WorldContextObject, const class FName ItemId, const int32 ItemNum, const bool IsUpdateMapUsable, const bool IsDispLog);
	static bool AddMoney(class UObject* WorldContextObject, const int32 Money);
	static void AllOpenBrainMessageIgnorConditionsAndLock(class UObject* WorldContextObject, const int32 TargetThread);
	static bool CheckAppliedAddContent(class UObject* WorldContextObject, class FName ContentName);
	static bool CheckIsNeedRetryTips(class UObject* WorldContextObject);
	static bool CheckStartTeamBondsEpisode(class UObject* WorldContextObject, EPlayerID PlayerId, int32* EpisodeNo);
	static bool CheckTeamBondsLevelUp(class UObject* WorldContextObject, EPlayerID PlayerId, int32 ProgressNo);
	static void ClearRetryTips(class UObject* WorldContextObject);
	static float DisplayTipsOrMiniTipsByHelpID(class UObject* WorldContextObject, EHelpTutorial HelpID, const bool NotPauseControll, const bool NotCloseOfPause, const bool IsPlayableCheck, const bool IsFade);
	static void EndBondsEpisode(class UObject* WorldContextObject, bool IsCancel);
	static int32 GetBeginningTips(class UObject* WorldContextObject, EPlayerID Player, int32 ProgressNo, int32 NextLocation);
	static EGameClearState GetGameClearState(class UObject* WorldContextObject);
	static EHCGameDifficulty GetGameDifficulty(class UObject* WorldContextObject);
	static bool GetHasPresentedItemInfoList(class UObject* WorldContextObject, EPlayerID SendCharaID, EPlayerID RecvCharaID, TArray<struct FPresentInfoData>* ItemList, bool IncludeEvent);
	static bool GetIsProgressBondsEpisode(class UObject* WorldContextObject, EPlayerID* PlayerId, EPlayerID* TargetID);
	static int32 GetItemNum(class UObject* WorldContextObject, const class FName ItemId);
	static int32 GetMoney(class UObject* WorldContextObject);
	static int32 GetNextTips(class UObject* WorldContextObject);
	static bool GetPresentItemInfoList(class UObject* WorldContextObject, EPlayerID SendCharaID, EPlayerID RecvCharaID, TArray<struct FPresentInfoData>* ItemList);
	static class FName GetPurposeMessage(class UObject* WorldContextObject);
	static bool GetSasControllChange(class UObject* WorldContextObject);
	static class USaveLoadExSystemParamManager* GetSaveLoadExSystemParamManager(class UObject* WorldContextObject);
	static int32 GetTeamBondsLevel(class UObject* WorldContextObject, EPlayerID PlayerId);
	static int32 GetTeamBondsMaxLevel(class UObject* WorldContextObject);
	static int32 GetTeamBondsProgress(class UObject* WorldContextObject, EPlayerID PlayerId);
	static bool GetTransferObject(class UObject* WorldContextObject, int32 ItemId, int32* ObjectID, bool IsRemove);
	static bool GetTransferObjectByName(class UObject* WorldContextObject, class FName ItemId, int32* ObjectID, bool IsRemove);
	static bool IsDispTipsOrMiniTips(class UObject* WorldContextObject, EHelpTutorial HelpID);
	static bool IsHelpTutoIDMini(class UObject* WorldContextObject, EHelpTutorial HelpID);
	static bool IsTipsDispEnable(class UObject* WorldContextObject, EHelpTutorial HelpID);
	static void ResetDispTipsState(class UObject* WorldContextObject, EHelpTutorial HelpID);
	static void SetGameClear(class UObject* WorldContextObject, bool ClearFlag);
	static void SetGameClearState(class UObject* WorldContextObject, EGameClearState State);
	static void SetGameDifficulty(class UObject* WorldContextObject, EHCGameDifficulty Diffuculty);
	static void SetTeamBondsProgress(class UObject* WorldContextObject, EPlayerID PlayerId, int32 Progress);
	static void SetTitleProductFlag(class UObject* WorldContextObject, bool EndingAfterFlag);
	static bool SetTransferObject(class UObject* WorldContextObject, int32 ItemId, int32 ObjectID, bool IsOverwrite);
	static bool SetTransferObjectByName(class UObject* WorldContextObject, class FName ItemId, int32 ObjectID, bool IsOverwrite);
	static void SetZeroEpClear(class UObject* WorldContextObject, bool ZeroEpFlag);
	static void StartBondsEpisode(class UObject* WorldContextObject, EPlayerID PlayerId, EPlayerID TargetID, int32 bondsEpNumber);
	static void StartDLCBondsEpisode(class UObject* WorldContextObject, class FName bondsID);
	static bool UpdatePresentItemInfo(class UObject* WorldContextObject, EPlayerID SendCharaID, EPlayerID RecvCharaID, class FName ItemId);
	static bool UpdateTeamBondsLevel(class UObject* WorldContextObject, EPlayerID PlayerId, int32 ProgressNo, bool IsSingleLvUp);
	static void WorldmapCheckOpenFromProgressID(class UObject* WorldContextObject, int32 ProgressId);
	static bool WorldmapCloseLocation(class UObject* WorldContextObject, int32 LocationNo, int32 AreaNo, bool IsAreaAll);
	static bool WorldmapGetOpenParam(class UObject* WorldContextObject, TArray<struct FWorldmapOpenLCParam>* OpenedList);
	static bool WorldmapIsLocationNewOpen(class UObject* WorldContextObject, int32 LocationId, int32 AreaId);
	static bool WorldmapIsLocationNotSelectable(class UObject* WorldContextObject, int32 LocationId);
	static bool WorldmapIsLocationNotSelectableAll(class UObject* WorldContextObject);
	static bool WorldmapIsLocationSelectable(class UObject* WorldContextObject, int32 LocationNo, int32 AreaNo);
	static bool WorldmapOpenLocation(class UObject* WorldContextObject, int32 LocationNo, int32 AreaNo, bool IsSelectable);
	static bool WorldmapSetLocationNewOpen(class UObject* WorldContextObject, int32 LocationNo, int32 AreaNo, bool IsNewOpen, bool IsAreaAll);
	static bool WorldmapSetLocationNotSelectable(class UObject* WorldContextObject, int32 LocationId, bool IsNotSelectable);
	static bool WorldmapSetLocationNotSelectableAll(class UObject* WorldContextObject, bool IsNotSelectable);
	static bool WorldmapSetLocationSelectable(class UObject* WorldContextObject, int32 LocationNo, int32 AreaNo, bool IsSelectable, bool IsForce, bool IsAreaAll);
	static bool WorldmapSetLocationSelectable_WithPortal(class UObject* WorldContextObject, int32 LocationNo, int32 AreaNo, int32 PortalNo, bool IsSelectable, bool IsForce, bool IsAreaAll);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserParameterUtility">();
	}
	static class UUserParameterUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserParameterUtility>();
	}
};
static_assert(alignof(UUserParameterUtility) == 0x000008, "Wrong alignment on UUserParameterUtility");
static_assert(sizeof(UUserParameterUtility) == 0x000028, "Wrong size on UUserParameterUtility");

// Class BattlePrototype.RSGamepadLayout
// 0x21D0 (0x21F8 - 0x0028)
class URSGamepadLayout final : public UObject
{
public:
	ERSGamepadLayoutType                          Layout;                                            // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x57];                                      // 0x0029(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Enabled;                                           // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0xD27];                                     // 0x0081(0x0D27)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             UEOnPushR1Event;                                   // 0x0DA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushR2Event;                                   // 0x0DB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushR3Event;                                   // 0x0DC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushL1Event;                                   // 0x0DD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushL2Event;                                   // 0x0DE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushL3Event;                                   // 0x0DF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushRUPEvent;                                  // 0x0E08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushRDOWNEvent;                                // 0x0E18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushRLEFTEvent;                                // 0x0E28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushRRIGHTEvent;                               // 0x0E38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushDPAD_UPEvent;                              // 0x0E48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushDPAD_DOWNEvent;                            // 0x0E58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushDPAD_LEFTEvent;                            // 0x0E68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushDPAD_RIGHTEvent;                           // 0x0E78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushDPADEMU_UPEvent;                           // 0x0E88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushDPADEMU_DOWNEvent;                         // 0x0E98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushDPADEMU_LEFTEvent;                         // 0x0EA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushDPADEMU_RIGHTEvent;                        // 0x0EB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSELECTEvent;                               // 0x0EC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSTARTEvent;                                // 0x0ED8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushDECIDEEvent;                               // 0x0EE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushCANCELEvent;                               // 0x0EF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushMOUSELEFTEvent;                            // 0x0F08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushMOUSERIGHTEvent;                           // 0x0F18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushMOUSEMIDDLEEvent;                          // 0x0F28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushMOUSEWHEELUPEvent;                         // 0x0F38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushMOUSEWHEELDOWNEvent;                       // 0x0F48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushMOVE_FORWARDEvent;                         // 0x0F58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushMOVE_BACKWARDEvent;                        // 0x0F68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushMOVE_LEFTEvent;                            // 0x0F78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushMOVE_RIGHTEvent;                           // 0x0F88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushACTIONEvent;                               // 0x0F98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSTEP_DASHEvent;                            // 0x0FA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushWEAPON_ATTACKEvent;                        // 0x0FB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushWEAPON_ATTACK_SUBEvent;                    // 0x0FC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushJUMPEvent;                                 // 0x0FD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushPSYCHICEvent;                              // 0x0FE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushPSYCHIC_SPECIALEvent;                      // 0x0FF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushBRAINFIELDEvent;                           // 0x1008(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushPSYCHICFIELDEvent;                         // 0x1018(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushCAMERA_RESETEvent;                         // 0x1028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushLOCK_ONEvent;                              // 0x1038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushLOCK_ON_SWITCH_LEvent;                     // 0x1048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushLOCK_ON_SWITCH_REvent;                     // 0x1058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushASSAULT_VISIONEvent;                       // 0x1068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSASMENU_PAGESWITCHEvent;                   // 0x1078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSASMENU_OPENCLOSEEvent;                    // 0x1088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSAS_ACTION_UEvent;                         // 0x1098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSAS_ACTION_DEvent;                         // 0x10A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSAS_ACTION_LEvent;                         // 0x10B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSAS_ACTION_REvent;                         // 0x10C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSTOP_SASEvent;                             // 0x10D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushCVMENU_OPENCLOSEEvent;                     // 0x10E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushCV_ACTION_UEvent;                          // 0x10F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushCV_ACTION_DEvent;                          // 0x1108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushCV_ACTION_LEvent;                          // 0x1118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushCV_ACTION_REvent;                          // 0x1128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushITEM_SELECT_LEvent;                        // 0x1138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushITEM_SELECT_REvent;                        // 0x1148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushITEM_USEEvent;                             // 0x1158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushOPEN_MENUEvent;                            // 0x1168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushOPEN_DETAILMAPEvent;                       // 0x1178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushOPEN_WORLDMAPEvent;                        // 0x1188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushACTION2Event;                              // 0x1198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushOPEN_BRAIN_MESSAGEEvent;                   // 0x11A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseR1Event;                                // 0x11B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseR2Event;                                // 0x11C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseR3Event;                                // 0x11D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseL1Event;                                // 0x11E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseL2Event;                                // 0x11F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseL3Event;                                // 0x1208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseRUPEvent;                               // 0x1218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseRDOWNEvent;                             // 0x1228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseRLEFTEvent;                             // 0x1238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseRRIGHTEvent;                            // 0x1248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseDPAD_UPEvent;                           // 0x1258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseDPAD_DOWNEvent;                         // 0x1268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseDPAD_LEFTEvent;                         // 0x1278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseDPAD_RIGHTEvent;                        // 0x1288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseDPADEMU_UPEvent;                        // 0x1298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseDPADEMU_DOWNEvent;                      // 0x12A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseDPADEMU_LEFTEvent;                      // 0x12B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseDPADEMU_RIGHTEvent;                     // 0x12C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSELECTEvent;                            // 0x12D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSTARTEvent;                             // 0x12E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseDECIDEEvent;                            // 0x12F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseCANCELEvent;                            // 0x1308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseMOUSELEFTEvent;                         // 0x1318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseMOUSERIGHTEvent;                        // 0x1328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseMOUSEMIDDLEEvent;                       // 0x1338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseMOUSEWHEELUPEvent;                      // 0x1348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseMOUSEWHEELDOWNEvent;                    // 0x1358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseMOVE_FORWARDEvent;                      // 0x1368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseMOVE_BACKWARDEvent;                     // 0x1378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseMOVE_LEFTEvent;                         // 0x1388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseMOVE_RIGHTEvent;                        // 0x1398(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseACTIONEvent;                            // 0x13A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSTEP_DASHEvent;                         // 0x13B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseWEAPON_ATTACKEvent;                     // 0x13C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseWEAPON_ATTACK_SUBEvent;                 // 0x13D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseJUMPEvent;                              // 0x13E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleasePSYCHICEvent;                           // 0x13F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleasePSYCHIC_SPECIALEvent;                   // 0x1408(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseBRAINFIELDEvent;                        // 0x1418(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleasePSYCHICFIELDEvent;                      // 0x1428(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseCAMERA_RESETEvent;                      // 0x1438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseLOCK_ONEvent;                           // 0x1448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseLOCK_ON_SWITCH_LEvent;                  // 0x1458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseLOCK_ON_SWITCH_REvent;                  // 0x1468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseASSAULT_VISIONEvent;                    // 0x1478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSASMENU_PAGESWITCHEvent;                // 0x1488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSASMENU_OPENCLOSEEvent;                 // 0x1498(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSAS_ACTION_UEvent;                      // 0x14A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSAS_ACTION_DEvent;                      // 0x14B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSAS_ACTION_LEvent;                      // 0x14C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSAS_ACTION_REvent;                      // 0x14D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSTOP_SASEvent;                          // 0x14E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseCVMENU_OPENCLOSEEvent;                  // 0x14F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseCV_ACTION_UEvent;                       // 0x1508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseCV_ACTION_DEvent;                       // 0x1518(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseCV_ACTION_LEvent;                       // 0x1528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseCV_ACTION_REvent;                       // 0x1538(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseITEM_SELECT_LEvent;                     // 0x1548(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseITEM_SELECT_REvent;                     // 0x1558(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseITEM_USEEvent;                          // 0x1568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseOPEN_MENUEvent;                         // 0x1578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseOPEN_DETAILMAPEvent;                    // 0x1588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseOPEN_WORLDMAPEvent;                     // 0x1598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseACTION2Event;                           // 0x15A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseOPEN_BRAIN_MESSAGEEvent;                // 0x15B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressR1Event;                                    // 0x15C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressR2Event;                                    // 0x15D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressR3Event;                                    // 0x15E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressL1Event;                                    // 0x15F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressL2Event;                                    // 0x1608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressL3Event;                                    // 0x1618(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressRUPEvent;                                   // 0x1628(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressRDOWNEvent;                                 // 0x1638(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressRLEFTEvent;                                 // 0x1648(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressRRIGHTEvent;                                // 0x1658(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressDPAD_UPEvent;                               // 0x1668(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressDPAD_DOWNEvent;                             // 0x1678(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressDPAD_LEFTEvent;                             // 0x1688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressDPAD_RIGHTEvent;                            // 0x1698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressDPADEMU_UPEvent;                            // 0x16A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressDPADEMU_DOWNEvent;                          // 0x16B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressDPADEMU_LEFTEvent;                          // 0x16C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressDPADEMU_RIGHTEvent;                         // 0x16D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSELECTEvent;                                // 0x16E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSTARTEvent;                                 // 0x16F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressDECIDEEvent;                                // 0x1708(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressCANCELEvent;                                // 0x1718(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressMOUSELEFTEvent;                             // 0x1728(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressMOUSERIGHTEvent;                            // 0x1738(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressMOUSEMIDDLEEvent;                           // 0x1748(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressMOUSEWHEELUPEvent;                          // 0x1758(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressMOUSEWHEELDOWNEvent;                        // 0x1768(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressMOVE_FORWARDEvent;                          // 0x1778(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressMOVE_BACKWARDEvent;                         // 0x1788(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressMOVE_LEFTEvent;                             // 0x1798(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressMOVE_RIGHTEvent;                            // 0x17A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressACTIONEvent;                                // 0x17B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSTEP_DASHEvent;                             // 0x17C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressWEAPON_ATTACKEvent;                         // 0x17D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressWEAPON_ATTACK_SUBEvent;                     // 0x17E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressJUMPEvent;                                  // 0x17F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressPSYCHICEvent;                               // 0x1808(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressPSYCHIC_SPECIALEvent;                       // 0x1818(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressBRAINFIELDEvent;                            // 0x1828(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressPSYCHICFIELDEvent;                          // 0x1838(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressCAMERA_RESETEvent;                          // 0x1848(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressLOCK_ONEvent;                               // 0x1858(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressLOCK_ON_SWITCH_LEvent;                      // 0x1868(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressLOCK_ON_SWITCH_REvent;                      // 0x1878(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressASSAULT_VISIONEvent;                        // 0x1888(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSASMENU_PAGESWITCHEvent;                    // 0x1898(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSASMENU_OPENCLOSEEvent;                     // 0x18A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSAS_ACTION_UEvent;                          // 0x18B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSAS_ACTION_DEvent;                          // 0x18C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSAS_ACTION_LEvent;                          // 0x18D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSAS_ACTION_REvent;                          // 0x18E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSTOP_SASEvent;                              // 0x18F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressCVMENU_OPENCLOSEEvent;                      // 0x1908(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressCV_ACTION_UEvent;                           // 0x1918(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressCV_ACTION_DEvent;                           // 0x1928(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressCV_ACTION_LEvent;                           // 0x1938(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressCV_ACTION_REvent;                           // 0x1948(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressITEM_SELECT_LEvent;                         // 0x1958(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressITEM_SELECT_REvent;                         // 0x1968(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressITEM_USEEvent;                              // 0x1978(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressOPEN_MENUEvent;                             // 0x1988(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressOPEN_DETAILMAPEvent;                        // 0x1998(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressOPEN_WORLDMAPEvent;                         // 0x19A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressACTION2Event;                               // 0x19B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressOPEN_BRAIN_MESSAGEEvent;                    // 0x19C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerR1Event;                                  // 0x19D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerR2Event;                                  // 0x19E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerR3Event;                                  // 0x19F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerL1Event;                                  // 0x1A08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerL2Event;                                  // 0x1A18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerL3Event;                                  // 0x1A28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerRUPEvent;                                 // 0x1A38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerRDOWNEvent;                               // 0x1A48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerRLEFTEvent;                               // 0x1A58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerRRIGHTEvent;                              // 0x1A68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerDPAD_UPEvent;                             // 0x1A78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerDPAD_DOWNEvent;                           // 0x1A88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerDPAD_LEFTEvent;                           // 0x1A98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerDPAD_RIGHTEvent;                          // 0x1AA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerDPADEMU_UPEvent;                          // 0x1AB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerDPADEMU_DOWNEvent;                        // 0x1AC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerDPADEMU_LEFTEvent;                        // 0x1AD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerDPADEMU_RIGHTEvent;                       // 0x1AE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSELECTEvent;                              // 0x1AF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSTARTEvent;                               // 0x1B08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerDECIDEEvent;                              // 0x1B18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerCANCELEvent;                              // 0x1B28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerMOUSELEFTEvent;                           // 0x1B38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerMOUSERIGHTEvent;                          // 0x1B48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerMOUSEMIDDLEEvent;                         // 0x1B58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerMOUSEWHEELUPEvent;                        // 0x1B68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerMOUSEWHEELDOWNEvent;                      // 0x1B78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerMOVE_FORWARDEvent;                        // 0x1B88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerMOVE_BACKWARDEvent;                       // 0x1B98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerMOVE_LEFTEvent;                           // 0x1BA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerMOVE_RIGHTEvent;                          // 0x1BB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerACTIONEvent;                              // 0x1BC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSTEP_DASHEvent;                           // 0x1BD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerWEAPON_ATTACKEvent;                       // 0x1BE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerWEAPON_ATTACK_SUBEvent;                   // 0x1BF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerJUMPEvent;                                // 0x1C08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerPSYCHICEvent;                             // 0x1C18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerPSYCHIC_SPECIALEvent;                     // 0x1C28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerBRAINFIELDEvent;                          // 0x1C38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerPSYCHICFIELDEvent;                        // 0x1C48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerCAMERA_RESETEvent;                        // 0x1C58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerLOCK_ONEvent;                             // 0x1C68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerLOCK_ON_SWITCH_LEvent;                    // 0x1C78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerLOCK_ON_SWITCH_REvent;                    // 0x1C88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerASSAULT_VISIONEvent;                      // 0x1C98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSASMENU_PAGESWITCHEvent;                  // 0x1CA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSASMENU_OPENCLOSEEvent;                   // 0x1CB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSAS_ACTION_UEvent;                        // 0x1CC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSAS_ACTION_DEvent;                        // 0x1CD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSAS_ACTION_LEvent;                        // 0x1CE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSAS_ACTION_REvent;                        // 0x1CF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSTOP_SASEvent;                            // 0x1D08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerCVMENU_OPENCLOSEEvent;                    // 0x1D18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerCV_ACTION_UEvent;                         // 0x1D28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerCV_ACTION_DEvent;                         // 0x1D38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerCV_ACTION_LEvent;                         // 0x1D48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerCV_ACTION_REvent;                         // 0x1D58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerITEM_SELECT_LEvent;                       // 0x1D68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerITEM_SELECT_REvent;                       // 0x1D78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerITEM_USEEvent;                            // 0x1D88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerOPEN_MENUEvent;                           // 0x1D98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerOPEN_DETAILMAPEvent;                      // 0x1DA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerOPEN_WORLDMAPEvent;                       // 0x1DB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerACTION2Event;                             // 0x1DC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerOPEN_BRAIN_MESSAGEEvent;                  // 0x1DD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerR1Event;                               // 0x1DE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerR2Event;                               // 0x1DF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerR3Event;                               // 0x1E08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerL1Event;                               // 0x1E18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerL2Event;                               // 0x1E28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerL3Event;                               // 0x1E38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerRUPEvent;                              // 0x1E48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerRDOWNEvent;                            // 0x1E58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerRLEFTEvent;                            // 0x1E68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerRRIGHTEvent;                           // 0x1E78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerDPAD_UPEvent;                          // 0x1E88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerDPAD_DOWNEvent;                        // 0x1E98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerDPAD_LEFTEvent;                        // 0x1EA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerDPAD_RIGHTEvent;                       // 0x1EB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerDPADEMU_UPEvent;                       // 0x1EC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerDPADEMU_DOWNEvent;                     // 0x1ED8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerDPADEMU_LEFTEvent;                     // 0x1EE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerDPADEMU_RIGHTEvent;                    // 0x1EF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSELECTEvent;                           // 0x1F08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSTARTEvent;                            // 0x1F18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerDECIDEEvent;                           // 0x1F28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerCANCELEvent;                           // 0x1F38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerMOUSELEFTEvent;                        // 0x1F48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerMOUSERIGHTEvent;                       // 0x1F58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerMOUSEMIDDLEEvent;                      // 0x1F68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerMOUSEWHEELUPEvent;                     // 0x1F78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerMOUSEWHEELDOWNEvent;                   // 0x1F88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerMOVE_FORWARDEvent;                     // 0x1F98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerMOVE_BACKWARDEvent;                    // 0x1FA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerMOVE_LEFTEvent;                        // 0x1FB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerMOVE_RIGHTEvent;                       // 0x1FC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerACTIONEvent;                           // 0x1FD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSTEP_DASHEvent;                        // 0x1FE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerWEAPON_ATTACKEvent;                    // 0x1FF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerWEAPON_ATTACK_SUBEvent;                // 0x2008(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerJUMPEvent;                             // 0x2018(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerPSYCHICEvent;                          // 0x2028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerPSYCHIC_SPECIALEvent;                  // 0x2038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerBRAINFIELDEvent;                       // 0x2048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerPSYCHICFIELDEvent;                     // 0x2058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerCAMERA_RESETEvent;                     // 0x2068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerLOCK_ONEvent;                          // 0x2078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerLOCK_ON_SWITCH_LEvent;                 // 0x2088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerLOCK_ON_SWITCH_REvent;                 // 0x2098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerASSAULT_VISIONEvent;                   // 0x20A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSASMENU_PAGESWITCHEvent;               // 0x20B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSASMENU_OPENCLOSEEvent;                // 0x20C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSAS_ACTION_UEvent;                     // 0x20D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSAS_ACTION_DEvent;                     // 0x20E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSAS_ACTION_LEvent;                     // 0x20F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSAS_ACTION_REvent;                     // 0x2108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSTOP_SASEvent;                         // 0x2118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerCVMENU_OPENCLOSEEvent;                 // 0x2128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerCV_ACTION_UEvent;                      // 0x2138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerCV_ACTION_DEvent;                      // 0x2148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerCV_ACTION_LEvent;                      // 0x2158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerCV_ACTION_REvent;                      // 0x2168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerITEM_SELECT_LEvent;                    // 0x2178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerITEM_SELECT_REvent;                    // 0x2188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerITEM_USEEvent;                         // 0x2198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerOPEN_MENUEvent;                        // 0x21A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerOPEN_DETAILMAPEvent;                   // 0x21B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerOPEN_WORLDMAPEvent;                    // 0x21C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerACTION2Event;                          // 0x21D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerOPEN_BRAIN_MESSAGEEvent;               // 0x21E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class URSGamepadEvent* GetKeyEvent(const ERSGamepadInputName InputName);
	void SetDisable();
	void SetEnable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSGamepadLayout">();
	}
	static class URSGamepadLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSGamepadLayout>();
	}
};
static_assert(alignof(URSGamepadLayout) == 0x000008, "Wrong alignment on URSGamepadLayout");
static_assert(sizeof(URSGamepadLayout) == 0x0021F8, "Wrong size on URSGamepadLayout");
static_assert(offsetof(URSGamepadLayout, Layout) == 0x000028, "Member 'URSGamepadLayout::Layout' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, Enabled) == 0x000080, "Member 'URSGamepadLayout::Enabled' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushR1Event) == 0x000DA8, "Member 'URSGamepadLayout::UEOnPushR1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushR2Event) == 0x000DB8, "Member 'URSGamepadLayout::UEOnPushR2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushR3Event) == 0x000DC8, "Member 'URSGamepadLayout::UEOnPushR3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushL1Event) == 0x000DD8, "Member 'URSGamepadLayout::UEOnPushL1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushL2Event) == 0x000DE8, "Member 'URSGamepadLayout::UEOnPushL2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushL3Event) == 0x000DF8, "Member 'URSGamepadLayout::UEOnPushL3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushRUPEvent) == 0x000E08, "Member 'URSGamepadLayout::UEOnPushRUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushRDOWNEvent) == 0x000E18, "Member 'URSGamepadLayout::UEOnPushRDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushRLEFTEvent) == 0x000E28, "Member 'URSGamepadLayout::UEOnPushRLEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushRRIGHTEvent) == 0x000E38, "Member 'URSGamepadLayout::UEOnPushRRIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushDPAD_UPEvent) == 0x000E48, "Member 'URSGamepadLayout::UEOnPushDPAD_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushDPAD_DOWNEvent) == 0x000E58, "Member 'URSGamepadLayout::UEOnPushDPAD_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushDPAD_LEFTEvent) == 0x000E68, "Member 'URSGamepadLayout::UEOnPushDPAD_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushDPAD_RIGHTEvent) == 0x000E78, "Member 'URSGamepadLayout::UEOnPushDPAD_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushDPADEMU_UPEvent) == 0x000E88, "Member 'URSGamepadLayout::UEOnPushDPADEMU_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushDPADEMU_DOWNEvent) == 0x000E98, "Member 'URSGamepadLayout::UEOnPushDPADEMU_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushDPADEMU_LEFTEvent) == 0x000EA8, "Member 'URSGamepadLayout::UEOnPushDPADEMU_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushDPADEMU_RIGHTEvent) == 0x000EB8, "Member 'URSGamepadLayout::UEOnPushDPADEMU_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSELECTEvent) == 0x000EC8, "Member 'URSGamepadLayout::UEOnPushSELECTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSTARTEvent) == 0x000ED8, "Member 'URSGamepadLayout::UEOnPushSTARTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushDECIDEEvent) == 0x000EE8, "Member 'URSGamepadLayout::UEOnPushDECIDEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushCANCELEvent) == 0x000EF8, "Member 'URSGamepadLayout::UEOnPushCANCELEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushMOUSELEFTEvent) == 0x000F08, "Member 'URSGamepadLayout::UEOnPushMOUSELEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushMOUSERIGHTEvent) == 0x000F18, "Member 'URSGamepadLayout::UEOnPushMOUSERIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushMOUSEMIDDLEEvent) == 0x000F28, "Member 'URSGamepadLayout::UEOnPushMOUSEMIDDLEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushMOUSEWHEELUPEvent) == 0x000F38, "Member 'URSGamepadLayout::UEOnPushMOUSEWHEELUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushMOUSEWHEELDOWNEvent) == 0x000F48, "Member 'URSGamepadLayout::UEOnPushMOUSEWHEELDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushMOVE_FORWARDEvent) == 0x000F58, "Member 'URSGamepadLayout::UEOnPushMOVE_FORWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushMOVE_BACKWARDEvent) == 0x000F68, "Member 'URSGamepadLayout::UEOnPushMOVE_BACKWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushMOVE_LEFTEvent) == 0x000F78, "Member 'URSGamepadLayout::UEOnPushMOVE_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushMOVE_RIGHTEvent) == 0x000F88, "Member 'URSGamepadLayout::UEOnPushMOVE_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushACTIONEvent) == 0x000F98, "Member 'URSGamepadLayout::UEOnPushACTIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSTEP_DASHEvent) == 0x000FA8, "Member 'URSGamepadLayout::UEOnPushSTEP_DASHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushWEAPON_ATTACKEvent) == 0x000FB8, "Member 'URSGamepadLayout::UEOnPushWEAPON_ATTACKEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushWEAPON_ATTACK_SUBEvent) == 0x000FC8, "Member 'URSGamepadLayout::UEOnPushWEAPON_ATTACK_SUBEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushJUMPEvent) == 0x000FD8, "Member 'URSGamepadLayout::UEOnPushJUMPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushPSYCHICEvent) == 0x000FE8, "Member 'URSGamepadLayout::UEOnPushPSYCHICEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushPSYCHIC_SPECIALEvent) == 0x000FF8, "Member 'URSGamepadLayout::UEOnPushPSYCHIC_SPECIALEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushBRAINFIELDEvent) == 0x001008, "Member 'URSGamepadLayout::UEOnPushBRAINFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushPSYCHICFIELDEvent) == 0x001018, "Member 'URSGamepadLayout::UEOnPushPSYCHICFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushCAMERA_RESETEvent) == 0x001028, "Member 'URSGamepadLayout::UEOnPushCAMERA_RESETEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushLOCK_ONEvent) == 0x001038, "Member 'URSGamepadLayout::UEOnPushLOCK_ONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushLOCK_ON_SWITCH_LEvent) == 0x001048, "Member 'URSGamepadLayout::UEOnPushLOCK_ON_SWITCH_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushLOCK_ON_SWITCH_REvent) == 0x001058, "Member 'URSGamepadLayout::UEOnPushLOCK_ON_SWITCH_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushASSAULT_VISIONEvent) == 0x001068, "Member 'URSGamepadLayout::UEOnPushASSAULT_VISIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSASMENU_PAGESWITCHEvent) == 0x001078, "Member 'URSGamepadLayout::UEOnPushSASMENU_PAGESWITCHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSASMENU_OPENCLOSEEvent) == 0x001088, "Member 'URSGamepadLayout::UEOnPushSASMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSAS_ACTION_UEvent) == 0x001098, "Member 'URSGamepadLayout::UEOnPushSAS_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSAS_ACTION_DEvent) == 0x0010A8, "Member 'URSGamepadLayout::UEOnPushSAS_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSAS_ACTION_LEvent) == 0x0010B8, "Member 'URSGamepadLayout::UEOnPushSAS_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSAS_ACTION_REvent) == 0x0010C8, "Member 'URSGamepadLayout::UEOnPushSAS_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSTOP_SASEvent) == 0x0010D8, "Member 'URSGamepadLayout::UEOnPushSTOP_SASEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushCVMENU_OPENCLOSEEvent) == 0x0010E8, "Member 'URSGamepadLayout::UEOnPushCVMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushCV_ACTION_UEvent) == 0x0010F8, "Member 'URSGamepadLayout::UEOnPushCV_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushCV_ACTION_DEvent) == 0x001108, "Member 'URSGamepadLayout::UEOnPushCV_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushCV_ACTION_LEvent) == 0x001118, "Member 'URSGamepadLayout::UEOnPushCV_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushCV_ACTION_REvent) == 0x001128, "Member 'URSGamepadLayout::UEOnPushCV_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushITEM_SELECT_LEvent) == 0x001138, "Member 'URSGamepadLayout::UEOnPushITEM_SELECT_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushITEM_SELECT_REvent) == 0x001148, "Member 'URSGamepadLayout::UEOnPushITEM_SELECT_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushITEM_USEEvent) == 0x001158, "Member 'URSGamepadLayout::UEOnPushITEM_USEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushOPEN_MENUEvent) == 0x001168, "Member 'URSGamepadLayout::UEOnPushOPEN_MENUEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushOPEN_DETAILMAPEvent) == 0x001178, "Member 'URSGamepadLayout::UEOnPushOPEN_DETAILMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushOPEN_WORLDMAPEvent) == 0x001188, "Member 'URSGamepadLayout::UEOnPushOPEN_WORLDMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushACTION2Event) == 0x001198, "Member 'URSGamepadLayout::UEOnPushACTION2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushOPEN_BRAIN_MESSAGEEvent) == 0x0011A8, "Member 'URSGamepadLayout::UEOnPushOPEN_BRAIN_MESSAGEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseR1Event) == 0x0011B8, "Member 'URSGamepadLayout::UEOnReleaseR1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseR2Event) == 0x0011C8, "Member 'URSGamepadLayout::UEOnReleaseR2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseR3Event) == 0x0011D8, "Member 'URSGamepadLayout::UEOnReleaseR3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseL1Event) == 0x0011E8, "Member 'URSGamepadLayout::UEOnReleaseL1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseL2Event) == 0x0011F8, "Member 'URSGamepadLayout::UEOnReleaseL2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseL3Event) == 0x001208, "Member 'URSGamepadLayout::UEOnReleaseL3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseRUPEvent) == 0x001218, "Member 'URSGamepadLayout::UEOnReleaseRUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseRDOWNEvent) == 0x001228, "Member 'URSGamepadLayout::UEOnReleaseRDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseRLEFTEvent) == 0x001238, "Member 'URSGamepadLayout::UEOnReleaseRLEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseRRIGHTEvent) == 0x001248, "Member 'URSGamepadLayout::UEOnReleaseRRIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseDPAD_UPEvent) == 0x001258, "Member 'URSGamepadLayout::UEOnReleaseDPAD_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseDPAD_DOWNEvent) == 0x001268, "Member 'URSGamepadLayout::UEOnReleaseDPAD_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseDPAD_LEFTEvent) == 0x001278, "Member 'URSGamepadLayout::UEOnReleaseDPAD_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseDPAD_RIGHTEvent) == 0x001288, "Member 'URSGamepadLayout::UEOnReleaseDPAD_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseDPADEMU_UPEvent) == 0x001298, "Member 'URSGamepadLayout::UEOnReleaseDPADEMU_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseDPADEMU_DOWNEvent) == 0x0012A8, "Member 'URSGamepadLayout::UEOnReleaseDPADEMU_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseDPADEMU_LEFTEvent) == 0x0012B8, "Member 'URSGamepadLayout::UEOnReleaseDPADEMU_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseDPADEMU_RIGHTEvent) == 0x0012C8, "Member 'URSGamepadLayout::UEOnReleaseDPADEMU_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSELECTEvent) == 0x0012D8, "Member 'URSGamepadLayout::UEOnReleaseSELECTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSTARTEvent) == 0x0012E8, "Member 'URSGamepadLayout::UEOnReleaseSTARTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseDECIDEEvent) == 0x0012F8, "Member 'URSGamepadLayout::UEOnReleaseDECIDEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseCANCELEvent) == 0x001308, "Member 'URSGamepadLayout::UEOnReleaseCANCELEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseMOUSELEFTEvent) == 0x001318, "Member 'URSGamepadLayout::UEOnReleaseMOUSELEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseMOUSERIGHTEvent) == 0x001328, "Member 'URSGamepadLayout::UEOnReleaseMOUSERIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseMOUSEMIDDLEEvent) == 0x001338, "Member 'URSGamepadLayout::UEOnReleaseMOUSEMIDDLEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseMOUSEWHEELUPEvent) == 0x001348, "Member 'URSGamepadLayout::UEOnReleaseMOUSEWHEELUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseMOUSEWHEELDOWNEvent) == 0x001358, "Member 'URSGamepadLayout::UEOnReleaseMOUSEWHEELDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseMOVE_FORWARDEvent) == 0x001368, "Member 'URSGamepadLayout::UEOnReleaseMOVE_FORWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseMOVE_BACKWARDEvent) == 0x001378, "Member 'URSGamepadLayout::UEOnReleaseMOVE_BACKWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseMOVE_LEFTEvent) == 0x001388, "Member 'URSGamepadLayout::UEOnReleaseMOVE_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseMOVE_RIGHTEvent) == 0x001398, "Member 'URSGamepadLayout::UEOnReleaseMOVE_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseACTIONEvent) == 0x0013A8, "Member 'URSGamepadLayout::UEOnReleaseACTIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSTEP_DASHEvent) == 0x0013B8, "Member 'URSGamepadLayout::UEOnReleaseSTEP_DASHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseWEAPON_ATTACKEvent) == 0x0013C8, "Member 'URSGamepadLayout::UEOnReleaseWEAPON_ATTACKEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseWEAPON_ATTACK_SUBEvent) == 0x0013D8, "Member 'URSGamepadLayout::UEOnReleaseWEAPON_ATTACK_SUBEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseJUMPEvent) == 0x0013E8, "Member 'URSGamepadLayout::UEOnReleaseJUMPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleasePSYCHICEvent) == 0x0013F8, "Member 'URSGamepadLayout::UEOnReleasePSYCHICEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleasePSYCHIC_SPECIALEvent) == 0x001408, "Member 'URSGamepadLayout::UEOnReleasePSYCHIC_SPECIALEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseBRAINFIELDEvent) == 0x001418, "Member 'URSGamepadLayout::UEOnReleaseBRAINFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleasePSYCHICFIELDEvent) == 0x001428, "Member 'URSGamepadLayout::UEOnReleasePSYCHICFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseCAMERA_RESETEvent) == 0x001438, "Member 'URSGamepadLayout::UEOnReleaseCAMERA_RESETEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseLOCK_ONEvent) == 0x001448, "Member 'URSGamepadLayout::UEOnReleaseLOCK_ONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseLOCK_ON_SWITCH_LEvent) == 0x001458, "Member 'URSGamepadLayout::UEOnReleaseLOCK_ON_SWITCH_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseLOCK_ON_SWITCH_REvent) == 0x001468, "Member 'URSGamepadLayout::UEOnReleaseLOCK_ON_SWITCH_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseASSAULT_VISIONEvent) == 0x001478, "Member 'URSGamepadLayout::UEOnReleaseASSAULT_VISIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSASMENU_PAGESWITCHEvent) == 0x001488, "Member 'URSGamepadLayout::UEOnReleaseSASMENU_PAGESWITCHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSASMENU_OPENCLOSEEvent) == 0x001498, "Member 'URSGamepadLayout::UEOnReleaseSASMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSAS_ACTION_UEvent) == 0x0014A8, "Member 'URSGamepadLayout::UEOnReleaseSAS_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSAS_ACTION_DEvent) == 0x0014B8, "Member 'URSGamepadLayout::UEOnReleaseSAS_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSAS_ACTION_LEvent) == 0x0014C8, "Member 'URSGamepadLayout::UEOnReleaseSAS_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSAS_ACTION_REvent) == 0x0014D8, "Member 'URSGamepadLayout::UEOnReleaseSAS_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSTOP_SASEvent) == 0x0014E8, "Member 'URSGamepadLayout::UEOnReleaseSTOP_SASEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseCVMENU_OPENCLOSEEvent) == 0x0014F8, "Member 'URSGamepadLayout::UEOnReleaseCVMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseCV_ACTION_UEvent) == 0x001508, "Member 'URSGamepadLayout::UEOnReleaseCV_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseCV_ACTION_DEvent) == 0x001518, "Member 'URSGamepadLayout::UEOnReleaseCV_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseCV_ACTION_LEvent) == 0x001528, "Member 'URSGamepadLayout::UEOnReleaseCV_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseCV_ACTION_REvent) == 0x001538, "Member 'URSGamepadLayout::UEOnReleaseCV_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseITEM_SELECT_LEvent) == 0x001548, "Member 'URSGamepadLayout::UEOnReleaseITEM_SELECT_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseITEM_SELECT_REvent) == 0x001558, "Member 'URSGamepadLayout::UEOnReleaseITEM_SELECT_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseITEM_USEEvent) == 0x001568, "Member 'URSGamepadLayout::UEOnReleaseITEM_USEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseOPEN_MENUEvent) == 0x001578, "Member 'URSGamepadLayout::UEOnReleaseOPEN_MENUEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseOPEN_DETAILMAPEvent) == 0x001588, "Member 'URSGamepadLayout::UEOnReleaseOPEN_DETAILMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseOPEN_WORLDMAPEvent) == 0x001598, "Member 'URSGamepadLayout::UEOnReleaseOPEN_WORLDMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseACTION2Event) == 0x0015A8, "Member 'URSGamepadLayout::UEOnReleaseACTION2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseOPEN_BRAIN_MESSAGEEvent) == 0x0015B8, "Member 'URSGamepadLayout::UEOnReleaseOPEN_BRAIN_MESSAGEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressR1Event) == 0x0015C8, "Member 'URSGamepadLayout::OnPressR1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressR2Event) == 0x0015D8, "Member 'URSGamepadLayout::OnPressR2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressR3Event) == 0x0015E8, "Member 'URSGamepadLayout::OnPressR3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressL1Event) == 0x0015F8, "Member 'URSGamepadLayout::OnPressL1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressL2Event) == 0x001608, "Member 'URSGamepadLayout::OnPressL2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressL3Event) == 0x001618, "Member 'URSGamepadLayout::OnPressL3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressRUPEvent) == 0x001628, "Member 'URSGamepadLayout::OnPressRUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressRDOWNEvent) == 0x001638, "Member 'URSGamepadLayout::OnPressRDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressRLEFTEvent) == 0x001648, "Member 'URSGamepadLayout::OnPressRLEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressRRIGHTEvent) == 0x001658, "Member 'URSGamepadLayout::OnPressRRIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressDPAD_UPEvent) == 0x001668, "Member 'URSGamepadLayout::OnPressDPAD_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressDPAD_DOWNEvent) == 0x001678, "Member 'URSGamepadLayout::OnPressDPAD_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressDPAD_LEFTEvent) == 0x001688, "Member 'URSGamepadLayout::OnPressDPAD_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressDPAD_RIGHTEvent) == 0x001698, "Member 'URSGamepadLayout::OnPressDPAD_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressDPADEMU_UPEvent) == 0x0016A8, "Member 'URSGamepadLayout::OnPressDPADEMU_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressDPADEMU_DOWNEvent) == 0x0016B8, "Member 'URSGamepadLayout::OnPressDPADEMU_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressDPADEMU_LEFTEvent) == 0x0016C8, "Member 'URSGamepadLayout::OnPressDPADEMU_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressDPADEMU_RIGHTEvent) == 0x0016D8, "Member 'URSGamepadLayout::OnPressDPADEMU_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSELECTEvent) == 0x0016E8, "Member 'URSGamepadLayout::OnPressSELECTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSTARTEvent) == 0x0016F8, "Member 'URSGamepadLayout::OnPressSTARTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressDECIDEEvent) == 0x001708, "Member 'URSGamepadLayout::OnPressDECIDEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressCANCELEvent) == 0x001718, "Member 'URSGamepadLayout::OnPressCANCELEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressMOUSELEFTEvent) == 0x001728, "Member 'URSGamepadLayout::OnPressMOUSELEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressMOUSERIGHTEvent) == 0x001738, "Member 'URSGamepadLayout::OnPressMOUSERIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressMOUSEMIDDLEEvent) == 0x001748, "Member 'URSGamepadLayout::OnPressMOUSEMIDDLEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressMOUSEWHEELUPEvent) == 0x001758, "Member 'URSGamepadLayout::OnPressMOUSEWHEELUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressMOUSEWHEELDOWNEvent) == 0x001768, "Member 'URSGamepadLayout::OnPressMOUSEWHEELDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressMOVE_FORWARDEvent) == 0x001778, "Member 'URSGamepadLayout::OnPressMOVE_FORWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressMOVE_BACKWARDEvent) == 0x001788, "Member 'URSGamepadLayout::OnPressMOVE_BACKWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressMOVE_LEFTEvent) == 0x001798, "Member 'URSGamepadLayout::OnPressMOVE_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressMOVE_RIGHTEvent) == 0x0017A8, "Member 'URSGamepadLayout::OnPressMOVE_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressACTIONEvent) == 0x0017B8, "Member 'URSGamepadLayout::OnPressACTIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSTEP_DASHEvent) == 0x0017C8, "Member 'URSGamepadLayout::OnPressSTEP_DASHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressWEAPON_ATTACKEvent) == 0x0017D8, "Member 'URSGamepadLayout::OnPressWEAPON_ATTACKEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressWEAPON_ATTACK_SUBEvent) == 0x0017E8, "Member 'URSGamepadLayout::OnPressWEAPON_ATTACK_SUBEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressJUMPEvent) == 0x0017F8, "Member 'URSGamepadLayout::OnPressJUMPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressPSYCHICEvent) == 0x001808, "Member 'URSGamepadLayout::OnPressPSYCHICEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressPSYCHIC_SPECIALEvent) == 0x001818, "Member 'URSGamepadLayout::OnPressPSYCHIC_SPECIALEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressBRAINFIELDEvent) == 0x001828, "Member 'URSGamepadLayout::OnPressBRAINFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressPSYCHICFIELDEvent) == 0x001838, "Member 'URSGamepadLayout::OnPressPSYCHICFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressCAMERA_RESETEvent) == 0x001848, "Member 'URSGamepadLayout::OnPressCAMERA_RESETEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressLOCK_ONEvent) == 0x001858, "Member 'URSGamepadLayout::OnPressLOCK_ONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressLOCK_ON_SWITCH_LEvent) == 0x001868, "Member 'URSGamepadLayout::OnPressLOCK_ON_SWITCH_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressLOCK_ON_SWITCH_REvent) == 0x001878, "Member 'URSGamepadLayout::OnPressLOCK_ON_SWITCH_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressASSAULT_VISIONEvent) == 0x001888, "Member 'URSGamepadLayout::OnPressASSAULT_VISIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSASMENU_PAGESWITCHEvent) == 0x001898, "Member 'URSGamepadLayout::OnPressSASMENU_PAGESWITCHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSASMENU_OPENCLOSEEvent) == 0x0018A8, "Member 'URSGamepadLayout::OnPressSASMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSAS_ACTION_UEvent) == 0x0018B8, "Member 'URSGamepadLayout::OnPressSAS_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSAS_ACTION_DEvent) == 0x0018C8, "Member 'URSGamepadLayout::OnPressSAS_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSAS_ACTION_LEvent) == 0x0018D8, "Member 'URSGamepadLayout::OnPressSAS_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSAS_ACTION_REvent) == 0x0018E8, "Member 'URSGamepadLayout::OnPressSAS_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSTOP_SASEvent) == 0x0018F8, "Member 'URSGamepadLayout::OnPressSTOP_SASEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressCVMENU_OPENCLOSEEvent) == 0x001908, "Member 'URSGamepadLayout::OnPressCVMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressCV_ACTION_UEvent) == 0x001918, "Member 'URSGamepadLayout::OnPressCV_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressCV_ACTION_DEvent) == 0x001928, "Member 'URSGamepadLayout::OnPressCV_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressCV_ACTION_LEvent) == 0x001938, "Member 'URSGamepadLayout::OnPressCV_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressCV_ACTION_REvent) == 0x001948, "Member 'URSGamepadLayout::OnPressCV_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressITEM_SELECT_LEvent) == 0x001958, "Member 'URSGamepadLayout::OnPressITEM_SELECT_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressITEM_SELECT_REvent) == 0x001968, "Member 'URSGamepadLayout::OnPressITEM_SELECT_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressITEM_USEEvent) == 0x001978, "Member 'URSGamepadLayout::OnPressITEM_USEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressOPEN_MENUEvent) == 0x001988, "Member 'URSGamepadLayout::OnPressOPEN_MENUEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressOPEN_DETAILMAPEvent) == 0x001998, "Member 'URSGamepadLayout::OnPressOPEN_DETAILMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressOPEN_WORLDMAPEvent) == 0x0019A8, "Member 'URSGamepadLayout::OnPressOPEN_WORLDMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressACTION2Event) == 0x0019B8, "Member 'URSGamepadLayout::OnPressACTION2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressOPEN_BRAIN_MESSAGEEvent) == 0x0019C8, "Member 'URSGamepadLayout::OnPressOPEN_BRAIN_MESSAGEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerR1Event) == 0x0019D8, "Member 'URSGamepadLayout::OnTriggerR1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerR2Event) == 0x0019E8, "Member 'URSGamepadLayout::OnTriggerR2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerR3Event) == 0x0019F8, "Member 'URSGamepadLayout::OnTriggerR3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerL1Event) == 0x001A08, "Member 'URSGamepadLayout::OnTriggerL1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerL2Event) == 0x001A18, "Member 'URSGamepadLayout::OnTriggerL2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerL3Event) == 0x001A28, "Member 'URSGamepadLayout::OnTriggerL3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerRUPEvent) == 0x001A38, "Member 'URSGamepadLayout::OnTriggerRUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerRDOWNEvent) == 0x001A48, "Member 'URSGamepadLayout::OnTriggerRDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerRLEFTEvent) == 0x001A58, "Member 'URSGamepadLayout::OnTriggerRLEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerRRIGHTEvent) == 0x001A68, "Member 'URSGamepadLayout::OnTriggerRRIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerDPAD_UPEvent) == 0x001A78, "Member 'URSGamepadLayout::OnTriggerDPAD_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerDPAD_DOWNEvent) == 0x001A88, "Member 'URSGamepadLayout::OnTriggerDPAD_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerDPAD_LEFTEvent) == 0x001A98, "Member 'URSGamepadLayout::OnTriggerDPAD_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerDPAD_RIGHTEvent) == 0x001AA8, "Member 'URSGamepadLayout::OnTriggerDPAD_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerDPADEMU_UPEvent) == 0x001AB8, "Member 'URSGamepadLayout::OnTriggerDPADEMU_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerDPADEMU_DOWNEvent) == 0x001AC8, "Member 'URSGamepadLayout::OnTriggerDPADEMU_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerDPADEMU_LEFTEvent) == 0x001AD8, "Member 'URSGamepadLayout::OnTriggerDPADEMU_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerDPADEMU_RIGHTEvent) == 0x001AE8, "Member 'URSGamepadLayout::OnTriggerDPADEMU_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSELECTEvent) == 0x001AF8, "Member 'URSGamepadLayout::OnTriggerSELECTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSTARTEvent) == 0x001B08, "Member 'URSGamepadLayout::OnTriggerSTARTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerDECIDEEvent) == 0x001B18, "Member 'URSGamepadLayout::OnTriggerDECIDEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerCANCELEvent) == 0x001B28, "Member 'URSGamepadLayout::OnTriggerCANCELEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerMOUSELEFTEvent) == 0x001B38, "Member 'URSGamepadLayout::OnTriggerMOUSELEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerMOUSERIGHTEvent) == 0x001B48, "Member 'URSGamepadLayout::OnTriggerMOUSERIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerMOUSEMIDDLEEvent) == 0x001B58, "Member 'URSGamepadLayout::OnTriggerMOUSEMIDDLEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerMOUSEWHEELUPEvent) == 0x001B68, "Member 'URSGamepadLayout::OnTriggerMOUSEWHEELUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerMOUSEWHEELDOWNEvent) == 0x001B78, "Member 'URSGamepadLayout::OnTriggerMOUSEWHEELDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerMOVE_FORWARDEvent) == 0x001B88, "Member 'URSGamepadLayout::OnTriggerMOVE_FORWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerMOVE_BACKWARDEvent) == 0x001B98, "Member 'URSGamepadLayout::OnTriggerMOVE_BACKWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerMOVE_LEFTEvent) == 0x001BA8, "Member 'URSGamepadLayout::OnTriggerMOVE_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerMOVE_RIGHTEvent) == 0x001BB8, "Member 'URSGamepadLayout::OnTriggerMOVE_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerACTIONEvent) == 0x001BC8, "Member 'URSGamepadLayout::OnTriggerACTIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSTEP_DASHEvent) == 0x001BD8, "Member 'URSGamepadLayout::OnTriggerSTEP_DASHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerWEAPON_ATTACKEvent) == 0x001BE8, "Member 'URSGamepadLayout::OnTriggerWEAPON_ATTACKEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerWEAPON_ATTACK_SUBEvent) == 0x001BF8, "Member 'URSGamepadLayout::OnTriggerWEAPON_ATTACK_SUBEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerJUMPEvent) == 0x001C08, "Member 'URSGamepadLayout::OnTriggerJUMPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerPSYCHICEvent) == 0x001C18, "Member 'URSGamepadLayout::OnTriggerPSYCHICEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerPSYCHIC_SPECIALEvent) == 0x001C28, "Member 'URSGamepadLayout::OnTriggerPSYCHIC_SPECIALEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerBRAINFIELDEvent) == 0x001C38, "Member 'URSGamepadLayout::OnTriggerBRAINFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerPSYCHICFIELDEvent) == 0x001C48, "Member 'URSGamepadLayout::OnTriggerPSYCHICFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerCAMERA_RESETEvent) == 0x001C58, "Member 'URSGamepadLayout::OnTriggerCAMERA_RESETEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerLOCK_ONEvent) == 0x001C68, "Member 'URSGamepadLayout::OnTriggerLOCK_ONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerLOCK_ON_SWITCH_LEvent) == 0x001C78, "Member 'URSGamepadLayout::OnTriggerLOCK_ON_SWITCH_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerLOCK_ON_SWITCH_REvent) == 0x001C88, "Member 'URSGamepadLayout::OnTriggerLOCK_ON_SWITCH_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerASSAULT_VISIONEvent) == 0x001C98, "Member 'URSGamepadLayout::OnTriggerASSAULT_VISIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSASMENU_PAGESWITCHEvent) == 0x001CA8, "Member 'URSGamepadLayout::OnTriggerSASMENU_PAGESWITCHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSASMENU_OPENCLOSEEvent) == 0x001CB8, "Member 'URSGamepadLayout::OnTriggerSASMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSAS_ACTION_UEvent) == 0x001CC8, "Member 'URSGamepadLayout::OnTriggerSAS_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSAS_ACTION_DEvent) == 0x001CD8, "Member 'URSGamepadLayout::OnTriggerSAS_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSAS_ACTION_LEvent) == 0x001CE8, "Member 'URSGamepadLayout::OnTriggerSAS_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSAS_ACTION_REvent) == 0x001CF8, "Member 'URSGamepadLayout::OnTriggerSAS_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSTOP_SASEvent) == 0x001D08, "Member 'URSGamepadLayout::OnTriggerSTOP_SASEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerCVMENU_OPENCLOSEEvent) == 0x001D18, "Member 'URSGamepadLayout::OnTriggerCVMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerCV_ACTION_UEvent) == 0x001D28, "Member 'URSGamepadLayout::OnTriggerCV_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerCV_ACTION_DEvent) == 0x001D38, "Member 'URSGamepadLayout::OnTriggerCV_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerCV_ACTION_LEvent) == 0x001D48, "Member 'URSGamepadLayout::OnTriggerCV_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerCV_ACTION_REvent) == 0x001D58, "Member 'URSGamepadLayout::OnTriggerCV_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerITEM_SELECT_LEvent) == 0x001D68, "Member 'URSGamepadLayout::OnTriggerITEM_SELECT_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerITEM_SELECT_REvent) == 0x001D78, "Member 'URSGamepadLayout::OnTriggerITEM_SELECT_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerITEM_USEEvent) == 0x001D88, "Member 'URSGamepadLayout::OnTriggerITEM_USEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerOPEN_MENUEvent) == 0x001D98, "Member 'URSGamepadLayout::OnTriggerOPEN_MENUEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerOPEN_DETAILMAPEvent) == 0x001DA8, "Member 'URSGamepadLayout::OnTriggerOPEN_DETAILMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerOPEN_WORLDMAPEvent) == 0x001DB8, "Member 'URSGamepadLayout::OnTriggerOPEN_WORLDMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerACTION2Event) == 0x001DC8, "Member 'URSGamepadLayout::OnTriggerACTION2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerOPEN_BRAIN_MESSAGEEvent) == 0x001DD8, "Member 'URSGamepadLayout::OnTriggerOPEN_BRAIN_MESSAGEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerR1Event) == 0x001DE8, "Member 'URSGamepadLayout::OnRepTriggerR1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerR2Event) == 0x001DF8, "Member 'URSGamepadLayout::OnRepTriggerR2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerR3Event) == 0x001E08, "Member 'URSGamepadLayout::OnRepTriggerR3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerL1Event) == 0x001E18, "Member 'URSGamepadLayout::OnRepTriggerL1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerL2Event) == 0x001E28, "Member 'URSGamepadLayout::OnRepTriggerL2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerL3Event) == 0x001E38, "Member 'URSGamepadLayout::OnRepTriggerL3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerRUPEvent) == 0x001E48, "Member 'URSGamepadLayout::OnRepTriggerRUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerRDOWNEvent) == 0x001E58, "Member 'URSGamepadLayout::OnRepTriggerRDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerRLEFTEvent) == 0x001E68, "Member 'URSGamepadLayout::OnRepTriggerRLEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerRRIGHTEvent) == 0x001E78, "Member 'URSGamepadLayout::OnRepTriggerRRIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerDPAD_UPEvent) == 0x001E88, "Member 'URSGamepadLayout::OnRepTriggerDPAD_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerDPAD_DOWNEvent) == 0x001E98, "Member 'URSGamepadLayout::OnRepTriggerDPAD_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerDPAD_LEFTEvent) == 0x001EA8, "Member 'URSGamepadLayout::OnRepTriggerDPAD_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerDPAD_RIGHTEvent) == 0x001EB8, "Member 'URSGamepadLayout::OnRepTriggerDPAD_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerDPADEMU_UPEvent) == 0x001EC8, "Member 'URSGamepadLayout::OnRepTriggerDPADEMU_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerDPADEMU_DOWNEvent) == 0x001ED8, "Member 'URSGamepadLayout::OnRepTriggerDPADEMU_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerDPADEMU_LEFTEvent) == 0x001EE8, "Member 'URSGamepadLayout::OnRepTriggerDPADEMU_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerDPADEMU_RIGHTEvent) == 0x001EF8, "Member 'URSGamepadLayout::OnRepTriggerDPADEMU_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSELECTEvent) == 0x001F08, "Member 'URSGamepadLayout::OnRepTriggerSELECTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSTARTEvent) == 0x001F18, "Member 'URSGamepadLayout::OnRepTriggerSTARTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerDECIDEEvent) == 0x001F28, "Member 'URSGamepadLayout::OnRepTriggerDECIDEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerCANCELEvent) == 0x001F38, "Member 'URSGamepadLayout::OnRepTriggerCANCELEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerMOUSELEFTEvent) == 0x001F48, "Member 'URSGamepadLayout::OnRepTriggerMOUSELEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerMOUSERIGHTEvent) == 0x001F58, "Member 'URSGamepadLayout::OnRepTriggerMOUSERIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerMOUSEMIDDLEEvent) == 0x001F68, "Member 'URSGamepadLayout::OnRepTriggerMOUSEMIDDLEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerMOUSEWHEELUPEvent) == 0x001F78, "Member 'URSGamepadLayout::OnRepTriggerMOUSEWHEELUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerMOUSEWHEELDOWNEvent) == 0x001F88, "Member 'URSGamepadLayout::OnRepTriggerMOUSEWHEELDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerMOVE_FORWARDEvent) == 0x001F98, "Member 'URSGamepadLayout::OnRepTriggerMOVE_FORWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerMOVE_BACKWARDEvent) == 0x001FA8, "Member 'URSGamepadLayout::OnRepTriggerMOVE_BACKWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerMOVE_LEFTEvent) == 0x001FB8, "Member 'URSGamepadLayout::OnRepTriggerMOVE_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerMOVE_RIGHTEvent) == 0x001FC8, "Member 'URSGamepadLayout::OnRepTriggerMOVE_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerACTIONEvent) == 0x001FD8, "Member 'URSGamepadLayout::OnRepTriggerACTIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSTEP_DASHEvent) == 0x001FE8, "Member 'URSGamepadLayout::OnRepTriggerSTEP_DASHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerWEAPON_ATTACKEvent) == 0x001FF8, "Member 'URSGamepadLayout::OnRepTriggerWEAPON_ATTACKEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerWEAPON_ATTACK_SUBEvent) == 0x002008, "Member 'URSGamepadLayout::OnRepTriggerWEAPON_ATTACK_SUBEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerJUMPEvent) == 0x002018, "Member 'URSGamepadLayout::OnRepTriggerJUMPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerPSYCHICEvent) == 0x002028, "Member 'URSGamepadLayout::OnRepTriggerPSYCHICEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerPSYCHIC_SPECIALEvent) == 0x002038, "Member 'URSGamepadLayout::OnRepTriggerPSYCHIC_SPECIALEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerBRAINFIELDEvent) == 0x002048, "Member 'URSGamepadLayout::OnRepTriggerBRAINFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerPSYCHICFIELDEvent) == 0x002058, "Member 'URSGamepadLayout::OnRepTriggerPSYCHICFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerCAMERA_RESETEvent) == 0x002068, "Member 'URSGamepadLayout::OnRepTriggerCAMERA_RESETEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerLOCK_ONEvent) == 0x002078, "Member 'URSGamepadLayout::OnRepTriggerLOCK_ONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerLOCK_ON_SWITCH_LEvent) == 0x002088, "Member 'URSGamepadLayout::OnRepTriggerLOCK_ON_SWITCH_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerLOCK_ON_SWITCH_REvent) == 0x002098, "Member 'URSGamepadLayout::OnRepTriggerLOCK_ON_SWITCH_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerASSAULT_VISIONEvent) == 0x0020A8, "Member 'URSGamepadLayout::OnRepTriggerASSAULT_VISIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSASMENU_PAGESWITCHEvent) == 0x0020B8, "Member 'URSGamepadLayout::OnRepTriggerSASMENU_PAGESWITCHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSASMENU_OPENCLOSEEvent) == 0x0020C8, "Member 'URSGamepadLayout::OnRepTriggerSASMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSAS_ACTION_UEvent) == 0x0020D8, "Member 'URSGamepadLayout::OnRepTriggerSAS_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSAS_ACTION_DEvent) == 0x0020E8, "Member 'URSGamepadLayout::OnRepTriggerSAS_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSAS_ACTION_LEvent) == 0x0020F8, "Member 'URSGamepadLayout::OnRepTriggerSAS_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSAS_ACTION_REvent) == 0x002108, "Member 'URSGamepadLayout::OnRepTriggerSAS_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSTOP_SASEvent) == 0x002118, "Member 'URSGamepadLayout::OnRepTriggerSTOP_SASEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerCVMENU_OPENCLOSEEvent) == 0x002128, "Member 'URSGamepadLayout::OnRepTriggerCVMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerCV_ACTION_UEvent) == 0x002138, "Member 'URSGamepadLayout::OnRepTriggerCV_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerCV_ACTION_DEvent) == 0x002148, "Member 'URSGamepadLayout::OnRepTriggerCV_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerCV_ACTION_LEvent) == 0x002158, "Member 'URSGamepadLayout::OnRepTriggerCV_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerCV_ACTION_REvent) == 0x002168, "Member 'URSGamepadLayout::OnRepTriggerCV_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerITEM_SELECT_LEvent) == 0x002178, "Member 'URSGamepadLayout::OnRepTriggerITEM_SELECT_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerITEM_SELECT_REvent) == 0x002188, "Member 'URSGamepadLayout::OnRepTriggerITEM_SELECT_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerITEM_USEEvent) == 0x002198, "Member 'URSGamepadLayout::OnRepTriggerITEM_USEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerOPEN_MENUEvent) == 0x0021A8, "Member 'URSGamepadLayout::OnRepTriggerOPEN_MENUEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerOPEN_DETAILMAPEvent) == 0x0021B8, "Member 'URSGamepadLayout::OnRepTriggerOPEN_DETAILMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerOPEN_WORLDMAPEvent) == 0x0021C8, "Member 'URSGamepadLayout::OnRepTriggerOPEN_WORLDMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerACTION2Event) == 0x0021D8, "Member 'URSGamepadLayout::OnRepTriggerACTION2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerOPEN_BRAIN_MESSAGEEvent) == 0x0021E8, "Member 'URSGamepadLayout::OnRepTriggerOPEN_BRAIN_MESSAGEEvent' has a wrong offset!");

// Class BattlePrototype.WorldmapOpenParam
// 0x0068 (0x0090 - 0x0028)
class UWorldmapOpenParam final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FWorldmapOpenLCParam>      OpenParam;                                         // 0x0038(0x0050)(NativeAccessSpecifierPrivate)
	bool                                          NotSelectableAll;                                  // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckOpenFromProgressID(int32 ProgressId, bool CheckNearly);
	void ClearAll();
	bool CloseLocation(int32 LocationNo, int32 AreaNo, int32 PortalNo, bool IsAllArea);
	bool GetLocationNotSelectableAll_FromBF();
	bool GetOpenedList(TArray<struct FWorldmapOpenLCParam>* OpenedList);
	bool IsLocationNewOpened(int32 LocationNo, int32 AreaNo, int32 PortalNo);
	bool IsLocationNotSelectable(int32 LocationNo);
	bool IsLocationNotSelectableAll();
	bool IsLocationSelectable(int32 LocationNo, int32 AreaNo, int32 PortalNo);
	bool OpenLocation(int32 LocationNo, int32 AreaNo, int32 PortalNo, bool IsSelectable);
	bool SetLocationNewOpened(int32 LocationNo, int32 AreaNo, int32 PortalNo, bool IsNewOpened, bool IsAllArea);
	void SetLocationNotSelectable(int32 LocationNo, bool IsNotSelectable);
	void SetLocationNotSelectableAll(bool IsNotSelectable);
	void SetLocationNotSelectableAll_FromBF(bool IsNotSelectable);
	bool SetLocationSelectable(int32 LocationNo, int32 AreaNo, int32 PortalNo, bool IsSelectable, bool IsForce, bool IsAllArea);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldmapOpenParam">();
	}
	static class UWorldmapOpenParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldmapOpenParam>();
	}
};
static_assert(alignof(UWorldmapOpenParam) == 0x000008, "Wrong alignment on UWorldmapOpenParam");
static_assert(sizeof(UWorldmapOpenParam) == 0x000090, "Wrong size on UWorldmapOpenParam");
static_assert(offsetof(UWorldmapOpenParam, OpenParam) == 0x000038, "Member 'UWorldmapOpenParam::OpenParam' has a wrong offset!");
static_assert(offsetof(UWorldmapOpenParam, NotSelectableAll) == 0x000088, "Member 'UWorldmapOpenParam::NotSelectableAll' has a wrong offset!");

// Class BattlePrototype.RSGameViewportClient
// 0x0000 (0x0330 - 0x0330)
class URSGameViewportClient final : public UGameViewportClient
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSGameViewportClient">();
	}
	static class URSGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSGameViewportClient>();
	}
};
static_assert(alignof(URSGameViewportClient) == 0x000008, "Wrong alignment on URSGameViewportClient");
static_assert(sizeof(URSGameViewportClient) == 0x000330, "Wrong size on URSGameViewportClient");

// Class BattlePrototype.RSGeneralFuncLib
// 0x0000 (0x0028 - 0x0028)
class URSGeneralFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static class UActorComponent* AddActorComponent(class AActor* Actor, class UClass* ComponentClass);
	static void CharacterMoveSmooth(class ACharacter* InCharacter, const struct FVector& InVelocity, const float DeltaSeconds);
	static void ClearUnusedRenderTargets(class UObject* WorldContextObject);
	static void ClearViewStateMIDPool(class UObject* WorldContextObject);
	static void GetChildrenMeshComponents(TArray<class UMeshComponent*>* OutMeshComps, class USceneComponent* TargetComponent, bool IncludeAllDescendants);
	static float GetPrimitiveBoundsScale(class UPrimitiveComponent* Primitive);
	static class FString GetRedSettingPurpose();
	static bool HasCelLookMaterialActor(class AActor* Actor);
	static bool HasCelLookMaterialComponent(class UMeshComponent* Mesh);
	static bool HasMaterialParent(class UMaterialInterface* TestMaterial, class UMaterialInterface* CheckMaterial);
	static bool HasRedEnemyMaterialActor(class AActor* Actor);
	static bool HasRedEnemyMaterialComponent(class UMeshComponent* Mesh);
	static bool IsBodySimulatingPhysics(class UPrimitiveComponent* Primitive);
	static bool IsEditor();
	static bool IsInDisplayScreen(const class APlayerController* PC, const struct FVector& TargetPos);
	static bool IsPlayMovieCapture();
	static bool IsPlaySimulate();
	static bool IsVisibleMaterial(class USkinnedMeshComponent* Mesh, int32 MaterialID);
	static TArray<int32> SearchMeshCompMaterialExcludeSlotName(class UMeshComponent* Mesh, const class FString& Name_0, bool IsCaseCheck);
	static TArray<int32> SearchMeshCompMaterialFromSlotName(class UMeshComponent* Mesh, const class FString& Name_0, bool IsCaseCheck);
	static TArray<int32> SearchMeshMaterialFromSlotName(class USkinnedMeshComponent* Mesh, const class FString& Name_0, bool IsCaseCheck);
	static void SetCellLightingParamter(float LightPower, float LightSunnyMax);
	static void SetEnableFrameRateSmoothing(class UObject* WorldContextObject, bool bEnable);
	static void SetScalarParameter(class USkinnedMeshComponent* Mesh, int32 MaterialIndex, class FName ParameterName, float Value, bool CreateDynamicMaterial);
	static void SetScalarParameterAll(class UMeshComponent* Mesh, class FName ParameterName, float Value, bool CreateDynamicMaterial);
	static void SetScalarParameterAllArray(class UMeshComponent* Mesh, const TArray<class FName>& ParameterName, const TArray<float>& Value, bool CreateDynamicMaterial);
	static void SetScalarParameterArrayExcludeSlotName(class UMeshComponent* Mesh, class FName SlotName, bool IsCaseCheck, const TArray<class FName>& ParameterName, const TArray<float>& Value, bool CreateDynamicMaterial);
	static void SetScalarParameterArrayFromIndexList(class UMeshComponent* Mesh, const TArray<int32>& MaterialSlotIndexList, const TArray<class FName>& ParameterName, const TArray<float>& Value, bool CreateDynamicMaterial);
	static void SetScalarParameterArrayFromSlotName(class UMeshComponent* Mesh, class FName SlotName, bool IsCaseCheck, const TArray<class FName>& ParameterName, const TArray<float>& Value, bool CreateDynamicMaterial);
	static void SetScalarParameterFromSlotName(class USkinnedMeshComponent* Mesh, const class FString& SlotName, class FName ParameterName, float Value, bool IsCaseCheck, bool CreateDynamicMaterial);
	static void SetTextureParameterAll(class UMeshComponent* Mesh, class FName ParameterName, class UTexture* Value, bool CreateDynamicMaterial);
	static void SetTextureParameterAllArray(class UMeshComponent* Mesh, const TArray<class FName>& ParameterName, const TArray<class UTexture*>& Value, bool CreateDynamicMaterial);
	static void SetVectorParameterAll(class UMeshComponent* Mesh, class FName ParameterName, const struct FLinearColor& Value, bool CreateDynamicMaterial);
	static void SetVectorParameterAllArray(class UMeshComponent* Mesh, const TArray<class FName>& ParameterName, const TArray<struct FLinearColor>& Value, bool CreateDynamicMaterial);
	static void SetVectorParameterArrayExcludeSlotName(class UMeshComponent* Mesh, class FName SlotName, bool IsCaseCheck, const TArray<class FName>& ParameterName, const TArray<struct FLinearColor>& Value, bool CreateDynamicMaterial);
	static void SetVectorParameterArrayFromIndexList(class UMeshComponent* Mesh, const TArray<int32>& MaterialSlotIndexList, const TArray<class FName>& ParameterName, const TArray<struct FLinearColor>& Value, bool CreateDynamicMaterial);
	static void SetVectorParameterArrayFromSlotName(class UMeshComponent* Mesh, class FName SlotName, bool IsCaseCheck, const TArray<class FName>& ParameterName, const TArray<struct FLinearColor>& Value, bool CreateDynamicMaterial);
	static void SetVisibleMaterial(class USkinnedMeshComponent* Mesh, int32 MaterialID, bool bShow, int32 LODIndex);
	static void SetVisibleMaterialAll(class USkinnedMeshComponent* Mesh, bool bShow);
	static void SetVisibleMaterialAllLODs(class USkinnedMeshComponent* Mesh, int32 MaterialID, bool bShow);
	static void SetVisibleMaterialAllLODsFromSlotName(class USkinnedMeshComponent* Mesh, const class FString& Name_0, bool bShow, bool IsCaseCheck);
	static void SetVisibleMaterialFromSlotName(class USkinnedMeshComponent* Mesh, const class FString& Name_0, bool bShow, int32 LODIndex, bool IsCaseCheck);
	static void ShrinkActorArray(const TArray<class AActor*>& InActors, TArray<class AActor*>* OutActors);
	static void WorldPhysicsIdling(class UObject* WorldContextObject, float IdlingSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSGeneralFuncLib">();
	}
	static class URSGeneralFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSGeneralFuncLib>();
	}
};
static_assert(alignof(URSGeneralFuncLib) == 0x000008, "Wrong alignment on URSGeneralFuncLib");
static_assert(sizeof(URSGeneralFuncLib) == 0x000028, "Wrong size on URSGeneralFuncLib");

// Class BattlePrototype.RSGoalActorBase
// 0x0000 (0x0230 - 0x0230)
class ARSGoalActorBase : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSGoalActorBase">();
	}
	static class ARSGoalActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSGoalActorBase>();
	}
};
static_assert(alignof(ARSGoalActorBase) == 0x000008, "Wrong alignment on ARSGoalActorBase");
static_assert(sizeof(ARSGoalActorBase) == 0x000230, "Wrong size on ARSGoalActorBase");

// Class BattlePrototype.RSHUDBase
// 0x0480 (0x07A0 - 0x0320)
class ARSHUDBase : public AHUD
{
public:
	uint8                                         Pad_320[0x30];                                     // 0x0320(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USoundAtomCue*>                  SEArray;                                           // 0x0350(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 M_pAtomComponentClass;                             // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 M_pUILetterBoxMaskClass;                           // 0x0368(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUILetterBoxMask*                       UILetterBoxMask;                                   // 0x0370(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 M_pUIFadeClass;                                    // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIFade*                                UIFadeArray[0x2];                                  // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 M_pUIGeneralChoiceClass;                           // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIGeneralChoice*                       UIGeneralChoice;                                   // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 M_pUISystemNoticeChoiceClass;                      // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIGeneralChoice*                       UISystemNoticeChoice;                              // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 M_pUITipsClass;                                    // 0x03B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUITips*                                UITips;                                            // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 M_pUISystemMessageClass;                           // 0x03C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIInfoWindow*                          UISystemMessage;                                   // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIActionIcon*>                  ActionIconArray;                                   // 0x03D0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          InitFlag;                                          // 0x03E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0x9];                                      // 0x03E1(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DebugDrawMessageFlag;                              // 0x03EA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EB[0x5];                                      // 0x03EB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 M_pUIMouseClass;                                   // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIMouse*                               UIMouse;                                           // 0x03F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 M_pUIScarletLogoClsss;                             // 0x0400(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIScarletLogo*                         M_pUIScarletLogo;                                  // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIBase*>                        ManageWidgetList;                                  // 0x0410(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentTickUnit;                                   // 0x0420(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUINoticeQuest*                         NoticeQuest;                                       // 0x0428(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUINoticeQuestReward*                   NoticeQuestReward;                                 // 0x0430(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_438[0x17C];                                    // 0x0438(0x017C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InputLevel;                                        // 0x05B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B8[0x30];                                     // 0x05B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIMenuBattleControl*                   HUD_battle_menu;                                   // 0x05E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESubMenuType                                  CurrentSubMenu;                                    // 0x05F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F1[0x1];                                      // 0x05F1(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	ERSGamepadLayoutType                          PrevInputManagerLayoutType;                        // 0x05F2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         PrevGameViewRenderLayer;                           // 0x05F3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StateSubMenu;                                      // 0x05F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           RestrictOpenMenuClaimantList;                      // 0x05F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           RestrictOpenTipsClaimantList;                      // 0x0608(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_618[0x18];                                     // 0x0618(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIDetailMap*                           WidgetDetailMap;                                   // 0x0630(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIWorldMap*                            WidgetWorldMap;                                    // 0x0638(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WorldMapStartParam;                                // 0x0640(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          WorldMapOpenFlag;                                  // 0x0644(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_645[0x3];                                      // 0x0645(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIShop*                                WidgetShop;                                        // 0x0648(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUICode*                                WidgetCode;                                        // 0x0650(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIMainContents*                        WidgetParty;                                       // 0x0658(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUISaveLoad*                            WidgetSaveLoad;                                    // 0x0660(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIPresent*                             WidgetPresent;                                     // 0x0668(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIPresentNext*                         WidgetPresentNext;                                 // 0x0670(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIAreaHere*                            WidgetAreaHere;                                    // 0x0678(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIAreaNext*                            WidgetAreaNext;                                    // 0x0680(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUICredit*                              WidgetCredit;                                      // 0x0688(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUITutoOperation*                       WidgetOperation;                                   // 0x0690(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIBrainTalk*                           WidgetBrainTalk;                                   // 0x0698(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A0[0x10];                                     // 0x06A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ActiveResurrectIconList;                           // 0x06B0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsTitleOutGame;                                    // 0x06C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C1[0x7];                                      // 0x06C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUIConfigBrightness>        M_pConfigClassBrightness;                          // 0x06C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIConfigChoice>            M_pConfigClassChoice;                              // 0x06D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIConfigController>        M_pConfigClassController;                          // 0x06D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIConfigSelect2>           M_pConfigClassSelect2;                             // 0x06E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIConfigSelect3>           M_pConfigClassSelect3;                             // 0x06E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIConfigSelect5>           M_pConfigClassSelect5;                             // 0x06F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIConfigSelectMulti>       M_pConfigClassSelectMulti;                         // 0x06F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIConfigSelectSlider>      M_pConfigClassSelectSlider;                        // 0x0700(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIBase>                    M_pTabClassParts4;                                 // 0x0708(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIBase>                    M_pTabClassParts5;                                 // 0x0710(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIBase>                    M_pTabClassParts6;                                 // 0x0718(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIConfigBrightness*                    M_pConfigBrightness;                               // 0x0720(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIConfigChoice*                        M_pConfigChoice;                                   // 0x0728(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIConfigController*                    M_pConfigController;                               // 0x0730(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIConfigSelect2*                       M_pConfigSelect2;                                  // 0x0738(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIConfigSelect3*                       M_pConfigSelect3;                                  // 0x0740(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIConfigSelect5*                       M_pSConfigelect5;                                  // 0x0748(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIConfigSelectMulti*                   M_pConfigSelectMulti;                              // 0x0750(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIConfigSelectSlider*                  M_pConfigSelectSlider;                             // 0x0758(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBase*                                M_pTabParts4;                                      // 0x0760(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBase*                                M_pTabParts5;                                      // 0x0768(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBase*                                M_pTabParts6;                                      // 0x0770(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_778[0x8];                                      // 0x0778(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             ReturnFromPartyMenu;                               // 0x0780(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_790[0x3];                                      // 0x0790(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DebugIsDrawInvalidationInfo;                       // 0x0793(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_794[0x4];                                      // 0x0794(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 M_pDebugDrawClass;                                 // 0x0798(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UUIActionIcon* AddActionIcon();
	bool CanPlayCutScene_FromNative(const bool IsTipsCheck);
	bool ChangeSoundState(ESoundState State);
	void ChangeStaffRollSpeed(float Speed);
	void CheckEndAllMessage(bool* IsEnd);
	bool CheckEndChoiceMessage();
	void CheckEndMessage(int32 MessageIndex, bool* IsEnd);
	void CheckInput(class UUIBase* Widget, EUIInputButton ButtonType, EUIInputType InputType, bool* IsInput);
	bool CheckSubQuestReward();
	int32 CheckSubQuestRewardResult();
	void CloseBrainTalkFromNative();
	bool CloseMessageGuide();
	bool CloseMinimap(bool Force);
	void CloseScarletLogo();
	bool CloseStartBondsQuest(class FName bondsQuestId);
	bool CloseStartSubQuest(class FName SubQuestID);
	void CloseSystemMessage();
	bool CloseTutoOperation();
	bool CloseTutoTips();
	void DEBUG_PRINT(const class FText& Message, float PosX, float PosY, const struct FLinearColor& Color, const struct FVector2D& Scale);
	void DebugChangeVisible(bool Visibleflag);
	void DebugDrawInvalidationWidget();
	int32 DrawChoiceMessage(int32 ChoiceNum, const class FString& Choice0, const class FString& Choice1, const class FString& Choice2, const class FString& Choice3, const class FString& Choice4, int32 DefaultIndex, int32 CancelIndex, float DrawSecond, bool IsEnableCancel);
	int32 DrawMessage(const class FString& Talker, const class FString& Message, int32 WindowType, float DrawSecond, bool IsEnableSkip, class URSAtomComponentBase* Voice, bool IsSkipVoiceEnd);
	bool EndMinimapBrainField();
	void EndStaffRoll();
	void EndSubMenu();
	void FadeIn(bool IsUnderCaption, float Second);
	void FadeInBlack(bool IsUnderCaption, float Second);
	void FadeInDefineColor(EUIFadeColorType Color, bool IsUnderCaption, float Second);
	void FadeInFreeColor(const struct FLinearColor& Color, bool IsUnderCaption, float Second);
	void FadeInWhite(bool IsUnderCaption, float Second);
	void FadeOutBlack(bool IsUnderCaption, float Second);
	void FadeOutDefineColor(EUIFadeColorType Color, bool IsUnderCaption, float Second);
	void FadeOutFreeColor(const struct FLinearColor& Color, bool IsUnderCaption, float Second);
	void FadeOutWhite(bool IsUnderCaption, float Second);
	void ForceEndGeneralChoice();
	struct FVector2D GetAnalogStickL(class UUIBase* Widget);
	struct FVector2D GetAnalogStickR(class UUIBase* Widget);
	void GetChoiceResult(int32 MessageIndex, int32* Result);
	bool GetDebugDispUserTag();
	class FString GetDebugMinimapAreaSetting();
	bool GetDebugMinimapCreateMapDisable();
	bool GetDebugMinimapIconEnemyTickDisable();
	bool GetDebugMinimapIconFootTickDisable();
	bool GetDebugMinimapIconNpcTickDisable();
	bool GetDebugMinimapIconTickDisable();
	bool GetDebugMinimapIconUpdateAdjust();
	bool GetDebugMinimapMaterialTickDisable();
	bool GetDebugMinimapTickDisable();
	bool GetDebugMinimapTraceTickDisable();
	int32 GetDebugSaveLoadMenuSetting();
	struct FVector2D GetDebugViewportSize();
	bool GetEnablePartyMenu();
	int32 GetGeneralChoiceResult();
	int32 GetInputLevel();
	void GetLastChoiceResult(int32* Result);
	class URSAtomComponentBase* GetMessageVoice();
	bool GetMouseDispIcon();
	bool GetMouseDispRectangle();
	bool GetOverlapEventInvalidFlag();
	bool GetReserveShopMenu();
	bool Init();
	void InitCreateScarletLogo();
	void InitFade();
	void InitMouseCursor();
	bool IsBrainTalkFinishedWait();
	bool IsCancelGeneralChoice();
	bool IsCurrentMessageWithChoices();
	bool IsCurrentMessageWithVoice();
	bool IsCustomTimeDilationAccelerate(float* CurrentCustomTimeDilation);
	bool IsEnableOpenMenu();
	bool IsEnableOpenTips();
	bool IsEndGameOverFromNative();
	bool IsEndGeneralChoice();
	bool IsEndStaffRoll();
	bool IsEndSubMenu(ESubMenuType SubMenuType);
	bool IsEndSystemMessage();
	bool IsEventFinishWaitMode_AfterCounter();
	bool IsFoucusMouse();
	void IsFoundCustomTimeDilationRegistName_FromNative(const class FString& RegistName, bool* IsFound, float* CurrentCustomTimeDilation);
	bool IslockInputSubMenu();
	bool IsOpenLoadingUI();
	bool IsOpenSubMenu();
	bool IsOutGameHudMain();
	bool IsPlayBrainTuto();
	bool IsSavedSaveLoadMenu();
	bool IsSavedSaveLoadMenuError();
	bool IsTutoOperation();
	bool IsTutoTips();
	bool IsValidMessageVoiceToMessageBuffer();
	void LoadResidentWidget();
	void LockInputSubMenu();
	float MiniTipsStartDraw(EHelpTutorial TipsID);
	bool MiniTipsStopDraw(EHelpTutorial TipsID);
	bool MiniTipsSuccessStartDraw();
	bool MiniTipsSuccessStopDraw();
	bool NextBrainTalkMessage(const int32 Index_0);
	void OnAvoid();
	void OnInitialized();
	bool OnTitleBack();
	void OpenBrainTalkFromNative(const int32 CharacterId, const int32 ExpressionID, const class FString& MessageID, const float DrawSecond);
	bool OpenBrainTuto();
	bool OpenMinimap(bool Force);
	void OpenScarletLogo();
	bool OpenStartBondsQuest(class FName bondsQuestId);
	bool OpenStartSubQuest(class FName SubQuestID);
	void OpenSystemMessage(const class FString& SystemMessage, bool IsWarning, bool IsGuide, bool IsFade);
	void OpenWorldMap();
	void PauseBrainTalkForEventFromNative(const bool IsPause);
	void PauseTutoOperation();
	bool PlayDecideAnimeBrainTuto();
	bool ProcBattleMenu();
	bool RemoveActionIcon(class UUIActionIcon* ActionIcon);
	void RemoveCustomTimeDilation_FromNative(const class FString& Name_0);
	void RemoveDiscoverIndexList(int32 Index_0);
	void RemoveFromManageWidget(class UUIBase* Widget);
	void ResetCustomTimeDilationAccelerateInValidSettings();
	void ResetWeaponMenuDefaultCursor();
	void RestrictOpenMenu(bool bRestrict, class FName ClaimantName);
	void RestrictOpenTips(bool bRestrict, class FName ClaimantName);
	void ResumeTutoOperation();
	void SasSetChangePageReady(bool ReadyFlagL, bool ReadyFlagR);
	void SetBPFoucusMouse();
	void SetBPUnFoucusMouse();
	void SetBrainMapCursorCorrectArea(float Area);
	void SetBrainMapCursorCorrectSpeed(float Speed);
	void SetBrainMapCursorSpeed(float Speed);
	void SetBrainMessageDefaultThread(class FName ThreadTitle);
	void SetCustomTimeDilation_FromNative(const class FString& Name_0, float CurrentCustomTimeDilation);
	void SetDebugDispUserTag(bool Dispflag);
	void SetDebugKeyboard(bool IsEnable);
	void SetDebugMinimapAreaSetting(const class FString& SettingAreaName);
	void SetDebugSaveLoadMenuSetting(int32 SettingIndex);
	void SetDebugWorldmapUnlockFlag(bool UnlockFlag);
	void SetEnablePartyMenu(bool EnableFlag);
	void SetGuideVisibleSysMess(bool IsGuide);
	bool SetLogBrainFieldAddTime();
	bool SetLogGetItem(const class FString& ItemName, int32 ItemNum);
	bool SetLogGetMoneyFromNative(int32 GetMoney);
	bool SetLogItemOverFlow(const class FString& ItemName);
	bool SetLogUpdateGoal();
	void SetMouseCursorShow(bool Showflag, bool Foceshow);
	void SetMouseCursorUse(bool Useflag);
	void SetMouseDispIcon(bool Icondisp);
	void SetMouseDispRectangle(bool Dispflag);
	void SetMouseEnableMainTab(bool Flag);
	void SetOpenBrainMessage();
	void SetOpenDetailMap();
	void SetOpenMainMenu();
	void SetOpenWorldMap();
	void SetOutGame(bool IsOutGame);
	void SetOverlapEventInvalidFlag(bool Enable);
	void SetPartyMenuViewerMode(bool IsViewerMode);
	void SetPlayBattleUI(bool FlagPlay);
	void SetReserveShopMenu(bool IsReserve);
	void SetTDebugInvisibleAll(bool IsInvisible);
	void SetVisibleActionUI(bool FlagVisible);
	void SetWeaponMenuDefaultCursor(EPlayerID CharaID, bool IsVisual);
	bool SkipMessage();
	bool StartAreaHere(int32 LocationId, int32 AreaId, int32 PortalID);
	bool StartAreaNext(int32 LocationId, int32 AreaId, int32 PortalID, bool IsWorldMap);
	bool StartAutoSaveIcon();
	void StartBossName(const class FString& bossId, EBossNameMode Mode, float FreeFixedDrawSecond);
	void StartBrainMessageMenu(bool IsAutoMode);
	bool StartCharaName(const class FString& CharaID);
	bool StartCode();
	void StartEventFinishWaitMode_AfterCounter();
	void StartGeneralChoice1(const class FString& TextMain, const class FString& TextIndex, bool Cancelable, int32 CancelIndex, bool IsFade);
	void StartGeneralChoice2(const class FString& TextMain, int32 DefaultIndex, const class FString& TextIndex1, const class FString& TextIndex2, bool Cancelable, int32 CancelIndex, bool IsFade);
	void StartGeneralChoice3(const class FString& TextMain, int32 DefaultIndex, const class FString& TextIndex1, const class FString& TextIndex2, const class FString& TextIndex3, bool Cancelable, int32 CancelIndex, bool IsFade);
	void StartGeneralChoice4(const class FString& TextMain, int32 DefaultIndex, const class FString& TextIndex1, const class FString& TextIndex2, const class FString& TextIndex3, const class FString& TextIndex4, bool Cancelable, int32 CancelIndex, bool IsFade);
	bool StartKeyword();
	bool StartMessageGuide(bool FlagSkip, bool FlagDecide, bool FlagCancel);
	bool StartMinimapBrainField();
	bool StartSasWindowNative(EPlayerID Target);
	void StartStaffRoll(float Speed);
	void StartSubMenu(ESubMenuType SubMenuType, int32 Parameter, int32 Parameter2);
	bool StartSubQuestReward(class FName SubQuestID);
	bool StartTownName(int32 LocationId);
	bool StartTutoOperation(class FName HelpTutoID);
	bool StartTutoTips(EHelpTutorial TutoID, bool NotPauseControll, bool NotCloseOfPause, bool IsFade);
	bool StopAutoSaveIcon();
	void StopBrainTalkVoiceFromNative();
	void TDebugDrawWidgetLayout();
	void UnloadResidentWidget();
	void UnLockInputSubMenu();
	bool UpdateItemMenuUI();

	float GetBrainMapCursorCorrectArea() const;
	float GetBrainMapCursorCorrectSpeed() const;
	float GetBrainMapCursorSpeed() const;
	class UClass* GetDebugDrawClass() const;
	bool GetDebugKeyboard() const;
	bool GetDebugWorldmapUnlockFlag() const;
	EInputDeviceType GetIconDeviceType() const;
	class FName GetResultCode() const;
	class FString GetResultKeyword() const;
	bool IsBattleMenuInitialized() const;
	bool IsBrainField() const;
	bool IsCanceledCode() const;
	bool IsCancelKeyword() const;
	bool IsChangedIconDeviceType() const;
	bool IsDrawMessageGuide() const;
	bool IsDrawMiniTipsSuccess() const;
	bool IsEndCode() const;
	bool IsEndKeyword() const;
	bool IsFade() const;
	bool IsFadeAnimation() const;
	bool IsLogMessageEmpty() const;
	bool IsPartyMenuViewerMode() const;
	bool IsPlayMessageOpenAnimationNative() const;
	bool IsPlaySasWindowNative() const;
	bool IsTDebugInvisibleAll() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSHUDBase">();
	}
	static class ARSHUDBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSHUDBase>();
	}
};
static_assert(alignof(ARSHUDBase) == 0x000008, "Wrong alignment on ARSHUDBase");
static_assert(sizeof(ARSHUDBase) == 0x0007A0, "Wrong size on ARSHUDBase");
static_assert(offsetof(ARSHUDBase, SEArray) == 0x000350, "Member 'ARSHUDBase::SEArray' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pAtomComponentClass) == 0x000360, "Member 'ARSHUDBase::M_pAtomComponentClass' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pUILetterBoxMaskClass) == 0x000368, "Member 'ARSHUDBase::M_pUILetterBoxMaskClass' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, UILetterBoxMask) == 0x000370, "Member 'ARSHUDBase::UILetterBoxMask' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pUIFadeClass) == 0x000378, "Member 'ARSHUDBase::M_pUIFadeClass' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, UIFadeArray) == 0x000380, "Member 'ARSHUDBase::UIFadeArray' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pUIGeneralChoiceClass) == 0x000390, "Member 'ARSHUDBase::M_pUIGeneralChoiceClass' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, UIGeneralChoice) == 0x000398, "Member 'ARSHUDBase::UIGeneralChoice' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pUISystemNoticeChoiceClass) == 0x0003A0, "Member 'ARSHUDBase::M_pUISystemNoticeChoiceClass' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, UISystemNoticeChoice) == 0x0003A8, "Member 'ARSHUDBase::UISystemNoticeChoice' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pUITipsClass) == 0x0003B0, "Member 'ARSHUDBase::M_pUITipsClass' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, UITips) == 0x0003B8, "Member 'ARSHUDBase::UITips' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pUISystemMessageClass) == 0x0003C0, "Member 'ARSHUDBase::M_pUISystemMessageClass' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, UISystemMessage) == 0x0003C8, "Member 'ARSHUDBase::UISystemMessage' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, ActionIconArray) == 0x0003D0, "Member 'ARSHUDBase::ActionIconArray' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, InitFlag) == 0x0003E0, "Member 'ARSHUDBase::InitFlag' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, DebugDrawMessageFlag) == 0x0003EA, "Member 'ARSHUDBase::DebugDrawMessageFlag' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pUIMouseClass) == 0x0003F0, "Member 'ARSHUDBase::M_pUIMouseClass' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, UIMouse) == 0x0003F8, "Member 'ARSHUDBase::UIMouse' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pUIScarletLogoClsss) == 0x000400, "Member 'ARSHUDBase::M_pUIScarletLogoClsss' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pUIScarletLogo) == 0x000408, "Member 'ARSHUDBase::M_pUIScarletLogo' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, ManageWidgetList) == 0x000410, "Member 'ARSHUDBase::ManageWidgetList' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, CurrentTickUnit) == 0x000420, "Member 'ARSHUDBase::CurrentTickUnit' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, NoticeQuest) == 0x000428, "Member 'ARSHUDBase::NoticeQuest' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, NoticeQuestReward) == 0x000430, "Member 'ARSHUDBase::NoticeQuestReward' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, InputLevel) == 0x0005B4, "Member 'ARSHUDBase::InputLevel' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, HUD_battle_menu) == 0x0005E8, "Member 'ARSHUDBase::HUD_battle_menu' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, CurrentSubMenu) == 0x0005F0, "Member 'ARSHUDBase::CurrentSubMenu' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, PrevInputManagerLayoutType) == 0x0005F2, "Member 'ARSHUDBase::PrevInputManagerLayoutType' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, PrevGameViewRenderLayer) == 0x0005F3, "Member 'ARSHUDBase::PrevGameViewRenderLayer' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, StateSubMenu) == 0x0005F4, "Member 'ARSHUDBase::StateSubMenu' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, RestrictOpenMenuClaimantList) == 0x0005F8, "Member 'ARSHUDBase::RestrictOpenMenuClaimantList' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, RestrictOpenTipsClaimantList) == 0x000608, "Member 'ARSHUDBase::RestrictOpenTipsClaimantList' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetDetailMap) == 0x000630, "Member 'ARSHUDBase::WidgetDetailMap' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetWorldMap) == 0x000638, "Member 'ARSHUDBase::WidgetWorldMap' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WorldMapStartParam) == 0x000640, "Member 'ARSHUDBase::WorldMapStartParam' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WorldMapOpenFlag) == 0x000644, "Member 'ARSHUDBase::WorldMapOpenFlag' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetShop) == 0x000648, "Member 'ARSHUDBase::WidgetShop' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetCode) == 0x000650, "Member 'ARSHUDBase::WidgetCode' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetParty) == 0x000658, "Member 'ARSHUDBase::WidgetParty' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetSaveLoad) == 0x000660, "Member 'ARSHUDBase::WidgetSaveLoad' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetPresent) == 0x000668, "Member 'ARSHUDBase::WidgetPresent' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetPresentNext) == 0x000670, "Member 'ARSHUDBase::WidgetPresentNext' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetAreaHere) == 0x000678, "Member 'ARSHUDBase::WidgetAreaHere' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetAreaNext) == 0x000680, "Member 'ARSHUDBase::WidgetAreaNext' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetCredit) == 0x000688, "Member 'ARSHUDBase::WidgetCredit' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetOperation) == 0x000690, "Member 'ARSHUDBase::WidgetOperation' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetBrainTalk) == 0x000698, "Member 'ARSHUDBase::WidgetBrainTalk' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, ActiveResurrectIconList) == 0x0006B0, "Member 'ARSHUDBase::ActiveResurrectIconList' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, IsTitleOutGame) == 0x0006C0, "Member 'ARSHUDBase::IsTitleOutGame' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigClassBrightness) == 0x0006C8, "Member 'ARSHUDBase::M_pConfigClassBrightness' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigClassChoice) == 0x0006D0, "Member 'ARSHUDBase::M_pConfigClassChoice' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigClassController) == 0x0006D8, "Member 'ARSHUDBase::M_pConfigClassController' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigClassSelect2) == 0x0006E0, "Member 'ARSHUDBase::M_pConfigClassSelect2' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigClassSelect3) == 0x0006E8, "Member 'ARSHUDBase::M_pConfigClassSelect3' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigClassSelect5) == 0x0006F0, "Member 'ARSHUDBase::M_pConfigClassSelect5' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigClassSelectMulti) == 0x0006F8, "Member 'ARSHUDBase::M_pConfigClassSelectMulti' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigClassSelectSlider) == 0x000700, "Member 'ARSHUDBase::M_pConfigClassSelectSlider' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pTabClassParts4) == 0x000708, "Member 'ARSHUDBase::M_pTabClassParts4' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pTabClassParts5) == 0x000710, "Member 'ARSHUDBase::M_pTabClassParts5' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pTabClassParts6) == 0x000718, "Member 'ARSHUDBase::M_pTabClassParts6' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigBrightness) == 0x000720, "Member 'ARSHUDBase::M_pConfigBrightness' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigChoice) == 0x000728, "Member 'ARSHUDBase::M_pConfigChoice' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigController) == 0x000730, "Member 'ARSHUDBase::M_pConfigController' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigSelect2) == 0x000738, "Member 'ARSHUDBase::M_pConfigSelect2' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigSelect3) == 0x000740, "Member 'ARSHUDBase::M_pConfigSelect3' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pSConfigelect5) == 0x000748, "Member 'ARSHUDBase::M_pSConfigelect5' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigSelectMulti) == 0x000750, "Member 'ARSHUDBase::M_pConfigSelectMulti' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigSelectSlider) == 0x000758, "Member 'ARSHUDBase::M_pConfigSelectSlider' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pTabParts4) == 0x000760, "Member 'ARSHUDBase::M_pTabParts4' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pTabParts5) == 0x000768, "Member 'ARSHUDBase::M_pTabParts5' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pTabParts6) == 0x000770, "Member 'ARSHUDBase::M_pTabParts6' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, ReturnFromPartyMenu) == 0x000780, "Member 'ARSHUDBase::ReturnFromPartyMenu' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, DebugIsDrawInvalidationInfo) == 0x000793, "Member 'ARSHUDBase::DebugIsDrawInvalidationInfo' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pDebugDrawClass) == 0x000798, "Member 'ARSHUDBase::M_pDebugDrawClass' has a wrong offset!");

// Class BattlePrototype.RSInGameFlow
// 0x0018 (0x0248 - 0x0230)
class ARSInGameFlow final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URSGameInstance*                        _gameInstance;                                     // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInGameFlowType                               _currentType;                                      // 0x0240(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize(class URSGameInstance* GameInst);
	void SetCurrentFlowType(EInGameFlowType Type);

	EInGameFlowType GetCurrentFlowType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSInGameFlow">();
	}
	static class ARSInGameFlow* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSInGameFlow>();
	}
};
static_assert(alignof(ARSInGameFlow) == 0x000008, "Wrong alignment on ARSInGameFlow");
static_assert(sizeof(ARSInGameFlow) == 0x000248, "Wrong size on ARSInGameFlow");
static_assert(offsetof(ARSInGameFlow, _gameInstance) == 0x000238, "Member 'ARSInGameFlow::_gameInstance' has a wrong offset!");
static_assert(offsetof(ARSInGameFlow, _currentType) == 0x000240, "Member 'ARSInGameFlow::_currentType' has a wrong offset!");

// Class BattlePrototype.InputManager
// 0x0288 (0x04B8 - 0x0230)
class AInputManager : public ARSActorSystemBase
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ERSGamepadLayoutType                          CurrentLayout;                                     // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThresholdStickAnalogToDigital;                     // 0x023C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCrossButtonDecide;                               // 0x0240(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             KeyboardPressEvent;                                // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             KeyboardReleasedEvent;                             // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ChangeInputTypeEvent;                              // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ChangeInputTypeWithMouseEvent;                     // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_288[0x18];                                     // 0x0288(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeltaMouseX;                                       // 0x02A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaMouseY;                                       // 0x02A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMouseControll;                                    // 0x02A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreMouseControll;                                 // 0x02A9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA[0x2];                                      // 0x02AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RawRStickX;                                        // 0x02AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RawRStickY;                                        // 0x02B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x204];                                    // 0x02B4(0x0204)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DetectionDeltaMouseMove(float XPos, float YPos);
	void Finalize();
	float GetAxisValue(ERSGamepadLayoutType Layout, ERSGamepadInputName Pad);
	ERSGamepadLayoutType GetCurrentLayoutType();
	class URSGamepadLayout* GetGamepadLayout(const ERSGamepadLayoutType Layout);
	EInputDeviceType GetInputDeviceType();
	struct FVector2D GetMouseMove();
	float GetMouseWheelAxisValue(ERSGamepadLayoutType Layout, ERSGamepadInputName Pad);
	bool GetOnPress(ERSGamepadLayoutType Layout, ERSGamepadInputName Pad);
	bool GetOnRepeatTrigger(ERSGamepadLayoutType Layout, ERSGamepadInputName Pad);
	bool GetOnTrigger(ERSGamepadLayoutType Layout, ERSGamepadInputName Pad);
	void GetRightStickAxisRawValue(float* RStickX, float* RStickY);
	bool GetUseKey(const ERSGamepadInputName InputName, ERSInputDeviceType* UseKey, ERSGamepadInputName* PadInputName, class FName* KeyInputName);
	class FString GetVirtualKeyboardText();
	void Initialize();
	bool IsDInput(const ERSGamepadInputName InputName);
	bool IsMouseInputRightStick();
	void IsScreenOutMouse(bool IsOut);
	bool IsSteamInBigPictureMode();
	void MouseCursorOnOff();
	void OnConfigedAxisAction(const ERSGamepadInputName Pad, float Value);
	void OnConfigedKeyboardAction(const struct FKey& Key, bool IsPress);
	void OnConfigedPadAction(const ERSGamepadInputName Pad, bool IsPress, bool IsDInput);
	void OnConfigedPadActionAndKey(const ERSGamepadInputName Pad, bool IsPress, const struct FKey& Key);
	void OnInputAxisAction(const float Value, const ERSGamepadInputName Pad);
	void OnInputMouseAxisAction(const float Value, const ERSGamepadInputName Pad);
	void OnMouseInputConvertAction(const struct FKey& Key, bool Actflag);
	void OnPressAction(const ERSGamepadInputName Pad);
	void OnReleaseAction(const ERSGamepadInputName Pad);
	void ResetCurrentLayout();
	void SetCurrentLayoutType(const ERSGamepadLayoutType Layout);
	void SetDeltaMouseMoveRaw(float XDelta, float YDelta);
	void SetDisableChangeInputModeFlag(bool Flg);
	bool ShowVirtualKeyboard(const class FString& Text, const class FString& HintText, int32 KeyboardType);
	void StopSimpleController();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputManager">();
	}
	static class AInputManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInputManager>();
	}
};
static_assert(alignof(AInputManager) == 0x000008, "Wrong alignment on AInputManager");
static_assert(sizeof(AInputManager) == 0x0004B8, "Wrong size on AInputManager");
static_assert(offsetof(AInputManager, CurrentLayout) == 0x000238, "Member 'AInputManager::CurrentLayout' has a wrong offset!");
static_assert(offsetof(AInputManager, ThresholdStickAnalogToDigital) == 0x00023C, "Member 'AInputManager::ThresholdStickAnalogToDigital' has a wrong offset!");
static_assert(offsetof(AInputManager, IsCrossButtonDecide) == 0x000240, "Member 'AInputManager::IsCrossButtonDecide' has a wrong offset!");
static_assert(offsetof(AInputManager, KeyboardPressEvent) == 0x000248, "Member 'AInputManager::KeyboardPressEvent' has a wrong offset!");
static_assert(offsetof(AInputManager, KeyboardReleasedEvent) == 0x000258, "Member 'AInputManager::KeyboardReleasedEvent' has a wrong offset!");
static_assert(offsetof(AInputManager, ChangeInputTypeEvent) == 0x000268, "Member 'AInputManager::ChangeInputTypeEvent' has a wrong offset!");
static_assert(offsetof(AInputManager, ChangeInputTypeWithMouseEvent) == 0x000278, "Member 'AInputManager::ChangeInputTypeWithMouseEvent' has a wrong offset!");
static_assert(offsetof(AInputManager, DeltaMouseX) == 0x0002A0, "Member 'AInputManager::DeltaMouseX' has a wrong offset!");
static_assert(offsetof(AInputManager, DeltaMouseY) == 0x0002A4, "Member 'AInputManager::DeltaMouseY' has a wrong offset!");
static_assert(offsetof(AInputManager, bMouseControll) == 0x0002A8, "Member 'AInputManager::bMouseControll' has a wrong offset!");
static_assert(offsetof(AInputManager, bPreMouseControll) == 0x0002A9, "Member 'AInputManager::bPreMouseControll' has a wrong offset!");
static_assert(offsetof(AInputManager, RawRStickX) == 0x0002AC, "Member 'AInputManager::RawRStickX' has a wrong offset!");
static_assert(offsetof(AInputManager, RawRStickY) == 0x0002B0, "Member 'AInputManager::RawRStickY' has a wrong offset!");

// Class BattlePrototype.RSLevelSequenceActor
// 0x0000 (0x02C0 - 0x02C0)
class ARSLevelSequenceActor final : public ALevelSequenceActor
{
public:
	void AddSpawnableTemplateTag(const TArray<class FName>& AddTags);
	void ChangeForceOwnerShipExternal(const TArray<class FText>& ObjNames);
	void ChangeForceOwnerShipExternalFromBinding(const TArray<struct FMovieSceneObjectBindingID>& ObjBindings);
	void ChangeForceOwnerShipExternalFromTagNames(const TArray<class FName>& TagNames);
	void ChangeForceOwnerShipInnerSequence(const TArray<class FText>& ObjNames);
	void ChangeForceOwnerShipInnerSequenceALL();
	void ChangeForceOwnerShipInnerSequenceFromBinding(const TArray<struct FMovieSceneObjectBindingID>& ObjBindings);
	void ChangeForceOwnerShipInnerSequenceFromTagNames(const TArray<class FName>& TagNames);
	void ForceUpdate(float DeltaTime);
	TArray<class AActor*> GetSequenceInSpawnedActorList();
	TArray<class AActor*> GetSequenceInSpawnedActorListFromClass(TSubclassOf<class AActor> ObjClass);
	void GetSequenceInSpawnedObjectList(TArray<class UObject*>* SpawnedObjects);
	struct FMovieSceneObjectBindingID GetSequenceObjectBindingID(const class FText& ObjName, const TArray<class FName>& ObjTags, bool* IsFind);
	void GetSequenceObjectBindingIDList(const TArray<class FText>& ObjNames, const TArray<class FName>& ObjTags, TArray<struct FMovieSceneObjectBindingID>* OutBindingIDList, bool* IsFind);
	void GetSequenceObjectBindingIDListFromClass(TSubclassOf<class AActor> ObjClass, TArray<struct FMovieSceneObjectBindingID>* OutBindingIDList, TArray<class FString>* OutNameList, bool* IsFind);
	void GetSequenceObjectBindingIDListFromClassAndMatchTexts(TSubclassOf<class AActor> ObjClass, const TArray<class FText>& PerfectMatchTexts, const TArray<class FText>& SuffixTexts, TArray<struct FMovieSceneObjectBindingID>* OutMatchBindingIDList, TArray<class FString>* OutMatchNameList, bool* IsFind);
	void RemoveIsActiveSectionForShotName(const class FText& ShotName);
	void RestartParticle(const TArray<struct FMovieSceneObjectBindingID>& BindingIDList, const TArray<class ASequencerParticle*>& ParticleList);
	void SetActiveCameraCutSection(bool IsActive);
	int32 SetActiveFromShotName(const class FText& ShotName, bool IsActive, bool IsContainName);
	void SetAnimationSlotNameToInString(class FName SlotName, const class FString& InString, const class FString& ExclusionInString);
	void SetBindingByObject(const struct FMovieSceneObjectBindingID& Binding, const TArray<class UObject*>& Objects, bool bAllowBindingsFromAsset);
	float SetEventSkipEndTimeForEventName(class FName SkipName, class FName EventName, bool* IsSuccess);
	void SetPlaybackHead();
	void SetShotSequence(class UMovieSceneSequence* Sequence, const class FText& ShotName);
	void SetupParticleBinding(const TArray<struct FMovieSceneObjectBindingID>& BindingIDList, const TArray<class ASequencerParticle*>& ParticleList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSLevelSequenceActor">();
	}
	static class ARSLevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSLevelSequenceActor>();
	}
};
static_assert(alignof(ARSLevelSequenceActor) == 0x000008, "Wrong alignment on ARSLevelSequenceActor");
static_assert(sizeof(ARSLevelSequenceActor) == 0x0002C0, "Wrong size on ARSLevelSequenceActor");

// Class BattlePrototype.RSManaComponent
// 0x0000 (0x0250 - 0x0250)
class URSManaComponent final : public UManaComponent
{
public:
	void StopMovie();

	bool IsInitialized() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSManaComponent">();
	}
	static class URSManaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSManaComponent>();
	}
};
static_assert(alignof(URSManaComponent) == 0x000008, "Wrong alignment on URSManaComponent");
static_assert(sizeof(URSManaComponent) == 0x000250, "Wrong size on URSManaComponent");

// Class BattlePrototype.RSMaterialLibrary
// 0x0000 (0x0028 - 0x0028)
class URSMaterialLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ChangeCharacterMaterial(class UMeshComponent* MeshComp, class UMaterialInterface* BodyMat, class UMaterialInterface* BodyLUTMat, class UMaterialInterface* EyeMat, class UMaterialInterface* EyeLUTMat, class UMaterialInterface* HairMat, class UMaterialInterface* HairLUTMat, class UMaterialInterface* SkinMat, class UMaterialInterface* SkinLUTMat, class UMaterialInterface* OutlineMat, class UMaterialInterface* OutlineLUTMat, class UMaterialInterface* MaskMat, class UMaterialInterface* MaskLUTMat, class UMaterialInterface* Wire0Mat, class UMaterialInterface* Wire1Mat, class UMaterialInterface* HologramMat, class UMaterialInterface* OtherMat, class UMaterialInterface* OtherLUTMat, const TArray<class UMaterialInterface*>& BaseLUTMaterials);
	static void ClearOverrideMaterials(class UMeshComponent* Mesh);
	static void CopyNeonWireDepthParameterNative(class UObject* WorldContextObject, int32 WireMaterialIndex, class USkeletalMeshComponent* WireDepthComp, class UMaterialInstanceDynamic* WireMaterial, class USkeletalMeshComponent* TargetMeshComp);
	static class UMaterialInstanceDynamic* CopyNeonWireDepthParameterNative2(class UObject* WorldContextObject, int32 WireMaterialIndex, class USkeletalMeshComponent* WireDepthComp, class UMaterialInstanceDynamic* WireMaterial, class USkeletalMeshComponent* TargetMeshComp, class UMaterialInterface* HologramWireMaterial, class UMaterialInterface* WireDepthMaterial, class UMaterialInterface* HologramWireDepthMaterial);
	static void DumpMaterialParameterCollection(class UObject* WorldContextObject, class UObject* Collection);
	static void EnableMaterialPreSkinFacialNormalNative(class UObject* WorldContextObject, class USkeletalMeshComponent* SkelMeshComp, bool bEnabled, bool bIsEvent);
	static void EnableMaterialPreSkinFacialNormalNPCNative(class UObject* WorldContextObject, class ANpcSkeletalMeshActor* NPCActor, bool bEnabled, bool bIsEvent);
	static bool GetDefaultScalarParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName, float* ParameterValue);
	static bool GetDefaultVectorParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName, struct FLinearColor* ParameterValue);
	static class UMaterialInterface* GetMaterialFromPath(const class FString& Path, bool Load);
	static bool GetMaterialInstanceAllScalarParameterInfo(class UMaterialInstance* MaterialInstance, TArray<struct FMaterialParameterInfo>* Info);
	static bool GetMaterialInstanceAllVectorParameterInfo(class UMaterialInstance* MaterialInstance, TArray<struct FMaterialParameterInfo>* Info);
	static bool GetMaterialInstanceParameterGroupName(class UMaterialInstance* MaterialInstance, const struct FMaterialParameterInfo& ParameterInfo, class FName* OutGroup);
	static void GetMaterialOverrideParameters(class UMaterialInstance* MaterialInstance, struct FMaterialOverrideParameters* OutParam);
	static void GetMaterialOverrideParametersALLHierarchy(class UMaterialInstance* MaterialInstance, struct FMaterialOverrideParameters* OutParam);
	static bool GetMaterialStaticSwitch(class UMaterialInterface* Material, const class FName& ParameterName, bool& StaticSwitch);
	static void GetMeshMaterialOverrideParameters(class UMeshComponent* Mesh, struct FMeshMaterialOverrideParameters* OutParam);
	static bool GetRsScalarParameterValue(class UMaterialInstance* MaterialInstance, const class FName& ParameterName, float* OutValue);
	static bool GetRsTextureParameterValue(class UMaterialInstance* MaterialInstance, const class FName& ParameterName, class UTexture2D** OutValue);
	static bool GetRsVectorParameterValue(class UMaterialInstance* MaterialInstance, const class FName& ParameterName, struct FLinearColor* OutValue);
	static bool GetScalarParameterByIndex(class UMaterialInstanceDynamic* DynamicMaterial, int32 ParameterIndex, float* OutValue);
	static bool GetScalarParameterIndex(class UMaterialInstanceDynamic* DynamicMaterial, const class FName& ParameterName, int32* OutParameterIndex);
	static bool GetVectorParameterByIndex(class UMaterialInstanceDynamic* DynamicMaterial, int32 ParameterIndex, struct FLinearColor* OutValue);
	static bool GetVectorParameterIndex(class UMaterialInstanceDynamic* DynamicMaterial, const class FName& ParameterName, int32* OutParameterIndex);
	static void ResetMIDScalarParameterValue(const TArray<class UMeshComponent*>& MeshComps, const TArray<class FName>& ParameterNames);
	static void ResetMIDScalarParameterValueFromDefault(const TArray<class UMeshComponent*>& MeshComps, const TArray<class FName>& ParameterNames);
	static void SetMaterialOverrideParameters(class UMaterialInstanceDynamic* MaterialInstanceDynamic, const struct FMaterialOverrideParameters& OutParam, bool ClearParam);
	static void SetMeshMaterialOverrideParameters(class UMeshComponent* Mesh, const struct FMeshMaterialOverrideParameters& OverrideParam, bool ClearParam);
	static bool SetScalarParameterByIndex(class UMaterialInstanceDynamic* DynamicMaterial, int32 ParameterIndex, float Value);
	static bool SetVectorParameterByIndex(class UMaterialInstanceDynamic* DynamicMaterial, int32 ParameterIndex, const struct FLinearColor& Value);
	static void UpdateMaterialPreSkinFacialNormalToSlotsNative(class UObject* WorldContextObject, class USkeletalMeshComponent* SkelMeshComp, bool bIsEvent, const TArray<int32>& MaterialSlots);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSMaterialLibrary">();
	}
	static class URSMaterialLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSMaterialLibrary>();
	}
};
static_assert(alignof(URSMaterialLibrary) == 0x000008, "Wrong alignment on URSMaterialLibrary");
static_assert(sizeof(URSMaterialLibrary) == 0x000028, "Wrong size on URSMaterialLibrary");

// Class BattlePrototype.RSMaterialStaticMeshComponent
// 0x0000 (0x04A0 - 0x04A0)
class URSMaterialStaticMeshComponent final : public UStaticMeshComponent
{
public:
	void SetMaterialMeshScalar(class FName ParameterName, float Value);
	void SetMaterialMeshVector(class FName ParameterName, const struct FLinearColor& Value);
	void SetupMaterial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSMaterialStaticMeshComponent">();
	}
	static class URSMaterialStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSMaterialStaticMeshComponent>();
	}
};
static_assert(alignof(URSMaterialStaticMeshComponent) == 0x000010, "Wrong alignment on URSMaterialStaticMeshComponent");
static_assert(sizeof(URSMaterialStaticMeshComponent) == 0x0004A0, "Wrong size on URSMaterialStaticMeshComponent");

// Class BattlePrototype.RSMathFuncLib
// 0x0000 (0x0028 - 0x0028)
class URSMathFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector ClosestPointOnInfiniteLine(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FVector& Point);
	static struct FVector ClosestPointOnLine(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FVector& Point);
	static bool LineBoxIntersection(const struct FBox& InBox, const struct FVector& Start, const struct FVector& End, struct FVector* HitLocation, struct FVector* HitNormal, float* HitLength);
	static float PointDistToLine(const struct FVector& Point, const struct FVector& Direction, const struct FVector& Origin, struct FVector* OutClosestPoint);
	static struct FVector2D RandomLocationInCircle(float Radius, int32 RetrayMax);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSMathFuncLib">();
	}
	static class URSMathFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSMathFuncLib>();
	}
};
static_assert(alignof(URSMathFuncLib) == 0x000008, "Wrong alignment on URSMathFuncLib");
static_assert(sizeof(URSMathFuncLib) == 0x000028, "Wrong size on URSMathFuncLib");

// Class BattlePrototype.RSMovieManager
// 0x0058 (0x0288 - 0x0230)
class ARSMovieManager : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UManaTexture*, int32>              ReleaseManaTextures;                               // 0x0238(0x0050)(NativeAccessSpecifierPrivate)

public:
	bool LoadMovieTexture(const class FString& Path);
	void ResetFlags(class UManaTexture* Mana);
	bool ResetManaComponentOtherNative();
	bool SetIndividualSetting(bool Flag);
	bool SetMovieImageTexture(class UImage* Image);
	bool SetMoviePrepareSetting();
	void SetMovieTextureAndPrepare(class UManaTexture* MovieTexture);
	void SetMovieTextureNative(class UManaTexture* MovieTexture, class UMaterialInstanceDynamic* ManaMaterial);
	void TextureRelease();

	class UManaTexture* GetManaTextureNative() const;
	EManaComponentStatus GetStatusNative() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSMovieManager">();
	}
	static class ARSMovieManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSMovieManager>();
	}
};
static_assert(alignof(ARSMovieManager) == 0x000008, "Wrong alignment on ARSMovieManager");
static_assert(sizeof(ARSMovieManager) == 0x000288, "Wrong size on ARSMovieManager");
static_assert(offsetof(ARSMovieManager, ReleaseManaTextures) == 0x000238, "Member 'ARSMovieManager::ReleaseManaTextures' has a wrong offset!");

// Class BattlePrototype.RSNavLinkProxy
// 0x0000 (0x0280 - 0x0280)
class ARSNavLinkProxy final : public ANavLinkProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSNavLinkProxy">();
	}
	static class ARSNavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSNavLinkProxy>();
	}
};
static_assert(alignof(ARSNavLinkProxy) == 0x000008, "Wrong alignment on ARSNavLinkProxy");
static_assert(sizeof(ARSNavLinkProxy) == 0x000280, "Wrong size on ARSNavLinkProxy");

// Class BattlePrototype.RSNewStaticNodeActor
// 0x0000 (0x0230 - 0x0230)
class ARSNewStaticNodeActor : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSNewStaticNodeActor">();
	}
	static class ARSNewStaticNodeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSNewStaticNodeActor>();
	}
};
static_assert(alignof(ARSNewStaticNodeActor) == 0x000008, "Wrong alignment on ARSNewStaticNodeActor");
static_assert(sizeof(ARSNewStaticNodeActor) == 0x000230, "Wrong size on ARSNewStaticNodeActor");

// Class BattlePrototype.RSNpcAnimInstance
// 0x0060 (0x0680 - 0x0620)
class URSNpcAnimInstance : public UASAnimInstance
{
public:
	bool                                          IsNewTownPeople;                                   // 0x0620(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_621[0x7];                                      // 0x0621(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WaitMotionType;                                    // 0x0628(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UASAnimationSet*                        AnimationSet;                                      // 0x0638(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      FacialAnimation;                                   // 0x0640(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENpcAnimationKind                             NpcAnimKind;                                       // 0x0648(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLookAt;                                          // 0x0649(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSit;                                             // 0x064A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64B[0x1];                                      // 0x064B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LookAtPoint;                                       // 0x064C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseKawaiiPhysics;                                  // 0x0658(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_659[0x3];                                      // 0x0659(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EyeXAxisValue;                                     // 0x065C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeYAxisValue;                                     // 0x0660(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HeadRot;                                           // 0x0664(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0670(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_674[0xC];                                      // 0x0674(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAnimSequenceBase* GetAnimSequenceFromAnimationSet(const class FName& Key);
	void SetAnimation(ENpcAnimationKind AnimKind);
	void SetAnimationForce(ENpcAnimationKind AnimKind);
	void SetIsLookAt(bool IsLookAt_0);
	void SetNpcIdleAnimation(class UAnimSequenceBase* IdleAnimation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSNpcAnimInstance">();
	}
	static class URSNpcAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSNpcAnimInstance>();
	}
};
static_assert(alignof(URSNpcAnimInstance) == 0x000010, "Wrong alignment on URSNpcAnimInstance");
static_assert(sizeof(URSNpcAnimInstance) == 0x000680, "Wrong size on URSNpcAnimInstance");
static_assert(offsetof(URSNpcAnimInstance, IsNewTownPeople) == 0x000620, "Member 'URSNpcAnimInstance::IsNewTownPeople' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, WaitMotionType) == 0x000628, "Member 'URSNpcAnimInstance::WaitMotionType' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, AnimationSet) == 0x000638, "Member 'URSNpcAnimInstance::AnimationSet' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, FacialAnimation) == 0x000640, "Member 'URSNpcAnimInstance::FacialAnimation' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, NpcAnimKind) == 0x000648, "Member 'URSNpcAnimInstance::NpcAnimKind' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, IsLookAt) == 0x000649, "Member 'URSNpcAnimInstance::IsLookAt' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, IsSit) == 0x00064A, "Member 'URSNpcAnimInstance::IsSit' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, LookAtPoint) == 0x00064C, "Member 'URSNpcAnimInstance::LookAtPoint' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, UseKawaiiPhysics) == 0x000658, "Member 'URSNpcAnimInstance::UseKawaiiPhysics' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, EyeXAxisValue) == 0x00065C, "Member 'URSNpcAnimInstance::EyeXAxisValue' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, EyeYAxisValue) == 0x000660, "Member 'URSNpcAnimInstance::EyeYAxisValue' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, HeadRot) == 0x000664, "Member 'URSNpcAnimInstance::HeadRot' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, StartTime) == 0x000670, "Member 'URSNpcAnimInstance::StartTime' has a wrong offset!");

// Class BattlePrototype.UIConfigGame
// 0x05B0 (0x0938 - 0x0388)
class UUIConfigGame : public UUIBase
{
public:
	float                                         LineHeight;                                        // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IndexPerPage;                                      // 0x038C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ControllerIndexPerPage;                            // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         KeyboardIndexPerPage;                              // 0x0394(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          M_pSoundSampleVoiceJP;                             // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundAtomCue*                          M_pSoundSampleVoiceEN;                             // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x528];                                    // 0x03A8(0x0528)(Fixing Size After Last Property [ Dumper-7 ])
	class USaveLoadScreenParamManager*            M_pSystemSaveLoadScreenParamManager;               // 0x08D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8D8[0x60];                                     // 0x08D8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void bindAnyKey();
	void InitializeArrowLR(int32 Index_0, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision);
	void InitializeCategory(int32 Category, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UTextBlock* TextCategory);
	void InitializeCommonParts(class UTextBlock* TextHelp, class UUIGuide* UiKeyGuide, class UUIMainContents* Parent, class UWidgetAnimation* AnimMainMenuInfoWin, class UWidgetAnimation* AnimMainMenuInfoWinIn, class UWidgetAnimation* AnimMainMenuInfoWinOut);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimInfoWin, class UWidgetAnimation* AnimInfoWinIn, class UWidgetAnimation* AnimInfoWinOut, class UBackgroundBlur* BackgroundBlur, class UBorder* borderAllColor, class UImage* ImageCoverBlack, class UREDScrollBoxSimple* ScrollBox, class UTextBlock* TextTitle, class UTextBlock* TextHelp, class UOverlay* MenuSet, class UUIGuide* UIGuide, class UUIConfigBrightness* UiBrightness, class UUIConfigKeyboardMouse* UiKeyboardMouse, class UUIConfigController* UiController, class UUIConfigGraphics* UiGraphics, class UUIConfigOther* UiOther, class UImage* ImageOtherCategoryLine, class UUIConfigChoice* UIConfigChoice, class UUIConfigSelect3* UiIndexDifficulty, class UUIConfigSelect2* UiIndexAutoLockOn, class UUIConfigSelect2* UiIndexAutoCamera, class UUIConfigSelect2* UiIndexCameraAfterMoveType, class UUIConfigSelect2* UiIndexDisplayEnemyDamage, class UUIConfigSelect2* UiIndexMiniMapDisplay, class UUIConfigSelect2* UiIndexMiniMapRotation, class UUIConfigSelect2* UiIndexMiniMapScaling, class UUIConfigSelect2* UiIndexBrainCrashCutin, class UUIConfigSelect2* UiIndexAutoSkip, class UUIConfigSelectMulti* UiIndexVoiceLanguage, class UUIConfigSelectSlider* UiIndexVoiceVolume, class UUIConfigSelectSlider* UiIndexBGMVolume, class UUIConfigSelectSlider* UiIndexSEVolume, class UUIConfigSelect5* UiIndexCameraRotationSpeed, class UUIConfigSelect2* UiIndexCameraRotationPitch, class UUIConfigSelect2* UiIndexCameraRotatinoYaw, class UUIConfigSelect2* UiIndexControllerVibration);
	bool IsAllowChangeMainMenuTab();
	void PlayVibrationS();
	void SetAnyKey(const struct FKey& Key);
	void SetChangeMainMenuTabL();
	void SetChangeMainMenuTabR();
	void SetContentsChange(bool IsChange);
	void StartFromTitle();
	void UnbindAnyKey();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool IsChangeMainMenuTabL() const;
	bool IsChangeMainMenuTabR() const;
	bool IsEndMenu() const;
	bool IsPlayingProgramAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigGame">();
	}
	static class UUIConfigGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigGame>();
	}
};
static_assert(alignof(UUIConfigGame) == 0x000008, "Wrong alignment on UUIConfigGame");
static_assert(sizeof(UUIConfigGame) == 0x000938, "Wrong size on UUIConfigGame");
static_assert(offsetof(UUIConfigGame, LineHeight) == 0x000388, "Member 'UUIConfigGame::LineHeight' has a wrong offset!");
static_assert(offsetof(UUIConfigGame, IndexPerPage) == 0x00038C, "Member 'UUIConfigGame::IndexPerPage' has a wrong offset!");
static_assert(offsetof(UUIConfigGame, ControllerIndexPerPage) == 0x000390, "Member 'UUIConfigGame::ControllerIndexPerPage' has a wrong offset!");
static_assert(offsetof(UUIConfigGame, KeyboardIndexPerPage) == 0x000394, "Member 'UUIConfigGame::KeyboardIndexPerPage' has a wrong offset!");
static_assert(offsetof(UUIConfigGame, M_pSoundSampleVoiceJP) == 0x000398, "Member 'UUIConfigGame::M_pSoundSampleVoiceJP' has a wrong offset!");
static_assert(offsetof(UUIConfigGame, M_pSoundSampleVoiceEN) == 0x0003A0, "Member 'UUIConfigGame::M_pSoundSampleVoiceEN' has a wrong offset!");
static_assert(offsetof(UUIConfigGame, M_pSystemSaveLoadScreenParamManager) == 0x0008D0, "Member 'UUIConfigGame::M_pSystemSaveLoadScreenParamManager' has a wrong offset!");

// Class BattlePrototype.RSOutGameMode
// 0x0000 (0x0328 - 0x0328)
class ARSOutGameMode final : public ARSGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSOutGameMode">();
	}
	static class ARSOutGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSOutGameMode>();
	}
};
static_assert(alignof(ARSOutGameMode) == 0x000008, "Wrong alignment on ARSOutGameMode");
static_assert(sizeof(ARSOutGameMode) == 0x000328, "Wrong size on ARSOutGameMode");

// Class BattlePrototype.RSParallelObjectInterface
// 0x0000 (0x0028 - 0x0028)
class IRSParallelObjectInterface final : public IInterface
{
public:
	ERSParallelTiming GetParallelTiming();
	bool IsEnableParallelTick();
	void ParallelTick(float DeltaTime);
	void PostParallelTick();
	void PreParallelTick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSParallelObjectInterface">();
	}
	static class IRSParallelObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRSParallelObjectInterface>();
	}
};
static_assert(alignof(IRSParallelObjectInterface) == 0x000008, "Wrong alignment on IRSParallelObjectInterface");
static_assert(sizeof(IRSParallelObjectInterface) == 0x000028, "Wrong size on IRSParallelObjectInterface");

// Class BattlePrototype.RSParallelObjectManageComponent
// 0x0068 (0x0128 - 0x00C0)
class URSParallelObjectManageComponent final : public UActorComponent
{
public:
	TMap<ERSParallelTiming, struct FParallelData> _ParallelTimingMap;                                // 0x00C0(0x0050)(NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UObject>>         _ReserveUnregisterObjectArray;                     // 0x0110(0x0010)(ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSParallelObjectManageComponent">();
	}
	static class URSParallelObjectManageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSParallelObjectManageComponent>();
	}
};
static_assert(alignof(URSParallelObjectManageComponent) == 0x000008, "Wrong alignment on URSParallelObjectManageComponent");
static_assert(sizeof(URSParallelObjectManageComponent) == 0x000128, "Wrong size on URSParallelObjectManageComponent");
static_assert(offsetof(URSParallelObjectManageComponent, _ParallelTimingMap) == 0x0000C0, "Member 'URSParallelObjectManageComponent::_ParallelTimingMap' has a wrong offset!");
static_assert(offsetof(URSParallelObjectManageComponent, _ReserveUnregisterObjectArray) == 0x000110, "Member 'URSParallelObjectManageComponent::_ReserveUnregisterObjectArray' has a wrong offset!");

// Class BattlePrototype.RSParallelObjectManager
// 0x0018 (0x0248 - 0x0230)
class ARSParallelObjectManager final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URSParallelObjectManageComponent*       _AfterPrePhysicsManageComponent;                   // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URSParallelObjectManageComponent*       _AfterDuringPhysicsManageComponent;                // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool RegisterObject(class UObject* Object);
	void SetSingleThread(bool bSet);
	void UnregisterObject(class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSParallelObjectManager">();
	}
	static class ARSParallelObjectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSParallelObjectManager>();
	}
};
static_assert(alignof(ARSParallelObjectManager) == 0x000008, "Wrong alignment on ARSParallelObjectManager");
static_assert(sizeof(ARSParallelObjectManager) == 0x000248, "Wrong size on ARSParallelObjectManager");
static_assert(offsetof(ARSParallelObjectManager, _AfterPrePhysicsManageComponent) == 0x000238, "Member 'ARSParallelObjectManager::_AfterPrePhysicsManageComponent' has a wrong offset!");
static_assert(offsetof(ARSParallelObjectManager, _AfterDuringPhysicsManageComponent) == 0x000240, "Member 'ARSParallelObjectManager::_AfterDuringPhysicsManageComponent' has a wrong offset!");

// Class BattlePrototype.UIConfigOther
// 0x0008 (0x0390 - 0x0388)
class UUIConfigOther : public UUIBase
{
public:
	class UUIBase*                                ChildIndex;                                        // 0x0388(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializeThis(class UUIBase* UiIndex, class UREDTextBlock* TextIndex);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigOther">();
	}
	static class UUIConfigOther* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigOther>();
	}
};
static_assert(alignof(UUIConfigOther) == 0x000008, "Wrong alignment on UUIConfigOther");
static_assert(sizeof(UUIConfigOther) == 0x000390, "Wrong size on UUIConfigOther");
static_assert(offsetof(UUIConfigOther, ChildIndex) == 0x000388, "Member 'UUIConfigOther::ChildIndex' has a wrong offset!");

// Class BattlePrototype.RSParticleStatics
// 0x0000 (0x0028 - 0x0028)
class URSParticleStatics final : public UBlueprintFunctionLibrary
{
public:
	static void SpawnEmitteDeactiveSystem(class URSParticleSystemComponentBase* PSC);
	static class URSParticleSystemComponentBase* SpawnEmitterAtLocation(const class UObject* WorldContextObject, TSubclassOf<class URSParticleSystemComponentBase> ComponentClass, class UParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, const bool IsActiveSystem, bool bAutoDestroy, const class UObject* Creator, ESequencerDilationOwner DilationOwner);
	static void SpawnEmitterAtLocationNoReturnComponent(const class UObject* WorldContextObject, TSubclassOf<class URSParticleSystemComponentBase> ComponentClass, class UParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, const bool IsActiveSystem, bool bAutoDestroy, const class UObject* Creator, ESequencerDilationOwner DilationOwner);
	static class URSParticleSystemComponentBase* SpawnEmitterAtLocationOptional(const class UObject* WorldContextObject, TSubclassOf<class URSParticleSystemComponentBase> ComponentClass, class UParticleSystem* EmitterTemplate, const TArray<struct FParticleSysParam>& InstanceParameters, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, const bool IsActiveSystem, bool bAutoDestroy, const class UObject* Creator, ESequencerDilationOwner DilationOwner);
	static class URSParticleSystemComponentBase* SpawnEmitterAttached(TSubclassOf<class URSParticleSystemComponentBase> ComponentClass, class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, EAttachLocation LocationType, const bool IsActiveSystem, bool bAutoDestroy, const class UObject* Creator, bool bForceConnectWorld, class URSParticleSystemComponentBase* PTurnUsePSC, bool bAttachLocationOnly, ESequencerDilationOwner DilationOwner);
	static void SpawnEmitterAttachedNoReturnComponent(TSubclassOf<class URSParticleSystemComponentBase> ComponentClass, class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, EAttachLocation LocationType, const bool IsActiveSystem, bool bAutoDestroy, const class UObject* Creator, bool bForceConnectWorld, class URSParticleSystemComponentBase* PTurnUsePSC, ESequencerDilationOwner DilationOwner);
	static void StartEmitterForSpawnedComponent(class URSParticleSystemComponentBase* PPSC, const class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, const struct FVector& SpawnScale, const bool IsActiveSystem, const class UObject* Creator, ESequencerDilationOwner DilationOwner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSParticleStatics">();
	}
	static class URSParticleStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSParticleStatics>();
	}
};
static_assert(alignof(URSParticleStatics) == 0x000008, "Wrong alignment on URSParticleStatics");
static_assert(sizeof(URSParticleStatics) == 0x000028, "Wrong size on URSParticleStatics");

// Class BattlePrototype.RSParticleSystemComponentBase
// 0x0080 (0x06F0 - 0x0670)
#pragma pack(push, 0x1)
class alignas(0x10) URSParticleSystemComponentBase : public UParticleSystemComponent
{
public:
	class AActor*                                 CreatorActor;                                      // 0x0668(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrailTime;                                         // 0x0670(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsApplyStageSetting;                               // 0x0674(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_675[0x73];                                     // 0x0675(0x0073)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class UMaterialInstanceDynamic*> GetDynamicMaterialInstanceALL();
	class FName GetEmitterName(int32 Index_0);
	int32 GetMaterialIndexFromEmitterName(class FName EmitterName);
	bool HasTranslucencyMaterial();
	bool HasTranslucencyOrAdditiveMaterial();
	void Initialize();
	void PlayCheckFlags();
	void PlayParticleImplements();
	void ResetParticleBP();
	void RestartParticle();
	void SetAllEmitterEnable(bool bNewEnableState);
	void SetAttachedOption(bool InAttachLocationX, bool InAttachLocationY, bool InAttachLocationZ, bool InAttachRotationX, bool InAttachRotationY, bool InAttachRotationZ, bool InAttachScaleX, bool InAttachScaleY, bool InAttachScaleZ, ERSParticleSystemAttachRotationOffMode InAttachRotationOffMode);
	void SetCulling(bool InCulling);
	void SetDilationOwner(ESequencerDilationOwner InDilationOwner);
	void SetEnableDistanceCulling(bool UseCulling);
	void SetForceLOD(int32 InLODLevel);
	void SetHideDebuggingInfoScreen(bool Hide);
	void SetLocalTimeDilation(float Dilation);
	void StopAndHideParticleImplements();
	void StopParticleImplements();
	bool UseStageSetting_Native();

	void GetAttachedOptionLocation(bool* OutAttachLocationX, bool* OutAttachLocationY, bool* OutAttachLocationZ) const;
	void GetAttachedOptionRotation(bool* OutAttachRotationX, bool* OutAttachRotationY, bool* OutAttachRotationZ) const;
	void GetAttachedOptionScale(bool* OutAttachScaleX, bool* OutAttachScaleY, bool* OutAttachScaleZ) const;
	int32 GetForceLOD() const;
	bool IsAutoDestroy() const;
	bool IsCulling() const;
	bool IsEnableDistanceCulling() const;
	bool IsHideDebuggingInfoScreen() const;
	bool UseForceLOD() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSParticleSystemComponentBase">();
	}
	static class URSParticleSystemComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSParticleSystemComponentBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(URSParticleSystemComponentBase) == 0x000010, "Wrong alignment on URSParticleSystemComponentBase");
static_assert(sizeof(URSParticleSystemComponentBase) == 0x0006F0, "Wrong size on URSParticleSystemComponentBase");
static_assert(offsetof(URSParticleSystemComponentBase, CreatorActor) == 0x000668, "Member 'URSParticleSystemComponentBase::CreatorActor' has a wrong offset!");
static_assert(offsetof(URSParticleSystemComponentBase, TrailTime) == 0x000670, "Member 'URSParticleSystemComponentBase::TrailTime' has a wrong offset!");
static_assert(offsetof(URSParticleSystemComponentBase, IsApplyStageSetting) == 0x000674, "Member 'URSParticleSystemComponentBase::IsApplyStageSetting' has a wrong offset!");

// Class BattlePrototype.RSParticleSystemManager
// 0x27F0 (0x2A20 - 0x0230)
class ARSParticleSystemManager : public AActor
{
public:
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             FootStepDataTable;                                 // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UCharacterPhysicalSurfaceActionEffectResource*> MapFootStep;                                       // 0x0248(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGeneralPhysicalSurfaceActionEffectResourceArray> MapGeneralPhysicalActions;                         // 0x0298(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class URSParticleSystemComponentBase*> Components;                                        // 0x02E8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHitParticle>                   HitParticles;                                      // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDamageParticle>                DamageParticles;                                   // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSpecialDamageParticle>         SpecialDamageParticles;                            // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleComponentListManager*>  ParticleComponentListManagers;                     // 0x0328(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class UParticleComponentListManager*> M_AnimNotifyParticleCompListMngMap;                // 0x0338(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         SeeThroughRate;                                    // 0x0388(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38C[0x14];                                     // 0x038C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACullDistanceEffectBackgroundVolume*> CullDistanceBGVolumes;                             // 0x03A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CullDistanceBG;                                    // 0x03B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B4[0x2650];                                   // 0x03B4(0x2650)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ManageHitEffectNum;                                // 0x2A04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManageEffectStopEndTrail;                         // 0x2A08(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A09[0x7];                                     // 0x2A09(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class URSParticleSystemComponentBase>> PlayHitEffectManageList;                           // 0x2A10(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ActivateAllParticles(bool IsReset);
	void AddBackGroundParticle(class URSParticleSystemComponentBase* EffectBG);
	void ClearBackGroundParticle();
	void CullEffectAtStaticEvent(const struct FVector& CameraLocation);
	void DeactivateAllParticles();
	void DumpBackgroundCellList();
	void EventOnSystemFinishedSeeThroughParticle(class UParticleSystemComponent* PSystem);
	class UParticleSystem* GetGeneralPhysicalSurfaceActionResource(const EGamePhysicalSurfaceType PhysicsType, class FName ActionType);
	class UCharacterPhysicalSurfaceActionEffectResource* LoadFootStep(class FName NameId);
	void ParticleOnSystemFinished(class UParticleSystemComponent* PPSC);
	void PlayHitDamage(const struct FHitDamageInfo& Info);
	void RegisterComponent(class URSParticleSystemComponentBase* Component);
	void RegisterSeeThroughParticle(class URSParticleSystemComponentBase* Particle);
	void RemoveBackGroundParticle(class URSParticleSystemComponentBase* EffectBG);
	void ResetDebrisMaterial(class UParticleSystemComponent* PSystem);
	void SetBackgroundParameter(const struct FParticleSystemBackGroundParameter& Parameter);
	void SetDebugBackgroundInformation(bool bDebug);
	void SetSeeThroughRate(float Rate);
	void StartCheckBackgroundCull(const struct FVector& CheckLocation, bool OneFrameUpdate);
	bool UnloadFootStep(class FName NameId);
	void UnregisterComponent(class URSParticleSystemComponentBase* Component);
	void UnregisterComponentAll();
	void UnregisterSeeThroughParticle(class URSParticleSystemComponentBase* Particle);

	void DumpManagedParticles() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSParticleSystemManager">();
	}
	static class ARSParticleSystemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSParticleSystemManager>();
	}
};
static_assert(alignof(ARSParticleSystemManager) == 0x000008, "Wrong alignment on ARSParticleSystemManager");
static_assert(sizeof(ARSParticleSystemManager) == 0x002A20, "Wrong size on ARSParticleSystemManager");
static_assert(offsetof(ARSParticleSystemManager, FootStepDataTable) == 0x000240, "Member 'ARSParticleSystemManager::FootStepDataTable' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, MapFootStep) == 0x000248, "Member 'ARSParticleSystemManager::MapFootStep' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, MapGeneralPhysicalActions) == 0x000298, "Member 'ARSParticleSystemManager::MapGeneralPhysicalActions' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, Components) == 0x0002E8, "Member 'ARSParticleSystemManager::Components' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, HitParticles) == 0x0002F8, "Member 'ARSParticleSystemManager::HitParticles' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, DamageParticles) == 0x000308, "Member 'ARSParticleSystemManager::DamageParticles' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, SpecialDamageParticles) == 0x000318, "Member 'ARSParticleSystemManager::SpecialDamageParticles' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, ParticleComponentListManagers) == 0x000328, "Member 'ARSParticleSystemManager::ParticleComponentListManagers' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, M_AnimNotifyParticleCompListMngMap) == 0x000338, "Member 'ARSParticleSystemManager::M_AnimNotifyParticleCompListMngMap' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, SeeThroughRate) == 0x000388, "Member 'ARSParticleSystemManager::SeeThroughRate' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, CullDistanceBGVolumes) == 0x0003A0, "Member 'ARSParticleSystemManager::CullDistanceBGVolumes' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, CullDistanceBG) == 0x0003B0, "Member 'ARSParticleSystemManager::CullDistanceBG' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, ManageHitEffectNum) == 0x002A04, "Member 'ARSParticleSystemManager::ManageHitEffectNum' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, bManageEffectStopEndTrail) == 0x002A08, "Member 'ARSParticleSystemManager::bManageEffectStopEndTrail' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, PlayHitEffectManageList) == 0x002A10, "Member 'ARSParticleSystemManager::PlayHitEffectManageList' has a wrong offset!");

// Class BattlePrototype.UIConfigSelectMulti
// 0x00E0 (0x0468 - 0x0388)
class UUIConfigSelectMulti : public UUIBase
{
public:
	uint8                                         Pad_388[0xE0];                                     // 0x0388(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefaultGlay, class UWidgetAnimation* AnimSelectGlay, class UWidgetAnimation* AnimInGlay, class UWidgetAnimation* AnimOutGlay, class UTextBlock* TextTitle, class UTextBlock* TextParameter);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigSelectMulti">();
	}
	static class UUIConfigSelectMulti* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigSelectMulti>();
	}
};
static_assert(alignof(UUIConfigSelectMulti) == 0x000008, "Wrong alignment on UUIConfigSelectMulti");
static_assert(sizeof(UUIConfigSelectMulti) == 0x000468, "Wrong size on UUIConfigSelectMulti");

// Class BattlePrototype.RSParticleTrailSystemComponent
// 0x0020 (0x0710 - 0x06F0)
class URSParticleTrailSystemComponent final : public URSParticleSystemComponentBase
{
public:
	class FName                                   FirstSocketName;                                   // 0x06E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SecondSocketName;                                  // 0x06F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrailWidthMode                               WidthScaleMode;                                    // 0x06F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F9[0x3];                                      // 0x06F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WidthScale;                                        // 0x06FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeRate;                                          // 0x0700(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FadeOutMaterialScalarName;                         // 0x0704(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70C[0x4];                                      // 0x070C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSParticleTrailSystemComponent">();
	}
	static class URSParticleTrailSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSParticleTrailSystemComponent>();
	}
};
static_assert(alignof(URSParticleTrailSystemComponent) == 0x000010, "Wrong alignment on URSParticleTrailSystemComponent");
static_assert(sizeof(URSParticleTrailSystemComponent) == 0x000710, "Wrong size on URSParticleTrailSystemComponent");
static_assert(offsetof(URSParticleTrailSystemComponent, FirstSocketName) == 0x0006E8, "Member 'URSParticleTrailSystemComponent::FirstSocketName' has a wrong offset!");
static_assert(offsetof(URSParticleTrailSystemComponent, SecondSocketName) == 0x0006F0, "Member 'URSParticleTrailSystemComponent::SecondSocketName' has a wrong offset!");
static_assert(offsetof(URSParticleTrailSystemComponent, WidthScaleMode) == 0x0006F8, "Member 'URSParticleTrailSystemComponent::WidthScaleMode' has a wrong offset!");
static_assert(offsetof(URSParticleTrailSystemComponent, WidthScale) == 0x0006FC, "Member 'URSParticleTrailSystemComponent::WidthScale' has a wrong offset!");
static_assert(offsetof(URSParticleTrailSystemComponent, FadeRate) == 0x000700, "Member 'URSParticleTrailSystemComponent::FadeRate' has a wrong offset!");
static_assert(offsetof(URSParticleTrailSystemComponent, FadeOutMaterialScalarName) == 0x000704, "Member 'URSParticleTrailSystemComponent::FadeOutMaterialScalarName' has a wrong offset!");

// Class BattlePrototype.RSPlayerAnimInstance
// 0x0200 (0x0820 - 0x0620)
class URSPlayerAnimInstance : public URSCharacterAnimInstance
{
public:
	EPlayerAnimKind                               RequestAnimKind;                                   // 0x0620(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_621[0x3];                                      // 0x0621(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RequestAnimParam;                                  // 0x0624(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipPhysics;                                      // 0x0628(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSkipPhysics;                                // 0x0629(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62A[0x2];                                      // 0x062A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftStickPower;                                    // 0x062C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftStickPrevDiff;                                 // 0x0630(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerWalkRunStateKind                       WalkRunStateKind;                                  // 0x0634(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_635[0x3];                                      // 0x0635(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkSpeed;                                         // 0x0638(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkDir;                                           // 0x063C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWalkStopAble;                                     // 0x0640(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_641[0x3];                                      // 0x0641(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StepDirection;                                     // 0x0644(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerAnimDir                                AnimParamDir;                                      // 0x0650(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_651[0x3];                                      // 0x0651(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SprintBank;                                        // 0x0654(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HeadRot;                                           // 0x0660(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               SpineAimRot;                                       // 0x066C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUniquePsychicAimFlag;                             // 0x0678(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattling;                                         // 0x0679(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTalkMode;                                         // 0x067A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAjitoFlag;                                        // 0x067B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlyingAnimation;                                  // 0x067C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCaptureBlend;                                  // 0x067D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCaptureBlendRateBack;                             // 0x067E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_67F[0x1];                                      // 0x067F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CaptureBlendRate;                                  // 0x0680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseKawaiiPhysics;                                  // 0x0684(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERSCharaRestrictionState                      RestrictionState;                                  // 0x0685(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_686[0x2];                                      // 0x0686(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchChangeNowAnimKind;                         // 0x0688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchChangeWalkRunStateKind;                    // 0x0698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchMontageStarted;                            // 0x06A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchMontageBlendingOut;                        // 0x06B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchMontageEnded;                              // 0x06C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                HandIK_Offset;                                     // 0x06D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CharacterIK_Offset;                                // 0x06E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandIK_Alpha;                                      // 0x06F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RigidbodyAlpha;                                    // 0x06F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RigidIdlingSec;                                    // 0x06F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDynamicsIdlingSec;                             // 0x06FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddDamageBlendRate;                                // 0x0700(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDispDebugLog;                                     // 0x0704(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerAnimKind                               NowAnimKind;                                       // 0x0705(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerAnimKind                               OldAnimKind;                                       // 0x0706(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSubstateLastMotion;                               // 0x0707(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           DelayTimerHandle;                                  // 0x0708(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPlayerAnimTransitionKind                     DelayTransition;                                   // 0x0710(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_711[0x3];                                      // 0x0711(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FDelayActorDilation;                               // 0x0714(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EyeHorizontal;                                     // 0x0718(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeVertical;                                       // 0x071C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeBlendRate;                                      // 0x0720(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_724[0x4];                                      // 0x0724(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _bEnableEyeControl;                                // 0x0728(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FloorCheckAngle;                                   // 0x0738(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKFootInterpSpeed;                             // 0x073C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKFootInterpSpeedUnderGround;                  // 0x0740(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKFootInterpSpeedFloaingFoot;                  // 0x0744(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKFootInterpSpeedCheckGroundOffset;            // 0x0748(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKMeshInterpSpeed;                             // 0x074C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKMeshFloatingInterpSpeed;                     // 0x0750(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundCheckHeightTop;                              // 0x0754(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundCheckHeightBottom;                           // 0x0758(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootUpperHeight;                                // 0x075C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootUpperHeightRun;                             // 0x0760(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootUpperHeightSprint;                          // 0x0764(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootUnderHeight;                                // 0x0768(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootUnderHeightRun;                             // 0x076C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootUnderHeightSprint;                          // 0x0770(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootUnderHeightAjito;                           // 0x0774(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootHeightDiff;                                 // 0x0778(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootHeightDiffSlopeUp;                          // 0x077C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootHeightDiffSlopeDown;                        // 0x0780(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IgnoreInterpFootRange;                             // 0x0784(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKBlendRate;                                   // 0x0788(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootIKOffset_Left;                                 // 0x078C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootIKOffset_Right;                                // 0x0798(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootIKJointTargetLocation_Left;                    // 0x07A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootIKJointTargetLocation_Right;                   // 0x07B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _MeshOffset;                                       // 0x07BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C0[0x60];                                     // 0x07C0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetFootIKGroundLocation(struct FVector* OutFootLeft, struct FVector* OutFootRight);
	void OnChangeAnimKind();
	void ReceiveTransitionNotify(EPlayerAnimTransitionKind Transition);
	void ReceiveTransitionNotifyDelay(EPlayerAnimTransitionKind Transition, float DelayTime);
	void RecvOnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void RecvOnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void RecvOnMontageStarted(class UAnimMontage* Montage);
	void ReregistReceiveTransitionNotifyDelay();
	void SetAttackFootHeightDiff(bool bUse, float Diff, float SlopeDownDiff);
	void SetAttackMaxFootUnderHeight(bool bUse, float Height, float SlopeDownHeight);
	void SetAttackMaxFootUpperHeight(bool bUse, float Height, float SlopeDownHeight);
	void SetCaptureBlend(bool bUse, bool bBack, float BlendRate);
	void SetEnableFootIK(bool bEnable, float BlendTime);
	void SetEyeControlEnable(bool bEnable, class FName ClaimantName);
	void SetEyeControlParameter(float Horizontal, float Vertical);
	void SetWalkRunStateKind(EPlayerWalkRunStateKind Kind);

	EPlayerAnimKind GetNowAnimKind() const;
	bool IsCheckIdle() const;
	bool IsExistRequest() const;
	bool IsRequestKind(EPlayerAnimKind Kind) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSPlayerAnimInstance">();
	}
	static class URSPlayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSPlayerAnimInstance>();
	}
};
static_assert(alignof(URSPlayerAnimInstance) == 0x000010, "Wrong alignment on URSPlayerAnimInstance");
static_assert(sizeof(URSPlayerAnimInstance) == 0x000820, "Wrong size on URSPlayerAnimInstance");
static_assert(offsetof(URSPlayerAnimInstance, RequestAnimKind) == 0x000620, "Member 'URSPlayerAnimInstance::RequestAnimKind' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, RequestAnimParam) == 0x000624, "Member 'URSPlayerAnimInstance::RequestAnimParam' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bSkipPhysics) == 0x000628, "Member 'URSPlayerAnimInstance::bSkipPhysics' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bIgnoreSkipPhysics) == 0x000629, "Member 'URSPlayerAnimInstance::bIgnoreSkipPhysics' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, LeftStickPower) == 0x00062C, "Member 'URSPlayerAnimInstance::LeftStickPower' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, LeftStickPrevDiff) == 0x000630, "Member 'URSPlayerAnimInstance::LeftStickPrevDiff' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, WalkRunStateKind) == 0x000634, "Member 'URSPlayerAnimInstance::WalkRunStateKind' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, WalkSpeed) == 0x000638, "Member 'URSPlayerAnimInstance::WalkSpeed' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, WalkDir) == 0x00063C, "Member 'URSPlayerAnimInstance::WalkDir' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bWalkStopAble) == 0x000640, "Member 'URSPlayerAnimInstance::bWalkStopAble' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, StepDirection) == 0x000644, "Member 'URSPlayerAnimInstance::StepDirection' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, AnimParamDir) == 0x000650, "Member 'URSPlayerAnimInstance::AnimParamDir' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, SprintBank) == 0x000654, "Member 'URSPlayerAnimInstance::SprintBank' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, HeadRot) == 0x000660, "Member 'URSPlayerAnimInstance::HeadRot' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, SpineAimRot) == 0x00066C, "Member 'URSPlayerAnimInstance::SpineAimRot' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bUniquePsychicAimFlag) == 0x000678, "Member 'URSPlayerAnimInstance::bUniquePsychicAimFlag' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bBattling) == 0x000679, "Member 'URSPlayerAnimInstance::bBattling' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bTalkMode) == 0x00067A, "Member 'URSPlayerAnimInstance::bTalkMode' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bAjitoFlag) == 0x00067B, "Member 'URSPlayerAnimInstance::bAjitoFlag' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bFlyingAnimation) == 0x00067C, "Member 'URSPlayerAnimInstance::bFlyingAnimation' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bUseCaptureBlend) == 0x00067D, "Member 'URSPlayerAnimInstance::bUseCaptureBlend' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bCaptureBlendRateBack) == 0x00067E, "Member 'URSPlayerAnimInstance::bCaptureBlendRateBack' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, CaptureBlendRate) == 0x000680, "Member 'URSPlayerAnimInstance::CaptureBlendRate' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, UseKawaiiPhysics) == 0x000684, "Member 'URSPlayerAnimInstance::UseKawaiiPhysics' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, RestrictionState) == 0x000685, "Member 'URSPlayerAnimInstance::RestrictionState' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, DispatchChangeNowAnimKind) == 0x000688, "Member 'URSPlayerAnimInstance::DispatchChangeNowAnimKind' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, DispatchChangeWalkRunStateKind) == 0x000698, "Member 'URSPlayerAnimInstance::DispatchChangeWalkRunStateKind' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, DispatchMontageStarted) == 0x0006A8, "Member 'URSPlayerAnimInstance::DispatchMontageStarted' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, DispatchMontageBlendingOut) == 0x0006B8, "Member 'URSPlayerAnimInstance::DispatchMontageBlendingOut' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, DispatchMontageEnded) == 0x0006C8, "Member 'URSPlayerAnimInstance::DispatchMontageEnded' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, HandIK_Offset) == 0x0006D8, "Member 'URSPlayerAnimInstance::HandIK_Offset' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, CharacterIK_Offset) == 0x0006E4, "Member 'URSPlayerAnimInstance::CharacterIK_Offset' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, HandIK_Alpha) == 0x0006F0, "Member 'URSPlayerAnimInstance::HandIK_Alpha' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, RigidbodyAlpha) == 0x0006F4, "Member 'URSPlayerAnimInstance::RigidbodyAlpha' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, RigidIdlingSec) == 0x0006F8, "Member 'URSPlayerAnimInstance::RigidIdlingSec' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, AnimDynamicsIdlingSec) == 0x0006FC, "Member 'URSPlayerAnimInstance::AnimDynamicsIdlingSec' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, AddDamageBlendRate) == 0x000700, "Member 'URSPlayerAnimInstance::AddDamageBlendRate' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bDispDebugLog) == 0x000704, "Member 'URSPlayerAnimInstance::bDispDebugLog' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, NowAnimKind) == 0x000705, "Member 'URSPlayerAnimInstance::NowAnimKind' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, OldAnimKind) == 0x000706, "Member 'URSPlayerAnimInstance::OldAnimKind' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bSubstateLastMotion) == 0x000707, "Member 'URSPlayerAnimInstance::bSubstateLastMotion' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, DelayTimerHandle) == 0x000708, "Member 'URSPlayerAnimInstance::DelayTimerHandle' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, DelayTransition) == 0x000710, "Member 'URSPlayerAnimInstance::DelayTransition' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FDelayActorDilation) == 0x000714, "Member 'URSPlayerAnimInstance::FDelayActorDilation' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, EyeHorizontal) == 0x000718, "Member 'URSPlayerAnimInstance::EyeHorizontal' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, EyeVertical) == 0x00071C, "Member 'URSPlayerAnimInstance::EyeVertical' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, EyeBlendRate) == 0x000720, "Member 'URSPlayerAnimInstance::EyeBlendRate' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, _bEnableEyeControl) == 0x000728, "Member 'URSPlayerAnimInstance::_bEnableEyeControl' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FloorCheckAngle) == 0x000738, "Member 'URSPlayerAnimInstance::FloorCheckAngle' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKFootInterpSpeed) == 0x00073C, "Member 'URSPlayerAnimInstance::FootIKFootInterpSpeed' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKFootInterpSpeedUnderGround) == 0x000740, "Member 'URSPlayerAnimInstance::FootIKFootInterpSpeedUnderGround' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKFootInterpSpeedFloaingFoot) == 0x000744, "Member 'URSPlayerAnimInstance::FootIKFootInterpSpeedFloaingFoot' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKFootInterpSpeedCheckGroundOffset) == 0x000748, "Member 'URSPlayerAnimInstance::FootIKFootInterpSpeedCheckGroundOffset' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKMeshInterpSpeed) == 0x00074C, "Member 'URSPlayerAnimInstance::FootIKMeshInterpSpeed' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKMeshFloatingInterpSpeed) == 0x000750, "Member 'URSPlayerAnimInstance::FootIKMeshFloatingInterpSpeed' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, GroundCheckHeightTop) == 0x000754, "Member 'URSPlayerAnimInstance::GroundCheckHeightTop' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, GroundCheckHeightBottom) == 0x000758, "Member 'URSPlayerAnimInstance::GroundCheckHeightBottom' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootUpperHeight) == 0x00075C, "Member 'URSPlayerAnimInstance::MaxFootUpperHeight' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootUpperHeightRun) == 0x000760, "Member 'URSPlayerAnimInstance::MaxFootUpperHeightRun' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootUpperHeightSprint) == 0x000764, "Member 'URSPlayerAnimInstance::MaxFootUpperHeightSprint' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootUnderHeight) == 0x000768, "Member 'URSPlayerAnimInstance::MaxFootUnderHeight' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootUnderHeightRun) == 0x00076C, "Member 'URSPlayerAnimInstance::MaxFootUnderHeightRun' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootUnderHeightSprint) == 0x000770, "Member 'URSPlayerAnimInstance::MaxFootUnderHeightSprint' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootUnderHeightAjito) == 0x000774, "Member 'URSPlayerAnimInstance::MaxFootUnderHeightAjito' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootHeightDiff) == 0x000778, "Member 'URSPlayerAnimInstance::MaxFootHeightDiff' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootHeightDiffSlopeUp) == 0x00077C, "Member 'URSPlayerAnimInstance::MaxFootHeightDiffSlopeUp' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootHeightDiffSlopeDown) == 0x000780, "Member 'URSPlayerAnimInstance::MaxFootHeightDiffSlopeDown' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, IgnoreInterpFootRange) == 0x000784, "Member 'URSPlayerAnimInstance::IgnoreInterpFootRange' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKBlendRate) == 0x000788, "Member 'URSPlayerAnimInstance::FootIKBlendRate' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKOffset_Left) == 0x00078C, "Member 'URSPlayerAnimInstance::FootIKOffset_Left' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKOffset_Right) == 0x000798, "Member 'URSPlayerAnimInstance::FootIKOffset_Right' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKJointTargetLocation_Left) == 0x0007A4, "Member 'URSPlayerAnimInstance::FootIKJointTargetLocation_Left' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKJointTargetLocation_Right) == 0x0007B0, "Member 'URSPlayerAnimInstance::FootIKJointTargetLocation_Right' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, _MeshOffset) == 0x0007BC, "Member 'URSPlayerAnimInstance::_MeshOffset' has a wrong offset!");

// Class BattlePrototype.RSPlayerCameraManager
// 0x0000 (0x34D0 - 0x34D0)
class ARSPlayerCameraManager : public APlayerCameraManager
{
public:
	void ClearCameraShakeCache();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSPlayerCameraManager">();
	}
	static class ARSPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSPlayerCameraManager>();
	}
};
static_assert(alignof(ARSPlayerCameraManager) == 0x000010, "Wrong alignment on ARSPlayerCameraManager");
static_assert(sizeof(ARSPlayerCameraManager) == 0x0034D0, "Wrong size on ARSPlayerCameraManager");

// Class BattlePrototype.UIDetailMap
// 0x0080 (0x0408 - 0x0388)
class UUIDetailMap : public UUIBase
{
public:
	class FName                                   M_SceneName;                                       // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABP_UI_SceneMap*                        M_ParentSceneMap;                                  // 0x0390(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_398[0x48];                                     // 0x0398(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSHUDBase*                             M_pHudBase;                                        // 0x03E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x20];                                     // 0x03E8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ControlDetailMap(int32 SubState);
	bool CreateDetailMap();
	TSubclassOf<class ABP_UI_SceneMap> GetDetaileMapRefalence(const class FString& Path);
	void InitializeAnime(class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_, class UWidgetAnimation* Iconinfoin, class UWidgetAnimation* Iconinfoout, class UWidgetAnimation* Default_iconinfo_none);
	bool InitializeDataDetailMap();
	void InitializeDetailMap();
	void InitializeMouseRectWidget(class UREDOverlay* Pc_pg1_1, class UREDOverlay* Pc_pg1_2, class UREDOverlay* Pc_pg2_2, class UREDOverlay* Pc_pg2_1);
	bool ReleaseDetailMap();
	bool TextFixDataDetailMap(int32 LocationNo);
	void UpdateStateDetailMap(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDetailMap">();
	}
	static class UUIDetailMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDetailMap>();
	}
};
static_assert(alignof(UUIDetailMap) == 0x000008, "Wrong alignment on UUIDetailMap");
static_assert(sizeof(UUIDetailMap) == 0x000408, "Wrong size on UUIDetailMap");
static_assert(offsetof(UUIDetailMap, M_SceneName) == 0x000388, "Member 'UUIDetailMap::M_SceneName' has a wrong offset!");
static_assert(offsetof(UUIDetailMap, M_ParentSceneMap) == 0x000390, "Member 'UUIDetailMap::M_ParentSceneMap' has a wrong offset!");
static_assert(offsetof(UUIDetailMap, M_pHudBase) == 0x0003E0, "Member 'UUIDetailMap::M_pHudBase' has a wrong offset!");

// Class BattlePrototype.RSPlayerController
// 0x0008 (0x05A0 - 0x0598)
class ARSPlayerController : public APlayerController
{
public:
	uint8                                         Pad_598[0x8];                                      // 0x0598(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDisableForceFeedback(bool bDisable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSPlayerController">();
	}
	static class ARSPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSPlayerController>();
	}
};
static_assert(alignof(ARSPlayerController) == 0x000008, "Wrong alignment on ARSPlayerController");
static_assert(sizeof(ARSPlayerController) == 0x0005A0, "Wrong size on ARSPlayerController");

// Class BattlePrototype.RSPlayerHologramAnimInstance
// 0x0030 (0x02A0 - 0x0270)
class URSPlayerHologramAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _bUseMontage;                                      // 0x0278(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               SpineAimRot;                                       // 0x027C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseWeaponRoot;                                    // 0x0288(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x3];                                      // 0x0289(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WeaponRootLocation;                                // 0x028C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSPlayerHologramAnimInstance">();
	}
	static class URSPlayerHologramAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSPlayerHologramAnimInstance>();
	}
};
static_assert(alignof(URSPlayerHologramAnimInstance) == 0x000010, "Wrong alignment on URSPlayerHologramAnimInstance");
static_assert(sizeof(URSPlayerHologramAnimInstance) == 0x0002A0, "Wrong size on URSPlayerHologramAnimInstance");
static_assert(offsetof(URSPlayerHologramAnimInstance, _bUseMontage) == 0x000278, "Member 'URSPlayerHologramAnimInstance::_bUseMontage' has a wrong offset!");
static_assert(offsetof(URSPlayerHologramAnimInstance, SpineAimRot) == 0x00027C, "Member 'URSPlayerHologramAnimInstance::SpineAimRot' has a wrong offset!");
static_assert(offsetof(URSPlayerHologramAnimInstance, bUseWeaponRoot) == 0x000288, "Member 'URSPlayerHologramAnimInstance::bUseWeaponRoot' has a wrong offset!");
static_assert(offsetof(URSPlayerHologramAnimInstance, WeaponRootLocation) == 0x00028C, "Member 'URSPlayerHologramAnimInstance::WeaponRootLocation' has a wrong offset!");

// Class BattlePrototype.RSPlayerHologramAnimInstanceInterface
// 0x0000 (0x0028 - 0x0028)
class IRSPlayerHologramAnimInstanceInterface final : public IInterface
{
public:
	void RequestAnim(EPlayerHologramAnimKind Kind);
	void SetAimRotator(const struct FRotator& Rotator);
	void SetUseMontage(bool bUse);
	void SetWeaponRootLocation(bool bUse, const struct FVector& Location);

	bool IsRequestAnimKind(EPlayerHologramAnimKind Kind) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSPlayerHologramAnimInstanceInterface">();
	}
	static class IRSPlayerHologramAnimInstanceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRSPlayerHologramAnimInstanceInterface>();
	}
};
static_assert(alignof(IRSPlayerHologramAnimInstanceInterface) == 0x000008, "Wrong alignment on IRSPlayerHologramAnimInstanceInterface");
static_assert(sizeof(IRSPlayerHologramAnimInstanceInterface) == 0x000028, "Wrong size on IRSPlayerHologramAnimInstanceInterface");

// Class BattlePrototype.RSPlayerSubAnimInstance
// 0x0010 (0x0280 - 0x0270)
class URSPlayerSubAnimInstance : public UAnimInstance
{
public:
	float                                         PhysicsAlpha;                                      // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsIdlingSec;                                  // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKawaiiPhysics;                                    // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSPlayerSubAnimInstance">();
	}
	static class URSPlayerSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSPlayerSubAnimInstance>();
	}
};
static_assert(alignof(URSPlayerSubAnimInstance) == 0x000010, "Wrong alignment on URSPlayerSubAnimInstance");
static_assert(sizeof(URSPlayerSubAnimInstance) == 0x000280, "Wrong size on URSPlayerSubAnimInstance");
static_assert(offsetof(URSPlayerSubAnimInstance, PhysicsAlpha) == 0x000270, "Member 'URSPlayerSubAnimInstance::PhysicsAlpha' has a wrong offset!");
static_assert(offsetof(URSPlayerSubAnimInstance, PhysicsIdlingSec) == 0x000274, "Member 'URSPlayerSubAnimInstance::PhysicsIdlingSec' has a wrong offset!");
static_assert(offsetof(URSPlayerSubAnimInstance, bKawaiiPhysics) == 0x000278, "Member 'URSPlayerSubAnimInstance::bKawaiiPhysics' has a wrong offset!");

// Class BattlePrototype.UISASGauge
// 0x0020 (0x03A8 - 0x0388)
class UUISASGauge final : public UUIBase
{
public:
	uint8                                         Pad_388[0x20];                                     // 0x0388(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimGauge_0_100, class UOverlay* Overlay);
	void SetButton(E_SASButton Button);
	void SetIconScale(const struct FVector2D& Scale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISASGauge">();
	}
	static class UUISASGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISASGauge>();
	}
};
static_assert(alignof(UUISASGauge) == 0x000008, "Wrong alignment on UUISASGauge");
static_assert(sizeof(UUISASGauge) == 0x0003A8, "Wrong size on UUISASGauge");

// Class BattlePrototype.RSSaveGame
// 0x00A8 (0x00D0 - 0x0028)
class URSSaveGame final : public UObject
{
public:
	class URSGameInstance*                        M_gameInst;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERSSaveGameSaveType                           M_saveType;                                        // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, struct FSaveDataParameter>       M_saveParam;                                       // 0x0038(0x0050)(NativeAccessSpecifierPrivate)
	uint32                                        M_MasterVersion;                                   // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSaveDataSlotBuffer>            M_slotBufferList;                                  // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSaveDataSlotBuffer                    M_systemBuffer;                                    // 0x00A0(0x0010)(NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_SaveLoadScreenParamManager;                      // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERedSaveExistsResult                          M_SaveExistsResult;                                // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URSSaveGameInternal*                    M_pAsyncAutoSaveRSSaveGameInternal;                // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AsyncAutoSave();
	bool AutoDelete(int32 SlotNo, const bool IsFileDelete);
	bool AutoLoad();
	bool AutoPreLoad();
	bool AutoSave();
	void Clear();
	bool DebugLoad(int32 DataNo);
	bool DebugLoad_DirectName(const class FString& Filename);
	bool DebugSave(int32 DataNo);
	bool DebugTimeSave();
	bool Delete(int32 SlotNo, const bool IsFileDelete);
	bool DeleteData(ERSSaveGameSaveType Type, const class FString& Filename, const int32 UserIndex);
	ERedSaveExistsResult GetSaveExistsResult();
	bool GetSaveLoadScreenParam(struct FSaveLoadScreenParam* SlotParam, int32 SlotNo);
	void Initialize(class URSGameInstance* GameInst, class USaveLoadScreenParamManager* PSaveLoadScreenParamManager);
	bool IsExistSaveData(ERSSaveGameSaveType Type);
	bool Load(int32 SlotNo);
	bool LoadNormalOnly(int32 SlotNo);
	bool LoadRetryData();
	bool LoadTrial();
	bool PreLoad();
	bool PreLoadNormalOnly();
	bool Save(int32 DataNo);
	bool SaveNormalOnly(int32 DataNo);
	bool SaveRetryData();
	bool SystemDataDelete(int32 SlotNo, const bool IsFileDelete);
	bool SystemLoad();
	bool SystemSave();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSaveGame">();
	}
	static class URSSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSaveGame>();
	}
};
static_assert(alignof(URSSaveGame) == 0x000008, "Wrong alignment on URSSaveGame");
static_assert(sizeof(URSSaveGame) == 0x0000D0, "Wrong size on URSSaveGame");
static_assert(offsetof(URSSaveGame, M_gameInst) == 0x000028, "Member 'URSSaveGame::M_gameInst' has a wrong offset!");
static_assert(offsetof(URSSaveGame, M_saveType) == 0x000030, "Member 'URSSaveGame::M_saveType' has a wrong offset!");
static_assert(offsetof(URSSaveGame, M_saveParam) == 0x000038, "Member 'URSSaveGame::M_saveParam' has a wrong offset!");
static_assert(offsetof(URSSaveGame, M_MasterVersion) == 0x000088, "Member 'URSSaveGame::M_MasterVersion' has a wrong offset!");
static_assert(offsetof(URSSaveGame, M_slotBufferList) == 0x000090, "Member 'URSSaveGame::M_slotBufferList' has a wrong offset!");
static_assert(offsetof(URSSaveGame, M_systemBuffer) == 0x0000A0, "Member 'URSSaveGame::M_systemBuffer' has a wrong offset!");
static_assert(offsetof(URSSaveGame, M_SaveLoadScreenParamManager) == 0x0000B0, "Member 'URSSaveGame::M_SaveLoadScreenParamManager' has a wrong offset!");
static_assert(offsetof(URSSaveGame, M_SaveExistsResult) == 0x0000B8, "Member 'URSSaveGame::M_SaveExistsResult' has a wrong offset!");
static_assert(offsetof(URSSaveGame, M_pAsyncAutoSaveRSSaveGameInternal) == 0x0000C0, "Member 'URSSaveGame::M_pAsyncAutoSaveRSSaveGameInternal' has a wrong offset!");

// Class BattlePrototype.RSSaveGameUtility
// 0x0000 (0x0028 - 0x0028)
class URSSaveGameUtility final : public UBlueprintFunctionLibrary
{
public:
	static void AutoLoadGame(class UObject* WorldContextObject, class USaveLoadScreenParamManager* PSaveLoadScreenParamManager);
	static void AutoPreLoadGame(class UObject* WorldContextObject, class USaveLoadScreenParamManager* PSaveLoadScreenParamManager);
	static void AutoSaveGame(class UObject* WorldContextObject, class USaveLoadScreenParamManager* PSaveLoadScreenParamManager);
	static bool CheckStorageSpace(class UObject* WorldContextObject);
	static bool IsExistSaveData(class UObject* WorldContextObject, class USaveLoadScreenParamManager* PSaveLoadScreenParamManager, ERSSaveGameSaveType Type);
	static void LoadGame(class UObject* WorldContextObject, class USaveLoadScreenParamManager* PSaveLoadScreenParamManager);
	static void SaveGame(class UObject* WorldContextObject, class USaveLoadScreenParamManager* PSaveLoadScreenParamManager, int32 No);
	static void SystemLoadGame(class UObject* WorldContextObject, class USaveLoadScreenParamManager* PSaveLoadScreenParamManager);
	static void SystemSaveGame(class UObject* WorldContextObject, class USaveLoadScreenParamManager* PSaveLoadScreenParamManager);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSaveGameUtility">();
	}
	static class URSSaveGameUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSaveGameUtility>();
	}
};
static_assert(alignof(URSSaveGameUtility) == 0x000008, "Wrong alignment on URSSaveGameUtility");
static_assert(sizeof(URSSaveGameUtility) == 0x000028, "Wrong size on URSSaveGameUtility");

// Class BattlePrototype.RSSaveGameInterface
// 0x0000 (0x0028 - 0x0028)
class IRSSaveGameInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSaveGameInterface">();
	}
	static class IRSSaveGameInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRSSaveGameInterface>();
	}
};
static_assert(alignof(IRSSaveGameInterface) == 0x000008, "Wrong alignment on IRSSaveGameInterface");
static_assert(sizeof(IRSSaveGameInterface) == 0x000028, "Wrong size on IRSSaveGameInterface");

// Class BattlePrototype.RSSaveGameInternal
// 0x0010 (0x0038 - 0x0028)
class URSSaveGameInternal final : public USaveGame
{
public:
	TArray<uint8>                                 buf;                                               // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSaveGameInternal">();
	}
	static class URSSaveGameInternal* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSaveGameInternal>();
	}
};
static_assert(alignof(URSSaveGameInternal) == 0x000008, "Wrong alignment on URSSaveGameInternal");
static_assert(sizeof(URSSaveGameInternal) == 0x000038, "Wrong size on URSSaveGameInternal");
static_assert(offsetof(URSSaveGameInternal, buf) == 0x000028, "Member 'URSSaveGameInternal::buf' has a wrong offset!");

// Class BattlePrototype.RSSceneCaptureComponent2D
// 0x0010 (0x0B40 - 0x0B30)
class URSSceneCaptureComponent2D final : public USceneCaptureComponent2D
{
public:
	bool                                          bUseTextureStreaming;                              // 0x0B30(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B31[0x3];                                      // 0x0B31(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TextureStreamingBoostFactor;                       // 0x0B34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSeparateTranslucency;                             // 0x0B38(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B39[0x7];                                      // 0x0B39(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FMatrix CalcProjectionMatrix(float ScreenOffsetX, float ScreenOffsetY, float ScaleX, float ScaleY);
	void CaptureSceneSafe();
	void CaptureSceneSafe2Pass();
	void ClearTemporary();
	void DebugTest();
	void SetShowDynamicShadows(bool bShow);
	void SetShowSkeletalMeshes(bool bShow);
	void SetUseScreenPercentage(bool bShow);
	void SetUseTAA(bool UseTAA);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSceneCaptureComponent2D">();
	}
	static class URSSceneCaptureComponent2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSceneCaptureComponent2D>();
	}
};
static_assert(alignof(URSSceneCaptureComponent2D) == 0x000010, "Wrong alignment on URSSceneCaptureComponent2D");
static_assert(sizeof(URSSceneCaptureComponent2D) == 0x000B40, "Wrong size on URSSceneCaptureComponent2D");
static_assert(offsetof(URSSceneCaptureComponent2D, bUseTextureStreaming) == 0x000B30, "Member 'URSSceneCaptureComponent2D::bUseTextureStreaming' has a wrong offset!");
static_assert(offsetof(URSSceneCaptureComponent2D, TextureStreamingBoostFactor) == 0x000B34, "Member 'URSSceneCaptureComponent2D::TextureStreamingBoostFactor' has a wrong offset!");
static_assert(offsetof(URSSceneCaptureComponent2D, bSeparateTranslucency) == 0x000B38, "Member 'URSSceneCaptureComponent2D::bSeparateTranslucency' has a wrong offset!");

// Class BattlePrototype.RSSequencerComponent
// 0x0060 (0x0120 - 0x00C0)
class URSSequencerComponent final : public UActorComponent
{
public:
	TMap<int32, class URSSequencerValueBase*>     MapValue;                                          // 0x00C0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 DelList;                                           // 0x0110(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AllDestroySequenceValue();
	int32 ConvertNameToId(const class FString& Name_0);
	bool DestroySequenceValue(int32 ID);
	class URSSequencerValueBase* GetSequenceValue(int32 ID);
	int32 RegisterSequenceValue(const class FString& HashName, class URSSequencerValueBase* Value, bool Override);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSequencerComponent">();
	}
	static class URSSequencerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSequencerComponent>();
	}
};
static_assert(alignof(URSSequencerComponent) == 0x000008, "Wrong alignment on URSSequencerComponent");
static_assert(sizeof(URSSequencerComponent) == 0x000120, "Wrong size on URSSequencerComponent");
static_assert(offsetof(URSSequencerComponent, MapValue) == 0x0000C0, "Member 'URSSequencerComponent::MapValue' has a wrong offset!");
static_assert(offsetof(URSSequencerComponent, DelList) == 0x000110, "Member 'URSSequencerComponent::DelList' has a wrong offset!");

// Class BattlePrototype.UIShop
// 0x11FC0 (0x12348 - 0x0388)
class UUIShop : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AUIShop3DManager>           BGModelClass;                                      // 0x03A0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x10];                                     // 0x03A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AUIShop3DManager*                       BGModel;                                           // 0x03B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C0[0x11F88];                                  // 0x03C0(0x11F88)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(int32 Index_0, class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision);
	void InitializeItemCategory(int32 Category, class UUIBase* Widget, class UImage* ImageSeparator, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimUnselect, class UTextBlock* TextCategory);
	void InitializeModeTab(int32 Mode, class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UTextBlock* TextBuySell);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimInfoWindow, class UWidgetAnimation* AnimInfoWindowIn, class UWidgetAnimation* AnimInfoWindowOut, class UWidgetAnimation* AnimChange1, class UWidgetAnimation* AnimChange2, class UCanvasPanel* ScrollBoxParent, class UREDScrollBox* ScrollBox, class UUIItemTrade* UIItemTrade, class UUIShopGetContents* UiGetContents, class UUIShopItemDetails* UIShopItemDetails, class UOverlay* UiPaymentParent, class UUIShopPayment* UIShopPayment, class UUIShopChoice* UiChoice, class UUIShopPartyStatus* UiPartyStatus, class UUIGuide* UIGuide, class UTextBlock* TextTitle, class UTextBlock* TextIndexItem, class UTextBlock* TextIndexHaveNum, class UTextBlock* TextIndexPrice, class UTextBlock* TextIndexBuySellNum, class UTextBlock* TextHelp, class UBorder* ShopListColor, class UBorder* ShopGoldSet);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUpdateElement(int32 Index_0, class UUserWidget* Widget);
	void Start(int32 ShopId, int32 TradeShopId, EShopMode Mode);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShop">();
	}
	static class UUIShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShop>();
	}
};
static_assert(alignof(UUIShop) == 0x000008, "Wrong alignment on UUIShop");
static_assert(sizeof(UUIShop) == 0x012348, "Wrong size on UUIShop");
static_assert(offsetof(UUIShop, ListElementSize) == 0x000388, "Member 'UUIShop::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUIShop, ListOffsetSize) == 0x000390, "Member 'UUIShop::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUIShop, ListIndexClass) == 0x000398, "Member 'UUIShop::ListIndexClass' has a wrong offset!");
static_assert(offsetof(UUIShop, BGModelClass) == 0x0003A0, "Member 'UUIShop::BGModelClass' has a wrong offset!");
static_assert(offsetof(UUIShop, BGModel) == 0x0003B8, "Member 'UUIShop::BGModel' has a wrong offset!");

// Class BattlePrototype.RSSequencerValueBase
// 0x0028 (0x0050 - 0x0028)
class URSSequencerValueBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            Curve;                                             // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URSSequencerComponent*                  SeqParent;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class URSSequencerComponent* GetSeqParent();
	void SetSeqParent(class URSSequencerComponent* Parent);
	void SetupTimer(float Time, class UCurveFloat* CurveData, bool LoopFlag, bool AutoDestroyFlag);
	void StoreParameter(float Rate);

	bool IsFinished() const;
	bool IsLoop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSequencerValueBase">();
	}
	static class URSSequencerValueBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSequencerValueBase>();
	}
};
static_assert(alignof(URSSequencerValueBase) == 0x000008, "Wrong alignment on URSSequencerValueBase");
static_assert(sizeof(URSSequencerValueBase) == 0x000050, "Wrong size on URSSequencerValueBase");
static_assert(offsetof(URSSequencerValueBase, Curve) == 0x000030, "Member 'URSSequencerValueBase::Curve' has a wrong offset!");
static_assert(offsetof(URSSequencerValueBase, SeqParent) == 0x000038, "Member 'URSSequencerValueBase::SeqParent' has a wrong offset!");

// Class BattlePrototype.RSSequencerValueAisac
// 0x0020 (0x0070 - 0x0050)
class URSSequencerValueAisac final : public URSSequencerValueBase
{
public:
	class UAtomComponent*                         Component;                                         // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ParameterName;                                     // 0x0058(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartValue;                                        // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndValue;                                          // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetParameter(class UAtomComponent* AtomComponent, const class FString& Name_0, float Start, float End, float Timer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSequencerValueAisac">();
	}
	static class URSSequencerValueAisac* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSequencerValueAisac>();
	}
};
static_assert(alignof(URSSequencerValueAisac) == 0x000008, "Wrong alignment on URSSequencerValueAisac");
static_assert(sizeof(URSSequencerValueAisac) == 0x000070, "Wrong size on URSSequencerValueAisac");
static_assert(offsetof(URSSequencerValueAisac, Component) == 0x000050, "Member 'URSSequencerValueAisac::Component' has a wrong offset!");
static_assert(offsetof(URSSequencerValueAisac, ParameterName) == 0x000058, "Member 'URSSequencerValueAisac::ParameterName' has a wrong offset!");
static_assert(offsetof(URSSequencerValueAisac, StartValue) == 0x000068, "Member 'URSSequencerValueAisac::StartValue' has a wrong offset!");
static_assert(offsetof(URSSequencerValueAisac, EndValue) == 0x00006C, "Member 'URSSequencerValueAisac::EndValue' has a wrong offset!");

// Class BattlePrototype.RSSequencerValueMaterialScalarParameter
// 0x0018 (0x0068 - 0x0050)
class URSSequencerValueMaterialScalarParameter final : public URSSequencerValueBase
{
public:
	class UMeshComponent*                         Component;                                         // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ParameterName;                                     // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartValue;                                        // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndValue;                                          // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetParameter(class UMeshComponent* MeshComponent, class FName Name_0, float Start, float End, float Timer, class UCurveFloat* CurveData, bool bLoop, bool bAutoDestroy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSequencerValueMaterialScalarParameter">();
	}
	static class URSSequencerValueMaterialScalarParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSequencerValueMaterialScalarParameter>();
	}
};
static_assert(alignof(URSSequencerValueMaterialScalarParameter) == 0x000008, "Wrong alignment on URSSequencerValueMaterialScalarParameter");
static_assert(sizeof(URSSequencerValueMaterialScalarParameter) == 0x000068, "Wrong size on URSSequencerValueMaterialScalarParameter");
static_assert(offsetof(URSSequencerValueMaterialScalarParameter, Component) == 0x000050, "Member 'URSSequencerValueMaterialScalarParameter::Component' has a wrong offset!");
static_assert(offsetof(URSSequencerValueMaterialScalarParameter, ParameterName) == 0x000058, "Member 'URSSequencerValueMaterialScalarParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(URSSequencerValueMaterialScalarParameter, StartValue) == 0x000060, "Member 'URSSequencerValueMaterialScalarParameter::StartValue' has a wrong offset!");
static_assert(offsetof(URSSequencerValueMaterialScalarParameter, EndValue) == 0x000064, "Member 'URSSequencerValueMaterialScalarParameter::EndValue' has a wrong offset!");

// Class BattlePrototype.RSSequencerValueMaterialVectorParameter
// 0x0030 (0x0080 - 0x0050)
class URSSequencerValueMaterialVectorParameter final : public URSSequencerValueBase
{
public:
	class UMeshComponent*                         Component;                                         // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ParameterName;                                     // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector4                               StartValue;                                        // 0x0060(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector4                               EndValue;                                          // 0x0070(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetParameter(class UMeshComponent* MeshComponent, class FName Name_0, const struct FVector4& Start, const struct FVector4& End, float Timer, class UCurveFloat* CurveData, bool bLoop, bool bAutoDestroy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSequencerValueMaterialVectorParameter">();
	}
	static class URSSequencerValueMaterialVectorParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSequencerValueMaterialVectorParameter>();
	}
};
static_assert(alignof(URSSequencerValueMaterialVectorParameter) == 0x000010, "Wrong alignment on URSSequencerValueMaterialVectorParameter");
static_assert(sizeof(URSSequencerValueMaterialVectorParameter) == 0x000080, "Wrong size on URSSequencerValueMaterialVectorParameter");
static_assert(offsetof(URSSequencerValueMaterialVectorParameter, Component) == 0x000050, "Member 'URSSequencerValueMaterialVectorParameter::Component' has a wrong offset!");
static_assert(offsetof(URSSequencerValueMaterialVectorParameter, ParameterName) == 0x000058, "Member 'URSSequencerValueMaterialVectorParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(URSSequencerValueMaterialVectorParameter, StartValue) == 0x000060, "Member 'URSSequencerValueMaterialVectorParameter::StartValue' has a wrong offset!");
static_assert(offsetof(URSSequencerValueMaterialVectorParameter, EndValue) == 0x000070, "Member 'URSSequencerValueMaterialVectorParameter::EndValue' has a wrong offset!");

// Class BattlePrototype.UIShopGetListIndex
// 0x0050 (0x03D8 - 0x0388)
class UUIShopGetListIndex : public UUIBase
{
public:
	uint8                                         Pad_388[0x50];                                     // 0x0388(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimDefaultLock, class UWidgetAnimation* AnimSelectLock, class UWidgetAnimation* AnimSelectInLock, class UImage* ImageNewIcon, class UTextBlock* TextItemName);
	void SetProgressIcon(int32 Progress);
	void UpdateStateThis(int32 State, int32 SubState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopGetListIndex">();
	}
	static class UUIShopGetListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopGetListIndex>();
	}
};
static_assert(alignof(UUIShopGetListIndex) == 0x000008, "Wrong alignment on UUIShopGetListIndex");
static_assert(sizeof(UUIShopGetListIndex) == 0x0003D8, "Wrong size on UUIShopGetListIndex");

// Class BattlePrototype.RSSequencerValueDebugging
// 0x0010 (0x0060 - 0x0050)
class URSSequencerValueDebugging final : public URSSequencerValueBase
{
public:
	class FString                                 Name_0;                                            // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetParameter(const class FString& InName, float Timer, class UCurveFloat* CurveData, bool LoopFlag, bool AutoDestroyFlag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSequencerValueDebugging">();
	}
	static class URSSequencerValueDebugging* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSequencerValueDebugging>();
	}
};
static_assert(alignof(URSSequencerValueDebugging) == 0x000008, "Wrong alignment on URSSequencerValueDebugging");
static_assert(sizeof(URSSequencerValueDebugging) == 0x000060, "Wrong size on URSSequencerValueDebugging");
static_assert(offsetof(URSSequencerValueDebugging, Name_0) == 0x000050, "Member 'URSSequencerValueDebugging::Name_0' has a wrong offset!");

// Class BattlePrototype.RSSequencerValueInterface
// 0x0000 (0x0028 - 0x0028)
class IRSSequencerValueInterface final : public IInterface
{
public:
	void OnDestroySequencer();
	void OnRegisterSequencer();
	bool UpdateSequencer(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSequencerValueInterface">();
	}
	static class IRSSequencerValueInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRSSequencerValueInterface>();
	}
};
static_assert(alignof(IRSSequencerValueInterface) == 0x000008, "Wrong alignment on IRSSequencerValueInterface");
static_assert(sizeof(IRSSequencerValueInterface) == 0x000028, "Wrong size on IRSSequencerValueInterface");

// Class BattlePrototype.RSSkeletalMeshMerger
// 0x0000 (0x0028 - 0x0028)
class URSSkeletalMeshMerger final : public UBlueprintFunctionLibrary
{
public:
	static class USkeletalMesh* MergeSkeletalMeshes(const struct FRSSkeletalMeshMergeParams& Params_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSkeletalMeshMerger">();
	}
	static class URSSkeletalMeshMerger* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSkeletalMeshMerger>();
	}
};
static_assert(alignof(URSSkeletalMeshMerger) == 0x000008, "Wrong alignment on URSSkeletalMeshMerger");
static_assert(sizeof(URSSkeletalMeshMerger) == 0x000028, "Wrong size on URSSkeletalMeshMerger");

// Class BattlePrototype.RSSoundManager
// 0x02A8 (0x04D8 - 0x0230)
class ARSSoundManager : public AActor
{
public:
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URSAtomComponentBase*>           Components;                                        // 0x0240(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URSAtomComponentBase*>           DestroyReserveList;                                // 0x0250(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             FootStepDataTable;                                 // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UCharacterPhysicalSurfaceActionSoundResource*> MapFootStep;                                       // 0x0268(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGeneralPhysicalSurfaceActionSoundResourceArray> MapGeneralPhysicalActions;                         // 0x02B8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class USoundAtomCue*>                  SoundEffectAttackPly;                              // 0x0308(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USoundAtomCue*>                  SoundEffectAttackEmnNormal;                        // 0x0318(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USoundAtomCue*>                  SoundEffectAttackEmnMetal;                         // 0x0328(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSoundEffectAttribute>          SoundEffectAttribute;                              // 0x0338(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSoundEffectDamage>             SoundEffectDamage;                                 // 0x0348(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitSoundIntervalWork;                              // 0x0358(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitSoundInterval;                                  // 0x035C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            CurveBgmTransEffect;                               // 0x0360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLoopSeParam>                   LoopSeList;                                        // 0x0368(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URSAtomComponentBase*>           BgmList;                                           // 0x0378(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCueSheetManager*                  CueSheetManager;                                   // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundPoolManager*                      PoolManager;                                       // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AActor>>          SoundEmitterList;                                  // 0x0398(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USoundAtomCueSheet*>             LoadedVoiceSheet;                                  // 0x03A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 BeforeStageName;                                   // 0x03B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         ScenarioVoiceCueSheetNames;                        // 0x03C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         BondsVoiceCueSheetNames;                           // 0x03D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USoundAtomCueSheet*>             LoadedScenarioVoiceSheet;                          // 0x03E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USoundAtomCueSheet*>             LoadedBondsVoiceSheet;                             // 0x03F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FNotifyPlaySoundReplaceParam>   EnBrainField_DataTableList;                        // 0x0408(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNotifyPlaySoundReplaceProgressIdData> ProgressID_DataTableList;                          // 0x0418(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENotifySoundReplace_EnStr                     M_NotifySoundReplace_EnStr;                        // 0x0428(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_429[0x7];                                      // 0x0429(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNotifyPlaySoundReplaceProgressIdData> ReplaceEnStr_Mid_DataTableList;                    // 0x0430(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNotifyPlaySoundReplaceProgressIdData> ReplaceEnStr_High_DataTableList;                   // 0x0440(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_450[0x8];                                      // 0x0450(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundVolumeController*                 SoundVolumeController;                             // 0x0458(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESoundState                                   SoundState;                                        // 0x0460(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_461[0x3];                                      // 0x0461(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MenuVolumeRate;                                    // 0x0464(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, class USoundAtomCue*>     AdlibCue;                                          // 0x0468(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<class URSAtomComponentBase*>           PlayingAdlibVoices_;                               // 0x04B8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USoundAtomCueSheet*>             SequencerSoundCueSheets;                           // 0x04C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class FString GetSoundSelectorLabelString(ESoundSelectorLabel Label);
	static class FString GetSoundSelectorString(ESoundSelector Selector);

	bool ChangeLanguageVoiceSheet(bool IsJapanese);
	bool ChangeSoundState(ESoundState SndState);
	class URSAtomComponentBase* DoIsVoiceToSpawnSoundAttachedLoadedSheetRS(const class UObject* WorldContextObject, TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAtomCue* Sound, class USceneComponent* AttachToComponent, class FName AttachPointName, class USoundAttenuation* AttenuationSettings, class UObject* Creator);
	float GetBaseSoundVolume(ESoundCategory SoundCategory, const class FString& ParamName);
	class FString GetCueSheetName(class USoundAtomCue* Cue);
	class USoundAtomCue* GetGeneralPhysicalSurfaceActionResource(const EGamePhysicalSurfaceType PhysicsType, class FName ActionType);
	class FString GetLanguageSettingString();
	bool GetPlayerWeaponActorListFromNative(class AActor* OwnerPlayer, EGetPlayerWeaponType Type, TArray<class AActor*>* WeaponList);
	TArray<struct FNotifyPlaySoundReplaceProgressIdData> GetReplaceEnStrDataTableList();
	class USoundAtomCueSheet* GetSoundCueSheet(const class FString& SheetName);
	class AActor* GetSoundEmitter(const int32 Index_0);
	int32 GetSoundEmitterListCount();
	bool IsRegistLoopSe(class FName Name_0);
	bool LoadBondsCueSheet(EPlayerID HeroID, EPlayerID PartnerId);
	class UCharacterPhysicalSurfaceActionSoundResource* LoadFootStep(class FName NameId);
	bool LoadScenarioCueSheet();
	void LoadSequencerSeCueSheet(class ARSLevelSequenceActor* SeqActor);
	void LoadUseAdlibVoicePath(class ULevelSequence* Seq, TArray<class FString>* AdlibVoiceNames, bool bCueReset);
	bool LoadVoiceCueSheetPlayStage(const class FString& SeName);
	int32 Macro_GetPartyTotalExp();
	bool Macro_GetPlayer(ERSPartyPlayerKind Kind, class USkeletalMeshComponent** Mesh, EPlayerID* PlayerId);
	bool Macro_IsSpCostume(ERSPartyPlayerKind Kind);
	void MakeBondsChueSheetName(EPlayerID HeroID, EPlayerID PartnerId, class FString* MakedName);
	class FString MakeCueSheetPath(const class FString& BaseName);
	void OnBrainCrashOn();
	void OnBrainFieldCloseFromNative();
	void OnEDBrainFieldBattleEndNativeEvent(EBrainFieldEndType EndType);
	void OnMessageSkipSePlay();
	void OnSkipEvent();
	bool PauseAllSound();
	bool PauseBgm(EBgmCategory Category, float FadeTime, float FadeVolume);
	bool PauseEnv(float FadeTime, float FadeVolume);
	bool PauseLoopSe(class FName Name_0, float FadeTime, float FadeVolume);
	bool PauseME(float FadeTime, float FadeVolume);
	void PlayAdlibVoiceFromLoadedAsset(const class FString& VoiceName);
	bool PlayBgm(EBgmCategory Category, class USoundAtomCue* AtomCue, float FadeTime, float FadeVolume, bool ForceFirstStart);
	class URSAtomComponentBase* PlayCueWeaponLocation(class AActor* OwnerPlayer, class USoundAtomCue* Sound, EGetPlayerWeaponType WeaponType, TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAttenuation* AttenuationSettings);
	bool PlayEnv(class USoundAtomCue* AtomCue, float FadeTime, float FadeVolume);
	void PlayHitSoundEffect(const struct FHitDamageInfo& Info);
	bool PlayLoopSe(class FName Name_0, class USoundAtomCue* AtomCue, const struct FVector& Location, const struct FRotator& Rotation, float FadeTime, float FadeVolume, bool ForceFirstStart);
	bool PlayME(class USoundAtomCue* AtomCue, float FadeTime, float FadeVolume);
	class URSAtomComponentBase* PlayVoice(class USoundAtomCue* Sound, bool IsAttache, bool IsAutoActivate, class USceneComponent* AttachToComponent, class FName AttachPointName, EFilterCallbackType FilterCallbackType);
	void PlayVoiceAtCue(const class UObject* WorldContextObject, class USoundAtomCue* SoundCue, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy);
	void PlayVoiceAtCueName(const class UObject* WorldContextObject, const class FString& CueName, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy);
	void RegisterComponent(class URSAtomComponentBase* Component);
	bool RegisterCueSheet(class USoundAtomCueSheet* Sheet);
	void RegisterSoundEmitter(class AActor* SoundEmitter);
	void RegistLoopSe(class FName Name_0, class URSAtomComponentBase* PSound);
	bool ReplacedVoiceSheet(bool IsJapanese);
	class USoundAtomCue* ReplaceNotifySound_Native(class USoundAtomCue* InputSound);
	void ResetAllBusBypass(bool Bypass);
	void ResetCharacterCueSheetVolume(const class FString& CharaID);
	void ResetNonPlayerCueSheetVolume();
	bool ResumeBgm(EBgmCategory Category, float FadeTime, float FadeVolume);
	bool ResumeEnv(float FadeTime, float FadeVolume);
	bool ResumeFromPauseAllSound();
	bool ResumeLoopSe(class FName Name_0, float FadeTime, float FadeVolume);
	bool ResumeME(float FadeTime, float FadeVolume);
	class URSAtomComponentBase* RSAtomCuePlay_AnimNotify_Native(class AActor* OwnerPlayer, class USoundAtomCue* Sound, bool UseWeaponLocation, EGetPlayerWeaponType WeaponType, TSubclassOf<class URSAtomComponentBase> ComponentClass, class USceneComponent* AttachToComponent, class FName AttachPointName, class USoundAttenuation* AttenuationSettings, bool IsInvalidProgressIdCheck);
	void SetAisacValue(class UAtomComponent* AtomCom, ESoundCategory Category, ESoundAisacControlId Control, float ControlValue);
	bool SetBaseSoundVolume(ESoundCategory SoundCategory, const class FString& ParamName, float Volume);
	void SetBgmTransEffectValue(const float Rate, const bool IsDirect);
	bool SetBGMVolume(float Volume);
	void SetCharacterCueSheetVolume(const class FString& CharaID);
	bool SetConfigVolumeByCategoryName(ESoundCategory SoundCategory, float DestVolume);
	bool SetFadeAllCategory(float FadeTime, float DestVol);
	bool SetFadeByCategoryName(ESoundCategory Category, float FadeTime, float DestVol);
	bool SetInGameVolumeAll(float DestVol);
	bool SetInGameVolumeByCategoryName(ESoundCategory Category, float DestVol);
	bool SetLoopSEVolume(float Volume);
	bool SetMuteAll();
	void SetNonPlayerCueSheetVolume();
	void SetNotifySoundReplace_EnStr(ENotifySoundReplace_EnStr Param);
	bool SetResumeFromMuteAll();
	void SetSoundBusBypass(EDspBus DspBus, bool Bypass);
	void SetSoundLevelParam(const struct FSoundLevelParam& SoundLevelParam, class UAtomComponent* AtomCom);
	void SetSoundLevelSnapshot(const struct FSoundSnapshot& Snapshot);
	void StopAllAdlibVoice();
	void StopAllSound();
	bool StopBgm(EBgmCategory Category, float FadeTime, float FadeVolume);
	bool StopEnv(float FadeTime, float FadeVolume);
	bool StopLoopSe(class FName Name_0, float FadeTime, float FadeVolume);
	bool StopME(float FadeTime, float FadeVolume);
	bool UnloadFootStep(class FName NameId);
	void UnLoadSequencerSeCueSheet();
	void UnregistAllLoopSe(const bool IsStopSound);
	void UnregisterComponent(class URSAtomComponentBase* Component);
	void UnregisterComponentAll();
	bool UnregisterCueSheet(class USoundAtomCueSheet* Sheet);
	void UnregisterSoundEmitter(class AActor* SoundEmitter);
	void UnregisterSoundEmitterAll();
	void UnregistLoopSe(class FName Name_0);

	class USoundCueSheetManager* GetCueSheetManager() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSoundManager">();
	}
	static class ARSSoundManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSSoundManager>();
	}
};
static_assert(alignof(ARSSoundManager) == 0x000008, "Wrong alignment on ARSSoundManager");
static_assert(sizeof(ARSSoundManager) == 0x0004D8, "Wrong size on ARSSoundManager");
static_assert(offsetof(ARSSoundManager, Components) == 0x000240, "Member 'ARSSoundManager::Components' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, DestroyReserveList) == 0x000250, "Member 'ARSSoundManager::DestroyReserveList' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, FootStepDataTable) == 0x000260, "Member 'ARSSoundManager::FootStepDataTable' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, MapFootStep) == 0x000268, "Member 'ARSSoundManager::MapFootStep' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, MapGeneralPhysicalActions) == 0x0002B8, "Member 'ARSSoundManager::MapGeneralPhysicalActions' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, SoundEffectAttackPly) == 0x000308, "Member 'ARSSoundManager::SoundEffectAttackPly' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, SoundEffectAttackEmnNormal) == 0x000318, "Member 'ARSSoundManager::SoundEffectAttackEmnNormal' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, SoundEffectAttackEmnMetal) == 0x000328, "Member 'ARSSoundManager::SoundEffectAttackEmnMetal' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, SoundEffectAttribute) == 0x000338, "Member 'ARSSoundManager::SoundEffectAttribute' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, SoundEffectDamage) == 0x000348, "Member 'ARSSoundManager::SoundEffectDamage' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, HitSoundIntervalWork) == 0x000358, "Member 'ARSSoundManager::HitSoundIntervalWork' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, HitSoundInterval) == 0x00035C, "Member 'ARSSoundManager::HitSoundInterval' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, CurveBgmTransEffect) == 0x000360, "Member 'ARSSoundManager::CurveBgmTransEffect' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, LoopSeList) == 0x000368, "Member 'ARSSoundManager::LoopSeList' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, BgmList) == 0x000378, "Member 'ARSSoundManager::BgmList' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, CueSheetManager) == 0x000388, "Member 'ARSSoundManager::CueSheetManager' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, PoolManager) == 0x000390, "Member 'ARSSoundManager::PoolManager' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, SoundEmitterList) == 0x000398, "Member 'ARSSoundManager::SoundEmitterList' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, LoadedVoiceSheet) == 0x0003A8, "Member 'ARSSoundManager::LoadedVoiceSheet' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, BeforeStageName) == 0x0003B8, "Member 'ARSSoundManager::BeforeStageName' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, ScenarioVoiceCueSheetNames) == 0x0003C8, "Member 'ARSSoundManager::ScenarioVoiceCueSheetNames' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, BondsVoiceCueSheetNames) == 0x0003D8, "Member 'ARSSoundManager::BondsVoiceCueSheetNames' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, LoadedScenarioVoiceSheet) == 0x0003E8, "Member 'ARSSoundManager::LoadedScenarioVoiceSheet' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, LoadedBondsVoiceSheet) == 0x0003F8, "Member 'ARSSoundManager::LoadedBondsVoiceSheet' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, EnBrainField_DataTableList) == 0x000408, "Member 'ARSSoundManager::EnBrainField_DataTableList' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, ProgressID_DataTableList) == 0x000418, "Member 'ARSSoundManager::ProgressID_DataTableList' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, M_NotifySoundReplace_EnStr) == 0x000428, "Member 'ARSSoundManager::M_NotifySoundReplace_EnStr' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, ReplaceEnStr_Mid_DataTableList) == 0x000430, "Member 'ARSSoundManager::ReplaceEnStr_Mid_DataTableList' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, ReplaceEnStr_High_DataTableList) == 0x000440, "Member 'ARSSoundManager::ReplaceEnStr_High_DataTableList' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, SoundVolumeController) == 0x000458, "Member 'ARSSoundManager::SoundVolumeController' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, SoundState) == 0x000460, "Member 'ARSSoundManager::SoundState' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, MenuVolumeRate) == 0x000464, "Member 'ARSSoundManager::MenuVolumeRate' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, AdlibCue) == 0x000468, "Member 'ARSSoundManager::AdlibCue' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, PlayingAdlibVoices_) == 0x0004B8, "Member 'ARSSoundManager::PlayingAdlibVoices_' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, SequencerSoundCueSheets) == 0x0004C8, "Member 'ARSSoundManager::SequencerSoundCueSheets' has a wrong offset!");

// Class BattlePrototype.RSSplineMeshComponent
// 0x0020 (0x0550 - 0x0530)
class URSSplineMeshComponent final : public USplineMeshComponent
{
public:
	bool                                          bRsCastDynamicShadow;                              // 0x0530(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsCastStaticShadow;                               // 0x0531(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsCanEverAffectNavigation;                        // 0x0532(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsOverrideLightMapRes;                            // 0x0533(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsUseTwoSidedLighting;                            // 0x0534(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsCastShadowAsTwoSided;                           // 0x0535(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_536[0x2];                                      // 0x0536(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RsOverriddenLightMapRes;                           // 0x0538(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsLightmapTypeForceVolumetric;                    // 0x053C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsVisibleInReflectionCaptures;                    // 0x053D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53E[0x2];                                      // 0x053E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RsMinDrawDistance;                                 // 0x0540(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RsLDMaxDrawDistance;                               // 0x0544(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsAllowCullDistanceVolume;                        // 0x0548(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_549[0x7];                                      // 0x0549(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSplineMeshComponent">();
	}
	static class URSSplineMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSplineMeshComponent>();
	}
};
static_assert(alignof(URSSplineMeshComponent) == 0x000010, "Wrong alignment on URSSplineMeshComponent");
static_assert(sizeof(URSSplineMeshComponent) == 0x000550, "Wrong size on URSSplineMeshComponent");
static_assert(offsetof(URSSplineMeshComponent, bRsCastDynamicShadow) == 0x000530, "Member 'URSSplineMeshComponent::bRsCastDynamicShadow' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, bRsCastStaticShadow) == 0x000531, "Member 'URSSplineMeshComponent::bRsCastStaticShadow' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, bRsCanEverAffectNavigation) == 0x000532, "Member 'URSSplineMeshComponent::bRsCanEverAffectNavigation' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, bRsOverrideLightMapRes) == 0x000533, "Member 'URSSplineMeshComponent::bRsOverrideLightMapRes' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, bRsUseTwoSidedLighting) == 0x000534, "Member 'URSSplineMeshComponent::bRsUseTwoSidedLighting' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, bRsCastShadowAsTwoSided) == 0x000535, "Member 'URSSplineMeshComponent::bRsCastShadowAsTwoSided' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, RsOverriddenLightMapRes) == 0x000538, "Member 'URSSplineMeshComponent::RsOverriddenLightMapRes' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, bRsLightmapTypeForceVolumetric) == 0x00053C, "Member 'URSSplineMeshComponent::bRsLightmapTypeForceVolumetric' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, bRsVisibleInReflectionCaptures) == 0x00053D, "Member 'URSSplineMeshComponent::bRsVisibleInReflectionCaptures' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, RsMinDrawDistance) == 0x000540, "Member 'URSSplineMeshComponent::RsMinDrawDistance' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, RsLDMaxDrawDistance) == 0x000544, "Member 'URSSplineMeshComponent::RsLDMaxDrawDistance' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, bRsAllowCullDistanceVolume) == 0x000548, "Member 'URSSplineMeshComponent::bRsAllowCullDistanceVolume' has a wrong offset!");

// Class BattlePrototype.RSStateComponent
// 0x0010 (0x00D0 - 0x00C0)
class URSStateComponent : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndProcess();
	int32 Enter(int32 Param);
	int32 Exit(int32 NextStateIndex);
	void NextProcess();
	void SetProcess(int32 NextProcess);
	void SetState(int32 StateIndex, int32 Param);
	bool Transition();
	int32 Update();

	int32 GetProcess() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSStateComponent">();
	}
	static class URSStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSStateComponent>();
	}
};
static_assert(alignof(URSStateComponent) == 0x000008, "Wrong alignment on URSStateComponent");
static_assert(sizeof(URSStateComponent) == 0x0000D0, "Wrong size on URSStateComponent");

// Class BattlePrototype.RSStateManageComponent
// 0x0028 (0x00E8 - 0x00C0)
class URSStateManageComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             DispatchEnterState;                                // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize(const TArray<class URSStateComponent*>& StateList);
	void SetState(int32 StateIndex, int32 Param);
	void Update();

	int32 GetCurrentStateIndex() const;
	int32 GetPrevStateIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSStateManageComponent">();
	}
	static class URSStateManageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSStateManageComponent>();
	}
};
static_assert(alignof(URSStateManageComponent) == 0x000008, "Wrong alignment on URSStateManageComponent");
static_assert(sizeof(URSStateManageComponent) == 0x0000E8, "Wrong size on URSStateManageComponent");
static_assert(offsetof(URSStateManageComponent, DispatchEnterState) == 0x0000C0, "Member 'URSStateManageComponent::DispatchEnterState' has a wrong offset!");

// Class BattlePrototype.UIItemTradeListIndex
// 0x00D0 (0x0458 - 0x0388)
class UUIItemTradeListIndex : public UUIBase
{
public:
	uint8                                         Pad_388[0xD0];                                     // 0x0388(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDefaultEnough, class UWidgetAnimation* AnimDefaultMax, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectEnough, class UWidgetAnimation* AnimSelectMax, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectInEnough, class UWidgetAnimation* AnimSelectInMax, class UWidgetAnimation* AnimSelect2, class UWidgetAnimation* AnimSelect2Enough, class UWidgetAnimation* AnimSelect2Max, class UWidgetAnimation* AnimChangeTradeItemIn, class UWidgetAnimation* AnimChangeTradeItemInEnough, class UWidgetAnimation* AnimChangeTradeItemInMax, class UWidgetAnimation* AnimChangeTradeItemOut, class UWidgetAnimation* AnimChangeTradeItemOutEnough, class UWidgetAnimation* AnimChangeTradeItemOutMax, class UImage* ImageNewIcon, class UImage* ImageWish, class UTextBlock* TextItemName, class UTextBlock* TextNumHave);
	bool SetItemInfo(const class FName& ItemId, int32 TradeItemIndex, bool CanTrade, int32 TakeNum);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemTradeListIndex">();
	}
	static class UUIItemTradeListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemTradeListIndex>();
	}
};
static_assert(alignof(UUIItemTradeListIndex) == 0x000008, "Wrong alignment on UUIItemTradeListIndex");
static_assert(sizeof(UUIItemTradeListIndex) == 0x000458, "Wrong size on UUIItemTradeListIndex");

// Class BattlePrototype.RSStaticEventCharaAnimInstance
// 0x0010 (0x0280 - 0x0270)
class URSStaticEventCharaAnimInstance : public UAnimInstance
{
public:
	float                                         EyeXAxisValue;                                     // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeYAxisValue;                                     // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeBlendWeight;                                    // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSStaticEventCharaAnimInstance">();
	}
	static class URSStaticEventCharaAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSStaticEventCharaAnimInstance>();
	}
};
static_assert(alignof(URSStaticEventCharaAnimInstance) == 0x000010, "Wrong alignment on URSStaticEventCharaAnimInstance");
static_assert(sizeof(URSStaticEventCharaAnimInstance) == 0x000280, "Wrong size on URSStaticEventCharaAnimInstance");
static_assert(offsetof(URSStaticEventCharaAnimInstance, EyeXAxisValue) == 0x000270, "Member 'URSStaticEventCharaAnimInstance::EyeXAxisValue' has a wrong offset!");
static_assert(offsetof(URSStaticEventCharaAnimInstance, EyeYAxisValue) == 0x000274, "Member 'URSStaticEventCharaAnimInstance::EyeYAxisValue' has a wrong offset!");
static_assert(offsetof(URSStaticEventCharaAnimInstance, EyeBlendWeight) == 0x000278, "Member 'URSStaticEventCharaAnimInstance::EyeBlendWeight' has a wrong offset!");

// Class BattlePrototype.RSStaticMeshComponent
// 0x0020 (0x04C0 - 0x04A0)
class URSStaticMeshComponent final : public UStaticMeshComponent
{
public:
	bool                                          bRsCastDynamicShadow;                              // 0x0498(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsCastStaticShadow;                               // 0x0499(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsCanEverAffectNavigation;                        // 0x049A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsOverrideLightMapRes;                            // 0x049B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsUseTwoSidedLighting;                            // 0x049C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsCastShadowAsTwoSided;                           // 0x049D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49E[0x2];                                      // 0x049E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RsOverriddenLightMapRes;                           // 0x04A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsLightmapTypeForceVolumetric;                    // 0x04A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsVisibleInReflectionCaptures;                    // 0x04A5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A6[0x2];                                      // 0x04A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RsMinDrawDistance;                                 // 0x04A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RsLDMaxDrawDistance;                               // 0x04AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRsAllowCullDistanceVolume : 1;                    // 0x04B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4B1[0xF];                                      // 0x04B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSStaticMeshComponent">();
	}
	static class URSStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSStaticMeshComponent>();
	}
};
static_assert(alignof(URSStaticMeshComponent) == 0x000010, "Wrong alignment on URSStaticMeshComponent");
static_assert(sizeof(URSStaticMeshComponent) == 0x0004C0, "Wrong size on URSStaticMeshComponent");
static_assert(offsetof(URSStaticMeshComponent, bRsCastDynamicShadow) == 0x000498, "Member 'URSStaticMeshComponent::bRsCastDynamicShadow' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, bRsCastStaticShadow) == 0x000499, "Member 'URSStaticMeshComponent::bRsCastStaticShadow' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, bRsCanEverAffectNavigation) == 0x00049A, "Member 'URSStaticMeshComponent::bRsCanEverAffectNavigation' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, bRsOverrideLightMapRes) == 0x00049B, "Member 'URSStaticMeshComponent::bRsOverrideLightMapRes' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, bRsUseTwoSidedLighting) == 0x00049C, "Member 'URSStaticMeshComponent::bRsUseTwoSidedLighting' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, bRsCastShadowAsTwoSided) == 0x00049D, "Member 'URSStaticMeshComponent::bRsCastShadowAsTwoSided' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, RsOverriddenLightMapRes) == 0x0004A0, "Member 'URSStaticMeshComponent::RsOverriddenLightMapRes' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, bRsLightmapTypeForceVolumetric) == 0x0004A4, "Member 'URSStaticMeshComponent::bRsLightmapTypeForceVolumetric' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, bRsVisibleInReflectionCaptures) == 0x0004A5, "Member 'URSStaticMeshComponent::bRsVisibleInReflectionCaptures' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, RsMinDrawDistance) == 0x0004A8, "Member 'URSStaticMeshComponent::RsMinDrawDistance' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, RsLDMaxDrawDistance) == 0x0004AC, "Member 'URSStaticMeshComponent::RsLDMaxDrawDistance' has a wrong offset!");

// Class BattlePrototype.RSTimeManager
// 0x0000 (0x0028 - 0x0028)
class URSTimeManager final : public UBlueprintFunctionLibrary
{
public:
	static float GetActorDeltaSeconds(const class AActor* Actor);
	static float GetActorIgnoreHitStop(float HitStopRate);
	static float GetSystemDeltaSeconds(const class UObject* Object);
	static float GetWorldNormalDeltaSeconds(const class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSTimeManager">();
	}
	static class URSTimeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSTimeManager>();
	}
};
static_assert(alignof(URSTimeManager) == 0x000008, "Wrong alignment on URSTimeManager");
static_assert(sizeof(URSTimeManager) == 0x000028, "Wrong size on URSTimeManager");

// Class BattlePrototype.RSTitleAnimInstance
// 0x0010 (0x0630 - 0x0620)
class URSTitleAnimInstance final : public URSCharacterAnimInstance
{
public:
	ETitleAnime                                   NowAnimKind;                                       // 0x0620(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETitleAnime                                   RequestAnimKind;                                   // 0x0621(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_622[0xE];                                      // 0x0622(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetRequestAnimKind(ETitleAnime Type);

	ETitleAnime GetNowAnimKind() const;
	bool IsExistRequest() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSTitleAnimInstance">();
	}
	static class URSTitleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSTitleAnimInstance>();
	}
};
static_assert(alignof(URSTitleAnimInstance) == 0x000010, "Wrong alignment on URSTitleAnimInstance");
static_assert(sizeof(URSTitleAnimInstance) == 0x000630, "Wrong size on URSTitleAnimInstance");
static_assert(offsetof(URSTitleAnimInstance, NowAnimKind) == 0x000620, "Member 'URSTitleAnimInstance::NowAnimKind' has a wrong offset!");
static_assert(offsetof(URSTitleAnimInstance, RequestAnimKind) == 0x000621, "Member 'URSTitleAnimInstance::RequestAnimKind' has a wrong offset!");

// Class BattlePrototype.UILoadingChapter
// 0x0058 (0x03E0 - 0x0388)
class UUILoadingChapter : public UUIBase
{
public:
	uint8                                         Pad_388[0x58];                                     // 0x0388(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextTitle, class UTextBlock* TextInfo, class UImage* ImageLocation, class UREDRetainerBox* RetainerBoxNoise1);
	void SetId(int32 ID);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	void IsClosable(bool* Closable) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILoadingChapter">();
	}
	static class UUILoadingChapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILoadingChapter>();
	}
};
static_assert(alignof(UUILoadingChapter) == 0x000008, "Wrong alignment on UUILoadingChapter");
static_assert(sizeof(UUILoadingChapter) == 0x0003E0, "Wrong size on UUILoadingChapter");

// Class BattlePrototype.RSTitleManager
// 0x00B8 (0x02E8 - 0x0230)
class ARSTitleManager final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             M_OnTitleEventSaveLoadError;                       // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             M_OnTitleEventSoundEnd;                            // 0x0248(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             M_OnTitleEventSoundStart;                          // 0x0258(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                M_paFirstFlowFonts[0x4];                           // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMultiLanguageTextData*                 M_pMultiLanguageTextData;                          // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserParamManager*                      UserParamManager;                                  // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARSHUDBase*                             M_pRSHudBase;                                      // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDatabaseManager*                       DatabaseManager;                                   // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URSGameInstance*                        M_pGameInstance;                                   // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URSSaveGame*                            M_pSaveSystem;                                     // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URSSaveGame*                            M_pSaveGame;                                       // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URSSaveGame*                            M_pAutoSave;                                       // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pSaveLoadParamManager;                           // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pAutoSaveLoadParamManager;                       // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pSaveLoadSystemParamManager;                     // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class URSTitleAnimInstance* GetKasaneAnimInstance();
	class ASkeletalMeshActor* GetKasaneMesh();
	class URSTitleAnimInstance* GetYuitoAnimInstance();
	class ASkeletalMeshActor* GetYuitoMesh();
	void InitializeAutoSaveSlotSetting();
	void InitializeSaveSlotSetting();
	bool IsChapterZeroCrear();
	bool IsClearChara(int32 SlotNo, bool* Yuito, bool* Kasane);
	bool IsClearData();
	bool IsClearEXNewRelease();
	bool IsEndGeneralChoice();
	bool IsEnding();
	bool IsFirstFlow();
	bool IsGameClearData();
	bool IsPlayMovie();
	bool IsPlaySequencer();
	bool IsReadyMovie();
	bool IsSaveData();
	bool IsStopMovie();
	bool IsStreamingLevelLoaded();
	bool IsValidUser();
	bool Pause(bool Flag);
	bool PlayMovie();
	bool PlaySequencer(const class FText& bindPlayName);
	bool PlaySequencerType(EUITitleSequencer Type, const class FText& bindPlayName);
	bool SaveDataErrorCheck(ETitleSaveCheck CheckType);
	bool SetEffectKill(class FName ChName);
	bool SetKasaneEffect();
	bool SetMaterialEffectKill();
	void SetPlaySequencerType();
	void SetSaveLoadScreenParam(class USaveLoadScreenParamManager* SaveLoad, class USaveLoadScreenParamManager* AutoSave);
	bool SettingMovie();
	bool SetYuitoEffect();
	bool StopMovie();
	bool SystemSaveDataErrorCheck();
	void TitleLSResetBindings();
	void TitleToLogojump();

	bool IsTitleBackStatic() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSTitleManager">();
	}
	static class ARSTitleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSTitleManager>();
	}
};
static_assert(alignof(ARSTitleManager) == 0x000008, "Wrong alignment on ARSTitleManager");
static_assert(sizeof(ARSTitleManager) == 0x0002E8, "Wrong size on ARSTitleManager");
static_assert(offsetof(ARSTitleManager, M_OnTitleEventSaveLoadError) == 0x000238, "Member 'ARSTitleManager::M_OnTitleEventSaveLoadError' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_OnTitleEventSoundEnd) == 0x000248, "Member 'ARSTitleManager::M_OnTitleEventSoundEnd' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_OnTitleEventSoundStart) == 0x000258, "Member 'ARSTitleManager::M_OnTitleEventSoundStart' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_paFirstFlowFonts) == 0x000270, "Member 'ARSTitleManager::M_paFirstFlowFonts' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_pMultiLanguageTextData) == 0x000290, "Member 'ARSTitleManager::M_pMultiLanguageTextData' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, UserParamManager) == 0x000298, "Member 'ARSTitleManager::UserParamManager' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_pRSHudBase) == 0x0002A0, "Member 'ARSTitleManager::M_pRSHudBase' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, DatabaseManager) == 0x0002A8, "Member 'ARSTitleManager::DatabaseManager' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_pGameInstance) == 0x0002B0, "Member 'ARSTitleManager::M_pGameInstance' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_pSaveSystem) == 0x0002B8, "Member 'ARSTitleManager::M_pSaveSystem' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_pSaveGame) == 0x0002C0, "Member 'ARSTitleManager::M_pSaveGame' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_pAutoSave) == 0x0002C8, "Member 'ARSTitleManager::M_pAutoSave' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_pSaveLoadParamManager) == 0x0002D0, "Member 'ARSTitleManager::M_pSaveLoadParamManager' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_pAutoSaveLoadParamManager) == 0x0002D8, "Member 'ARSTitleManager::M_pAutoSaveLoadParamManager' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_pSaveLoadSystemParamManager) == 0x0002E0, "Member 'ARSTitleManager::M_pSaveLoadSystemParamManager' has a wrong offset!");

// Class BattlePrototype.RSToolFuncLib
// 0x0000 (0x0028 - 0x0028)
class URSToolFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void CaptureProfileGPU(const class FString& OutputFileName);
	static void CheckCaptureMovie();
	static class UActorComponent* EditorAddActorComponent(class AActor* ActorInstance, class UClass* ComponentClass, bool IsMovable);
	static void EditorCallConstructionScript(class AActor* ActorInstance);
	static void EditorClipboardCopy(const class FString& Text);
	static void EditorDumpReferenceAsset(class UObject* Target);
	static void EditorDumpReferencerAsset(class UObject* Target);
	static void EditorFlushInstancedStaticMesh(class UInstancedStaticMeshComponent* Component, bool* HasError);
	static void EditorLogInstancedStaticMesh(class UInstancedStaticMeshComponent* Component);
	static void EditorRefreshMaterial(class UMaterialInterface* Material);
	static bool EditorRemoveActorComponent(class AActor* Actor, class UActorComponent* Component);
	static void EditorSearchReferenceAsset(class UObject* Target, const TArray<class UObject*>& SearchList);
	static void EditorSearchReferenceFromClassList(class UObject* Target, const TArray<class UClass*>& SearchList);
	static void EditorSearchReferencerAsset(class UObject* Target, const TArray<class UObject*>& SearchList);
	static void EditorSetCanEverAffectNavigation(class UActorComponent* Component, bool Enable);
	static void EditorSetComponentAttachParentBound(class USceneComponent* Component, bool Enable);
	static void EditorSetComponentDiffuseBoost(class UPrimitiveComponent* Component, float Value);
	static void EditorSetComponentDynamicShadow(class UPrimitiveComponent* Component, bool Enable);
	static void EditorSetComponentEmissiveBoost(class UPrimitiveComponent* Component, float Value);
	static void EditorSetComponentEmissiveForStaticLighting(class UPrimitiveComponent* Component, bool Enable);
	static void EditorSetComponentLightmapResolution(class UPrimitiveComponent* Component, bool Enable, int32 Resolution);
	static void EditorSetComponentMobility(class USceneComponent* Component, EEditorMobility Mobility);
	static void EditorSetComponentStartAwake(class UPrimitiveComponent* Component, bool Enable);
	static void EditorSetComponentStaticShadow(class UPrimitiveComponent* Component, bool Enable);
	static void EndCaptureMovie();
	static void GetDevelopUObjectCount(const TArray<class UClass*>& ClassList, TArray<int32>* CountList, bool ChildClass);
	static void SetupDrawEvents(class UObject* WorldContextObject, bool Enable);
	static void StartCaptureMovie(const class FString& OutputFileName, int32 RecordSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSToolFuncLib">();
	}
	static class URSToolFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSToolFuncLib>();
	}
};
static_assert(alignof(URSToolFuncLib) == 0x000008, "Wrong alignment on URSToolFuncLib");
static_assert(sizeof(URSToolFuncLib) == 0x000028, "Wrong size on URSToolFuncLib");

// Class BattlePrototype.RSUniqueIdInterface
// 0x0000 (0x0028 - 0x0028)
class IRSUniqueIdInterface final : public IInterface
{
public:
	class FName GetEnemyDeadReplaceLogName() const;
	int32 GetUniqueId() const;
	class FName GetUniqueName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSUniqueIdInterface">();
	}
	static class IRSUniqueIdInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRSUniqueIdInterface>();
	}
};
static_assert(alignof(IRSUniqueIdInterface) == 0x000008, "Wrong alignment on IRSUniqueIdInterface");
static_assert(sizeof(IRSUniqueIdInterface) == 0x000028, "Wrong size on IRSUniqueIdInterface");

// Class BattlePrototype.RSUniqueIdComponent
// 0x0010 (0x00D0 - 0x00C0)
class URSUniqueIdComponent final : public UActorComponent
{
public:
	int32                                         ID;                                                // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   Name_0;                                            // 0x00C4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetId(int32 InId);
	void SetName(class FName InName);

	int32 GetId() const;
	const class FName GetName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSUniqueIdComponent">();
	}
	static class URSUniqueIdComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSUniqueIdComponent>();
	}
};
static_assert(alignof(URSUniqueIdComponent) == 0x000008, "Wrong alignment on URSUniqueIdComponent");
static_assert(sizeof(URSUniqueIdComponent) == 0x0000D0, "Wrong size on URSUniqueIdComponent");
static_assert(offsetof(URSUniqueIdComponent, ID) == 0x0000C0, "Member 'URSUniqueIdComponent::ID' has a wrong offset!");
static_assert(offsetof(URSUniqueIdComponent, Name_0) == 0x0000C4, "Member 'URSUniqueIdComponent::Name_0' has a wrong offset!");

// Class BattlePrototype.UIMainContents
// 0x0048 (0x03D0 - 0x0388)
class UUIMainContents : public UUIBase
{
public:
	TArray<class UUIBase*>                        MenuList;                                          // 0x0388(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIConfigGame*                          UIConfig;                                          // 0x0398(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MenuIndex;                                         // 0x03A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MenuIndexNext;                                     // 0x03A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MenuIndexBackup;                                   // 0x03A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TabEnableFlag;                                     // 0x03AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MIsBrainMessageAutoMode;                           // 0x03B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B1[0x3];                                      // 0x03B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MBrainMessageDefaultThreadID;                      // 0x03B4(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MIsMenuSingle;                                     // 0x03BC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3BD[0x13];                                     // 0x03BD(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimPressButtonL();
	void AnimPressButtonR();
	void ControlFunc(int32 SubState);
	bool Create3DView();
	bool IsEndCurrentMenu();
	bool Release3DView();
	bool ResetReplyBondsEpisodeFlag();
	bool ResetWeaponMenuDefaultCursor();
	bool SetBrainMapCursorCorrectArea(float Area);
	bool SetBrainMapCursorCorrectSpeed(float Speed);
	bool SetBrainMapCursorSpeed(float Speed);
	void SetBrainMessageAutoMode(bool IsAuto);
	void SetBrainMessageDefaultThread(class FName ThreadID);
	bool SetChangeMainMenuTab(int32 Nextindex);
	bool SetChangeMainMenuTabL();
	bool SetChangeMainMenuTabR();
	bool SetMouseEnableMode(bool Flag);
	void SetOnlyBrainMessage(bool IsOnlyBrainMessage);
	void SetOnlyEnemyBooks(bool IsOnlyEnemyBooks);
	void SetOnlyWeaponMenu(bool IsOnlyWeaponMenu);
	void SetPopupMode(bool IsPopupMode);
	void SetStartBrainMessage(bool IsDefaultBrainMessage);
	void SetTabEnable(int32 Index_0, bool IsEnable);
	void SetViewerMode(bool IsViewerMode);
	bool SetWeaponMenuDefaultCursor(EPlayerID CharaID, bool IsVisual);

	float GetBrainMapCursorCorrectArea() const;
	float GetBrainMapCursorCorrectSpeed() const;
	float GetBrainMapCursorSpeed() const;
	bool IsLockTabChange() const;
	bool IsOnlyBrainMessage() const;
	bool IsOnlyEnemyBooks() const;
	bool IsOnlyWeaponMenu() const;
	bool IsPopupMode() const;
	bool IsReplyBondsEpisode() const;
	bool IsStartBrainMessage() const;
	bool IsTabEnable(int32 Index_0) const;
	bool IsViewerMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMainContents">();
	}
	static class UUIMainContents* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMainContents>();
	}
};
static_assert(alignof(UUIMainContents) == 0x000008, "Wrong alignment on UUIMainContents");
static_assert(sizeof(UUIMainContents) == 0x0003D0, "Wrong size on UUIMainContents");
static_assert(offsetof(UUIMainContents, MenuList) == 0x000388, "Member 'UUIMainContents::MenuList' has a wrong offset!");
static_assert(offsetof(UUIMainContents, UIConfig) == 0x000398, "Member 'UUIMainContents::UIConfig' has a wrong offset!");
static_assert(offsetof(UUIMainContents, MenuIndex) == 0x0003A0, "Member 'UUIMainContents::MenuIndex' has a wrong offset!");
static_assert(offsetof(UUIMainContents, MenuIndexNext) == 0x0003A4, "Member 'UUIMainContents::MenuIndexNext' has a wrong offset!");
static_assert(offsetof(UUIMainContents, MenuIndexBackup) == 0x0003A8, "Member 'UUIMainContents::MenuIndexBackup' has a wrong offset!");
static_assert(offsetof(UUIMainContents, TabEnableFlag) == 0x0003AC, "Member 'UUIMainContents::TabEnableFlag' has a wrong offset!");
static_assert(offsetof(UUIMainContents, MIsBrainMessageAutoMode) == 0x0003B0, "Member 'UUIMainContents::MIsBrainMessageAutoMode' has a wrong offset!");
static_assert(offsetof(UUIMainContents, MBrainMessageDefaultThreadID) == 0x0003B4, "Member 'UUIMainContents::MBrainMessageDefaultThreadID' has a wrong offset!");
static_assert(offsetof(UUIMainContents, MIsMenuSingle) == 0x0003BC, "Member 'UUIMainContents::MIsMenuSingle' has a wrong offset!");

// Class BattlePrototype.RSUniqueIdFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URSUniqueIdFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsCharacterFromUniqueId(int32 ID);
	static bool IsCharacterFromUniqueName(class FName Name_0);
	static bool IsEnemyFromUniqueId(int32 ID);
	static bool IsEnemyFromUniqueName(class FName Name_0);
	static bool IsENPCFromUniqueId(int32 ID);
	static bool IsENPCFromUniqueName(class FName Name_0);
	static bool IsItemFromUniqueId(int32 ID);
	static bool IsItemFromUniqueName(class FName Name_0);
	static bool IsPlayerFromUniqueId(int32 ID);
	static bool IsPlayerFromUniqueName(class FName Name_0);
	static bool IsWeaponFromUniqueId(int32 ID);
	static bool IsWeaponFromUniqueName(class FName Name_0);
	static int32 UniqueIdFromName(class FName Name_0);
	static class FName UniqueNameFromId(int32 ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSUniqueIdFunctionLibrary">();
	}
	static class URSUniqueIdFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSUniqueIdFunctionLibrary>();
	}
};
static_assert(alignof(URSUniqueIdFunctionLibrary) == 0x000008, "Wrong alignment on URSUniqueIdFunctionLibrary");
static_assert(sizeof(URSUniqueIdFunctionLibrary) == 0x000028, "Wrong size on URSUniqueIdFunctionLibrary");

// Class BattlePrototype.RSUtilityEventFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URSUtilityEventFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FName> GetMovieTextureNameListFromMakeEventActor(TSubclassOf<class AActor> MakeEventActorClass);
	static TArray<class FName> GetPresetNameListFromMakeEventActor(TSubclassOf<class AActor> MakeEventActorClass);
	static class FString GetStandbyPhaseFromProgressID(int32 ProgressId);
	static TArray<class FName> GetTextureNameListFromMakeEventActor(TSubclassOf<class AActor> MakeEventActorClass);
	static void SetupCutsceneHideDitherSaveShop(class UObject* WorldContextObject, float DitherRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSUtilityEventFunctionLibrary">();
	}
	static class URSUtilityEventFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSUtilityEventFunctionLibrary>();
	}
};
static_assert(alignof(URSUtilityEventFunctionLibrary) == 0x000008, "Wrong alignment on URSUtilityEventFunctionLibrary");
static_assert(sizeof(URSUtilityEventFunctionLibrary) == 0x000028, "Wrong size on URSUtilityEventFunctionLibrary");

// Class BattlePrototype.RSUtilityLibrary
// 0x0000 (0x0028 - 0x0028)
class URSUtilityLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString AddAssetPathPrefix(const class FString& Path, const class FString& Prefix, int32 Index_0);
	static class FString AddAssetPathSuffix(const class FString& Path, const class FString& Suffix, int32 LastIndex);
	static struct FWeightedBlendables AddPostProcessMaterials(const struct FWeightedBlendables& BaseMaterials, const struct FWeightedBlendables& OverrideMaterials, float Weight);
	static struct FPostProcessSettings AddPostProcessSettings(const struct FPostProcessSettings& BaseSettings, const struct FPostProcessSettings& OverrideSettings, float Weight);
	static struct FPostProcessSettings AddPostProcessSettingsCamera(const struct FPostProcessSettings& BaseSettings, class UCineCameraComponent* OverrideCamera);
	static void AddStageParameterSettings(const struct FStageParameterSettings& BaseSetting, const struct FStageParameterSettings& OverrideSetting, float Weight, struct FStageParameterSettings* OutSettings);
	static bool ApplyDLC(const class UObject* WorldContextObject, class FName ContentsName, bool IsForceApply);
	static void BackToTitle(const class UObject* WorldContextObject, const bool bAccountReset);
	static bool BitFlagCheck(int32 Flag, int32 bitIndex);
	static int32 BitFlagOff(int32 Flag, int32 bitIndex);
	static int32 BitFlagOn(int32 Flag, int32 bitIndex);
	static struct FPostProcessSettings CalcPostProcessVolume(const TArray<class APostProcessVolume*>& PostProcessLists, const struct FVector& Location, bool CheckEnable);
	static struct FTransform CalcRootMotionTransform(class USkeletalMeshComponent* Mesh, bool bWorld);
	static struct FPostProcessSettings CalcSceneCapturePostProcessSettings(class USceneCaptureComponent2D* SceneCapture, const TArray<class APostProcessVolume*>& PostProcessLists, const struct FVector& Location, bool CheckEnable);
	static struct FPostProcessSettings CalcScenePostProcessVolume(class UObject* WorldContextObject, const struct FVector& Location, bool CheckEnable);
	static struct FPostProcessSettings CalcStaticCapturePostProcessSettings(class USceneCaptureComponent2D* SceneCapture, const TArray<class APostProcessVolume*>& PostProcessLists, const TArray<struct FPostProcessSettings>& AddPPSs, const struct FVector& Location, float AddPPSPriority, bool CheckEnable);
	static void ClearMainViewTemporalBuffer();
	static void ClearPlayerOverlapEvent(const class UObject* WorldContextObject);
	static bool CompareSkeleton(class UAnimSequence* AnimSequence, class USkeletalMeshComponent* SkelMeshComp);
	static bool ConstructLocalEntitleData(const class UObject* WorldContextObject);
	static class FString ConvertAssetPathPlatformName(const class FString& Path);
	static E_SASKindNative ConvertPlayerIDtoSAS(EPlayerID PlayerId);
	static EPlayerID ConvertSAStoPlayerID(E_SASKindNative SasKind);
	static void CopyBaseCineCameraToCineCamera(class UCineCameraComponent* BaseCineCamera, class UCineCameraComponent* ToCineCamera);
	static void CopySequencerTemplateToCineCamera(class ARSLevelSequenceActor* Sequencer, const struct FMovieSceneObjectBindingID& BindingID, class UCineCameraComponent* CineCamera);
	static class UMaterialInstanceDynamic* CreateDynamicMaterialInstanceFromName_Mesh(class UMeshComponent* MeshComponent, const class FName MaterialName, class UMaterialInterface* SourceMaterial);
	static class UMaterialInstanceDynamic* CreateDynamicMaterialInstanceFromName_Particle(class URSParticleSystemComponentBase* RSParticleComponent, const class FName EmitterName, class UMaterialInterface* SourceMaterial);
	static class UTextureRenderTarget2D* CreateRenderTarget2DCustom(class UObject* WorldContextObject, int32 Width, int32 Height, ERenderTargetCustomFormat Format, ETextureAddress AddressX, ETextureAddress AddressY, bool LinearGamma);
	static void DebugDisplayURO(class USkinnedMeshComponent* Mesh, bool bDisplay);
	static void DebugLogWarning(const class FText& WarningText);
	static void ExNewGameParamAdjust(const class UObject* WorldContextObject, const bool IsTakeOverPlayerLv, const bool IsTakeOverBrainMap);
	static void ForceGC(bool bFullPurge);
	static void ForceGC_NoEditor(bool bFullPurge);
	static void ForceUploadGPUScene();
	static void GameClearSaveParamAdjust(const class UObject* WorldContextObject);
	static void GameOverActorStopFunc(const class UObject* WorldContextObject);
	static class AActor* GetActorFromTag(class UObject* WorldObject, class FName Tag);
	static class AActor* GetActorFromTagConst(const class UObject* WorldObject, const class FName& Tag);
	static class AActor* GetActorFromTagForLevelName(const class UObject* WorldContextObject, class FName Tag, class FName LevelName);
	static TArray<class AActor*> GetActorsFromLevelStreaming(class ULevelStreaming* Level);
	static bool GetAppropriateSystemAvailableResolutions(struct FScreenResolutionSetting* Resolution, const int32 Width, const int32 Height, const bool bIgnoreRefreshRate);
	static TSubclassOf<class AActor> GetAssetUClass(class FName ClassName, class FName AssetName);
	static void GetCelLookAmbientReplaceParam(struct FLinearColor* OutColor, float* OutRate);
	static struct FVector GetCelLookLightDirection();
	static struct FTransform GetComposedRefPoseTransform(class USkeletalMesh* SkeletalMesh, class FName BoneName);
	static struct FRotator GetCurrentCameraRotation(const class UObject* WorldContextObject);
	static uint8 GetGameViewRenderLayer();
	static bool GetInitialScreenResolution(struct FVector2D* Resolution, bool* IsVertical);
	static float GetMaxDistanceFactor(class USkinnedMeshComponent* Mesh);
	static bool GetNativeScreenResolution(struct FVector2D* Resolution, bool* IsVertical);
	static class FName GetPrimaryAssetTypeName(const struct FPrimaryAssetType& AssetType);
	static class URSGameInstance* GetRSGameInstance(const class UObject* WorldContextObject);
	static bool GetScreenResolution(struct FVector2D* Resolution, bool* IsVertical);
	static class USkeletalMeshComponent* GetSkeletalMeshFromActor(class AActor* Actor);
	static bool GetSystemAvailableFullscreenResolutions(const TArray<struct FScreenResolutionSetting>& InResolutions, TArray<struct FScreenResolutionSetting>* OutResolutions, bool bIgnoreRefreshRate);
	static bool GetSystemAvailableResolutions(TArray<struct FScreenResolutionSetting>* Resolutions, bool bIgnoreRefreshRate);
	static bool GetSystemAvailableWindowedResolutions(const TArray<struct FScreenResolutionSetting>& InResolutions, TArray<struct FScreenResolutionSetting>* OutResolutions, bool bIgnoreRefreshRate);
	static float GetUROUpdateRate(class USkinnedMeshComponent* Mesh);
	static TArray<class APostProcessVolume*> GetWorldPostProcessVolume(class UObject* WorldContextObject);
	static void GeWorldPostProcesstEnabledMaterials(class UObject* WorldContextObject, const struct FVector& Location, TArray<class UMaterialInterface*>* OutMaterials, TArray<class FString>* OutMaterialNames);
	static bool HasSimpleCollision(class UPrimitiveComponent* Primitive);
	static bool HasWorldEndOfFrameUpdates(const class UObject* WorldContextObject);
	static void InvalidDLCInvalidation(const class UObject* WorldContextObject, const TArray<class FName>& InvalidContentsList);
	static bool IsAddContentsNewFlag(const class UObject* WorldContextObject, class FName ContentsName);
	static bool IsAllSlotNotAppliedAndNotNotifiedDLC(const class UObject* WorldContextObject, TArray<class FName>* ResultAddContentsNameList);
	static bool IsAnimMontageStoped(class UAnimInstance* AnimInstance, class UAnimSequenceBase* Anim);
	static bool IsApplicationActive();
	static bool IsAppliedDLC(const class UObject* WorldContextObject, class FName ContentsName);
	static bool IsDisplayVertical(bool* IsVertical);
	static bool IsDLCHaveNoRightsInApplied(const class UObject* WorldContextObject, const TArray<class FName>& AppliedAddContentsNameList);
	static bool IsDLCOverPossession(const class UObject* WorldContextObject, class FName ContentsName);
	static bool IsExistNotInformNewAddContents(const class UObject* WorldContextObject, TArray<class FName>* AddContentsNameList, const bool IsUpdateSystemSave);
	static bool IsExistNotInformPurchasedAddContents(const class UObject* WorldContextObject, TArray<class FName>* AddContentsNameList, const bool IsUpdateSystemSave);
	static bool IsGameClearThisPlay(const class UObject* WorldContextObject);
	static bool IsNewDLC(const class UObject* WorldContextObject, bool IsParamUpdate);
	static bool IsNotAppliedDLC(const class UObject* WorldContextObject, TArray<class FName>* NotAppliedAddContentsNameList, const bool IsPurchasedOnly);
	static bool IsNotAppliedDLCAndReceiveBrainMessage(class UObject* WorldContextObject);
	static bool IsRootMotionAnimMontage(class UAnimMontage* Anim);
	static void LevelChangeBeforeWorkFromIngame(const class UObject* WorldContextObject);
	static void LoadAssetFromStringAssetReference(class UObject* WorldContextObject, const struct FSoftObjectPath& StringAsset, TDelegate<void(class UObject* Loaded)> OnLoaded, const struct FLatentActionInfo& LatentInfo, bool NoFindCheck);
	static class UDataTable* LoadDataTable(const class FString& FilePath);
	static class UObject* LoadObjectGeneric(const class FString& FilePath);
	static class UClass* LoadSoftClass(TSoftClassPtr<class UClass> Target);
	static TSubclassOf<class AActor> LoadSoftClassActor(TSoftClassPtr<class UClass> Target);
	static class UObject* LoadSoftObject(TSoftObjectPtr<class UObject> Target);
	static class AActor* LoadSoftObjectActor(TSoftObjectPtr<class AActor> Target);
	static void OutputNowTime(const class FString& LogText);
	static void RedAssert(bool IsCheck, const class FString& Message);
	static void RedEnsure(bool IsCheck, const class FString& Message);
	static void RedUnImplement();
	static void RefreshSkinMesh(class USkinnedMeshComponent* SkinMesh);
	static void RemovePostProcessMaterialFromComponent(class UPostProcessComponent* PPComponent, class UMaterialInterface* RemoveMaterial);
	static struct FPostProcessSettings RemovePostProcessMaterialFromPPS(const struct FPostProcessSettings& BaseSettings, class UMaterialInterface* RemoveMaterial);
	static void ReplaceMaterialInstanceFromImagePlatformTexture(class UImage* Image);
	static void ReplaceMaterialInstancePlatformTexture(class UMaterialInstanceDynamic* MaterialInstance);
	static void ResetRenderTargets(const class UObject* WorldContextObject);
	static void RestorePPMaskParticlenative(class UObject* WorldContextObject, const TArray<class ASequencerParticle*>& SequencerParticles, const TArray<int32>& RestoreCustomStencil);
	static void SaveDataLoadAfterParamAdjust(const class UObject* WorldContextObject);
	static void SetAddContentsNewFlag(const class UObject* WorldContextObject, class FName ContentsName, const bool Flag);
	static void SetBgEdgeDriveColor(const struct FLinearColor& InnerColor, const struct FLinearColor& OuterColor);
	static void SetBgEdgeDriveLocation(const struct FVector& Location);
	static void SetBgEdgeDriveParameter(float Length, float Smooth, float ColorShift, float Parameter4, float EdgeThresholdNomrmal, float EdgeThresholdLuminance, float Parameter7, float Parameter8);
	static void SetCelLookLightDirection(const struct FVector& LightDirection);
	static void SetDisplayBrightnessNative(class UObject* WorldContextObject, int32 Brightness);
	static void SetEnableURO(class USkinnedMeshComponent* Mesh, bool bEnable);
	static void SetGameViewRenderLayer(uint8 RenderLayer);
	static void SetLightChannnel(class UPrimitiveComponent* Primitive, bool Channel0, bool Channel1, bool Channel2);
	static void SetMainViewOverrideAA(bool bOverride, int32 AAMethod);
	static void SetPicturizeQuality(int32 Quality);
	static void SetRenderAfterDOF(class UMaterial* Material, bool IsEnable);
	static void SetShadowMapAtlasTargetsEnabled(bool Enabled);
	static void SetupPPMaskParticlenative(class UObject* WorldContextObject, TArray<class ASequencerParticle*>* SequencerParticles, TArray<int32>* RestoreCustomStencil, bool Enable);
	static void SetUROParameter(class USkinnedMeshComponent* Mesh, const TArray<float>& Thesholds, int32 MaxEvalRateForInterpolation, int32 BaseNonRenderedUpdateRate);
	static void ShippingDebugString(const class FString& OutString);
	static class AActor* SpawnActorFromBPFilePath(class UObject* WorldContextObject, const class FString& Path);
	static void StartDeadGameOverPreWork(const class UObject* WorldContextObject);
	static void UnloadLevelInstance(class UObject* WorldContextObject, class ULevelStreamingDynamic* LevelStreaming);
	static void UpdateBoundsComponent(class USceneComponent* Component);
	static void UpdateDLCInfo(const class UObject* WorldContextObject, const TArray<class FName>& EntitledContentsList, const TArray<class FName>& InvalidContentsList, bool IsInvalidDLCInvalidation);

	void OnAssetLoaded__DelegateSignature(class UObject* Loaded);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSUtilityLibrary">();
	}
	static class URSUtilityLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSUtilityLibrary>();
	}
};
static_assert(alignof(URSUtilityLibrary) == 0x000008, "Wrong alignment on URSUtilityLibrary");
static_assert(sizeof(URSUtilityLibrary) == 0x000028, "Wrong size on URSUtilityLibrary");

// Class BattlePrototype.RSUtilityMathFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URSUtilityMathFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CalcMeshSocketRotation(struct FVector* OutLocation, struct FRotator* OutRotator, class AActor* RotateActor, class UMeshComponent* Mesh, class FName SocketName, float Angle);
	static struct FVector ClampVectorLimitAngle(const struct FVector& baseDist, const struct FVector& CheckDist, float LimitDegree);
	static struct FVector GetBulletDirection(const struct FVector& FireLocation, const struct FVector& TargetLocation, const struct FVector& FireForwardVector, float MaxAngleXY, float MaxAngleZ);
	static struct FVector GetDamageReactionDir(class AActor* Owner, const struct FHCHitResult& HitResult);
	static void GetSearchBaseParam(const class UObject* WorldContextObject, struct FVector* OutPlayerLocation, struct FVector* OutCameraDirH);
	static float GetTargetAngle(const struct FVector& baseDist, const struct FVector& TargetDist);
	static float GetTargetRangeAngle(const struct FVector& baseDist, const struct FVector& TargetDist);
	static bool IsNearlyAngle(float A, float B, float Angle);
	static struct FVector TurnToTargetVector(const struct FVector& SrcVec, const struct FVector& DstVec, float Angle);
	static float UpdateTimer(float Timer, float DeltaSeconds);
	static struct FVector UpDownVector(const struct FVector& Src, float Angle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSUtilityMathFunctionLibrary">();
	}
	static class URSUtilityMathFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSUtilityMathFunctionLibrary>();
	}
};
static_assert(alignof(URSUtilityMathFunctionLibrary) == 0x000008, "Wrong alignment on URSUtilityMathFunctionLibrary");
static_assert(sizeof(URSUtilityMathFunctionLibrary) == 0x000028, "Wrong size on URSUtilityMathFunctionLibrary");

// Class BattlePrototype.RSWidgetComponent
// 0x0000 (0x0550 - 0x0550)
class URSWidgetComponent final : public UWidgetComponent
{
public:
	void CallUpdateWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSWidgetComponent">();
	}
	static class URSWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSWidgetComponent>();
	}
};
static_assert(alignof(URSWidgetComponent) == 0x000010, "Wrong alignment on URSWidgetComponent");
static_assert(sizeof(URSWidgetComponent) == 0x000550, "Wrong size on URSWidgetComponent");

// Class BattlePrototype.SASManager
// 0x0008 (0x0238 - 0x0230)
class ASASManager : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetSASEffectFixParam(E_SASKindNative InKind, TArray<struct F_SASParamNative>* OutFixParam);
	bool IsCutinPlayingNative();
	bool IsPlayingCutinExtra();
	void ResetHudCustomTimeDilationAccelerateSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SASManager">();
	}
	static class ASASManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASASManager>();
	}
};
static_assert(alignof(ASASManager) == 0x000008, "Wrong alignment on ASASManager");
static_assert(sizeof(ASASManager) == 0x000238, "Wrong size on ASASManager");

// Class BattlePrototype.SASVisionComponent
// 0x00B8 (0x0178 - 0x00C0)
class USASVisionComponent final : public UActorComponent
{
public:
	TSubclassOf<class AActor>                     _maskActorClass;                                   // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           _curveMaskAppearLocation;                          // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           _curveMaskDisappearLocation;                       // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           _curveMaskRotation;                                // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           _curveMaskScale;                                   // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bDebugDispMask;                                   // 0x00E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _meshShakeOffsetMax;                               // 0x00EC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _meshShakeSpanShort;                               // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _meshShakeSpanLongMin;                             // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _meshShakeSpanLongMax;                             // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _meshShakeSmallContinueMin;                        // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _meshShakeSmallContinueMax;                        // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bShakeLinear;                                     // 0x010C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D[0x6B];                                     // 0x010D(0x006B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USASVisionComponent* GetSASVisionComponent(class AActor* Actor);

	bool OnStartDisappear();
	void StartDisappear();

	class AActor* GetMainActor() const;
	class USkeletalMeshComponent* GetMainMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SASVisionComponent">();
	}
	static class USASVisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USASVisionComponent>();
	}
};
static_assert(alignof(USASVisionComponent) == 0x000008, "Wrong alignment on USASVisionComponent");
static_assert(sizeof(USASVisionComponent) == 0x000178, "Wrong size on USASVisionComponent");
static_assert(offsetof(USASVisionComponent, _maskActorClass) == 0x0000C0, "Member 'USASVisionComponent::_maskActorClass' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _curveMaskAppearLocation) == 0x0000C8, "Member 'USASVisionComponent::_curveMaskAppearLocation' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _curveMaskDisappearLocation) == 0x0000D0, "Member 'USASVisionComponent::_curveMaskDisappearLocation' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _curveMaskRotation) == 0x0000D8, "Member 'USASVisionComponent::_curveMaskRotation' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _curveMaskScale) == 0x0000E0, "Member 'USASVisionComponent::_curveMaskScale' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _bDebugDispMask) == 0x0000E8, "Member 'USASVisionComponent::_bDebugDispMask' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _meshShakeOffsetMax) == 0x0000EC, "Member 'USASVisionComponent::_meshShakeOffsetMax' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _meshShakeSpanShort) == 0x0000F8, "Member 'USASVisionComponent::_meshShakeSpanShort' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _meshShakeSpanLongMin) == 0x0000FC, "Member 'USASVisionComponent::_meshShakeSpanLongMin' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _meshShakeSpanLongMax) == 0x000100, "Member 'USASVisionComponent::_meshShakeSpanLongMax' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _meshShakeSmallContinueMin) == 0x000104, "Member 'USASVisionComponent::_meshShakeSmallContinueMin' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _meshShakeSmallContinueMax) == 0x000108, "Member 'USASVisionComponent::_meshShakeSmallContinueMax' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _bShakeLinear) == 0x00010C, "Member 'USASVisionComponent::_bShakeLinear' has a wrong offset!");

// Class BattlePrototype.UICharaPresentListIndex
// 0x0030 (0x03B8 - 0x0388)
class UUICharaPresentListIndex : public UUIBase
{
public:
	uint8                                         Pad_388[0x30];                                     // 0x0388(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UTextBlock* TextItemName);
	bool SetItemInfo(const class FName& ItemId);
	void UpdateStateThis();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICharaPresentListIndex">();
	}
	static class UUICharaPresentListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICharaPresentListIndex>();
	}
};
static_assert(alignof(UUICharaPresentListIndex) == 0x000008, "Wrong alignment on UUICharaPresentListIndex");
static_assert(sizeof(UUICharaPresentListIndex) == 0x0003B8, "Wrong size on UUICharaPresentListIndex");

// Class BattlePrototype.SaveIntermediary
// 0x0000 (0x0230 - 0x0230)
class ASaveIntermediary final : public AActor
{
public:
	void Load(const class FString& SaveSlotName, int32* TestInt, float* TestFloat, class FName* TestName, TArray<int32>* TestArrayInt, struct FSaveTestStruct* TestStruct, TArray<struct FSaveTestStruct>* TestArrayStruct);
	void Save(const class FString& SlotName, int32 TestInt, float TestFloat, class FName TestName, const TArray<int32>& TestArrayInt, const struct FSaveTestStruct& TestStruct, const TArray<struct FSaveTestStruct>& TestArrayStruct);
	uint8 TestBuffer(int32 Num, int32 Index_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveIntermediary">();
	}
	static class ASaveIntermediary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASaveIntermediary>();
	}
};
static_assert(alignof(ASaveIntermediary) == 0x000008, "Wrong alignment on ASaveIntermediary");
static_assert(sizeof(ASaveIntermediary) == 0x000230, "Wrong size on ASaveIntermediary");

// Class BattlePrototype.SaveLoadArrangeItemManager
// 0x0038 (0x0060 - 0x0028)
class USaveLoadArrangeItemManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FArrangeItemListForSaveData>    M_allArrangeItemList;                              // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRandomArrangeItemIDInfo>       M_allRandomArrangeItemIDInfo;                      // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        M_timerCount;                                      // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadArrangeItemManager">();
	}
	static class USaveLoadArrangeItemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadArrangeItemManager>();
	}
};
static_assert(alignof(USaveLoadArrangeItemManager) == 0x000008, "Wrong alignment on USaveLoadArrangeItemManager");
static_assert(sizeof(USaveLoadArrangeItemManager) == 0x000060, "Wrong size on USaveLoadArrangeItemManager");
static_assert(offsetof(USaveLoadArrangeItemManager, M_allArrangeItemList) == 0x000038, "Member 'USaveLoadArrangeItemManager::M_allArrangeItemList' has a wrong offset!");
static_assert(offsetof(USaveLoadArrangeItemManager, M_allRandomArrangeItemIDInfo) == 0x000048, "Member 'USaveLoadArrangeItemManager::M_allRandomArrangeItemIDInfo' has a wrong offset!");
static_assert(offsetof(USaveLoadArrangeItemManager, M_timerCount) == 0x000058, "Member 'USaveLoadArrangeItemManager::M_timerCount' has a wrong offset!");

// Class BattlePrototype.SaveLoadEnemyParamManager
// 0x00B0 (0x00D8 - 0x0028)
class USaveLoadEnemyParamManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FEnemyRepopLevelInfo> M_EnemyRepopLevelInfoList;                         // 0x0038(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<class FName, bool>                       M_UniqueBrainCrashPlayedList;                      // 0x0088(0x0050)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadEnemyParamManager">();
	}
	static class USaveLoadEnemyParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadEnemyParamManager>();
	}
};
static_assert(alignof(USaveLoadEnemyParamManager) == 0x000008, "Wrong alignment on USaveLoadEnemyParamManager");
static_assert(sizeof(USaveLoadEnemyParamManager) == 0x0000D8, "Wrong size on USaveLoadEnemyParamManager");
static_assert(offsetof(USaveLoadEnemyParamManager, M_EnemyRepopLevelInfoList) == 0x000038, "Member 'USaveLoadEnemyParamManager::M_EnemyRepopLevelInfoList' has a wrong offset!");
static_assert(offsetof(USaveLoadEnemyParamManager, M_UniqueBrainCrashPlayedList) == 0x000088, "Member 'USaveLoadEnemyParamManager::M_UniqueBrainCrashPlayedList' has a wrong offset!");

// Class BattlePrototype.SaveLoadExSystemParamManager
// 0x0080 (0x00A8 - 0x0028)
class USaveLoadExSystemParamManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 M_AdditionalSystemSave;                            // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPatch01Param                          Patch01Param;                                      // 0x0048(0x0058)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadExSystemParamManager">();
	}
	static class USaveLoadExSystemParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadExSystemParamManager>();
	}
};
static_assert(alignof(USaveLoadExSystemParamManager) == 0x000008, "Wrong alignment on USaveLoadExSystemParamManager");
static_assert(sizeof(USaveLoadExSystemParamManager) == 0x0000A8, "Wrong size on USaveLoadExSystemParamManager");
static_assert(offsetof(USaveLoadExSystemParamManager, M_AdditionalSystemSave) == 0x000038, "Member 'USaveLoadExSystemParamManager::M_AdditionalSystemSave' has a wrong offset!");
static_assert(offsetof(USaveLoadExSystemParamManager, Patch01Param) == 0x000048, "Member 'USaveLoadExSystemParamManager::Patch01Param' has a wrong offset!");

// Class BattlePrototype.UIChromaticAberration
// 0x0028 (0x0050 - 0x0028)
class UUIChromaticAberration final : public UObject
{
public:
	class URetainerBox*                           RetainerBox;                                       // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               Material;                                          // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UImage*>                         Image;                                             // 0x0038(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EChromaticAberrationType                      Type;                                              // 0x0048(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Setup(class URetainerBox* InRetainerBox, class UImage* ImageRed, class UImage* ImageGreen, class UImage* ImageBlue);
	void Update();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIChromaticAberration">();
	}
	static class UUIChromaticAberration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIChromaticAberration>();
	}
};
static_assert(alignof(UUIChromaticAberration) == 0x000008, "Wrong alignment on UUIChromaticAberration");
static_assert(sizeof(UUIChromaticAberration) == 0x000050, "Wrong size on UUIChromaticAberration");
static_assert(offsetof(UUIChromaticAberration, RetainerBox) == 0x000028, "Member 'UUIChromaticAberration::RetainerBox' has a wrong offset!");
static_assert(offsetof(UUIChromaticAberration, Material) == 0x000030, "Member 'UUIChromaticAberration::Material' has a wrong offset!");
static_assert(offsetof(UUIChromaticAberration, Image) == 0x000038, "Member 'UUIChromaticAberration::Image' has a wrong offset!");
static_assert(offsetof(UUIChromaticAberration, Type) == 0x000048, "Member 'UUIChromaticAberration::Type' has a wrong offset!");

// Class BattlePrototype.SaveLoadParamClassManager
// 0x0060 (0x0088 - 0x0028)
class USaveLoadParamClassManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_isLoadExecution;                                 // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 M_RetryData;                                       // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 M_AsyncAutoSaveData;                               // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadSystemParamManager*            M_pSaveLoadSystemParamManager;                     // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USaveLoadPlayerParamManager*            M_pSaveLoadPlayerParamManager;                     // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USaveLoadEnemyParamManager*             M_pSaveLoadEnemyParamManager;                      // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USaveLoadArrangeItemManager*            M_pSaveLoadArrangeItemManager;                     // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USaveLoadExSystemParamManager*          M_pSaveLoadExSystemParamManager;                   // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USaveLoadArrangeItemManager* GetSaveLoadArrangeItemManager();
	class USaveLoadEnemyParamManager* GetSaveLoadEnemyParamManager();
	class USaveLoadExSystemParamManager* GetSaveLoadExSystemParamManager();
	class USaveLoadPlayerParamManager* GetSaveLoadPlayerParamManager();
	class USaveLoadSystemParamManager* GetSaveLoadSystemParamManager();
	bool IsLoadExecution();
	void SetGameInstance(class URSGameInstance* GameInst);
	void SetIsLoadExecution(const bool Flag);
	void SetSaveParamToGameParam(const class URSGameInstance* GameInst);
	void SetSaveParamToGameParam_ScenarioFlag(const class URSGameInstance* GameInst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadParamClassManager">();
	}
	static class USaveLoadParamClassManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadParamClassManager>();
	}
};
static_assert(alignof(USaveLoadParamClassManager) == 0x000008, "Wrong alignment on USaveLoadParamClassManager");
static_assert(sizeof(USaveLoadParamClassManager) == 0x000088, "Wrong size on USaveLoadParamClassManager");
static_assert(offsetof(USaveLoadParamClassManager, M_isLoadExecution) == 0x000030, "Member 'USaveLoadParamClassManager::M_isLoadExecution' has a wrong offset!");
static_assert(offsetof(USaveLoadParamClassManager, M_RetryData) == 0x000038, "Member 'USaveLoadParamClassManager::M_RetryData' has a wrong offset!");
static_assert(offsetof(USaveLoadParamClassManager, M_AsyncAutoSaveData) == 0x000048, "Member 'USaveLoadParamClassManager::M_AsyncAutoSaveData' has a wrong offset!");
static_assert(offsetof(USaveLoadParamClassManager, M_pSaveLoadSystemParamManager) == 0x000058, "Member 'USaveLoadParamClassManager::M_pSaveLoadSystemParamManager' has a wrong offset!");
static_assert(offsetof(USaveLoadParamClassManager, M_pSaveLoadPlayerParamManager) == 0x000060, "Member 'USaveLoadParamClassManager::M_pSaveLoadPlayerParamManager' has a wrong offset!");
static_assert(offsetof(USaveLoadParamClassManager, M_pSaveLoadEnemyParamManager) == 0x000068, "Member 'USaveLoadParamClassManager::M_pSaveLoadEnemyParamManager' has a wrong offset!");
static_assert(offsetof(USaveLoadParamClassManager, M_pSaveLoadArrangeItemManager) == 0x000070, "Member 'USaveLoadParamClassManager::M_pSaveLoadArrangeItemManager' has a wrong offset!");
static_assert(offsetof(USaveLoadParamClassManager, M_pSaveLoadExSystemParamManager) == 0x000078, "Member 'USaveLoadParamClassManager::M_pSaveLoadExSystemParamManager' has a wrong offset!");

// Class BattlePrototype.SaveLoadPlayerParamManager
// 0x0038 (0x0060 - 0x0028)
class USaveLoadPlayerParamManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EPlayerID                                     M_BattleMemberMain;                                // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     M_BattleMemberLeft;                                // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     M_BattleMemberRight;                               // 0x003A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSaveLoadPlayerParam>           M_saveLoadPlayerParamList;                         // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NpcAssistCountHP;                                // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NpcAssistCountBadStatus;                         // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NpcAssistCountRevive;                            // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bDriveUsedFlag;                                  // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadPlayerParamManager">();
	}
	static class USaveLoadPlayerParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadPlayerParamManager>();
	}
};
static_assert(alignof(USaveLoadPlayerParamManager) == 0x000008, "Wrong alignment on USaveLoadPlayerParamManager");
static_assert(sizeof(USaveLoadPlayerParamManager) == 0x000060, "Wrong size on USaveLoadPlayerParamManager");
static_assert(offsetof(USaveLoadPlayerParamManager, M_BattleMemberMain) == 0x000038, "Member 'USaveLoadPlayerParamManager::M_BattleMemberMain' has a wrong offset!");
static_assert(offsetof(USaveLoadPlayerParamManager, M_BattleMemberLeft) == 0x000039, "Member 'USaveLoadPlayerParamManager::M_BattleMemberLeft' has a wrong offset!");
static_assert(offsetof(USaveLoadPlayerParamManager, M_BattleMemberRight) == 0x00003A, "Member 'USaveLoadPlayerParamManager::M_BattleMemberRight' has a wrong offset!");
static_assert(offsetof(USaveLoadPlayerParamManager, M_saveLoadPlayerParamList) == 0x000040, "Member 'USaveLoadPlayerParamManager::M_saveLoadPlayerParamList' has a wrong offset!");
static_assert(offsetof(USaveLoadPlayerParamManager, M_NpcAssistCountHP) == 0x000050, "Member 'USaveLoadPlayerParamManager::M_NpcAssistCountHP' has a wrong offset!");
static_assert(offsetof(USaveLoadPlayerParamManager, M_NpcAssistCountBadStatus) == 0x000054, "Member 'USaveLoadPlayerParamManager::M_NpcAssistCountBadStatus' has a wrong offset!");
static_assert(offsetof(USaveLoadPlayerParamManager, M_NpcAssistCountRevive) == 0x000058, "Member 'USaveLoadPlayerParamManager::M_NpcAssistCountRevive' has a wrong offset!");
static_assert(offsetof(USaveLoadPlayerParamManager, M_bDriveUsedFlag) == 0x00005C, "Member 'USaveLoadPlayerParamManager::M_bDriveUsedFlag' has a wrong offset!");

// Class BattlePrototype.SaveLoadPsychicObjectManager
// 0x0020 (0x0048 - 0x0028)
class USaveLoadPsychicObjectManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSaveLoadPsychicObjectParam>    M_saveLoadPsychicObjectParamList;                  // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadPsychicObjectManager">();
	}
	static class USaveLoadPsychicObjectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadPsychicObjectManager>();
	}
};
static_assert(alignof(USaveLoadPsychicObjectManager) == 0x000008, "Wrong alignment on USaveLoadPsychicObjectManager");
static_assert(sizeof(USaveLoadPsychicObjectManager) == 0x000048, "Wrong size on USaveLoadPsychicObjectManager");
static_assert(offsetof(USaveLoadPsychicObjectManager, M_saveLoadPsychicObjectParamList) == 0x000038, "Member 'USaveLoadPsychicObjectManager::M_saveLoadPsychicObjectParamList' has a wrong offset!");

// Class BattlePrototype.SaveLoadScreenParamManager
// 0x0028 (0x0050 - 0x0028)
class USaveLoadScreenParamManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSaveLoadScreenParam>           M_saveLoadScreenParamList;                         // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadScreenParamManager">();
	}
	static class USaveLoadScreenParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadScreenParamManager>();
	}
};
static_assert(alignof(USaveLoadScreenParamManager) == 0x000008, "Wrong alignment on USaveLoadScreenParamManager");
static_assert(sizeof(USaveLoadScreenParamManager) == 0x000050, "Wrong size on USaveLoadScreenParamManager");
static_assert(offsetof(USaveLoadScreenParamManager, M_saveLoadScreenParamList) == 0x000038, "Member 'USaveLoadScreenParamManager::M_saveLoadScreenParamList' has a wrong offset!");

// Class BattlePrototype.UIConfigChoice
// 0x00C0 (0x0448 - 0x0388)
class UUIConfigChoice : public UUIBase
{
public:
	uint8                                         Pad_388[0xC0];                                     // 0x0388(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeIndex(int32 Index_0, class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UREDTextBlock* TextIndex);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UTextBlock* TextWindowTitle, class UTextBlock* TextMain, class UOverlay* OverlayGuideSet);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigChoice">();
	}
	static class UUIConfigChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigChoice>();
	}
};
static_assert(alignof(UUIConfigChoice) == 0x000008, "Wrong alignment on UUIConfigChoice");
static_assert(sizeof(UUIConfigChoice) == 0x000448, "Wrong size on UUIConfigChoice");

// Class BattlePrototype.SaveLoadSystemParamManager
// 0x00A0 (0x00C8 - 0x0028)
class USaveLoadSystemParamManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_LastSaveSlotNo;                                  // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint32>                                M_ScenarioFlags;                                   // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ProgressID;                                      // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_LocationID;                                      // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AreaID;                                          // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_VariationID;                                     // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PortalID;                                        // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 M_LiftFloorList;                                   // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         M_LoadMakeEventPathList;                           // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x40];                                      // 0x0088(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetLastSaveSlotNo();
	void SetLastSaveSlotNo(const int32 SlotNo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadSystemParamManager">();
	}
	static class USaveLoadSystemParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadSystemParamManager>();
	}
};
static_assert(alignof(USaveLoadSystemParamManager) == 0x000008, "Wrong alignment on USaveLoadSystemParamManager");
static_assert(sizeof(USaveLoadSystemParamManager) == 0x0000C8, "Wrong size on USaveLoadSystemParamManager");
static_assert(offsetof(USaveLoadSystemParamManager, M_LastSaveSlotNo) == 0x000038, "Member 'USaveLoadSystemParamManager::M_LastSaveSlotNo' has a wrong offset!");
static_assert(offsetof(USaveLoadSystemParamManager, M_ScenarioFlags) == 0x000040, "Member 'USaveLoadSystemParamManager::M_ScenarioFlags' has a wrong offset!");
static_assert(offsetof(USaveLoadSystemParamManager, M_ProgressID) == 0x000050, "Member 'USaveLoadSystemParamManager::M_ProgressID' has a wrong offset!");
static_assert(offsetof(USaveLoadSystemParamManager, M_LocationID) == 0x000054, "Member 'USaveLoadSystemParamManager::M_LocationID' has a wrong offset!");
static_assert(offsetof(USaveLoadSystemParamManager, M_AreaID) == 0x000058, "Member 'USaveLoadSystemParamManager::M_AreaID' has a wrong offset!");
static_assert(offsetof(USaveLoadSystemParamManager, M_VariationID) == 0x00005C, "Member 'USaveLoadSystemParamManager::M_VariationID' has a wrong offset!");
static_assert(offsetof(USaveLoadSystemParamManager, M_PortalID) == 0x000060, "Member 'USaveLoadSystemParamManager::M_PortalID' has a wrong offset!");
static_assert(offsetof(USaveLoadSystemParamManager, M_LiftFloorList) == 0x000068, "Member 'USaveLoadSystemParamManager::M_LiftFloorList' has a wrong offset!");
static_assert(offsetof(USaveLoadSystemParamManager, M_LoadMakeEventPathList) == 0x000078, "Member 'USaveLoadSystemParamManager::M_LoadMakeEventPathList' has a wrong offset!");

// Class BattlePrototype.SavePointBase
// 0x0098 (0x02C8 - 0x0230)
class ASavePointBase : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          ShowBoxComponent;                                  // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      CollisionCapsuleComponent;                         // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          EventBoxComponent;                                 // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AMakeEventActor>            MakeEventActorClass;                               // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMakeEventActor*                        MakeEventActor;                                    // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   ChildActionIcon;                                   // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActionIconWorldPositionOffset;                     // 0x0270(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionIconType                               ActionIconType;                                    // 0x027C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D[0x3];                                      // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUIMapIconAdjust                       MapIconAdjust;                                     // 0x0280(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ANpcShopBase*                           PairActor;                                         // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFitGround;                                       // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x17];                                     // 0x02B1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UChildActorComponent* GetChildActionIcon();
	void RegisterPairActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SavePointBase">();
	}
	static class ASavePointBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASavePointBase>();
	}
};
static_assert(alignof(ASavePointBase) == 0x000008, "Wrong alignment on ASavePointBase");
static_assert(sizeof(ASavePointBase) == 0x0002C8, "Wrong size on ASavePointBase");
static_assert(offsetof(ASavePointBase, SkeletalMeshComponent) == 0x000238, "Member 'ASavePointBase::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ASavePointBase, ShowBoxComponent) == 0x000240, "Member 'ASavePointBase::ShowBoxComponent' has a wrong offset!");
static_assert(offsetof(ASavePointBase, CollisionCapsuleComponent) == 0x000248, "Member 'ASavePointBase::CollisionCapsuleComponent' has a wrong offset!");
static_assert(offsetof(ASavePointBase, EventBoxComponent) == 0x000250, "Member 'ASavePointBase::EventBoxComponent' has a wrong offset!");
static_assert(offsetof(ASavePointBase, MakeEventActorClass) == 0x000258, "Member 'ASavePointBase::MakeEventActorClass' has a wrong offset!");
static_assert(offsetof(ASavePointBase, MakeEventActor) == 0x000260, "Member 'ASavePointBase::MakeEventActor' has a wrong offset!");
static_assert(offsetof(ASavePointBase, ChildActionIcon) == 0x000268, "Member 'ASavePointBase::ChildActionIcon' has a wrong offset!");
static_assert(offsetof(ASavePointBase, ActionIconWorldPositionOffset) == 0x000270, "Member 'ASavePointBase::ActionIconWorldPositionOffset' has a wrong offset!");
static_assert(offsetof(ASavePointBase, ActionIconType) == 0x00027C, "Member 'ASavePointBase::ActionIconType' has a wrong offset!");
static_assert(offsetof(ASavePointBase, MapIconAdjust) == 0x000280, "Member 'ASavePointBase::MapIconAdjust' has a wrong offset!");
static_assert(offsetof(ASavePointBase, PairActor) == 0x0002A8, "Member 'ASavePointBase::PairActor' has a wrong offset!");
static_assert(offsetof(ASavePointBase, IsFitGround) == 0x0002B0, "Member 'ASavePointBase::IsFitGround' has a wrong offset!");

// Class BattlePrototype.ScarParam
// 0x00D0 (0x0100 - 0x0030)
class UScarParam final : public UDataAsset
{
public:
	float                                         LengthStroke;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LengthThick;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LengthFront;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScarColorParam                        ColorNormal;                                       // 0x003C(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FScarColorParam                        ColorFlame;                                        // 0x007C(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FScarColorParam                        ColorElectric;                                     // 0x00BC(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScarParam">();
	}
	static class UScarParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScarParam>();
	}
};
static_assert(alignof(UScarParam) == 0x000008, "Wrong alignment on UScarParam");
static_assert(sizeof(UScarParam) == 0x000100, "Wrong size on UScarParam");
static_assert(offsetof(UScarParam, LengthStroke) == 0x000030, "Member 'UScarParam::LengthStroke' has a wrong offset!");
static_assert(offsetof(UScarParam, LengthThick) == 0x000034, "Member 'UScarParam::LengthThick' has a wrong offset!");
static_assert(offsetof(UScarParam, LengthFront) == 0x000038, "Member 'UScarParam::LengthFront' has a wrong offset!");
static_assert(offsetof(UScarParam, ColorNormal) == 0x00003C, "Member 'UScarParam::ColorNormal' has a wrong offset!");
static_assert(offsetof(UScarParam, ColorFlame) == 0x00007C, "Member 'UScarParam::ColorFlame' has a wrong offset!");
static_assert(offsetof(UScarParam, ColorElectric) == 0x0000BC, "Member 'UScarParam::ColorElectric' has a wrong offset!");

// Class BattlePrototype.SceneManager
// 0x0090 (0x02C0 - 0x0230)
class ASceneManager : public ARSActorSystemBase
{
public:
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsAreaChanging;                                    // 0x0240(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnBeforeChangeScenarioFlag;                        // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAfterChangeScenarioFlag;                         // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeAreaLoadStatus;                            // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          IsCheckTextureLoadAtStartScene;                    // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TextureLoadPercentAtStartScene;                    // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AJumpAreaBase*>                  CurrentEnabledJumpAreas;                           // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint32>                                M_flags;                                           // 0x0290(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_FlagTable;                                       // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlueprintFunctionLibrary*              FunctionLibrary;                                   // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 M_FunctionLibraryActor;                            // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isSaveDataLoadFlow_ArrangeItemManager;           // 0x02B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isAreaChangeRetrySaveFlag;                       // 0x02B9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BA[0x6];                                      // 0x02BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCurrentJumpArea(class AJumpAreaBase* Actor);
	void CallFuncFromCode_UpdateAllTownPeopleState();
	void CallOnChangeAreaLoadStatus(EChangeAreaStatus Status, bool IsChangeLocation);
	void CallPortalFunction(int32 LocationId, int32 AreaId, int32 PortalID, int32* NextLocationID, int32* NextAreaID, class FName* PortalName);
	bool CheckScenarioFlag(class FName RowName);
	void ClearCurrentJumpArea();
	void FlushPhysicsSimulation();
	void GetBeforeLocationAndArea(int32* LocationId, int32* AreaId);
	class FName GetBeforeLocationName();
	void GetCurrentLocationAndArea(int32* LocationId, int32* AreaId);
	void GetCurrentLocationInfo(int32* LocationId, int32* AreaId, int32* VariationID, int32* PortalID);
	class FName GetCurrentLocationName();
	EMainScenarioType GetMainScenarioType();
	bool IsAreaChangeRetrySaveFlag();
	bool IsSaveDataLoadFlow_ArrangeItemManager();
	void OffScenarioFlag(class FName RowName);
	bool OnEndGameMenu();
	void OnScenarioFlag(class FName RowName);
	void RemoveCurrentJumpArea(class AJumpAreaBase* Actor);
	void RequestChangeScene(int32 LocationId, int32 AreaId, int32 PortalID, const TArray<class FName>& SceneArgs, bool NoFade, bool* Error, ELoadingScreenType LoadingScreenType, int32 LoadingScreenParam, bool IsAutoSaveEnable, class FName BattleSimulatorLevelInfosName);
	void RequestChangeSceneBattleSimulator(class FName BattleSimulatorRowName);
	void SetIsAreaChangeRetrySaveFlag(const bool Flag);
	void SetIsSaveDataLoadFlow_ArrangeItemManager(const bool Flag);
	void ToggleScenarioFlag(class FName RowName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneManager">();
	}
	static class ASceneManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASceneManager>();
	}
};
static_assert(alignof(ASceneManager) == 0x000008, "Wrong alignment on ASceneManager");
static_assert(sizeof(ASceneManager) == 0x0002C0, "Wrong size on ASceneManager");
static_assert(offsetof(ASceneManager, IsAreaChanging) == 0x000240, "Member 'ASceneManager::IsAreaChanging' has a wrong offset!");
static_assert(offsetof(ASceneManager, OnBeforeChangeScenarioFlag) == 0x000248, "Member 'ASceneManager::OnBeforeChangeScenarioFlag' has a wrong offset!");
static_assert(offsetof(ASceneManager, OnAfterChangeScenarioFlag) == 0x000258, "Member 'ASceneManager::OnAfterChangeScenarioFlag' has a wrong offset!");
static_assert(offsetof(ASceneManager, OnChangeAreaLoadStatus) == 0x000268, "Member 'ASceneManager::OnChangeAreaLoadStatus' has a wrong offset!");
static_assert(offsetof(ASceneManager, IsCheckTextureLoadAtStartScene) == 0x000278, "Member 'ASceneManager::IsCheckTextureLoadAtStartScene' has a wrong offset!");
static_assert(offsetof(ASceneManager, TextureLoadPercentAtStartScene) == 0x00027C, "Member 'ASceneManager::TextureLoadPercentAtStartScene' has a wrong offset!");
static_assert(offsetof(ASceneManager, CurrentEnabledJumpAreas) == 0x000280, "Member 'ASceneManager::CurrentEnabledJumpAreas' has a wrong offset!");
static_assert(offsetof(ASceneManager, M_flags) == 0x000290, "Member 'ASceneManager::M_flags' has a wrong offset!");
static_assert(offsetof(ASceneManager, M_FlagTable) == 0x0002A0, "Member 'ASceneManager::M_FlagTable' has a wrong offset!");
static_assert(offsetof(ASceneManager, FunctionLibrary) == 0x0002A8, "Member 'ASceneManager::FunctionLibrary' has a wrong offset!");
static_assert(offsetof(ASceneManager, M_FunctionLibraryActor) == 0x0002B0, "Member 'ASceneManager::M_FunctionLibraryActor' has a wrong offset!");
static_assert(offsetof(ASceneManager, M_isSaveDataLoadFlow_ArrangeItemManager) == 0x0002B8, "Member 'ASceneManager::M_isSaveDataLoadFlow_ArrangeItemManager' has a wrong offset!");
static_assert(offsetof(ASceneManager, M_isAreaChangeRetrySaveFlag) == 0x0002B9, "Member 'ASceneManager::M_isAreaChangeRetrySaveFlag' has a wrong offset!");

// Class BattlePrototype.UIPresentNext
// 0x0008 (0x0390 - 0x0388)
class UUIPresentNext : public UUIBase
{
public:
	class FName                                   M_ItemID;                                          // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetItemID(class FName ItemId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPresentNext">();
	}
	static class UUIPresentNext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPresentNext>();
	}
};
static_assert(alignof(UUIPresentNext) == 0x000008, "Wrong alignment on UUIPresentNext");
static_assert(sizeof(UUIPresentNext) == 0x000390, "Wrong size on UUIPresentNext");
static_assert(offsetof(UUIPresentNext, M_ItemID) == 0x000388, "Member 'UUIPresentNext::M_ItemID' has a wrong offset!");

// Class BattlePrototype.SearchingComponent
// 0x0000 (0x00C0 - 0x00C0)
class USearchingComponent final : public UActorComponent
{
public:
	bool IsDistanceAngleCheck(class AActor* Target, const struct FVector& TargetLocation, float Range, float Angle, const struct FRotator& Rot, bool NoHeight, const struct FVector& SelfLocation, bool SelfLocationOn);

	bool IsSearch(const struct FVector& VecStart, const struct FVector& VecEnd, const struct FVector& VecForward, float Distance, float Range) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchingComponent">();
	}
	static class USearchingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USearchingComponent>();
	}
};
static_assert(alignof(USearchingComponent) == 0x000008, "Wrong alignment on USearchingComponent");
static_assert(sizeof(USearchingComponent) == 0x0000C0, "Wrong size on USearchingComponent");

// Class BattlePrototype.SeqAnimInstance
// 0x0000 (0x0270 - 0x0270)
class USeqAnimInstance final : public UAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeqAnimInstance">();
	}
	static class USeqAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeqAnimInstance>();
	}
};
static_assert(alignof(USeqAnimInstance) == 0x000010, "Wrong alignment on USeqAnimInstance");
static_assert(sizeof(USeqAnimInstance) == 0x000270, "Wrong size on USeqAnimInstance");

// Class BattlePrototype.SequencerCharacterDummy
// 0x0008 (0x0238 - 0x0230)
class ASequencerCharacterDummy : public ARSActorSystemBase
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerCharacterDummy">();
	}
	static class ASequencerCharacterDummy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASequencerCharacterDummy>();
	}
};
static_assert(alignof(ASequencerCharacterDummy) == 0x000008, "Wrong alignment on ASequencerCharacterDummy");
static_assert(sizeof(ASequencerCharacterDummy) == 0x000238, "Wrong size on ASequencerCharacterDummy");
static_assert(offsetof(ASequencerCharacterDummy, Mesh) == 0x000230, "Member 'ASequencerCharacterDummy::Mesh' has a wrong offset!");

// Class BattlePrototype.SequencerEventUtility
// 0x0000 (0x0230 - 0x0230)
class ASequencerEventUtility final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerEventUtility">();
	}
	static class ASequencerEventUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASequencerEventUtility>();
	}
};
static_assert(alignof(ASequencerEventUtility) == 0x000008, "Wrong alignment on ASequencerEventUtility");
static_assert(sizeof(ASequencerEventUtility) == 0x000230, "Wrong size on ASequencerEventUtility");

// Class BattlePrototype.UIQuestDetailsMain
// 0x0060 (0x03E8 - 0x0388)
class UUIQuestDetailsMain : public UUIBase
{
public:
	uint8                                         Pad_388[0x60];                                     // 0x0388(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UTextBlock* TextTitle, class UREDScrollBoxSimple* ScrollBox, class UImage* Image1, class UImage* Image2, class UImage* Image3, class UImage* Image4, class UImage* Image5, class UUIQuestIcon* UIQuestIcon, class UUIQuestNamePlate* UIQuestNamePlate, class UCanvasPanel* QuestPanel, class UOverlay* OverlayImage1Set, class UOverlay* OverlayImage2Set, class UOverlay* OverlayImage3Set, class UOverlay* OverlayImage4Set, class UOverlay* OverlayImage5Set, class UOverlay* OverlayText1Set, class UOverlay* OverlayText2Set, class UOverlay* OverlayText3Set, class UOverlay* OverlayText4Set, class UOverlay* OverlayText5Set, class UOverlay* OverlayText6Set);
	void SetProgressIcon(int32 ProgressIndex);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestDetailsMain">();
	}
	static class UUIQuestDetailsMain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestDetailsMain>();
	}
};
static_assert(alignof(UUIQuestDetailsMain) == 0x000008, "Wrong alignment on UUIQuestDetailsMain");
static_assert(sizeof(UUIQuestDetailsMain) == 0x0003E8, "Wrong size on UUIQuestDetailsMain");

// Class BattlePrototype.SequencerFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class USequencerFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetGhostTrailInfo(class ARSLevelSequenceActor* Sequencer, class UObject* GhostTrailObject, TArray<struct FGhostTrailInfo>* GhostTrailInfo);
	static bool IsSequencerSpawner(class ARSLevelSequenceActor* Sequencer, class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerFunctionLibrary">();
	}
	static class USequencerFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USequencerFunctionLibrary>();
	}
};
static_assert(alignof(USequencerFunctionLibrary) == 0x000008, "Wrong alignment on USequencerFunctionLibrary");
static_assert(sizeof(USequencerFunctionLibrary) == 0x000028, "Wrong size on USequencerFunctionLibrary");

// Class BattlePrototype.SequencerMovieManagerController
// 0x0010 (0x0240 - 0x0230)
class ASequencerMovieManagerController : public AActor
{
public:
	TArray<class UManaTexture*>                   ManaTextureArray;                                  // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerMovieManagerController">();
	}
	static class ASequencerMovieManagerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASequencerMovieManagerController>();
	}
};
static_assert(alignof(ASequencerMovieManagerController) == 0x000008, "Wrong alignment on ASequencerMovieManagerController");
static_assert(sizeof(ASequencerMovieManagerController) == 0x000240, "Wrong size on ASequencerMovieManagerController");
static_assert(offsetof(ASequencerMovieManagerController, ManaTextureArray) == 0x000230, "Member 'ASequencerMovieManagerController::ManaTextureArray' has a wrong offset!");

// Class BattlePrototype.SequencerParticle
// 0x0038 (0x0268 - 0x0230)
class ASequencerParticle : public AActor
{
public:
	float                                         WarmupTime;                                        // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoolVector                            AttachSocketLocation;                              // 0x0234(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoolVector                            AttachSocketRotation;                              // 0x0237(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	ERSParticleSystemAttachRotationOffMode        AttachSocketRotationOffMode;                       // 0x023A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoolVector                            AttachSocketScale;                                 // 0x023B(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	ESequencerDilationOwner                       DilationOwner;                                     // 0x023E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23F[0x1];                                      // 0x023F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class URSParticleSystemComponentBase*         ParticleSystemComponent;                           // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x20];                                     // 0x0248(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActivated(class UActorComponent* Component, bool bReset);
	void SetupAttachInstanceParameter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerParticle">();
	}
	static class ASequencerParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASequencerParticle>();
	}
};
static_assert(alignof(ASequencerParticle) == 0x000008, "Wrong alignment on ASequencerParticle");
static_assert(sizeof(ASequencerParticle) == 0x000268, "Wrong size on ASequencerParticle");
static_assert(offsetof(ASequencerParticle, WarmupTime) == 0x000230, "Member 'ASequencerParticle::WarmupTime' has a wrong offset!");
static_assert(offsetof(ASequencerParticle, AttachSocketLocation) == 0x000234, "Member 'ASequencerParticle::AttachSocketLocation' has a wrong offset!");
static_assert(offsetof(ASequencerParticle, AttachSocketRotation) == 0x000237, "Member 'ASequencerParticle::AttachSocketRotation' has a wrong offset!");
static_assert(offsetof(ASequencerParticle, AttachSocketRotationOffMode) == 0x00023A, "Member 'ASequencerParticle::AttachSocketRotationOffMode' has a wrong offset!");
static_assert(offsetof(ASequencerParticle, AttachSocketScale) == 0x00023B, "Member 'ASequencerParticle::AttachSocketScale' has a wrong offset!");
static_assert(offsetof(ASequencerParticle, DilationOwner) == 0x00023E, "Member 'ASequencerParticle::DilationOwner' has a wrong offset!");
static_assert(offsetof(ASequencerParticle, ParticleSystemComponent) == 0x000240, "Member 'ASequencerParticle::ParticleSystemComponent' has a wrong offset!");

// Class BattlePrototype.SequencerParticleTrail
// 0x0028 (0x0290 - 0x0268)
class ASequencerParticleTrail final : public ASequencerParticle
{
public:
	class FName                                   FirstSocketName;                                   // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SecondSocketName;                                  // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrailWidthMode                               WidthScaleMode;                                    // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WidthScale;                                        // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeRate;                                          // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FadeOutMaterialScalarName;                         // 0x0284(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerParticleTrail">();
	}
	static class ASequencerParticleTrail* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASequencerParticleTrail>();
	}
};
static_assert(alignof(ASequencerParticleTrail) == 0x000008, "Wrong alignment on ASequencerParticleTrail");
static_assert(sizeof(ASequencerParticleTrail) == 0x000290, "Wrong size on ASequencerParticleTrail");
static_assert(offsetof(ASequencerParticleTrail, FirstSocketName) == 0x000268, "Member 'ASequencerParticleTrail::FirstSocketName' has a wrong offset!");
static_assert(offsetof(ASequencerParticleTrail, SecondSocketName) == 0x000270, "Member 'ASequencerParticleTrail::SecondSocketName' has a wrong offset!");
static_assert(offsetof(ASequencerParticleTrail, WidthScaleMode) == 0x000278, "Member 'ASequencerParticleTrail::WidthScaleMode' has a wrong offset!");
static_assert(offsetof(ASequencerParticleTrail, WidthScale) == 0x00027C, "Member 'ASequencerParticleTrail::WidthScale' has a wrong offset!");
static_assert(offsetof(ASequencerParticleTrail, FadeRate) == 0x000280, "Member 'ASequencerParticleTrail::FadeRate' has a wrong offset!");
static_assert(offsetof(ASequencerParticleTrail, FadeOutMaterialScalarName) == 0x000284, "Member 'ASequencerParticleTrail::FadeOutMaterialScalarName' has a wrong offset!");

// Class BattlePrototype.UIQuestMenu
// 0x0E58 (0x11E0 - 0x0388)
class UUIQuestMenu : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0xE40];                                    // 0x03A0(0x0E40)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(int32 Index_0, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision);
	void InitializeCategory(int32 Category, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimUnselect, class UTextBlock* TextCategory);
	void InitializeCommonParts(class UUIMainContents* UIMainContents, class UTextBlock* TextHelp, class UUIGuide* UiKeyGuide);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimInfoWindow, class UWidgetAnimation* AnimInfoWindowIn, class UWidgetAnimation* AnimInfoWindowOut, class UBorder* borderAllColor, class UREDScrollBox* ScrollBox, class UUIQuestListIndex* UiListIndexBase, class UUIQuestChoice* ChildQuestPopup, class UUIBase* ChildErrorPopup, class UUIQuestDetailsMain* ChildDetailsMain, class UUIQuestDetailsSub* ChildDetailsSub, class UUIQuestDetailsBonds* ChildDetailsBounds);
	bool IsEndErrorPopup();
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUpdateElement(int32 Index_0, class UUserWidget* Widget);
	void SetContentsChange(bool IsChange);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool IsEndMenu() const;
	bool IsPlayingProgramAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestMenu">();
	}
	static class UUIQuestMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestMenu>();
	}
};
static_assert(alignof(UUIQuestMenu) == 0x000008, "Wrong alignment on UUIQuestMenu");
static_assert(sizeof(UUIQuestMenu) == 0x0011E0, "Wrong size on UUIQuestMenu");
static_assert(offsetof(UUIQuestMenu, ListElementSize) == 0x000388, "Member 'UUIQuestMenu::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUIQuestMenu, ListOffsetSize) == 0x000390, "Member 'UUIQuestMenu::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUIQuestMenu, ListIndexClass) == 0x000398, "Member 'UUIQuestMenu::ListIndexClass' has a wrong offset!");

// Class BattlePrototype.SequencerSound
// 0x0010 (0x0240 - 0x0230)
class ASequencerSound : public AActor
{
public:
	class URSAtomComponentBase*                   AtomComponent;                                     // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class URSAtomComponentBase* GetAtomComponent();
	void StopSequenceSound(float FadeTime, float FadeVolume);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerSound">();
	}
	static class ASequencerSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASequencerSound>();
	}
};
static_assert(alignof(ASequencerSound) == 0x000008, "Wrong alignment on ASequencerSound");
static_assert(sizeof(ASequencerSound) == 0x000240, "Wrong size on ASequencerSound");
static_assert(offsetof(ASequencerSound, AtomComponent) == 0x000230, "Member 'ASequencerSound::AtomComponent' has a wrong offset!");

// Class BattlePrototype.SequencerSoundManagerController
// 0x0010 (0x0240 - 0x0230)
class ASequencerSoundManagerController : public AActor
{
public:
	TArray<class USoundAtomCue*>                  BgmCueArray;                                       // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerSoundManagerController">();
	}
	static class ASequencerSoundManagerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASequencerSoundManagerController>();
	}
};
static_assert(alignof(ASequencerSoundManagerController) == 0x000008, "Wrong alignment on ASequencerSoundManagerController");
static_assert(sizeof(ASequencerSoundManagerController) == 0x000240, "Wrong size on ASequencerSoundManagerController");
static_assert(offsetof(ASequencerSoundManagerController, BgmCueArray) == 0x000230, "Member 'ASequencerSoundManagerController::BgmCueArray' has a wrong offset!");

// Class BattlePrototype.ShowDestinationActor
// 0x0000 (0x0230 - 0x0230)
class AShowDestinationActor : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowDestinationActor">();
	}
	static class AShowDestinationActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShowDestinationActor>();
	}
};
static_assert(alignof(AShowDestinationActor) == 0x000008, "Wrong alignment on AShowDestinationActor");
static_assert(sizeof(AShowDestinationActor) == 0x000230, "Wrong size on AShowDestinationActor");

// Class BattlePrototype.ShowDestinationData
// 0x0008 (0x0030 - 0x0028)
class UShowDestinationData final : public UObject
{
public:
	class UShowDestinationDBAsset*                ShowDestinationAsset_;                             // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GetDataCellFromActorName(class FName ActorName, struct FShowDestinationDBDataCell* Cell);
	bool LoadDataAsset(const class FString& DtPath);

	const TMap<class FName, struct FShowDestinationDBDataCell> GetDB() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowDestinationData">();
	}
	static class UShowDestinationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShowDestinationData>();
	}
};
static_assert(alignof(UShowDestinationData) == 0x000008, "Wrong alignment on UShowDestinationData");
static_assert(sizeof(UShowDestinationData) == 0x000030, "Wrong size on UShowDestinationData");
static_assert(offsetof(UShowDestinationData, ShowDestinationAsset_) == 0x000028, "Member 'UShowDestinationData::ShowDestinationAsset_' has a wrong offset!");

// Class BattlePrototype.UISASButton2
// 0x0018 (0x03A0 - 0x0388)
class UUISASButton2 : public UUIBase
{
public:
	uint8                                         Pad_388[0x18];                                     // 0x0388(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Decide();
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimChangeSas1, class UWidgetAnimation* AnimDefaultSas, class UWidgetAnimation* AnimChangeSas2, class UWidgetAnimation* AnimDecisionSas, class UWidgetAnimation* AnimChangePage1, class UWidgetAnimation* AnimDefaultPage, class UWidgetAnimation* AnimChangePage2, class UWidgetAnimation* AnimDecisionPage, class UImage* ImageSasIconFont, class UImage* ImageSasButton);
	void SetPageFlag(bool IsPage);
	void SetReadyFlag(bool IsReady);
	void UpdateStateThis(int32 State, int32 SubState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISASButton2">();
	}
	static class UUISASButton2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISASButton2>();
	}
};
static_assert(alignof(UUISASButton2) == 0x000008, "Wrong alignment on UUISASButton2");
static_assert(sizeof(UUISASButton2) == 0x0003A0, "Wrong size on UUISASButton2");

// Class BattlePrototype.ShowDestinationDBAsset
// 0x0050 (0x0078 - 0x0028)
class UShowDestinationDBAsset final : public UObject
{
public:
	TMap<class FName, struct FShowDestinationDBDataCell> DBMap;                                             // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	void Convert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowDestinationDBAsset">();
	}
	static class UShowDestinationDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShowDestinationDBAsset>();
	}
};
static_assert(alignof(UShowDestinationDBAsset) == 0x000008, "Wrong alignment on UShowDestinationDBAsset");
static_assert(sizeof(UShowDestinationDBAsset) == 0x000078, "Wrong size on UShowDestinationDBAsset");
static_assert(offsetof(UShowDestinationDBAsset, DBMap) == 0x000028, "Member 'UShowDestinationDBAsset::DBMap' has a wrong offset!");

// Class BattlePrototype.ShowDestinationExporter
// 0x0098 (0x02C8 - 0x0230)
class AShowDestinationExporter final : public AActor
{
public:
	uint8                                         Pad_230[0x98];                                     // 0x0230(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConvertString();
	void ExportData();
	void GetAllActorsOfAllLevels(const class UObject* WorldContextObject, TArray<class AActor*>* Actors);
	void RegistData(const class FString& ActorName, const struct FVector& ActorPosition, int32 CheckType, int32 ProgressId, int32 Nanka, const TArray<int32>& CType, const TArray<class FString>& CName, const TArray<bool>& CIsCheck, class FString* LocationName, class FString* AreaName);
	void RegistSortData(const class FString& ActorName, const class FString& LocationName, const class FString& AreaName, const struct FVector& ActorPosition, int32 CheckType, int32 ProgressId, int32 Nanka, const TArray<int32>& CType, const TArray<class FString>& CName, const TArray<bool>& CIsCheck);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowDestinationExporter">();
	}
	static class AShowDestinationExporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShowDestinationExporter>();
	}
};
static_assert(alignof(AShowDestinationExporter) == 0x000008, "Wrong alignment on AShowDestinationExporter");
static_assert(sizeof(AShowDestinationExporter) == 0x0002C8, "Wrong size on AShowDestinationExporter");

// Class BattlePrototype.ShowDestinationTableExporter
// 0x0040 (0x0270 - 0x0230)
class AShowDestinationTableExporter final : public AActor
{
public:
	uint8                                         Pad_230[0x20];                                     // 0x0230(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULevel*>                         LoadedLevels_;                                     // 0x0250(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FShowDestinationActorData>      PickedUpActor_;                                    // 0x0260(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ExportCSVData();
	void GetAllActorsOfAllLevels(const class UObject* WorldContextObject, TArray<class AActor*>* PickedUpActor, int32 LocationId, int32 AreaId);
	bool RegistDataAtLoadedLevel(int32 LocationId, int32 AreaId);
	void RegistExportDatas(const TArray<struct FShowDestinationActorData>& ExportDatas);
	void SearchLoadedLevels();
	void StartupAtLoadBeginDoOnce();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowDestinationTableExporter">();
	}
	static class AShowDestinationTableExporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShowDestinationTableExporter>();
	}
};
static_assert(alignof(AShowDestinationTableExporter) == 0x000008, "Wrong alignment on AShowDestinationTableExporter");
static_assert(sizeof(AShowDestinationTableExporter) == 0x000270, "Wrong size on AShowDestinationTableExporter");
static_assert(offsetof(AShowDestinationTableExporter, LoadedLevels_) == 0x000250, "Member 'AShowDestinationTableExporter::LoadedLevels_' has a wrong offset!");
static_assert(offsetof(AShowDestinationTableExporter, PickedUpActor_) == 0x000260, "Member 'AShowDestinationTableExporter::PickedUpActor_' has a wrong offset!");

// Class BattlePrototype.SIWBlock
// 0x0008 (0x0238 - 0x0230)
class ASIWBlock final : public AActor
{
public:
	float                                         AttenuationRate;                                   // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SIWBlock">();
	}
	static class ASIWBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASIWBlock>();
	}
};
static_assert(alignof(ASIWBlock) == 0x000008, "Wrong alignment on ASIWBlock");
static_assert(sizeof(ASIWBlock) == 0x000238, "Wrong size on ASIWBlock");
static_assert(offsetof(ASIWBlock, AttenuationRate) == 0x000230, "Member 'ASIWBlock::AttenuationRate' has a wrong offset!");

// Class BattlePrototype.SnowCaptureBase
// 0x0108 (0x0338 - 0x0230)
class ASnowCaptureBase final : public AActor
{
public:
	class USceneComponent*                        RootComponent_;                                    // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URSSceneCaptureComponent2D*             SceneCaptureComponent_;                            // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SimpleMeshComponentCenter_;                        // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SimpleMeshComponentLeft_;                          // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SimpleMeshComponentRight_;                         // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SimpleMeshFootComponentCenter_;                    // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SimpleMeshFootComponentLeft_;                      // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SimpleMeshFootComponentRight_;                     // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SimpleBodyMeshComponentCenter_;                    // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SimpleBodyMeshComponentLeft_;                      // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SimpleBodyMeshComponentRight_;                     // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ALandscapeProxy*>                Landscapes_;                                       // 0x0288(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSnowDepthData>                 DepthDatas_;                                       // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DepthMaterialBase_;                                // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AddDepthValue_;                                    // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TextureSize_;                                      // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         blurLevel_;                                        // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseBlurBeforeFrameTex_;                            // 0x02BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BD[0x3];                                      // 0x02BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         blurSpeedMulti_;                                   // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         beforeCaptureDecayValue_;                          // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseSimpleMesh_;                                    // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseBothFeetSimpleMesh_;                            // 0x02C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CA[0x6];                                      // 0x02CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            SimpleMesh_;                                       // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SimpleMeshScale_;                                  // 0x02D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            SimpleBodyMesh_;                                   // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SimpleBodyMeshScale_;                              // 0x02F0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSCharacterBase*                       PlayerData_;                                       // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsOddFrame_;                                       // 0x0308(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_309[0x3];                                      // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                beforeActorEven_;                                  // 0x030C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                beforeActorOdd_;                                   // 0x0318(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           MpcSnowCapture_;                                   // 0x0328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x8];                                      // 0x0330(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateRenderTargets();
	void CreateSnowMaterialInstance();
	void RegistShowOnlyActorComponent();
	void SetLandscapematerialParam(const struct FSnowDepthData& DepthData, const struct FVector& beforeLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnowCaptureBase">();
	}
	static class ASnowCaptureBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASnowCaptureBase>();
	}
};
static_assert(alignof(ASnowCaptureBase) == 0x000008, "Wrong alignment on ASnowCaptureBase");
static_assert(sizeof(ASnowCaptureBase) == 0x000338, "Wrong size on ASnowCaptureBase");
static_assert(offsetof(ASnowCaptureBase, RootComponent_) == 0x000230, "Member 'ASnowCaptureBase::RootComponent_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SceneCaptureComponent_) == 0x000238, "Member 'ASnowCaptureBase::SceneCaptureComponent_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleMeshComponentCenter_) == 0x000240, "Member 'ASnowCaptureBase::SimpleMeshComponentCenter_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleMeshComponentLeft_) == 0x000248, "Member 'ASnowCaptureBase::SimpleMeshComponentLeft_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleMeshComponentRight_) == 0x000250, "Member 'ASnowCaptureBase::SimpleMeshComponentRight_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleMeshFootComponentCenter_) == 0x000258, "Member 'ASnowCaptureBase::SimpleMeshFootComponentCenter_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleMeshFootComponentLeft_) == 0x000260, "Member 'ASnowCaptureBase::SimpleMeshFootComponentLeft_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleMeshFootComponentRight_) == 0x000268, "Member 'ASnowCaptureBase::SimpleMeshFootComponentRight_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleBodyMeshComponentCenter_) == 0x000270, "Member 'ASnowCaptureBase::SimpleBodyMeshComponentCenter_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleBodyMeshComponentLeft_) == 0x000278, "Member 'ASnowCaptureBase::SimpleBodyMeshComponentLeft_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleBodyMeshComponentRight_) == 0x000280, "Member 'ASnowCaptureBase::SimpleBodyMeshComponentRight_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, Landscapes_) == 0x000288, "Member 'ASnowCaptureBase::Landscapes_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, DepthDatas_) == 0x000298, "Member 'ASnowCaptureBase::DepthDatas_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, DepthMaterialBase_) == 0x0002A8, "Member 'ASnowCaptureBase::DepthMaterialBase_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, AddDepthValue_) == 0x0002B0, "Member 'ASnowCaptureBase::AddDepthValue_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, TextureSize_) == 0x0002B4, "Member 'ASnowCaptureBase::TextureSize_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, blurLevel_) == 0x0002B8, "Member 'ASnowCaptureBase::blurLevel_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, UseBlurBeforeFrameTex_) == 0x0002BC, "Member 'ASnowCaptureBase::UseBlurBeforeFrameTex_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, blurSpeedMulti_) == 0x0002C0, "Member 'ASnowCaptureBase::blurSpeedMulti_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, beforeCaptureDecayValue_) == 0x0002C4, "Member 'ASnowCaptureBase::beforeCaptureDecayValue_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, UseSimpleMesh_) == 0x0002C8, "Member 'ASnowCaptureBase::UseSimpleMesh_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, UseBothFeetSimpleMesh_) == 0x0002C9, "Member 'ASnowCaptureBase::UseBothFeetSimpleMesh_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleMesh_) == 0x0002D0, "Member 'ASnowCaptureBase::SimpleMesh_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleMeshScale_) == 0x0002D8, "Member 'ASnowCaptureBase::SimpleMeshScale_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleBodyMesh_) == 0x0002E8, "Member 'ASnowCaptureBase::SimpleBodyMesh_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleBodyMeshScale_) == 0x0002F0, "Member 'ASnowCaptureBase::SimpleBodyMeshScale_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, PlayerData_) == 0x000300, "Member 'ASnowCaptureBase::PlayerData_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, IsOddFrame_) == 0x000308, "Member 'ASnowCaptureBase::IsOddFrame_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, beforeActorEven_) == 0x00030C, "Member 'ASnowCaptureBase::beforeActorEven_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, beforeActorOdd_) == 0x000318, "Member 'ASnowCaptureBase::beforeActorOdd_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, MpcSnowCapture_) == 0x000328, "Member 'ASnowCaptureBase::MpcSnowCapture_' has a wrong offset!");

// Class BattlePrototype.SoundBackground
// 0x0008 (0x0238 - 0x0230)
class ASoundBackground final : public ARSActorBackgroundBase
{
public:
	class URSAtomComponentBase*                   AtomComponent;                                     // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundBackground">();
	}
	static class ASoundBackground* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASoundBackground>();
	}
};
static_assert(alignof(ASoundBackground) == 0x000008, "Wrong alignment on ASoundBackground");
static_assert(sizeof(ASoundBackground) == 0x000238, "Wrong size on ASoundBackground");
static_assert(offsetof(ASoundBackground, AtomComponent) == 0x000230, "Member 'ASoundBackground::AtomComponent' has a wrong offset!");

// Class BattlePrototype.SoundCategoryComponent
// 0x00D0 (0x0190 - 0x00C0)
class USoundCategoryComponent final : public UActorComponent
{
public:
	uint8                                         Pad_C0[0xD0];                                      // 0x00C0(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Fade(float DeltaTime);
	void FadeIn(ESoundCategory Category, float FadeTime, float FadeScale);
	void FadeOut(ESoundCategory Category, float FadeTime, float FadeScale);
	float GetSoundBaseVolumeCategoryScale(ESoundCategory Category);
	float GetSoundVolumeCategoryScaleCalc(ESoundCategory Category);
	void ResetSoundVolumeCategoryScale();
	void SetFadeParam(ESoundCategory Category, float FadeTime, float FadeFinishScale);
	void SetSoundVolumeCategoryScale(ESoundCategory Category, float Scale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundCategoryComponent">();
	}
	static class USoundCategoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundCategoryComponent>();
	}
};
static_assert(alignof(USoundCategoryComponent) == 0x000008, "Wrong alignment on USoundCategoryComponent");
static_assert(sizeof(USoundCategoryComponent) == 0x000190, "Wrong size on USoundCategoryComponent");

// Class BattlePrototype.SoundCueSheetManager
// 0x0010 (0x00D0 - 0x00C0)
class USoundCueSheetManager final : public UActorComponent
{
public:
	TArray<struct FSoundCueSheet>                 DynamicCueSheet;                                   // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class USoundAtomCue* GetAtomCueByLoadedCueSheet(TSoftObjectPtr<class USoundAtomCue> AtomCueSoftRef, TSoftObjectPtr<class USoundAtomCueSheet> PreferenceCueSheetSoftRef);
	class USoundAtomCue* GetAtomCueByLoadedCueSheetFromString(const class FString& CueName);
	class USoundAtomCueSheet* GetCueSheetByName(const class FString& CueSheetName);
	bool Register(class USoundAtomCueSheet* Sheet);
	bool RegisterFromPath(const class FString& Path);
	bool RegisterFromSoftRef(TSoftObjectPtr<class USoundAtomCueSheet> SheetSoftRef);
	bool Unregister(class USoundAtomCueSheet* Sheet);
	bool UnregisterFromPath(const class FString& Path);
	bool UnregisterFromSoftRef(TSoftObjectPtr<class USoundAtomCueSheet> SheetSoftRef);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundCueSheetManager">();
	}
	static class USoundCueSheetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundCueSheetManager>();
	}
};
static_assert(alignof(USoundCueSheetManager) == 0x000008, "Wrong alignment on USoundCueSheetManager");
static_assert(sizeof(USoundCueSheetManager) == 0x0000D0, "Wrong size on USoundCueSheetManager");
static_assert(offsetof(USoundCueSheetManager, DynamicCueSheet) == 0x0000C0, "Member 'USoundCueSheetManager::DynamicCueSheet' has a wrong offset!");

// Class BattlePrototype.SoundPoolObject
// 0x0010 (0x0038 - 0x0028)
class USoundPoolObject final : public UObject
{
public:
	class URSAtomComponentBase*                   Component;                                         // 0x0028(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Used;                                              // 0x0030(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class URSAtomComponentBase* Get();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundPoolObject">();
	}
	static class USoundPoolObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundPoolObject>();
	}
};
static_assert(alignof(USoundPoolObject) == 0x000008, "Wrong alignment on USoundPoolObject");
static_assert(sizeof(USoundPoolObject) == 0x000038, "Wrong size on USoundPoolObject");
static_assert(offsetof(USoundPoolObject, Component) == 0x000028, "Member 'USoundPoolObject::Component' has a wrong offset!");
static_assert(offsetof(USoundPoolObject, Used) == 0x000030, "Member 'USoundPoolObject::Used' has a wrong offset!");

// Class BattlePrototype.SoundPoolManager
// 0x0020 (0x0048 - 0x0028)
class USoundPoolManager final : public UObject
{
public:
	class UClass*                                 Class_0;                                           // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USoundPoolObject*>               Heap;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Num;                                               // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundPoolManager">();
	}
	static class USoundPoolManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundPoolManager>();
	}
};
static_assert(alignof(USoundPoolManager) == 0x000008, "Wrong alignment on USoundPoolManager");
static_assert(sizeof(USoundPoolManager) == 0x000048, "Wrong size on USoundPoolManager");
static_assert(offsetof(USoundPoolManager, Class_0) == 0x000028, "Member 'USoundPoolManager::Class_0' has a wrong offset!");
static_assert(offsetof(USoundPoolManager, Heap) == 0x000030, "Member 'USoundPoolManager::Heap' has a wrong offset!");
static_assert(offsetof(USoundPoolManager, Num) == 0x000040, "Member 'USoundPoolManager::Num' has a wrong offset!");

// Class BattlePrototype.SprintComponent
// 0x0070 (0x0130 - 0x00C0)
class USprintComponent : public UActorComponent
{
public:
	float                                         _fWalkableFloorAngle;                              // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _isSprinting;                                      // 0x00C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _isEndSprinting;                                   // 0x00C5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C6[0x2];                                       // 0x00C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStartSprint;                                     // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnEndSprint;                                       // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	float                                         _sprintStartSec;                                   // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _walkStartTime;                                    // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _sprintClaimantName;                               // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxWalkSpeedRateBySprint;                         // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxWalkSpeedRateByBattleSprint;                   // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _sprintCurveAngle;                                 // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _sprintBankPow;                                    // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _sprintBankBackPow;                                // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C[0x24];                                     // 0x010C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeBattleSprint(bool bBattle);
	void EndSprint();
	void ProcessSprint(float DeltaTime);
	void SetEventSprint(bool bEnable);
	void SetMaxWalkSpeedRate();
	void SetSprintSpeedRate(float Rate, float BattleRate);
	void StartSprint(bool bBattle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SprintComponent">();
	}
	static class USprintComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USprintComponent>();
	}
};
static_assert(alignof(USprintComponent) == 0x000008, "Wrong alignment on USprintComponent");
static_assert(sizeof(USprintComponent) == 0x000130, "Wrong size on USprintComponent");
static_assert(offsetof(USprintComponent, _fWalkableFloorAngle) == 0x0000C0, "Member 'USprintComponent::_fWalkableFloorAngle' has a wrong offset!");
static_assert(offsetof(USprintComponent, _isSprinting) == 0x0000C4, "Member 'USprintComponent::_isSprinting' has a wrong offset!");
static_assert(offsetof(USprintComponent, _isEndSprinting) == 0x0000C5, "Member 'USprintComponent::_isEndSprinting' has a wrong offset!");
static_assert(offsetof(USprintComponent, OnStartSprint) == 0x0000C8, "Member 'USprintComponent::OnStartSprint' has a wrong offset!");
static_assert(offsetof(USprintComponent, OnEndSprint) == 0x0000D8, "Member 'USprintComponent::OnEndSprint' has a wrong offset!");
static_assert(offsetof(USprintComponent, _sprintStartSec) == 0x0000E8, "Member 'USprintComponent::_sprintStartSec' has a wrong offset!");
static_assert(offsetof(USprintComponent, _walkStartTime) == 0x0000EC, "Member 'USprintComponent::_walkStartTime' has a wrong offset!");
static_assert(offsetof(USprintComponent, _sprintClaimantName) == 0x0000F0, "Member 'USprintComponent::_sprintClaimantName' has a wrong offset!");
static_assert(offsetof(USprintComponent, _maxWalkSpeedRateBySprint) == 0x0000F8, "Member 'USprintComponent::_maxWalkSpeedRateBySprint' has a wrong offset!");
static_assert(offsetof(USprintComponent, _maxWalkSpeedRateByBattleSprint) == 0x0000FC, "Member 'USprintComponent::_maxWalkSpeedRateByBattleSprint' has a wrong offset!");
static_assert(offsetof(USprintComponent, _sprintCurveAngle) == 0x000100, "Member 'USprintComponent::_sprintCurveAngle' has a wrong offset!");
static_assert(offsetof(USprintComponent, _sprintBankPow) == 0x000104, "Member 'USprintComponent::_sprintBankPow' has a wrong offset!");
static_assert(offsetof(USprintComponent, _sprintBankBackPow) == 0x000108, "Member 'USprintComponent::_sprintBankBackPow' has a wrong offset!");

// Class BattlePrototype.StageEffectParameterSettingVolume
// 0x0018 (0x02A0 - 0x0288)
class AStageEffectParameterSettingVolume final : public ABlendableVolume
{
public:
	struct FStageEffectParameterSettings          Settings;                                          // 0x0288(0x0014)(Edit, BlueprintVisible, Interp, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageEffectParameterSettingVolume">();
	}
	static class AStageEffectParameterSettingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStageEffectParameterSettingVolume>();
	}
};
static_assert(alignof(AStageEffectParameterSettingVolume) == 0x000008, "Wrong alignment on AStageEffectParameterSettingVolume");
static_assert(sizeof(AStageEffectParameterSettingVolume) == 0x0002A0, "Wrong size on AStageEffectParameterSettingVolume");
static_assert(offsetof(AStageEffectParameterSettingVolume, Settings) == 0x000288, "Member 'AStageEffectParameterSettingVolume::Settings' has a wrong offset!");

// Class BattlePrototype.StageEffectParameterSettingVolumeManager
// 0x0018 (0x0260 - 0x0248)
class AStageEffectParameterSettingVolumeManager final : public ABlendableVolumeManager
{
public:
	struct FStageEffectParameterSettings          Parameter;                                         // 0x0248(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FStageEffectParameterSettings CalcParameter(const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageEffectParameterSettingVolumeManager">();
	}
	static class AStageEffectParameterSettingVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStageEffectParameterSettingVolumeManager>();
	}
};
static_assert(alignof(AStageEffectParameterSettingVolumeManager) == 0x000008, "Wrong alignment on AStageEffectParameterSettingVolumeManager");
static_assert(sizeof(AStageEffectParameterSettingVolumeManager) == 0x000260, "Wrong size on AStageEffectParameterSettingVolumeManager");
static_assert(offsetof(AStageEffectParameterSettingVolumeManager, Parameter) == 0x000248, "Member 'AStageEffectParameterSettingVolumeManager::Parameter' has a wrong offset!");

// Class BattlePrototype.StageManager
// 0x0028 (0x0258 - 0x0230)
class AStageManager : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UArrangeObjectManager*                  ArrangeObjectManager;                              // 0x0238(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrangeItemStageManager*               ArrangeItemStageManager;                           // 0x0240(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNpcManager*                            NpcManager;                                        // 0x0248(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGimmickManager*                        GimmickManager;                                    // 0x0250(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UArrangeItemStageManager* GetArrangeItemStageManager();
	class UArrangeObjectManager* GetArrangeObjectManager();
	class UGimmickManager* GetGimmickManager();
	class UNpcManager* GetNpcManager();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageManager">();
	}
	static class AStageManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStageManager>();
	}
};
static_assert(alignof(AStageManager) == 0x000008, "Wrong alignment on AStageManager");
static_assert(sizeof(AStageManager) == 0x000258, "Wrong size on AStageManager");
static_assert(offsetof(AStageManager, ArrangeObjectManager) == 0x000238, "Member 'AStageManager::ArrangeObjectManager' has a wrong offset!");
static_assert(offsetof(AStageManager, ArrangeItemStageManager) == 0x000240, "Member 'AStageManager::ArrangeItemStageManager' has a wrong offset!");
static_assert(offsetof(AStageManager, NpcManager) == 0x000248, "Member 'AStageManager::NpcManager' has a wrong offset!");
static_assert(offsetof(AStageManager, GimmickManager) == 0x000250, "Member 'AStageManager::GimmickManager' has a wrong offset!");

// Class BattlePrototype.StageParameterSettingLightVector
// 0x0028 (0x0258 - 0x0230)
class AStageParameterSettingLightVector final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UArrowComponent*                        AmbientLightVector;                                // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0244(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_245[0x13];                                     // 0x0245(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageParameterSettingLightVector">();
	}
	static class AStageParameterSettingLightVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStageParameterSettingLightVector>();
	}
};
static_assert(alignof(AStageParameterSettingLightVector) == 0x000008, "Wrong alignment on AStageParameterSettingLightVector");
static_assert(sizeof(AStageParameterSettingLightVector) == 0x000258, "Wrong size on AStageParameterSettingLightVector");
static_assert(offsetof(AStageParameterSettingLightVector, AmbientLightVector) == 0x000238, "Member 'AStageParameterSettingLightVector::AmbientLightVector' has a wrong offset!");
static_assert(offsetof(AStageParameterSettingLightVector, Priority) == 0x000240, "Member 'AStageParameterSettingLightVector::Priority' has a wrong offset!");
static_assert(offsetof(AStageParameterSettingLightVector, bEnabled) == 0x000244, "Member 'AStageParameterSettingLightVector::bEnabled' has a wrong offset!");

// Class BattlePrototype.StageParameterSettingVolume
// 0x00E0 (0x0368 - 0x0288)
class AStageParameterSettingVolume final : public ABlendableVolume
{
public:
	struct FStageParameterSettings                Settings;                                          // 0x0288(0x00E0)(Edit, BlueprintVisible, Interp, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageParameterSettingVolume">();
	}
	static class AStageParameterSettingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStageParameterSettingVolume>();
	}
};
static_assert(alignof(AStageParameterSettingVolume) == 0x000008, "Wrong alignment on AStageParameterSettingVolume");
static_assert(sizeof(AStageParameterSettingVolume) == 0x000368, "Wrong size on AStageParameterSettingVolume");
static_assert(offsetof(AStageParameterSettingVolume, Settings) == 0x000288, "Member 'AStageParameterSettingVolume::Settings' has a wrong offset!");

// Class BattlePrototype.UIShopPartyStatus
// 0x0060 (0x03E8 - 0x0388)
class UUIShopPartyStatus : public UUIBase
{
public:
	float                                         DefaultPositionY;                                  // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TradePositionY;                                    // 0x038C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x58];                                     // 0x0390(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeIcons(class UUIShopPartyStatusIcon* UiIcon1, class UUIShopPartyStatusIcon* UiIcon2, class UUIShopPartyStatusIcon* UiIcon3, class UUIShopPartyStatusIcon* UiIcon4, class UUIShopPartyStatusIcon* UiIcon5, class UUIShopPartyStatusIcon* UiIcon6, class UUIShopPartyStatusIcon* UiIcon7, class UUIShopPartyStatusIcon* UiIcon8, class UUIShopPartyStatusIcon* UiIcon9, class UUIShopPartyStatusIcon* UiIcon10);
	void InitializeThis(class UBorder* borderAllColor);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopPartyStatus">();
	}
	static class UUIShopPartyStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopPartyStatus>();
	}
};
static_assert(alignof(UUIShopPartyStatus) == 0x000008, "Wrong alignment on UUIShopPartyStatus");
static_assert(sizeof(UUIShopPartyStatus) == 0x0003E8, "Wrong size on UUIShopPartyStatus");
static_assert(offsetof(UUIShopPartyStatus, DefaultPositionY) == 0x000388, "Member 'UUIShopPartyStatus::DefaultPositionY' has a wrong offset!");
static_assert(offsetof(UUIShopPartyStatus, TradePositionY) == 0x00038C, "Member 'UUIShopPartyStatus::TradePositionY' has a wrong offset!");

// Class BattlePrototype.StageParameterSettingFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UStageParameterSettingFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ConvertStageSettingToMaterialParameters(const struct FStageParameterSettings& Settings, TArray<class FName>* ParamScalarNames, TArray<float>* ParamScalars, TArray<class FName>* ParamVectorNames, TArray<struct FLinearColor>* ParamVectors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageParameterSettingFunctionLibrary">();
	}
	static class UStageParameterSettingFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStageParameterSettingFunctionLibrary>();
	}
};
static_assert(alignof(UStageParameterSettingFunctionLibrary) == 0x000008, "Wrong alignment on UStageParameterSettingFunctionLibrary");
static_assert(sizeof(UStageParameterSettingFunctionLibrary) == 0x000028, "Wrong size on UStageParameterSettingFunctionLibrary");

// Class BattlePrototype.StepComponent
// 0x0038 (0x00F8 - 0x00C0)
class UStepComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnStartStep;                                       // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FVector                                _stepInputDirection;                               // 0x00D0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _stepDistanceScale;                                // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _sprintMoveDuration;                               // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _sprintMoveDistance;                               // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndStep();
	void InputStep(const struct FVector& StepDirection, float StepDistanceRate, bool bEnableSprintMomentum);
	void StartStep(const struct FVector& StepDirection, float StepDistanceRate, bool bEnableSprintMomentum);

	struct FVector CalcDirectionWorldToActor(const struct FVector& WorldDir) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StepComponent">();
	}
	static class UStepComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStepComponent>();
	}
};
static_assert(alignof(UStepComponent) == 0x000008, "Wrong alignment on UStepComponent");
static_assert(sizeof(UStepComponent) == 0x0000F8, "Wrong size on UStepComponent");
static_assert(offsetof(UStepComponent, OnStartStep) == 0x0000C0, "Member 'UStepComponent::OnStartStep' has a wrong offset!");
static_assert(offsetof(UStepComponent, _stepInputDirection) == 0x0000D0, "Member 'UStepComponent::_stepInputDirection' has a wrong offset!");
static_assert(offsetof(UStepComponent, _stepDistanceScale) == 0x0000DC, "Member 'UStepComponent::_stepDistanceScale' has a wrong offset!");
static_assert(offsetof(UStepComponent, _sprintMoveDuration) == 0x0000E0, "Member 'UStepComponent::_sprintMoveDuration' has a wrong offset!");
static_assert(offsetof(UStepComponent, _sprintMoveDistance) == 0x0000E4, "Member 'UStepComponent::_sprintMoveDistance' has a wrong offset!");

// Class BattlePrototype.TargetableObjectInterface
// 0x0000 (0x0028 - 0x0028)
class ITargetableObjectInterface final : public IInterface
{
public:
	class AActor* GetPsychicObjectShield();
	struct FVector GetTargetCursorLocation();
	bool IsPsychicObjectShieldActive();

	bool IsBerserkCharacter() const;
	bool IsControlPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetableObjectInterface">();
	}
	static class ITargetableObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITargetableObjectInterface>();
	}
};
static_assert(alignof(ITargetableObjectInterface) == 0x000008, "Wrong alignment on ITargetableObjectInterface");
static_assert(sizeof(ITargetableObjectInterface) == 0x000028, "Wrong size on ITargetableObjectInterface");

// Class BattlePrototype.TargetSearchComponent
// 0x0090 (0x0150 - 0x00C0)
class UTargetSearchComponent : public UActorComponent
{
public:
	float                                         SearchDistance;                                    // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchYaw;                                         // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchPitch;                                       // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTargetSearchArea>              SearchArea;                                        // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchMobDistance;                                 // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockDistance;                                      // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Trace2ndZOffset;                                   // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LockonPlayerPos;                                   // 0x00EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InternalLockUpdateTime;                            // 0x00F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchChangeTarget;                              // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AEnemyManager*                          PEnemyManager_;                                    // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABattleManager*                         PBattleManager_;                                   // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TickInterval_;                                     // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124[0x2C];                                     // 0x0124(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTargetSearchComponent* GetTargetSearchComponentFromActor(class AActor* Actor);

	bool ChangeLockTarget(float AxisValue, const TArray<class ARSCharacterBase*>& EnemyList);
	void ClearLostTargetActor();
	class ARSCharacterBase* GetCurrentTargetActor();
	class ARSCharacterBase* GetLostTargetActor();
	void LockonTargetCalcPos(float LockonHeight);
	void OnSetBattling(bool bBattle);
	void RestoreLockTarget(bool bRetargetRestoreFailed);
	void SetLockTarget(bool bLock);
	void SetLockTargetDirect(class ARSCharacterBase* Actor);
	void SetLostFlag();
	void SetTargetFix(bool bFix);
	void StoreLockTarget();
	void UpdateCurrentTarget();

	bool IsAbleTarget(class ARSCharacterBase* Target, bool IsLock, ETargetListType ListType, ETargetFailedReason* OutReason) const;
	bool IsBossBattle() const;
	bool IsLockTarget() const;
	bool IsLostLockTarget() const;
	bool IsTargetFix() const;
	class ARSCharacterBase* SearchTargetActor(const TArray<class ARSCharacterBase*>& EnemyList, ETargetListType ListType, bool bIgnoreRendered) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetSearchComponent">();
	}
	static class UTargetSearchComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetSearchComponent>();
	}
};
static_assert(alignof(UTargetSearchComponent) == 0x000008, "Wrong alignment on UTargetSearchComponent");
static_assert(sizeof(UTargetSearchComponent) == 0x000150, "Wrong size on UTargetSearchComponent");
static_assert(offsetof(UTargetSearchComponent, SearchDistance) == 0x0000C0, "Member 'UTargetSearchComponent::SearchDistance' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, SearchYaw) == 0x0000C4, "Member 'UTargetSearchComponent::SearchYaw' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, SearchPitch) == 0x0000C8, "Member 'UTargetSearchComponent::SearchPitch' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, SearchArea) == 0x0000D0, "Member 'UTargetSearchComponent::SearchArea' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, SearchMobDistance) == 0x0000E0, "Member 'UTargetSearchComponent::SearchMobDistance' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, LockDistance) == 0x0000E4, "Member 'UTargetSearchComponent::LockDistance' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, Trace2ndZOffset) == 0x0000E8, "Member 'UTargetSearchComponent::Trace2ndZOffset' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, LockonPlayerPos) == 0x0000EC, "Member 'UTargetSearchComponent::LockonPlayerPos' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, InternalLockUpdateTime) == 0x0000F8, "Member 'UTargetSearchComponent::InternalLockUpdateTime' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, DispatchChangeTarget) == 0x000100, "Member 'UTargetSearchComponent::DispatchChangeTarget' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, PEnemyManager_) == 0x000110, "Member 'UTargetSearchComponent::PEnemyManager_' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, PBattleManager_) == 0x000118, "Member 'UTargetSearchComponent::PBattleManager_' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, TickInterval_) == 0x000120, "Member 'UTargetSearchComponent::TickInterval_' has a wrong offset!");

// Class BattlePrototype.UITarget
// 0x0050 (0x03D8 - 0x0388)
class UUITarget : public UUIBase
{
public:
	uint8                                         Pad_388[0x50];                                     // 0x0388(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Change();
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimChange, class UWidgetAnimation* AnimOut2, class USizeBox* SizeBox0, class USizeBox* SizeBoxAdd);
	void SetFlagDisturb(bool IsDisturb);
	void SetSize(float Size);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITarget">();
	}
	static class UUITarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITarget>();
	}
};
static_assert(alignof(UUITarget) == 0x000008, "Wrong alignment on UUITarget");
static_assert(sizeof(UUITarget) == 0x0003D8, "Wrong size on UUITarget");

// Class BattlePrototype.TaskBaseNative
// 0x0038 (0x00A8 - 0x0070)
class UTaskBaseNative final : public UBTTaskNode
{
public:
	uint8                                         Pad_70[0x38];                                      // 0x0070(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TaskBaseNative">();
	}
	static class UTaskBaseNative* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTaskBaseNative>();
	}
};
static_assert(alignof(UTaskBaseNative) == 0x000008, "Wrong alignment on UTaskBaseNative");
static_assert(sizeof(UTaskBaseNative) == 0x0000A8, "Wrong size on UTaskBaseNative");

// Class BattlePrototype.DebuggingItemTeamBondsLevel
// 0x0008 (0x0308 - 0x0300)
class ADebuggingItemTeamBondsLevel final : public ADebuggingItemInt
{
public:
	EPlayerID                                     PlayerType;                                        // 0x0300(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemTeamBondsLevel">();
	}
	static class ADebuggingItemTeamBondsLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemTeamBondsLevel>();
	}
};
static_assert(alignof(ADebuggingItemTeamBondsLevel) == 0x000008, "Wrong alignment on ADebuggingItemTeamBondsLevel");
static_assert(sizeof(ADebuggingItemTeamBondsLevel) == 0x000308, "Wrong size on ADebuggingItemTeamBondsLevel");
static_assert(offsetof(ADebuggingItemTeamBondsLevel, PlayerType) == 0x000300, "Member 'ADebuggingItemTeamBondsLevel::PlayerType' has a wrong offset!");

// Class BattlePrototype.DebuggingItemPresentEvent
// 0x0008 (0x02E8 - 0x02E0)
class ADebuggingItemPresentEvent final : public ADebuggingItemEvent
{
public:
	EPlayerID                                     PlayerType;                                        // 0x02E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x3];                                      // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ToLevel;                                           // 0x02E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemPresentEvent">();
	}
	static class ADebuggingItemPresentEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemPresentEvent>();
	}
};
static_assert(alignof(ADebuggingItemPresentEvent) == 0x000008, "Wrong alignment on ADebuggingItemPresentEvent");
static_assert(sizeof(ADebuggingItemPresentEvent) == 0x0002E8, "Wrong size on ADebuggingItemPresentEvent");
static_assert(offsetof(ADebuggingItemPresentEvent, PlayerType) == 0x0002E0, "Member 'ADebuggingItemPresentEvent::PlayerType' has a wrong offset!");
static_assert(offsetof(ADebuggingItemPresentEvent, ToLevel) == 0x0002E4, "Member 'ADebuggingItemPresentEvent::ToLevel' has a wrong offset!");

// Class BattlePrototype.DebuggingItemTeamBondsLevelGroup
// 0x0030 (0x0300 - 0x02D0)
class ADebuggingItemTeamBondsLevelGroup final : public ADebuggingItemGroup
{
public:
	TArray<TWeakObjectPtr<class ADebuggingItemTeamBondsLevel>> LevelIntList;                                      // 0x02D0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ADebuggingItemPresentEvent>> PresentEventList;                                  // 0x02E0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserParamManager*                      ParamMan;                                          // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDatabaseManager*                       DbMan;                                             // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnChangeLevel(const class ADebuggingItemInt* Item);
	void OnExecutePresent(const class ADebuggingItemEvent* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemTeamBondsLevelGroup">();
	}
	static class ADebuggingItemTeamBondsLevelGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemTeamBondsLevelGroup>();
	}
};
static_assert(alignof(ADebuggingItemTeamBondsLevelGroup) == 0x000008, "Wrong alignment on ADebuggingItemTeamBondsLevelGroup");
static_assert(sizeof(ADebuggingItemTeamBondsLevelGroup) == 0x000300, "Wrong size on ADebuggingItemTeamBondsLevelGroup");
static_assert(offsetof(ADebuggingItemTeamBondsLevelGroup, LevelIntList) == 0x0002D0, "Member 'ADebuggingItemTeamBondsLevelGroup::LevelIntList' has a wrong offset!");
static_assert(offsetof(ADebuggingItemTeamBondsLevelGroup, PresentEventList) == 0x0002E0, "Member 'ADebuggingItemTeamBondsLevelGroup::PresentEventList' has a wrong offset!");
static_assert(offsetof(ADebuggingItemTeamBondsLevelGroup, ParamMan) == 0x0002F0, "Member 'ADebuggingItemTeamBondsLevelGroup::ParamMan' has a wrong offset!");
static_assert(offsetof(ADebuggingItemTeamBondsLevelGroup, DbMan) == 0x0002F8, "Member 'ADebuggingItemTeamBondsLevelGroup::DbMan' has a wrong offset!");

// Class BattlePrototype.UITitleCrossSave_ConfirmWindow
// 0x0040 (0x03C8 - 0x0388)
class UUITitleCrossSave_ConfirmWindow final : public UUIBase
{
public:
	uint8                                         Pad_388[0x40];                                     // 0x0388(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefault, class UREDTextBlock* TextMain, class UREDScrollBoxSimple* ScrollBox, class UUITitleCrossSave_ConfirmWindow_Parts_Select2* UiSelect2);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleCrossSave_ConfirmWindow">();
	}
	static class UUITitleCrossSave_ConfirmWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleCrossSave_ConfirmWindow>();
	}
};
static_assert(alignof(UUITitleCrossSave_ConfirmWindow) == 0x000008, "Wrong alignment on UUITitleCrossSave_ConfirmWindow");
static_assert(sizeof(UUITitleCrossSave_ConfirmWindow) == 0x0003C8, "Wrong size on UUITitleCrossSave_ConfirmWindow");

// Class BattlePrototype.TeamComponent
// 0x0008 (0x00C8 - 0x00C0)
class UTeamComponent final : public UActorComponent
{
public:
	ETeamKind                                     OwnKind;                                           // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void CopyTeamParameterBetweenActor(class AActor* From, class AActor* To);
	static class UTeamComponent* GetTeamComponentFromActor(class AActor* Actor);

	void CopyTeamParameterFrom(class UTeamComponent* Other);

	bool IsEnemy() const;
	bool IsFriend(const class UTeamComponent* Opponent) const;
	bool IsMob() const;
	bool IsPlayer() const;
	bool IsRival(const class UTeamComponent* Opponent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamComponent">();
	}
	static class UTeamComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamComponent>();
	}
};
static_assert(alignof(UTeamComponent) == 0x000008, "Wrong alignment on UTeamComponent");
static_assert(sizeof(UTeamComponent) == 0x0000C8, "Wrong size on UTeamComponent");
static_assert(offsetof(UTeamComponent, OwnKind) == 0x0000C0, "Member 'UTeamComponent::OwnKind' has a wrong offset!");

// Class BattlePrototype.TeamUtility
// 0x0000 (0x0028 - 0x0028)
class UTeamUtility final : public UObject
{
public:
	static void SearchRivalCharacters(TArray<class ARSCharacterBase*>* FindCharas, class ARSCharacterBase* StarndardChara, float SeachDistance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamUtility">();
	}
	static class UTeamUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamUtility>();
	}
};
static_assert(alignof(UTeamUtility) == 0x000008, "Wrong alignment on UTeamUtility");
static_assert(sizeof(UTeamUtility) == 0x000028, "Wrong size on UTeamUtility");

// Class BattlePrototype.TeleportableWallBase
// 0x0028 (0x0258 - 0x0230)
class ATeleportableWallBase final : public AActor
{
public:
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        IconPosition;                                      // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          ShowComponent;                                     // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                WorldPositionOffset;                               // 0x0248(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeleportableWallBase">();
	}
	static class ATeleportableWallBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeleportableWallBase>();
	}
};
static_assert(alignof(ATeleportableWallBase) == 0x000008, "Wrong alignment on ATeleportableWallBase");
static_assert(sizeof(ATeleportableWallBase) == 0x000258, "Wrong size on ATeleportableWallBase");
static_assert(offsetof(ATeleportableWallBase, MeshComponent) == 0x000230, "Member 'ATeleportableWallBase::MeshComponent' has a wrong offset!");
static_assert(offsetof(ATeleportableWallBase, IconPosition) == 0x000238, "Member 'ATeleportableWallBase::IconPosition' has a wrong offset!");
static_assert(offsetof(ATeleportableWallBase, ShowComponent) == 0x000240, "Member 'ATeleportableWallBase::ShowComponent' has a wrong offset!");
static_assert(offsetof(ATeleportableWallBase, WorldPositionOffset) == 0x000248, "Member 'ATeleportableWallBase::WorldPositionOffset' has a wrong offset!");

// Class BattlePrototype.TestSave
// 0x0100 (0x0128 - 0x0028)
class UTestSave final : public USaveGame
{
public:
	int32                                         TestInt_;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestFloat_;                                        // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TestFName_;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 TestArrayInt_;                                     // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSaveTestStruct                        TestStruct_;                                       // 0x0048(0x0018)(NativeAccessSpecifierPublic)
	TArray<struct FSaveTestStruct>                TestArrayStruct_;                                  // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0xB8];                                      // 0x0070(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestSave">();
	}
	static class UTestSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestSave>();
	}
};
static_assert(alignof(UTestSave) == 0x000008, "Wrong alignment on UTestSave");
static_assert(sizeof(UTestSave) == 0x000128, "Wrong size on UTestSave");
static_assert(offsetof(UTestSave, TestInt_) == 0x000028, "Member 'UTestSave::TestInt_' has a wrong offset!");
static_assert(offsetof(UTestSave, TestFloat_) == 0x00002C, "Member 'UTestSave::TestFloat_' has a wrong offset!");
static_assert(offsetof(UTestSave, TestFName_) == 0x000030, "Member 'UTestSave::TestFName_' has a wrong offset!");
static_assert(offsetof(UTestSave, TestArrayInt_) == 0x000038, "Member 'UTestSave::TestArrayInt_' has a wrong offset!");
static_assert(offsetof(UTestSave, TestStruct_) == 0x000048, "Member 'UTestSave::TestStruct_' has a wrong offset!");
static_assert(offsetof(UTestSave, TestArrayStruct_) == 0x000060, "Member 'UTestSave::TestArrayStruct_' has a wrong offset!");

// Class BattlePrototype.UITitleFirstConfigDifficulty
// 0x0100 (0x0488 - 0x0388)
class UUITitleFirstConfigDifficulty final : public UUIBase
{
public:
	uint8                                         Pad_388[0xF0];                                     // 0x0388(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSTitleManager*                        TitleManager;                                      // 0x0478(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x8];                                      // 0x0480(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeIndex(class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UREDTextBlock* TextIndex);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextDescription, class UTextBlock* TextDifficulty, class USpacer* GuideSpacer);
	void SetTitleManager(class ARSTitleManager* TitleManager_0);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool IsBack() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleFirstConfigDifficulty">();
	}
	static class UUITitleFirstConfigDifficulty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleFirstConfigDifficulty>();
	}
};
static_assert(alignof(UUITitleFirstConfigDifficulty) == 0x000008, "Wrong alignment on UUITitleFirstConfigDifficulty");
static_assert(sizeof(UUITitleFirstConfigDifficulty) == 0x000488, "Wrong size on UUITitleFirstConfigDifficulty");
static_assert(offsetof(UUITitleFirstConfigDifficulty, TitleManager) == 0x000478, "Member 'UUITitleFirstConfigDifficulty::TitleManager' has a wrong offset!");

// Class BattlePrototype.TextData
// 0x0008 (0x0030 - 0x0028)
class UTextData final : public UObject
{
public:
	class UDataTable*                             RefTextTable;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class FString GetText(class FName ID, bool* Founded);
	bool LoadResource(const class FString& FilePath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextData">();
	}
	static class UTextData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextData>();
	}
};
static_assert(alignof(UTextData) == 0x000008, "Wrong alignment on UTextData");
static_assert(sizeof(UTextData) == 0x000030, "Wrong size on UTextData");
static_assert(offsetof(UTextData, RefTextTable) == 0x000028, "Member 'UTextData::RefTextTable' has a wrong offset!");

// Class BattlePrototype.TickManageComponent
// 0x0030 (0x00F0 - 0x00C0)
class UTickManageComponent final : public UActorComponent
{
public:
	TArray<TWeakObjectPtr<class AActor>>          _ManageActorList;                                  // 0x00C0(0x0010)(ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UTickManageComponent>> _TickManageComponentList;                          // 0x00D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UActorComponent>> _ComponentList;                                    // 0x00E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void RegisterManageActor(class AActor* Actor);
	void RegisterManageComponent(const TArray<class UActorComponent*>& ComponentList);
	void SetManageTickEnable(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TickManageComponent">();
	}
	static class UTickManageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTickManageComponent>();
	}
};
static_assert(alignof(UTickManageComponent) == 0x000008, "Wrong alignment on UTickManageComponent");
static_assert(sizeof(UTickManageComponent) == 0x0000F0, "Wrong size on UTickManageComponent");
static_assert(offsetof(UTickManageComponent, _ManageActorList) == 0x0000C0, "Member 'UTickManageComponent::_ManageActorList' has a wrong offset!");
static_assert(offsetof(UTickManageComponent, _TickManageComponentList) == 0x0000D0, "Member 'UTickManageComponent::_TickManageComponentList' has a wrong offset!");
static_assert(offsetof(UTickManageComponent, _ComponentList) == 0x0000E0, "Member 'UTickManageComponent::_ComponentList' has a wrong offset!");

// Class BattlePrototype.TipsCountParamManager
// 0x0138 (0x0160 - 0x0028)
class UTipsCountParamManager final : public UObject
{
public:
	uint8                                         Pad_28[0x138];                                     // 0x0028(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitData(class URSGameInstance* GameInst);
	void ResetTips(EHelpTutorial HelpID);
	void SetDisplayedData(EHelpTutorial HelpID, bool NewValue);
	void SetHiddenTips(bool NewFlag);
	bool WhetherTheConditionsAreMet(EHelpTutorial HelpID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TipsCountParamManager">();
	}
	static class UTipsCountParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTipsCountParamManager>();
	}
};
static_assert(alignof(UTipsCountParamManager) == 0x000008, "Wrong alignment on UTipsCountParamManager");
static_assert(sizeof(UTipsCountParamManager) == 0x000160, "Wrong size on UTipsCountParamManager");

// Class BattlePrototype.TownPeopleManager
// 0x0010 (0x0240 - 0x0230)
class ATownPeopleManager final : public AActor
{
public:
	class UNpcManager*                            PNpcManager;                                       // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TownPeopleManager">();
	}
	static class ATownPeopleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATownPeopleManager>();
	}
};
static_assert(alignof(ATownPeopleManager) == 0x000008, "Wrong alignment on ATownPeopleManager");
static_assert(sizeof(ATownPeopleManager) == 0x000240, "Wrong size on ATownPeopleManager");
static_assert(offsetof(ATownPeopleManager, PNpcManager) == 0x000230, "Member 'ATownPeopleManager::PNpcManager' has a wrong offset!");

// Class BattlePrototype.UIMiniMainQuestGoal
// 0x0000 (0x0388 - 0x0388)
class UUIMiniMainQuestGoal : public UUIBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiniMainQuestGoal">();
	}
	static class UUIMiniMainQuestGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMiniMainQuestGoal>();
	}
};
static_assert(alignof(UUIMiniMainQuestGoal) == 0x000008, "Wrong alignment on UUIMiniMainQuestGoal");
static_assert(sizeof(UUIMiniMainQuestGoal) == 0x000388, "Wrong size on UUIMiniMainQuestGoal");

// Class BattlePrototype.TradeItemData
// 0x0008 (0x0030 - 0x0028)
class UTradeItemData final : public UObject
{
public:
	class UDataTable*                             TradeItemDataTable_;                               // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool GetDataLineByIndex(const class FName Index_0, struct FTradeItem* TradeItem);
	bool GetTItemDataFromDataTable(const class FString& TradeTablePath);

	class UDataTable* GetTradeItemDataTable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeItemData">();
	}
	static class UTradeItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeItemData>();
	}
};
static_assert(alignof(UTradeItemData) == 0x000008, "Wrong alignment on UTradeItemData");
static_assert(sizeof(UTradeItemData) == 0x000030, "Wrong size on UTradeItemData");
static_assert(offsetof(UTradeItemData, TradeItemDataTable_) == 0x000028, "Member 'UTradeItemData::TradeItemDataTable_' has a wrong offset!");

// Class BattlePrototype.TreasureItem
// 0x0010 (0x0350 - 0x0340)
class ATreasureItem : public AArrangeItemParticle
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent_;                            // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInitialize_;                                     // 0x0348(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsGetThisItem_;                                    // 0x0349(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34A[0x6];                                      // 0x034A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessAfterGetAnimFinished();
	void ProcessBeforeGetAnimBegin();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TreasureItem">();
	}
	static class ATreasureItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATreasureItem>();
	}
};
static_assert(alignof(ATreasureItem) == 0x000008, "Wrong alignment on ATreasureItem");
static_assert(sizeof(ATreasureItem) == 0x000350, "Wrong size on ATreasureItem");
static_assert(offsetof(ATreasureItem, SkeletalMeshComponent_) == 0x000340, "Member 'ATreasureItem::SkeletalMeshComponent_' has a wrong offset!");
static_assert(offsetof(ATreasureItem, IsInitialize_) == 0x000348, "Member 'ATreasureItem::IsInitialize_' has a wrong offset!");
static_assert(offsetof(ATreasureItem, IsGetThisItem_) == 0x000349, "Member 'ATreasureItem::IsGetThisItem_' has a wrong offset!");

// Class BattlePrototype.TrialParamDebugGroup
// 0x0028 (0x02F8 - 0x02D0)
class ATrialParamDebugGroup final : public ADebuggingItemGroup
{
public:
	TWeakObjectPtr<class ADebuggingItemBool>      IsPlayTrialYuito;                                  // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemBool>      IsPlayTrialKasane;                                 // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemEvent>     ExecParamChange;                                   // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemEvent>     ExecLoadTrialParam;                                // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USaveLoadScreenParamManager*            DebugSaveLoadScreenParamManager;                   // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnExecuteLoadTrialSave(const class ADebuggingItemEvent* Item);
	void OnExecuteParameterChange(const class ADebuggingItemEvent* Item);
	void OnPageOpened();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrialParamDebugGroup">();
	}
	static class ATrialParamDebugGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrialParamDebugGroup>();
	}
};
static_assert(alignof(ATrialParamDebugGroup) == 0x000008, "Wrong alignment on ATrialParamDebugGroup");
static_assert(sizeof(ATrialParamDebugGroup) == 0x0002F8, "Wrong size on ATrialParamDebugGroup");
static_assert(offsetof(ATrialParamDebugGroup, IsPlayTrialYuito) == 0x0002D0, "Member 'ATrialParamDebugGroup::IsPlayTrialYuito' has a wrong offset!");
static_assert(offsetof(ATrialParamDebugGroup, IsPlayTrialKasane) == 0x0002D8, "Member 'ATrialParamDebugGroup::IsPlayTrialKasane' has a wrong offset!");
static_assert(offsetof(ATrialParamDebugGroup, ExecParamChange) == 0x0002E0, "Member 'ATrialParamDebugGroup::ExecParamChange' has a wrong offset!");
static_assert(offsetof(ATrialParamDebugGroup, ExecLoadTrialParam) == 0x0002E8, "Member 'ATrialParamDebugGroup::ExecLoadTrialParam' has a wrong offset!");
static_assert(offsetof(ATrialParamDebugGroup, DebugSaveLoadScreenParamManager) == 0x0002F0, "Member 'ATrialParamDebugGroup::DebugSaveLoadScreenParamManager' has a wrong offset!");

// Class BattlePrototype.TriggerEffectManager
// 0x0120 (0x0350 - 0x0230)
class ATriggerEffectManager : public AActor
{
public:
	uint8                                         Pad_230[0x90];                                     // 0x0230(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_directShotPsyObj;                                // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x88];                                     // 0x02C8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangePanRatioOfPadEffect(float PadPanRatio);
	void ClearTriggerEffect();
	void EraseDirectShotPsyObj();
	void EraseTargetMeshComponent();
	void IgnoreCompatibleVibration(bool Flag);
	void IncorporateOffModeIntoTriggerEffect(bool IsOffMode);
	bool IsPadEffectPlaying();
	bool IsTriggerEffectOff(int32 Lr);
	bool IsTriggerEffectStopped(int32 Lr);
	bool IsTriggerInputStatus(int32 Lr);
	void Load(const class FString& GroupName, const class FString& Filename, EVibSndPrio Prio);
	void LoadHDB(const class FString& GroupName, const class FString& Filename);
	void PausePadEffect();
	void PlayEmulateCompatibleVibration(class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag, bool bLooping, bool bIgnoreTimeDilation, bool bPlayWhilePaused);
	void PlayHaptics(const class FString& Filename, EVibSndMode Svmode, class AActor* Sndowner);
	void PlayPadEffect(const class FString& Filename, float Wavvol, float Vibvol, bool RoopFlag, EVibSndPrio Svprio, EVibSndMode Svmode, class AActor* Sndowner, class UMeshComponent* SndownerMesh, class FName SndownerMeshSocketName, bool IsDistanceAttenuation);
	void PlayPadEffectV01(const class FString& Filename, float Wavvol, float Vibvol, bool RoopFlag, EVibSndPrio Svprio, EVibSndMode Svmode, class AActor* Sndowner, class UMeshComponent* SndownerMesh, class FName SndownerMeshSocketName, bool IsDistanceAttenuation);
	void RegistDirectShotPsyObj(class AActor* Actor);
	void RegistTargetMeshComponent(class UMeshComponent* Mesh, class FName TargetSocketName);
	void ResumePadEffect();
	void SetCompatibleVibrationMode(bool IsCompatibleVibMode);
	void SetIsCompatibleMode2Enabled(bool IsEnable);
	void SetPadEffectBrainCrashVolume(float Vol);
	void SetPadEffectBrainFieldVolume(float Vol);
	void SetPadEffectCompatibleMode2LargeVibAfterglow(float FrameNum);
	void SetPadEffectCompatibleMode2LargeVolume(float Vol);
	void SetPadEffectCompatibleMode2MaxRotRateOfLarge(float Vol);
	void SetPadEffectCompatibleMode2MaxRotRateOfSmall(float Vol);
	void SetPadEffectCompatibleMode2MinRotRateOfLarge(float Vol);
	void SetPadEffectCompatibleMode2MinRotRateOfSmall(float Vol);
	void SetPadEffectCompatibleMode2SmallVibAfterglow(float FrameNum);
	void SetPadEffectCompatibleMode2SmallVolume(float Vol);
	void SetPadEffectCompatibleMode2Volume(float Vol);
	void SetPadEffectCompatibleModeLargeVolume(float Vol);
	void SetPadEffectCompatibleModeMasterVolume(float Vol);
	void SetPadEffectCompatibleModeSmallVolume(float Vol);
	void SetPadEffectCompatibleVolume(float Vol);
	void SetPadEffectDirectShotVolume(float Vol);
	void SetPadEffectLocationVolume(float Vol);
	void SetPadEffectMapGimmickVolume(float Vol);
	void SetPadEffectMasterVolume(float Vol);
	void SetPadEffectOuterVibrationMagnification(float Mag);
	void SetPadEffectStrengthVolume(float Vol);
	void SetPadEffectVolume(float Wavvol, float Vibvol, float Sec);
	void SetPadEffectVolumeName(const class FString& Filename, float Wavvol, float Vibvol, float Sec);
	void SetRandomFrequencyVibration(int32 Lr, uint8 Pos, uint8 Amp, uint8 MinFre, uint8 MaxFre, bool IsReleaseEnhancements);
	void SetTriggerEffect(const struct FTrgEffParam& L, const struct FTrgEffParam& R, bool LeftInitFlag, bool RightInitFlag);
	void SetTriggerEffect2(ETrgEffMode M0, uint8 V00, uint8 V01, uint8 V02, ETrgEffMode M1, uint8 V10, uint8 V11, uint8 V12);
	void SetTriggerEffectOff(int32 Lr);
	void StopEmulateCompatibleVibration(class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag);
	void StopPadEffect(float Sec);
	void StopPadEffectName(const class FString& Filename, float Sec);
	void StopTriggerEffect(int32 Lr, float LingeringTime);
	void Unload(const class FString& GroupName);
	void UnloadHDB(const class FString& GroupName);
	void UpdateTriggerEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerEffectManager">();
	}
	static class ATriggerEffectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATriggerEffectManager>();
	}
};
static_assert(alignof(ATriggerEffectManager) == 0x000008, "Wrong alignment on ATriggerEffectManager");
static_assert(sizeof(ATriggerEffectManager) == 0x000350, "Wrong size on ATriggerEffectManager");
static_assert(offsetof(ATriggerEffectManager, M_directShotPsyObj) == 0x0002C0, "Member 'ATriggerEffectManager::M_directShotPsyObj' has a wrong offset!");

// Class BattlePrototype.UIMinimapDistance
// 0x0028 (0x03B0 - 0x0388)
class UUIMinimapDistance : public UUIBase
{
public:
	uint8                                         Pad_388[0x28];                                     // 0x0388(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeAnime(class UWidgetAnimation* Default_normal, class UWidgetAnimation* Default_red);
	void InitializeText(class UTextBlock* Distancenum, class UTextBlock* Distancetext);
	void SetDistance(const class FString& Num);
	void SetTextColor(EUIMinmapDistanceIconColor Color);
	void SetThumbnail(EUIMinmapDistanceIcon Icon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMinimapDistance">();
	}
	static class UUIMinimapDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMinimapDistance>();
	}
};
static_assert(alignof(UUIMinimapDistance) == 0x000008, "Wrong alignment on UUIMinimapDistance");
static_assert(sizeof(UUIMinimapDistance) == 0x0003B0, "Wrong size on UUIMinimapDistance");

// Class BattlePrototype.TumbleConditionComponent
// 0x0020 (0x0180 - 0x0160)
class UTumbleConditionComponent final : public UConditionComponent
{
public:
	float                                         _tumbleSec;                                        // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_164[0x1C];                                     // 0x0164(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TumbleConditionComponent">();
	}
	static class UTumbleConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTumbleConditionComponent>();
	}
};
static_assert(alignof(UTumbleConditionComponent) == 0x000010, "Wrong alignment on UTumbleConditionComponent");
static_assert(sizeof(UTumbleConditionComponent) == 0x000180, "Wrong size on UTumbleConditionComponent");
static_assert(offsetof(UTumbleConditionComponent, _tumbleSec) == 0x000160, "Member 'UTumbleConditionComponent::_tumbleSec' has a wrong offset!");

// Class BattlePrototype.TutorialData
// 0x0008 (0x0030 - 0x0028)
class UTutorialData final : public UObject
{
public:
	class UHelpTutorialDBAsset*                   HelpDataAsset_;                                    // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialData">();
	}
	static class UTutorialData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialData>();
	}
};
static_assert(alignof(UTutorialData) == 0x000008, "Wrong alignment on UTutorialData");
static_assert(sizeof(UTutorialData) == 0x000030, "Wrong size on UTutorialData");
static_assert(offsetof(UTutorialData, HelpDataAsset_) == 0x000028, "Member 'UTutorialData::HelpDataAsset_' has a wrong offset!");

// Class BattlePrototype.UIActionIcon
// 0x0100 (0x0488 - 0x0388)
class UUIActionIcon : public UUIBase
{
public:
	struct FVector2D                              baseOffset;                                        // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x8];                                      // 0x0390(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerActor;                                        // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0xE8];                                     // 0x03A0(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimIn2, class UWidgetAnimation* AnimOut2, class UWidgetAnimation* AnimSelect_Progress, class UWidgetAnimation* AnimSelectIn_Progress, class UWidgetAnimation* AnimSelectOut_Progress, class UWidgetAnimation* AnimIn2_Progress, class UWidgetAnimation* AnimOut2_Progress, class UWidgetAnimation* AnimSelect_Bonds, class UWidgetAnimation* AnimSelectIn_Bonds, class UWidgetAnimation* AnimSelectOut_Bonds, class UWidgetAnimation* AnimIn2_Bonds, class UWidgetAnimation* AnimOut2_Bonds, class UImage* ImageIcon, class UImage* ImageFrame1, class UImage* ImageFrame6Add, class UImage* ImageNo, class UImage* ImageNoAdd);
	void SetSubQuestStateDetail(EActionIconSubQuestState State, bool IsQuestActive, bool IsActive);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIActionIcon">();
	}
	static class UUIActionIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIActionIcon>();
	}
};
static_assert(alignof(UUIActionIcon) == 0x000008, "Wrong alignment on UUIActionIcon");
static_assert(sizeof(UUIActionIcon) == 0x000488, "Wrong size on UUIActionIcon");
static_assert(offsetof(UUIActionIcon, baseOffset) == 0x000388, "Member 'UUIActionIcon::baseOffset' has a wrong offset!");
static_assert(offsetof(UUIActionIcon, OwnerActor) == 0x000398, "Member 'UUIActionIcon::OwnerActor' has a wrong offset!");

// Class BattlePrototype.UINoticeQuest
// 0x0000 (0x0388 - 0x0388)
class UUINoticeQuest : public UUIBase
{
public:
	bool CloseStartBondsQuest(class FName QuestId, float DispTime, bool ManualClose);
	bool CloseStartSubQuest(class FName QuestId, float DispTime, bool ManualClose);
	class FString GetBondsQuestName(class FName QuestId);
	class FString GetSubQuestName(class FName QuestId);
	bool InitializeBondsQuestText(class FName QuestId);
	bool InitializeSubQuestText(class FName QuestId);
	bool OpenStartBondsQuest(class FName QuestId, float DispTime, bool ManualClose);
	bool OpenStartSubQuest(class FName QuestId, float DispTime, bool ManualClose);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINoticeQuest">();
	}
	static class UUINoticeQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINoticeQuest>();
	}
};
static_assert(alignof(UUINoticeQuest) == 0x000008, "Wrong alignment on UUINoticeQuest");
static_assert(sizeof(UUINoticeQuest) == 0x000388, "Wrong size on UUINoticeQuest");

// Class BattlePrototype.UIAreaHere
// 0x0028 (0x03B0 - 0x0388)
class UUIAreaHere : public UUIBase
{
public:
	float                                         DrawSeconds;                                       // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0x24];                                     // 0x038C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextAreaHere);
	void Start(int32 LocationId, int32 AreaId, int32 PortalID);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAreaHere">();
	}
	static class UUIAreaHere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAreaHere>();
	}
};
static_assert(alignof(UUIAreaHere) == 0x000008, "Wrong alignment on UUIAreaHere");
static_assert(sizeof(UUIAreaHere) == 0x0003B0, "Wrong size on UUIAreaHere");
static_assert(offsetof(UUIAreaHere, DrawSeconds) == 0x000388, "Member 'UUIAreaHere::DrawSeconds' has a wrong offset!");

// Class BattlePrototype.UIAreaNext
// 0x0018 (0x03A0 - 0x0388)
class UUIAreaNext : public UUIBase
{
public:
	uint8                                         Pad_388[0x18];                                     // 0x0388(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool End();
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut);
	bool Start(int32 LocationId, int32 AreaId, int32 PortalID, bool IsWorldMap);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAreaNext">();
	}
	static class UUIAreaNext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAreaNext>();
	}
};
static_assert(alignof(UUIAreaNext) == 0x000008, "Wrong alignment on UUIAreaNext");
static_assert(sizeof(UUIAreaNext) == 0x0003A0, "Wrong size on UUIAreaNext");

// Class BattlePrototype.UIAutoSaving
// 0x0008 (0x0390 - 0x0388)
class UUIAutoSaving : public UUIBase
{
public:
	float                                         M_SaveTimer;                                       // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OpenAutoSave();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAutoSaving">();
	}
	static class UUIAutoSaving* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAutoSaving>();
	}
};
static_assert(alignof(UUIAutoSaving) == 0x000008, "Wrong alignment on UUIAutoSaving");
static_assert(sizeof(UUIAutoSaving) == 0x000390, "Wrong size on UUIAutoSaving");
static_assert(offsetof(UUIAutoSaving, M_SaveTimer) == 0x000388, "Member 'UUIAutoSaving::M_SaveTimer' has a wrong offset!");

// Class BattlePrototype.UIBooksTop
// 0x02C8 (0x0650 - 0x0388)
class UUIBooksTop : public UUIBase
{
public:
	uint8                                         Pad_388[0x2C8];                                    // 0x0388(0x02C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(int32 Index_0, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision);
	void InitializeCategory(int32 Category, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimUnselect, class UWidgetAnimation* AnimDecision, class UTextBlock* TextCategory);
	void InitializeCommonParts(class UUIMainContents* Parent, class UTextBlock* TextHelp, class UUIGuide* UiKeyGuide);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UBorder* borderAllColor, class UBorder* borderPicture, class UREDRetainerBox* RetainerBoxMenu, class UImage* ImageGhostViewer, class UImage* ImageViewerNoise, class UWidgetAnimation* AnimDefaultView, class UWidgetAnimation* AnimChangeView, class UWidgetAnimation* AnimChangeDefault, class UUIBrainMessage* UIBrainMessage, class UUICharaBooks* UICharaBooks, class UUIEnemyBooks* UIEnemyBooks, class UUIWishList* UiWish, class UUIHelpMenu* UIHelpMenu);
	void SetContentsChange(bool IsChange);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool IsEndMenu() const;
	bool IsPlayingProgramAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBooksTop">();
	}
	static class UUIBooksTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBooksTop>();
	}
};
static_assert(alignof(UUIBooksTop) == 0x000008, "Wrong alignment on UUIBooksTop");
static_assert(sizeof(UUIBooksTop) == 0x000650, "Wrong size on UUIBooksTop");

// Class BattlePrototype.UIPartyCharaInfo
// 0x0010 (0x0398 - 0x0388)
class UUIPartyCharaInfo : public UUIBase
{
public:
	uint8                                         Pad_388[0x10];                                     // 0x0388(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(const TArray<class UUIBase*>& Charainfolist);
	bool IsCheckMouseCancel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyCharaInfo">();
	}
	static class UUIPartyCharaInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyCharaInfo>();
	}
};
static_assert(alignof(UUIPartyCharaInfo) == 0x000008, "Wrong alignment on UUIPartyCharaInfo");
static_assert(sizeof(UUIPartyCharaInfo) == 0x000398, "Wrong size on UUIPartyCharaInfo");

// Class BattlePrototype.UIBossName
// 0x0180 (0x0508 - 0x0388)
class UUIBossName : public UUIBase
{
public:
	float                                         PreShuffleSeconds;                                 // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShuffuleSeconds;                                   // 0x038C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShuffuleIntervalSeconds;                           // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FixedDrawSecond;                                   // 0x0394(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_398[0x170];                                    // 0x0398(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextBossName);
	void Start(const class FString& bossId, EBossNameMode Mode, float FreeFixedDrawSecond);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBossName">();
	}
	static class UUIBossName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBossName>();
	}
};
static_assert(alignof(UUIBossName) == 0x000008, "Wrong alignment on UUIBossName");
static_assert(sizeof(UUIBossName) == 0x000508, "Wrong size on UUIBossName");
static_assert(offsetof(UUIBossName, PreShuffleSeconds) == 0x000388, "Member 'UUIBossName::PreShuffleSeconds' has a wrong offset!");
static_assert(offsetof(UUIBossName, ShuffuleSeconds) == 0x00038C, "Member 'UUIBossName::ShuffuleSeconds' has a wrong offset!");
static_assert(offsetof(UUIBossName, ShuffuleIntervalSeconds) == 0x000390, "Member 'UUIBossName::ShuffuleIntervalSeconds' has a wrong offset!");
static_assert(offsetof(UUIBossName, FixedDrawSecond) == 0x000394, "Member 'UUIBossName::FixedDrawSecond' has a wrong offset!");

// Class BattlePrototype.UIBrainCrashGauge
// 0x0098 (0x0420 - 0x0388)
class UUIBrainCrashGauge : public UUIBase
{
public:
	uint8                                         Pad_388[0x50];                                     // 0x0388(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSCharacterBase*                       M_pTarget;                                         // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E0[0x40];                                     // 0x03E0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetGaugeTimerRate(float* Rate);
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimFull, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimDecision2, class UImage* ImageGaugeAdd, class UImage* ImageGaugeNormal);
	void OnPlayGaugeFullSound();
	void SetBg(class UImage* PImage);
	void SetTarget(class ARSCharacterBase* Target);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBrainCrashGauge">();
	}
	static class UUIBrainCrashGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBrainCrashGauge>();
	}
};
static_assert(alignof(UUIBrainCrashGauge) == 0x000008, "Wrong alignment on UUIBrainCrashGauge");
static_assert(sizeof(UUIBrainCrashGauge) == 0x000420, "Wrong size on UUIBrainCrashGauge");
static_assert(offsetof(UUIBrainCrashGauge, M_pTarget) == 0x0003D8, "Member 'UUIBrainCrashGauge::M_pTarget' has a wrong offset!");

// Class BattlePrototype.UIBrainGaugeEN
// 0x0010 (0x0398 - 0x0388)
class UUIBrainGaugeEN : public UUIBase
{
public:
	float                                         M_Percent;                                         // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_Time;                                            // 0x038C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_FlagPercentUpdate;                               // 0x0390(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_FlagGaugeMax;                                    // 0x0391(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_FlagBrainField;                                  // 0x0392(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_393[0x5];                                      // 0x0393(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndBrainField();
	void SetGaugeMax(bool IsFull);
	void SetGaugePercent(float Percent, float Time);
	void StartBrainField();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBrainGaugeEN">();
	}
	static class UUIBrainGaugeEN* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBrainGaugeEN>();
	}
};
static_assert(alignof(UUIBrainGaugeEN) == 0x000008, "Wrong alignment on UUIBrainGaugeEN");
static_assert(sizeof(UUIBrainGaugeEN) == 0x000398, "Wrong size on UUIBrainGaugeEN");
static_assert(offsetof(UUIBrainGaugeEN, M_Percent) == 0x000388, "Member 'UUIBrainGaugeEN::M_Percent' has a wrong offset!");
static_assert(offsetof(UUIBrainGaugeEN, M_Time) == 0x00038C, "Member 'UUIBrainGaugeEN::M_Time' has a wrong offset!");
static_assert(offsetof(UUIBrainGaugeEN, M_FlagPercentUpdate) == 0x000390, "Member 'UUIBrainGaugeEN::M_FlagPercentUpdate' has a wrong offset!");
static_assert(offsetof(UUIBrainGaugeEN, M_FlagGaugeMax) == 0x000391, "Member 'UUIBrainGaugeEN::M_FlagGaugeMax' has a wrong offset!");
static_assert(offsetof(UUIBrainGaugeEN, M_FlagBrainField) == 0x000392, "Member 'UUIBrainGaugeEN::M_FlagBrainField' has a wrong offset!");

// Class BattlePrototype.UIBrainMap
// 0x0060 (0x03E8 - 0x0388)
class UUIBrainMap : public UUIBase
{
public:
	struct FLinearColor                           ColorBrainIcon;                                    // 0x0388(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_398[0x50];                                     // 0x0398(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UBorder* borderAllColor, class UImage* ImageCoverBlack, class UImage* ImageCA_Red, class UImage* ImageCA_Green, class UImage* ImageCA_Blue, class UImage* ImageBrainIcon2, class UImage* ImageBrainIcon3, class UImage* ImageBrainIcon4, class UUIBase* UiMainChliceParts);
	void PlayContentsIn();
	void PlayContentsOut();
	void UpdateProgramAnimation(float DeltaSeconds);

	bool IsPlayingContentsIn() const;
	bool IsPlayingContentsOut() const;
	bool IsPlayingProgramAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBrainMap">();
	}
	static class UUIBrainMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBrainMap>();
	}
};
static_assert(alignof(UUIBrainMap) == 0x000008, "Wrong alignment on UUIBrainMap");
static_assert(sizeof(UUIBrainMap) == 0x0003E8, "Wrong size on UUIBrainMap");
static_assert(offsetof(UUIBrainMap, ColorBrainIcon) == 0x000388, "Member 'UUIBrainMap::ColorBrainIcon' has a wrong offset!");

// Class BattlePrototype.UIBrainTalk
// 0x00F0 (0x0478 - 0x0388)
class UUIBrainTalk : public UUIBase
{
public:
	uint8                                         Pad_388[0x58];                                     // 0x0388(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomComponent*                         Voice;                                             // 0x03E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x10];                                     // 0x03E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_isVoicePlayWait;                                 // 0x03F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F9[0x7F];                                     // 0x03F9(0x007F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTexture* GetFaceTexture(int32 Index_0);
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextBrainTalk, class UImage* IconFont, class UImage* FaceB, class UMaterialInstanceConstant* MaterialFontNormal, class UMaterialInstanceConstant* MaterialFontNoize);
	void IsEndTalk(bool* IsEnd);
	void PauseBrainTalkVoice(const bool IsPause);
	void PlayBrainTalkVoice();
	void SetBrainTalkMessage(int32 CharacterId, int32 ExpressionID, const class FString& Message, class UAtomComponent* Voice_0, float DrawSecond, const bool IsReserve);
	void SetBugMode(bool IsBug);
	void SetIsVoicePlayWait(bool Flag);
	void StopBrainTalkVoice();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBrainTalk">();
	}
	static class UUIBrainTalk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBrainTalk>();
	}
};
static_assert(alignof(UUIBrainTalk) == 0x000008, "Wrong alignment on UUIBrainTalk");
static_assert(sizeof(UUIBrainTalk) == 0x000478, "Wrong size on UUIBrainTalk");
static_assert(offsetof(UUIBrainTalk, Voice) == 0x0003E0, "Member 'UUIBrainTalk::Voice' has a wrong offset!");
static_assert(offsetof(UUIBrainTalk, M_isVoicePlayWait) == 0x0003F8, "Member 'UUIBrainTalk::M_isVoicePlayWait' has a wrong offset!");

// Class BattlePrototype.UICharaInfoWindow
// 0x0100 (0x0488 - 0x0388)
class UUICharaInfoWindow : public UUIBase
{
public:
	uint8                                         Pad_388[0x100];                                    // 0x0388(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault1, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimDefault1_2, class UWidgetAnimation* AnimDefault2_1, class UTextBlock* TextCharaName, class UTextBlock* TextCategoryName, class UTextBlock* TextCharaInfo, class UTextBlock* TextCharaDetails, class UImage* CharaImage, class UREDScrollBoxSimple* ScrollBox1, class UREDScrollBoxSimple* ScrollBox2, class UREDOverlay* Mousehitthubnail);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICharaInfoWindow">();
	}
	static class UUICharaInfoWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICharaInfoWindow>();
	}
};
static_assert(alignof(UUICharaInfoWindow) == 0x000008, "Wrong alignment on UUICharaInfoWindow");
static_assert(sizeof(UUICharaInfoWindow) == 0x000488, "Wrong size on UUICharaInfoWindow");

// Class BattlePrototype.UICharaSelectMenu
// 0x0100 (0x0488 - 0x0388)
class UUICharaSelectMenu final : public UUIBase
{
public:
	TDelegate<void(int32 Cursor)>                 M_OnEventSelectStart;                              // 0x0388(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class ARSTitleManager*                        M_pTitleManager;                                   // 0x0398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A0[0x10];                                     // 0x03A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserParamManager*                      UserParamManager;                                  // 0x03B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDatabaseManager*                       DatabaseManager;                                   // 0x03B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C0[0xC8];                                     // 0x03C0(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetCursor();
	bool GetDecideScenario();
	void InitializeAnime(class UWidgetAnimation* In_anime, class UWidgetAnimation* Default_anime, class UWidgetAnimation* Default_none_anime, class UWidgetAnimation* Out_anime, class UWidgetAnimation* In_yuito_anime, class UWidgetAnimation* Default_yuito_anime, class UWidgetAnimation* Decision_yuito_anime, class UWidgetAnimation* Out_yuito_anime, class UWidgetAnimation* In_kasane_anime, class UWidgetAnimation* Default_kasane_anime, class UWidgetAnimation* Decision_kasane_anime, class UWidgetAnimation* On_kasane_anime);
	void InitializeCharaSelect(class UUIGuide* UGuide, class UTextBlock* Charaselectguide, class UTextBlock* Charatext, class UTextBlock* CharaName, class UTextBlock* Characlear, class UBorder* Clearborder, class UREDImage* Mouse_yuito_hit, class UREDImage* Mouse_kasane_hit, class UREDImage* Mouse_yuito_hit2, class UREDImage* Mouse_kasane_hit2);
	void InitializeParts(int32 Index_0, class UUICharaSelectParts* Charaparts);
	void SetCharacterOutLine(int32 CursorIndex);
	void SetScenarioCrear(bool Yuito, bool Kasane);
	void SetTitleManager(class ARSTitleManager* Ptitlemanager);
	void Start(ECharaSelectType Type);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICharaSelectMenu">();
	}
	static class UUICharaSelectMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICharaSelectMenu>();
	}
};
static_assert(alignof(UUICharaSelectMenu) == 0x000008, "Wrong alignment on UUICharaSelectMenu");
static_assert(sizeof(UUICharaSelectMenu) == 0x000488, "Wrong size on UUICharaSelectMenu");
static_assert(offsetof(UUICharaSelectMenu, M_OnEventSelectStart) == 0x000388, "Member 'UUICharaSelectMenu::M_OnEventSelectStart' has a wrong offset!");
static_assert(offsetof(UUICharaSelectMenu, M_pTitleManager) == 0x000398, "Member 'UUICharaSelectMenu::M_pTitleManager' has a wrong offset!");
static_assert(offsetof(UUICharaSelectMenu, UserParamManager) == 0x0003B0, "Member 'UUICharaSelectMenu::UserParamManager' has a wrong offset!");
static_assert(offsetof(UUICharaSelectMenu, DatabaseManager) == 0x0003B8, "Member 'UUICharaSelectMenu::DatabaseManager' has a wrong offset!");

// Class BattlePrototype.UICodeListIndex
// 0x0050 (0x03D8 - 0x0388)
class UUICodeListIndex : public UUIBase
{
public:
	uint8                                         Pad_388[0x50];                                     // 0x0388(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimDefaultClear, class UWidgetAnimation* AnimSelectClear, class UWidgetAnimation* AnimSelectInClear, class UImage* ImageNewIcon, class UTextBlock* TextName);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICodeListIndex">();
	}
	static class UUICodeListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICodeListIndex>();
	}
};
static_assert(alignof(UUICodeListIndex) == 0x000008, "Wrong alignment on UUICodeListIndex");
static_assert(sizeof(UUICodeListIndex) == 0x0003D8, "Wrong size on UUICodeListIndex");

// Class BattlePrototype.UIConfigControllerSelect
// 0x0040 (0x03C8 - 0x0388)
class UUIConfigControllerSelect : public UUIBase
{
public:
	uint8                                         Pad_388[0x40];                                     // 0x0388(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class USpacer* Spacer, class UTextBlock* TextTitle);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigControllerSelect">();
	}
	static class UUIConfigControllerSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigControllerSelect>();
	}
};
static_assert(alignof(UUIConfigControllerSelect) == 0x000008, "Wrong alignment on UUIConfigControllerSelect");
static_assert(sizeof(UUIConfigControllerSelect) == 0x0003C8, "Wrong size on UUIConfigControllerSelect");

// Class BattlePrototype.UIConfigKeyboardMouse
// 0x0060 (0x03E8 - 0x0388)
class UUIConfigKeyboardMouse : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x48];                                     // 0x03A0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UREDScrollBox* ScrollBox);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUpdateElement(int32 Index_0, class UUserWidget* Widget);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigKeyboardMouse">();
	}
	static class UUIConfigKeyboardMouse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigKeyboardMouse>();
	}
};
static_assert(alignof(UUIConfigKeyboardMouse) == 0x000008, "Wrong alignment on UUIConfigKeyboardMouse");
static_assert(sizeof(UUIConfigKeyboardMouse) == 0x0003E8, "Wrong size on UUIConfigKeyboardMouse");
static_assert(offsetof(UUIConfigKeyboardMouse, ListElementSize) == 0x000388, "Member 'UUIConfigKeyboardMouse::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUIConfigKeyboardMouse, ListOffsetSize) == 0x000390, "Member 'UUIConfigKeyboardMouse::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUIConfigKeyboardMouse, ListIndexClass) == 0x000398, "Member 'UUIConfigKeyboardMouse::ListIndexClass' has a wrong offset!");

// Class BattlePrototype.UIConfigSelect3
// 0x01C8 (0x0550 - 0x0388)
class UUIConfigSelect3 : public UUIBase
{
public:
	uint8                                         Pad_388[0x1C8];                                    // 0x0388(0x01C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeIndex(int32 Index_0, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimEnable, class UWidgetAnimation* AnimEnableIn, class UWidgetAnimation* AnimEnableOut, class UTextBlock* TextIndex);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextTitle);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigSelect3">();
	}
	static class UUIConfigSelect3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigSelect3>();
	}
};
static_assert(alignof(UUIConfigSelect3) == 0x000008, "Wrong alignment on UUIConfigSelect3");
static_assert(sizeof(UUIConfigSelect3) == 0x000550, "Wrong size on UUIConfigSelect3");

// Class BattlePrototype.UICredit
// 0x3A08 (0x3D90 - 0x0388)
class UUICredit : public UUIBase
{
public:
	struct FSlateColor                            FontColor;                                         // 0x0388(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x2E0];                                    // 0x03B0(0x02E0)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextData*                              TextData;                                          // 0x0690(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_698[0x20];                                     // 0x0698(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             TextureLogos[0x2];                                 // 0x06B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C8[0x36C8];                                   // 0x06C8(0x36C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeCorporateName_Official(class UOverlay* Overlay, class USpacer* Spacer, class UREDTextBlock* TextBlock);
	void InitializeLogo(class UOverlay* Overlay, class USpacer* Spacer, class UImage* ImageLogo);
	void InitializeOfficial_StaffName(class UOverlay* Overlay, class USpacer* Spacer, class UREDTextBlock* TextPosition, class UREDTextBlock* TextStaff);
	void InitializeOfficial_StaffNameCombo(class UOverlay* Overlay, class USpacer* Spacer, class UREDTextBlock* TextPosition1, class UREDTextBlock* TextStaff1, class UREDTextBlock* TextPosition2, class UREDTextBlock* TextStaff2);
	void InitializeOfficial_StaffNameDouble(class UOverlay* Overlay, class USpacer* Spacer, class UREDTextBlock* TextPosition, class UREDTextBlock* TextStaff1, class UREDTextBlock* TextStaff2);
	void InitializeSpace_StaffName(class UOverlay* Overlay, class USpacer* Spacer, class UREDTextBlock* TextStaff);
	void InitializeSpace_StaffNameDouble(class UOverlay* Overlay, class USpacer* Spacer, class UREDTextBlock* TextStaff1, class UREDTextBlock* TextStaff2);
	void InitializeStaffName(class UOverlay* Overlay, class USpacer* Spacer, class UREDTextBlock* TextBlock);
	void InitializeStaffNameDouble(class UOverlay* Overlay, class USpacer* Spacer, class UREDTextBlock* TextStaff1, class UREDTextBlock* TextStaff2);
	void InitializeStaffNameQuad(class UOverlay* Overlay, class USpacer* Spacer, class UREDTextBlock* TextStaffLeft1, class UREDTextBlock* TextStaffLeft2, class UREDTextBlock* TextStaffRight1, class UREDTextBlock* TextStaffRight2);
	void InitializeThis(class UOverlay* OverlayParent);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICredit">();
	}
	static class UUICredit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICredit>();
	}
};
static_assert(alignof(UUICredit) == 0x000008, "Wrong alignment on UUICredit");
static_assert(sizeof(UUICredit) == 0x003D90, "Wrong size on UUICredit");
static_assert(offsetof(UUICredit, FontColor) == 0x000388, "Member 'UUICredit::FontColor' has a wrong offset!");
static_assert(offsetof(UUICredit, TextData) == 0x000690, "Member 'UUICredit::TextData' has a wrong offset!");
static_assert(offsetof(UUICredit, TextureLogos) == 0x0006B8, "Member 'UUICredit::TextureLogos' has a wrong offset!");

// Class BattlePrototype.UIEnemyBooks
// 0x00C8 (0x0450 - 0x0388)
class UUIEnemyBooks : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x50];                                     // 0x03A0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               TextureEnemy[0x4];                                 // 0x03F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_410[0x40];                                     // 0x0410(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeFromBooks(class UUIBooksTop* Parent, class UImage* ImageEnemy);
	void InitializeFromMain(class UUIMainContents* UIMainContents, class UTextBlock* TextHelp, class UUIGuide* UiKeyGuide);
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UREDScrollBox* ScrollBox, class UUIEnemyInfoWindow* ChildInfoWin, class UUIEnemyListIndex* ChildListIndex);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUpdateElement(int32 Index_0, class UUserWidget* Widget);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEnemyBooks">();
	}
	static class UUIEnemyBooks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEnemyBooks>();
	}
};
static_assert(alignof(UUIEnemyBooks) == 0x000008, "Wrong alignment on UUIEnemyBooks");
static_assert(sizeof(UUIEnemyBooks) == 0x000450, "Wrong size on UUIEnemyBooks");
static_assert(offsetof(UUIEnemyBooks, ListElementSize) == 0x000388, "Member 'UUIEnemyBooks::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUIEnemyBooks, ListOffsetSize) == 0x000390, "Member 'UUIEnemyBooks::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUIEnemyBooks, ListIndexClass) == 0x000398, "Member 'UUIEnemyBooks::ListIndexClass' has a wrong offset!");
static_assert(offsetof(UUIEnemyBooks, TextureEnemy) == 0x0003F0, "Member 'UUIEnemyBooks::TextureEnemy' has a wrong offset!");

// Class BattlePrototype.UIEquip
// 0x0028 (0x03B0 - 0x0388)
class UUIEquip : public UUIBase
{
public:
	uint8                                         Pad_388[0x20];                                     // 0x0388(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_IsSetDefaultCursorParam;                         // 0x03A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_IsDefaultCursorVisual;                           // 0x03A9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerID                                     M_DefaultCharaID;                                  // 0x03AA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AB[0x5];                                      // 0x03AB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeScrollBox(class UREDScrollBox* ScrollBox);
	void InitializeThis(class UOverlay* OverlayAllSet, class UOverlay* Overlay2);
	void PlayContentsIn();
	void PlayContentsOut();
	void ResetDefaultCursor();
	void SetDefaultCursor(EPlayerID CharaID, bool IsVisual);
	void UpdateProgramAnimation(float DeltaSeconds);
	void UpdatEquipListMouseFocus();

	bool IsPlayingContentsIn() const;
	bool IsPlayingContentsOut() const;
	bool IsPlayingProgramAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEquip">();
	}
	static class UUIEquip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEquip>();
	}
};
static_assert(alignof(UUIEquip) == 0x000008, "Wrong alignment on UUIEquip");
static_assert(sizeof(UUIEquip) == 0x0003B0, "Wrong size on UUIEquip");
static_assert(offsetof(UUIEquip, M_IsSetDefaultCursorParam) == 0x0003A8, "Member 'UUIEquip::M_IsSetDefaultCursorParam' has a wrong offset!");
static_assert(offsetof(UUIEquip, M_IsDefaultCursorVisual) == 0x0003A9, "Member 'UUIEquip::M_IsDefaultCursorVisual' has a wrong offset!");
static_assert(offsetof(UUIEquip, M_DefaultCharaID) == 0x0003AA, "Member 'UUIEquip::M_DefaultCharaID' has a wrong offset!");

// Class BattlePrototype.UIGamerTag
// 0x0018 (0x03A0 - 0x0388)
class UUIGamerTag final : public UUIBase
{
public:
	class UOverlay*                               Guide;                                             // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             XBoxUserName;                                      // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Anime_default;                                     // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializeThis(class UTextBlock* Usernametext, class UWidgetAnimation* _default);
	void InitializeThisGuide(class UOverlay* Guide_0);
	void SetGuideVisible(bool IsVisible_0);
	void SetUserName();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGamerTag">();
	}
	static class UUIGamerTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGamerTag>();
	}
};
static_assert(alignof(UUIGamerTag) == 0x000008, "Wrong alignment on UUIGamerTag");
static_assert(sizeof(UUIGamerTag) == 0x0003A0, "Wrong size on UUIGamerTag");
static_assert(offsetof(UUIGamerTag, Guide) == 0x000388, "Member 'UUIGamerTag::Guide' has a wrong offset!");
static_assert(offsetof(UUIGamerTag, XBoxUserName) == 0x000390, "Member 'UUIGamerTag::XBoxUserName' has a wrong offset!");
static_assert(offsetof(UUIGamerTag, Anime_default) == 0x000398, "Member 'UUIGamerTag::Anime_default' has a wrong offset!");

// Class BattlePrototype.UIGuide
// 0x0018 (0x03A0 - 0x0388)
class UUIGuide : public UUIBase
{
public:
	uint8                                         Pad_388[0x18];                                     // 0x0388(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void buildGuide();
	void ClearGuide();
	void InitializeThis(class USpacer* GuideSpacer);
	void SetGuide(int32 Index_0, EGuideKey Key, class FName String);
	void UpdateStateThis(int32 State, int32 SubState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide">();
	}
	static class UUIGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide>();
	}
};
static_assert(alignof(UUIGuide) == 0x000008, "Wrong alignment on UUIGuide");
static_assert(sizeof(UUIGuide) == 0x0003A0, "Wrong size on UUIGuide");

// Class BattlePrototype.UIHelpMenu
// 0x0110 (0x0498 - 0x0388)
class UUIHelpMenu : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0xF8];                                     // 0x03A0(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeAnime(class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	void InitializeArrow(int32 Index_0, class UUIHelpParts* Arrow);
	void InitializeCommonHelp(class UTextBlock* TextHelp, class UUIGuide* UiKeyGuide);
	void InitializeHelp(class UUITutoTipsParts* UTutoTipsParts);
	void InitializeList(class UCanvasPanel* ScrollBoxParent, class UREDScrollBox* ScrollBox);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUpdateElement(int32 Index_0, class UUserWidget* Widget);
	void UpdateStateHelpList(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHelpMenu">();
	}
	static class UUIHelpMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHelpMenu>();
	}
};
static_assert(alignof(UUIHelpMenu) == 0x000008, "Wrong alignment on UUIHelpMenu");
static_assert(sizeof(UUIHelpMenu) == 0x000498, "Wrong size on UUIHelpMenu");
static_assert(offsetof(UUIHelpMenu, ListElementSize) == 0x000388, "Member 'UUIHelpMenu::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUIHelpMenu, ListOffsetSize) == 0x000390, "Member 'UUIHelpMenu::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUIHelpMenu, ListIndexClass) == 0x000398, "Member 'UUIHelpMenu::ListIndexClass' has a wrong offset!");

// Class BattlePrototype.UIHelpPartsList
// 0x0058 (0x03E0 - 0x0388)
class UUIHelpPartsList : public UUIBase
{
public:
	uint8                                         Pad_388[0x58];                                     // 0x0388(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeListAnime(class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Select, class UWidgetAnimation* Default_);
	void InitializeListPartsList(class UTextBlock* TextList, class UImage* ImageNew);
	void UpdateStateHelpPartsList(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHelpPartsList">();
	}
	static class UUIHelpPartsList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHelpPartsList>();
	}
};
static_assert(alignof(UUIHelpPartsList) == 0x000008, "Wrong alignment on UUIHelpPartsList");
static_assert(sizeof(UUIHelpPartsList) == 0x0003E0, "Wrong size on UUIHelpPartsList");

// Class BattlePrototype.UIInfoWindow
// 0x0050 (0x03D8 - 0x0388)
class UUIInfoWindow : public UUIBase
{
public:
	bool                                          IsWarning;                                         // 0x0388(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_389[0x47];                                     // 0x0389(0x0047)(Fixing Size After Last Property [ Dumper-7 ])
	class URSAtomComponentBase*                   PlayingSE;                                         // 0x03D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextMain, class USpacer* Spacer, class UOverlay* GuideOverlay, class UImage* ImageGuideLine, class UImage* ImageFade);
	void SetMessage(const class FString& Message);
	void SetStyleNormal();
	void SetStyleWarning();
	void SetVisibleGuide(bool Flag);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIInfoWindow">();
	}
	static class UUIInfoWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIInfoWindow>();
	}
};
static_assert(alignof(UUIInfoWindow) == 0x000008, "Wrong alignment on UUIInfoWindow");
static_assert(sizeof(UUIInfoWindow) == 0x0003D8, "Wrong size on UUIInfoWindow");
static_assert(offsetof(UUIInfoWindow, IsWarning) == 0x000388, "Member 'UUIInfoWindow::IsWarning' has a wrong offset!");
static_assert(offsetof(UUIInfoWindow, PlayingSE) == 0x0003D0, "Member 'UUIInfoWindow::PlayingSE' has a wrong offset!");

// Class BattlePrototype.UIItemDetails
// 0x0060 (0x03E8 - 0x0388)
class UUIItemDetails : public UUIBase
{
public:
	uint8                                         Pad_388[0x60];                                     // 0x0388(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearItemInfo();
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDefaultMax, class UWidgetAnimation* AnimDefaultNoSet, class UImage* ImageNewIcon, class UTextBlock* TextItemName, class UTextBlock* TextParameter, class UTextBlock* TextItemDescription, class UTextBlock* TextHave, class UTextBlock* TextItemHaveNum, class UTextBlock* TextItemMaxNum, class UTextBlock* TextItemNumSlash);
	bool SetItemInfo(const class FName& ItemId, int32 ItemIndex);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemDetails">();
	}
	static class UUIItemDetails* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemDetails>();
	}
};
static_assert(alignof(UUIItemDetails) == 0x000008, "Wrong alignment on UUIItemDetails");
static_assert(sizeof(UUIItemDetails) == 0x0003E8, "Wrong size on UUIItemDetails");

// Class BattlePrototype.UIItemMenu
// 0xFE00 (0x10188 - 0x0388)
class UUIItemMenu : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0xFDE8];                                   // 0x03A0(0xFDE8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(int32 Index_0, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision);
	void InitializeCommonParts(class UTextBlock* TextHelp, class UUIGuide* UiKeyGuide);
	void InitializeItemCategory(int32 Category, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimUnselect, class UTextBlock* TextCategory);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UBorder* borderAllColor, class UREDScrollBox* ScrollBox, class UUIItemDetails* UIItemDetails, class UUIItemPartyStatus* UiPartyStatus);
	void ListFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUpdateElement(int32 Index_0, class UUserWidget* Widget);
	void SetContentsChange(bool IsChange);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool IsEndMenu() const;
	bool IsPlayingProgramAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemMenu">();
	}
	static class UUIItemMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemMenu>();
	}
};
static_assert(alignof(UUIItemMenu) == 0x000008, "Wrong alignment on UUIItemMenu");
static_assert(sizeof(UUIItemMenu) == 0x010188, "Wrong size on UUIItemMenu");
static_assert(offsetof(UUIItemMenu, ListElementSize) == 0x000388, "Member 'UUIItemMenu::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUIItemMenu, ListOffsetSize) == 0x000390, "Member 'UUIItemMenu::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUIItemMenu, ListIndexClass) == 0x000398, "Member 'UUIItemMenu::ListIndexClass' has a wrong offset!");

// Class BattlePrototype.UIItemPartyStatusIcon
// 0x0058 (0x03E0 - 0x0388)
class UUIItemPartyStatusIcon : public UUIBase
{
public:
	uint8                                         Pad_388[0x58];                                     // 0x0388(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimUnselect, class UWidgetAnimation* AnimDefaultMax, class UWidgetAnimation* AnimDarkMax, class UImage* ImageEquip, class UImage* ImageDone, class UHorizonFlipbookWidget* FlipArrowUP, class UHorizonFlipbookWidget* FlipArrowDOWN, class UPaperFlipbook* UpDefaultPF, class UPaperFlipbook* DownDefaultPF, class UOverlay* OverlayBondSet, class UTextBlock* TextBondNum);
	void SetEquipOrLoveIcon(EEquipOrLoveIcon Type);
	void SetFaceIcon(EPlayerID CharacterId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemPartyStatusIcon">();
	}
	static class UUIItemPartyStatusIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemPartyStatusIcon>();
	}
};
static_assert(alignof(UUIItemPartyStatusIcon) == 0x000008, "Wrong alignment on UUIItemPartyStatusIcon");
static_assert(sizeof(UUIItemPartyStatusIcon) == 0x0003E0, "Wrong size on UUIItemPartyStatusIcon");

// Class BattlePrototype.UIKeyword
// 0x0090 (0x0418 - 0x0388)
class UUIKeyword : public UUIBase
{
public:
	uint8                                         Pad_388[0x90];                                     // 0x0388(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextDescription, class UTextBlock* TextKeyword, class UTextBlock* TextInformation, class UEditableText* TextEdit);
	void TextCancel();
	void TextChange(const class FText& Text);
	void TextEnter(const class FText& Text);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	class FString GetResult() const;
	bool IsCancel() const;
	bool IsWindows() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyword">();
	}
	static class UUIKeyword* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyword>();
	}
};
static_assert(alignof(UUIKeyword) == 0x000008, "Wrong alignment on UUIKeyword");
static_assert(sizeof(UUIKeyword) == 0x000418, "Wrong size on UUIKeyword");

// Class BattlePrototype.UILetterBoxMask
// 0x0010 (0x0398 - 0x0388)
class UUILetterBoxMask : public UUIBase
{
public:
	uint8                                         Pad_388[0x10];                                     // 0x0388(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UImage* Image1, class UImage* Image2);
	void SetResolution();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILetterBoxMask">();
	}
	static class UUILetterBoxMask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILetterBoxMask>();
	}
};
static_assert(alignof(UUILetterBoxMask) == 0x000008, "Wrong alignment on UUILetterBoxMask");
static_assert(sizeof(UUILetterBoxMask) == 0x000398, "Wrong size on UUILetterBoxMask");

// Class BattlePrototype.UILogParts
// 0x0080 (0x0408 - 0x0388)
class UUILogParts : public UUIBase
{
public:
	float                                         ShuffleSeconds;                                    // 0x0388(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShuffleIntervalSeconds;                            // 0x038C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x78];                                     // 0x0390(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextBlock);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILogParts">();
	}
	static class UUILogParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILogParts>();
	}
};
static_assert(alignof(UUILogParts) == 0x000008, "Wrong alignment on UUILogParts");
static_assert(sizeof(UUILogParts) == 0x000408, "Wrong size on UUILogParts");
static_assert(offsetof(UUILogParts, ShuffleSeconds) == 0x000388, "Member 'UUILogParts::ShuffleSeconds' has a wrong offset!");
static_assert(offsetof(UUILogParts, ShuffleIntervalSeconds) == 0x00038C, "Member 'UUILogParts::ShuffleIntervalSeconds' has a wrong offset!");

// Class BattlePrototype.UIMatchID
// 0x0078 (0x0400 - 0x0388)
class UUIMatchID : public UUIBase
{
public:
	float                                         PreShuffleSeconds;                                 // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShuffuleSeconds;                                   // 0x038C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShuffuleIntervalSeconds;                           // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0x6C];                                     // 0x0394(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void End();
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextID, class UTextBlock* TextName);
	void Start(const class FName CharaID, const class FName ArmyCodeMessageID);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMatchID">();
	}
	static class UUIMatchID* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMatchID>();
	}
};
static_assert(alignof(UUIMatchID) == 0x000008, "Wrong alignment on UUIMatchID");
static_assert(sizeof(UUIMatchID) == 0x000400, "Wrong size on UUIMatchID");
static_assert(offsetof(UUIMatchID, PreShuffleSeconds) == 0x000388, "Member 'UUIMatchID::PreShuffleSeconds' has a wrong offset!");
static_assert(offsetof(UUIMatchID, ShuffuleSeconds) == 0x00038C, "Member 'UUIMatchID::ShuffuleSeconds' has a wrong offset!");
static_assert(offsetof(UUIMatchID, ShuffuleIntervalSeconds) == 0x000390, "Member 'UUIMatchID::ShuffuleIntervalSeconds' has a wrong offset!");

// Class BattlePrototype.UIMiniSubQuestGoal
// 0x0000 (0x0388 - 0x0388)
class UUIMiniSubQuestGoal : public UUIBase
{
public:
	bool SetSubquestActive();
	bool SetSubquestCompActive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiniSubQuestGoal">();
	}
	static class UUIMiniSubQuestGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMiniSubQuestGoal>();
	}
};
static_assert(alignof(UUIMiniSubQuestGoal) == 0x000008, "Wrong alignment on UUIMiniSubQuestGoal");
static_assert(sizeof(UUIMiniSubQuestGoal) == 0x000388, "Wrong size on UUIMiniSubQuestGoal");

// Class BattlePrototype.UIMiniBondsQuestGoal
// 0x0000 (0x0388 - 0x0388)
class UUIMiniBondsQuestGoal : public UUIBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiniBondsQuestGoal">();
	}
	static class UUIMiniBondsQuestGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMiniBondsQuestGoal>();
	}
};
static_assert(alignof(UUIMiniBondsQuestGoal) == 0x000008, "Wrong alignment on UUIMiniBondsQuestGoal");
static_assert(sizeof(UUIMiniBondsQuestGoal) == 0x000388, "Wrong size on UUIMiniBondsQuestGoal");

// Class BattlePrototype.UIMouse
// 0x0040 (0x03C8 - 0x0388)
class UUIMouse : public UUIBase
{
public:
	uint8                                         Pad_388[0x40];                                     // 0x0388(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetMouseAnimeNone();
	void InitializeAnime(class UWidgetAnimation* Out_focus, class UWidgetAnimation* In_focus, class UWidgetAnimation* Default_focus, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	bool IsFoucus();
	void MouseAnimeNone(bool Flag);
	void SetFoucus();
	void SetUnFoucus();
	void UpdateStateMouse(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMouse">();
	}
	static class UUIMouse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMouse>();
	}
};
static_assert(alignof(UUIMouse) == 0x000008, "Wrong alignment on UUIMouse");
static_assert(sizeof(UUIMouse) == 0x0003C8, "Wrong size on UUIMouse");

// Class BattlePrototype.UINoticeMessage
// 0x00A0 (0x0428 - 0x0388)
class UUINoticeMessage : public UUIBase
{
public:
	float                                         DispTimerMax;                                      // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0x9C];                                     // 0x038C(0x009C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddEvent(EUINoticeMessageCallType Type, class FName ID);
	void InitializeAnime(class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	void InitializeNoticeMessage(class UTextBlock* TextName, class UTextBlock* TextDetails, class UImage* KizunaImage, class UOverlay* bmguide);
	bool RemoveBrainMessageEvent(class FName ThreadID);
	bool RemoveEvent(EUINoticeMessageCallType Type, class FName ID);
	bool RemoveEventSubQuest();
	void SetNoticeIcon(int32 Type);
	void UpdateStateNoticeMessage(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINoticeMessage">();
	}
	static class UUINoticeMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINoticeMessage>();
	}
};
static_assert(alignof(UUINoticeMessage) == 0x000008, "Wrong alignment on UUINoticeMessage");
static_assert(sizeof(UUINoticeMessage) == 0x000428, "Wrong size on UUINoticeMessage");
static_assert(offsetof(UUINoticeMessage, DispTimerMax) == 0x000388, "Member 'UUINoticeMessage::DispTimerMax' has a wrong offset!");

// Class BattlePrototype.UINoticeQuestReward
// 0x00F0 (0x0478 - 0x0388)
class UUINoticeQuestReward : public UUIBase
{
public:
	uint8                                         Pad_388[0xF0];                                     // 0x0388(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeCategory(class UImage* Category1, class UImage* Category2, class UImage* Category3);
	void InitializeOverlay(class UOverlay* Overlay1, class UOverlay* Overlay2, class UOverlay* Overlay3);
	void InitializeQuestRewardChoiceIndex(int32 Index_0, class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UTextBlock* TextIndex);
	void InitializeRarity(class UImage* Rarity1, class UImage* Rarity2, class UImage* Rarity3);
	bool OpenStartReward(class FName QuestId);
	void SetItemCategoryIcon(class UImage* ImageCategory, EItemIcon Category);
	void SetItemRarity(class UImage* ImageRarity, EItemRarity Rarity);
	bool SetRewardText(class FName QuestId);
	bool UpdateCursor();

	int32 GetQuestRewardResult() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINoticeQuestReward">();
	}
	static class UUINoticeQuestReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINoticeQuestReward>();
	}
};
static_assert(alignof(UUINoticeQuestReward) == 0x000008, "Wrong alignment on UUINoticeQuestReward");
static_assert(sizeof(UUINoticeQuestReward) == 0x000478, "Wrong size on UUINoticeQuestReward");

// Class BattlePrototype.UINumberDamage
// 0x00E8 (0x0470 - 0x0388)
class UUINumberDamage : public UUIBase
{
public:
	uint8                                         Pad_388[0xB8];                                     // 0x0388(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              FixedMove;                                         // 0x0440(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_448[0x28];                                     // 0x0448(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimEnemy, class UWidgetAnimation* AnimEnemyCritical, class UWidgetAnimation* AnimHeal, class UWidgetAnimation* AnimNoDamage, class UWidgetAnimation* AnimSasCritical, class UWidgetAnimation* AnimBrainCrashCritical, class UImage* Number_1_1000, class UImage* Number_1_100, class UImage* Number_1_10, class UImage* Number_1_1, class UImage* Number_3_1000, class UImage* Number_3_100, class UImage* Number_3_10, class UImage* Number_3_1, class UOverlay* OverlaySetParent, class UHorizontalBox* HorizontalBoxCritialSet, class UHorizontalBox* HorizontalBoxNormalSet, class UOverlay* OverlayNoDamageSet);
	void InitializeThisEx(class UWidgetAnimation* AnimEnemy, class UWidgetAnimation* AnimEnemyCritical, class UWidgetAnimation* AnimHeal, class UWidgetAnimation* AnimNoDamage, class UWidgetAnimation* AnimSasCritical, class UWidgetAnimation* AnimBrainCrashCritical, class UImage* Number_1_100000, class UImage* Number_1_10000, class UImage* Number_1_1000, class UImage* Number_1_100, class UImage* Number_1_10, class UImage* Number_1_1, class UImage* Number_3_100000, class UImage* Number_3_10000, class UImage* Number_3_1000, class UImage* Number_3_100, class UImage* Number_3_10, class UImage* Number_3_1, class UOverlay* OverlaySetParent, class UHorizontalBox* HorizontalBoxCritialSet, class UHorizontalBox* HorizontalBoxNormalSet, class UOverlay* OverlayNoDamageSet);
	void SetFlagBrainCrashCritical(bool IsBrainCrashCritical);
	void SetFlagCritical(bool IsCritical);
	void SetFlagHeal(bool IsHeal);
	void SetFlagNoDamage(bool IsNoDamage);
	void SetFlagPlayer(bool IsPlayer);
	void SetFlagSasCritical(bool IsSasCritical);
	void SetNumber(int32 Number);
	void SetPosition2D(const struct FVector2D& Position);
	void SetPosition3D(const struct FVector& Position, const struct FVector2D& Offset);
	void SetThumbnailNumebr1(class UImage* Image, int32 Value);
	void SetThumbnailNumebr3(class UImage* Image, int32 Value);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINumberDamage">();
	}
	static class UUINumberDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINumberDamage>();
	}
};
static_assert(alignof(UUINumberDamage) == 0x000008, "Wrong alignment on UUINumberDamage");
static_assert(sizeof(UUINumberDamage) == 0x000470, "Wrong size on UUINumberDamage");
static_assert(offsetof(UUINumberDamage, FixedMove) == 0x000440, "Member 'UUINumberDamage::FixedMove' has a wrong offset!");

// Class BattlePrototype.UIPkObjectTimer
// 0x0040 (0x03C8 - 0x0388)
class UUIPkObjectTimer : public UUIBase
{
public:
	uint8                                         Pad_388[0x38];                                     // 0x0388(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Offset;                                            // 0x03C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UREDTextBlock* TextTimer, class UImage* ImageTimer, class UImage* ImageTimerAdd);
	bool SetupOffset();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPkObjectTimer">();
	}
	static class UUIPkObjectTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPkObjectTimer>();
	}
};
static_assert(alignof(UUIPkObjectTimer) == 0x000008, "Wrong alignment on UUIPkObjectTimer");
static_assert(sizeof(UUIPkObjectTimer) == 0x0003C8, "Wrong size on UUIPkObjectTimer");
static_assert(offsetof(UUIPkObjectTimer, Offset) == 0x0003C0, "Member 'UUIPkObjectTimer::Offset' has a wrong offset!");

// Class BattlePrototype.UIPsychicWeightGauge
// 0x00B8 (0x0440 - 0x0388)
class UUIPsychicWeightGauge : public UUIBase
{
public:
	uint8                                         Pad_388[0x38];                                     // 0x0388(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  Target;                                            // 0x03C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x78];                                     // 0x03C8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseDirectEx();
	struct FVector GetPsychicObjectWeightGaugePos(class AActor* Target_0);
	void InitializeThis(class UImage* ImageBar1, class UImage* ImageBar2, class UImage* ImageBar1Add, class UImage* ImageWeightButton, class UImage* ImageWeightIconFont, class UImage* ImageFrame1, class UImage* ImageFrame2, class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault1, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimDefault3, class UWidgetAnimation* AnimDefault4, class UWidgetAnimation* AnimIn1, class UWidgetAnimation* AnimIn2, class UWidgetAnimation* AnimIn4, class UWidgetAnimation* AnimOut1, class UWidgetAnimation* AnimOut2, class UWidgetAnimation* AnimChange1, class UWidgetAnimation* AnimChange2, class UWidgetAnimation* AnimDecision1, class UWidgetAnimation* AnimDecision2);
	void OpenEx();
	void SetEnableCombo(bool IsEnable);
	void SetEnabnle(bool IsEnable);
	void SetExObjectFlag(bool IsExObject);
	void SetGauge(int32 Level, float FPercent);
	void SetGaugeReverse(bool FlagReverse);
	void SetGaugeVisible(bool IsVisible_0);
	void SetStyle(EPsychicWeightGaugeButton Button, EPsychicWeightGaugeSize Size, int32 MaxLevel);
	void SetSuccessFlag(bool IsSuccess);
	void SetTarget(class AActor* Target_0);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	struct FLinearColor GetFontColorButton1() const;
	struct FLinearColor GetFontColorButton2() const;
	bool GetGaugeReverseFlag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPsychicWeightGauge">();
	}
	static class UUIPsychicWeightGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPsychicWeightGauge>();
	}
};
static_assert(alignof(UUIPsychicWeightGauge) == 0x000008, "Wrong alignment on UUIPsychicWeightGauge");
static_assert(sizeof(UUIPsychicWeightGauge) == 0x000440, "Wrong size on UUIPsychicWeightGauge");
static_assert(offsetof(UUIPsychicWeightGauge, Target) == 0x0003C0, "Member 'UUIPsychicWeightGauge::Target' has a wrong offset!");

// Class BattlePrototype.UIQuestChoice
// 0x0148 (0x04D0 - 0x0388)
class UUIQuestChoice : public UUIBase
{
public:
	uint8                                         Pad_388[0x148];                                    // 0x0388(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeIndex(int32 Index_0, class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UREDTextBlock* TextIndex);
	void InitializeReward(int32 Index_0, class UOverlay* Overlay, class UImage* ItemIconFrame, class UImage* IconCategory, class UImage* IconFrame);
	void InitializeThis(class UTextBlock* TextWindowTitle, class UOverlay* OverlayMainGatherItem, class USpacer* SpacerMain, class UOverlay* OverlayMainOther, class UTextBlock* TextMain, class UVerticalBox* VerticalBoxChoice, class UOverlay* OverlayReward, class UTextBlock* TextRewardTitle, class UHorizontalBox* HorizontalBoxGuide);
	void SetItemIcon(class FName ItemId, class UImage* ImageCategory, class UImage* ImageItemIconFrame);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestChoice">();
	}
	static class UUIQuestChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestChoice>();
	}
};
static_assert(alignof(UUIQuestChoice) == 0x000008, "Wrong alignment on UUIQuestChoice");
static_assert(sizeof(UUIQuestChoice) == 0x0004D0, "Wrong size on UUIQuestChoice");

// Class BattlePrototype.UIQuestIcon
// 0x0040 (0x03C8 - 0x0388)
class UUIQuestIcon : public UUIBase
{
public:
	uint8                                         Pad_388[0x40];                                     // 0x0388(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimDefault3, class UWidgetAnimation* AnimDefault4, class UWidgetAnimation* AnimDefault5, class UWidgetAnimation* AnimDefault6, class UTextBlock* TextName);
	void SetProgress(int32 Progress);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestIcon">();
	}
	static class UUIQuestIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestIcon>();
	}
};
static_assert(alignof(UUIQuestIcon) == 0x000008, "Wrong alignment on UUIQuestIcon");
static_assert(sizeof(UUIQuestIcon) == 0x0003C8, "Wrong size on UUIQuestIcon");

// Class BattlePrototype.UIQuestNamePlate
// 0x0018 (0x03A0 - 0x0388)
class UUIQuestNamePlate : public UUIBase
{
public:
	uint8                                         Pad_388[0x18];                                     // 0x0388(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UOverlay* FaceYuito, class UOverlay* FaceKasane, class UTextBlock* TextName);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestNamePlate">();
	}
	static class UUIQuestNamePlate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestNamePlate>();
	}
};
static_assert(alignof(UUIQuestNamePlate) == 0x000008, "Wrong alignment on UUIQuestNamePlate");
static_assert(sizeof(UUIQuestNamePlate) == 0x0003A0, "Wrong size on UUIQuestNamePlate");

// Class BattlePrototype.UIResurrectionGauge
// 0x0098 (0x0420 - 0x0388)
class UUIResurrectionGauge : public UUIBase
{
public:
	struct FVector2D                              baseOffset;                                        // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x8];                                      // 0x0390(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerActor;                                        // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0x80];                                     // 0x03A0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimIn2, class UWidgetAnimation* AnimOut2, class UImage* ImageIcon, class USpacer* Spacer);
	void SetGauge(float Guage);
	void SetMode(EResurrectionIconMode Mode);
	void SetOwnerActor(class AActor* OwnerActor_0);
	void SetWorldOffset(const struct FVector& WorldOffset);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIResurrectionGauge">();
	}
	static class UUIResurrectionGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIResurrectionGauge>();
	}
};
static_assert(alignof(UUIResurrectionGauge) == 0x000008, "Wrong alignment on UUIResurrectionGauge");
static_assert(sizeof(UUIResurrectionGauge) == 0x000420, "Wrong size on UUIResurrectionGauge");
static_assert(offsetof(UUIResurrectionGauge, baseOffset) == 0x000388, "Member 'UUIResurrectionGauge::baseOffset' has a wrong offset!");
static_assert(offsetof(UUIResurrectionGauge, OwnerActor) == 0x000398, "Member 'UUIResurrectionGauge::OwnerActor' has a wrong offset!");

// Class BattlePrototype.UISASFrame
// 0x00C0 (0x0448 - 0x0388)
class UUISASFrame : public UUIBase
{
public:
	uint8                                         Pad_388[0x90];                                     // 0x0388(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_buttonIndex;                                     // 0x0418(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41C[0x2C];                                     // 0x041C(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimGauge_Full, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimGauge_FullIn, class UWidgetAnimation* AnimGauge_Useing, class UWidgetAnimation* AnimGauge_Full_Out, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimChange1, class UWidgetAnimation* AnimChange2, class UOverlay* OverlaySasSet, class UImage* ImageIcon01, class UImage* ImageIcon01Add, class UImage* ImageObjectNone, class UImage* ImageBaseEffect, class UImage* ImageSasGaugeUse, class UImage* ImageSasGaugeUseAdd, class UUISASFrame2* UISASFrame2);
	bool IsEnable();
	void SetActive(bool IsActiveSAS, bool IsActiveCv);
	void SetActiveWidgetFlag(bool IsAcitveWidget);
	void SetButtonIndex(int32 Index_0);
	void SetCombinationVision(bool IsCv);
	void SetIconScale(const struct FVector2D& Scale);
	void SetIconVisible(bool IsVisible_0);
	void SetObject(class UUISASFrame2* FrameObject, class UImage* NoneObject);
	void SetSasGaugeR(class UImage* Image, int32 Index_0);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool CheckCombinationVisionCost(E_SASKindNative Sas) const;
	bool IsDecide() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISASFrame">();
	}
	static class UUISASFrame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISASFrame>();
	}
};
static_assert(alignof(UUISASFrame) == 0x000008, "Wrong alignment on UUISASFrame");
static_assert(sizeof(UUISASFrame) == 0x000448, "Wrong size on UUISASFrame");
static_assert(offsetof(UUISASFrame, M_buttonIndex) == 0x000418, "Member 'UUISASFrame::M_buttonIndex' has a wrong offset!");

// Class BattlePrototype.UISASLinkPopup
// 0x0008 (0x0390 - 0x0388)
class UUISASLinkPopup : public UUIBase
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeScrollBox(class UREDScrollBox* ScrollBox);
	void UpdateSasLinkPopupMouseFocus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISASLinkPopup">();
	}
	static class UUISASLinkPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISASLinkPopup>();
	}
};
static_assert(alignof(UUISASLinkPopup) == 0x000008, "Wrong alignment on UUISASLinkPopup");
static_assert(sizeof(UUISASLinkPopup) == 0x000390, "Wrong size on UUISASLinkPopup");

// Class BattlePrototype.UISaveLoad
// 0x0120 (0x04A8 - 0x0388)
class UUISaveLoad : public UUIBase
{
public:
	FMulticastInlineDelegateProperty_             M_OnEventInitializeStart;                          // 0x0388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TDelegate<void(bool Menudata, int32 Slot)>    M_OnEventSelectStart;                              // 0x0398(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              ListElementSize;                                   // 0x03A8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x03B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x03B8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x58];                                     // 0x03C0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class URSSaveGame*                            M_pAutoSave;                                       // 0x0418(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pAutoSaveLoadScreenParamManager;                 // 0x0420(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URSSaveGame*                            M_pSave;                                           // 0x0428(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pSaveLoadScreenParamManager;                     // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           ScrollBoxParent;                                   // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISaveLoadChoice*                      M_SaveLoadChoice;                                  // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARSHUDBase*                             M_pRSHudBase;                                      // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARSTitleManager*                        M_pTitleManager;                                   // 0x0450(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UREDScrollBox*                          ScrollBox;                                         // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIGuide*                               UGuide;                                            // 0x0460(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       LastAnimation;                                     // 0x0468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Anime_info_Win_out;                                // 0x0470(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Anime_info_Win_in;                                 // 0x0478(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Anime_info_Win;                                    // 0x0480(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Anime_out;                                         // 0x0488(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Anime_in;                                          // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Anime_default_none;                                // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Anime_default_;                                    // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	ESaveLoad GetCurrentMode();
	ESaveLoadSubType GetCurrentSubMode();
	void InitializeAnime(class UWidgetAnimation* Info_Win_out, class UWidgetAnimation* Info_Win_in, class UWidgetAnimation* Info_Win, class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	void InitializeList(class UCanvasPanel* ScrollBoxParent_0, class UREDScrollBox* ScrollBox_0);
	void InitializeSaveLoad(class UUIGuide* UGuide_0, class UUISaveLoadChoice* SaveLoadChoice);
	bool IsClearChara(int32 SlotNo, bool* Yuito, bool* Kasane);
	bool IsSaved();
	bool IsSavedError();
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Index_0, class UUserWidget* Widget);
	void ListUpdateElement(int32 Index_0, class UUserWidget* Widget);
	void SetTitleManager(class ARSTitleManager* Ptitlemanager);
	void Start(ESaveLoad ModeType, ESaveLoadSubType SubModeType);
	void UpdateStateSaveLoad(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISaveLoad">();
	}
	static class UUISaveLoad* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISaveLoad>();
	}
};
static_assert(alignof(UUISaveLoad) == 0x000008, "Wrong alignment on UUISaveLoad");
static_assert(sizeof(UUISaveLoad) == 0x0004A8, "Wrong size on UUISaveLoad");
static_assert(offsetof(UUISaveLoad, M_OnEventInitializeStart) == 0x000388, "Member 'UUISaveLoad::M_OnEventInitializeStart' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, M_OnEventSelectStart) == 0x000398, "Member 'UUISaveLoad::M_OnEventSelectStart' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, ListElementSize) == 0x0003A8, "Member 'UUISaveLoad::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, ListOffsetSize) == 0x0003B0, "Member 'UUISaveLoad::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, ListIndexClass) == 0x0003B8, "Member 'UUISaveLoad::ListIndexClass' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, M_pAutoSave) == 0x000418, "Member 'UUISaveLoad::M_pAutoSave' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, M_pAutoSaveLoadScreenParamManager) == 0x000420, "Member 'UUISaveLoad::M_pAutoSaveLoadScreenParamManager' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, M_pSave) == 0x000428, "Member 'UUISaveLoad::M_pSave' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, M_pSaveLoadScreenParamManager) == 0x000430, "Member 'UUISaveLoad::M_pSaveLoadScreenParamManager' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, ScrollBoxParent) == 0x000438, "Member 'UUISaveLoad::ScrollBoxParent' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, M_SaveLoadChoice) == 0x000440, "Member 'UUISaveLoad::M_SaveLoadChoice' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, M_pRSHudBase) == 0x000448, "Member 'UUISaveLoad::M_pRSHudBase' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, M_pTitleManager) == 0x000450, "Member 'UUISaveLoad::M_pTitleManager' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, ScrollBox) == 0x000458, "Member 'UUISaveLoad::ScrollBox' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, UGuide) == 0x000460, "Member 'UUISaveLoad::UGuide' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, LastAnimation) == 0x000468, "Member 'UUISaveLoad::LastAnimation' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, Anime_info_Win_out) == 0x000470, "Member 'UUISaveLoad::Anime_info_Win_out' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, Anime_info_Win_in) == 0x000478, "Member 'UUISaveLoad::Anime_info_Win_in' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, Anime_info_Win) == 0x000480, "Member 'UUISaveLoad::Anime_info_Win' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, Anime_out) == 0x000488, "Member 'UUISaveLoad::Anime_out' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, Anime_in) == 0x000490, "Member 'UUISaveLoad::Anime_in' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, Anime_default_none) == 0x000498, "Member 'UUISaveLoad::Anime_default_none' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, Anime_default_) == 0x0004A0, "Member 'UUISaveLoad::Anime_default_' has a wrong offset!");

// Class BattlePrototype.UISaveLoadChoice
// 0x00F8 (0x0480 - 0x0388)
class UUISaveLoadChoice : public UUIBase
{
public:
	uint8                                         Pad_388[0xF8];                                     // 0x0388(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeAnime(class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	void InitializeSaveLoadSelectIndex(int32 Index_0, class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UTextBlock* TextIndex);
	void InitializeText(class UTextBlock* TextTitle, class UTextBlock* TextMain, class UVerticalBox* TextVerticalBox, class UOverlay* GuideOverlay);
	bool StartSaveLoadChoice(const class FString& TextTitle, const class FString& TextMain, int32 DefaultIndex, const class FString& TextIndex1, const class FString& TextIndex2, int32 TextNum, bool Cancelable, int32 CancelIndex);
	void UpdateStateSaveLoadChoice(int32 State, int32 SubState, float DeltaSeconds);

	int32 GetResult() const;
	bool GetResultAct() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISaveLoadChoice">();
	}
	static class UUISaveLoadChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISaveLoadChoice>();
	}
};
static_assert(alignof(UUISaveLoadChoice) == 0x000008, "Wrong alignment on UUISaveLoadChoice");
static_assert(sizeof(UUISaveLoadChoice) == 0x000480, "Wrong size on UUISaveLoadChoice");

// Class BattlePrototype.UISaveLoadList
// 0x0200 (0x0588 - 0x0388)
class UUISaveLoadList : public UUIBase
{
public:
	ESaveLoadListType                             M_SaveLoadListType;                                // 0x0388(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_389[0x1FF];                                    // 0x0389(0x01FF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ESaveLoadListType GetSaveDataType();
	void InitializeDataBreakListAnime(class UWidgetAnimation* Decide, class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Select, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	void InitializeDataExLoadAnime(class UWidgetAnimation* Decide, class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Select, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	void InitializeListAnime(class UWidgetAnimation* Decide, class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Select, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	void InitializeListClear(class UOverlay* Clear_01, class UOverlay* Clear_02, class UTextBlock* Textclear_01, class UTextBlock* Textclear_02);
	void InitializeListText(class UImage* ImageScreen, class UTextBlock* TextChapter, class UTextBlock* TextChapterTitle, class UTextBlock* TextInfo, class UTextBlock* TextPlLv, class UTextBlock* PlLvNum, class UTextBlock* PlName, class UTextBlock* TextDayFixTime, class UTextBlock* TextPlEx, class UImage* ImagePlEx, class UTextBlock* TextSlash, class UTextBlock* TextSaveType);
	void InitializeListTextCommon(class UImage* ImageLine, class UImage* ImageClearIcon, class UTextBlock* TextDay1, class UTextBlock* TextDay2, class UTextBlock* TextTime1, class UTextBlock* TextTime2);
	void InitializeListTextTime(class UTextBlock* TextDayTime, class UTextBlock* TextDayhh, class UTextBlock* TextDaymm, class UTextBlock* TextDayss, class UTextBlock* TextTimehh, class UTextBlock* TextTimemm, class UTextBlock* TextTimess);
	void InitializeNoDataListAnime(class UWidgetAnimation* Decide, class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Select, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	bool SetDataFontOutLineColor(ESaveLoadListType DataType, class UTextBlock* Text);
	bool SetFontColor(ESaveLoadListClearType DataType, class UTextBlock* Text);
	bool SetLevelFontColor(bool LevelMax);
	void SetScreenTexture(int32 ImageType, class UTexture2D* ImageData);
	bool SetTitleFontOutLineColor(ESaveLoadListType DataType, class UTextBlock* Text);
	void UpdateStateSaveLoadList(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISaveLoadList">();
	}
	static class UUISaveLoadList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISaveLoadList>();
	}
};
static_assert(alignof(UUISaveLoadList) == 0x000008, "Wrong alignment on UUISaveLoadList");
static_assert(sizeof(UUISaveLoadList) == 0x000588, "Wrong size on UUISaveLoadList");
static_assert(offsetof(UUISaveLoadList, M_SaveLoadListType) == 0x000388, "Member 'UUISaveLoadList::M_SaveLoadListType' has a wrong offset!");

// Class BattlePrototype.UIShopChoice
// 0x00F8 (0x0480 - 0x0388)
class UUIShopChoice : public UUIBase
{
public:
	uint8                                         Pad_388[0xF8];                                     // 0x0388(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeIndex(int32 Index_0, class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UREDTextBlock* TextIndex);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimBuySellTransfer, class UTextBlock* TextWindowTitle, class UTextBlock* TextMain, class UVerticalBox* MultiGroupParent, class UVerticalBox* ChoiceSet, class UOverlay* GoldSet, class UUIShopPayment* ChildShopPayment, class UUIShopTransfer* ChildShopTransfer, class UOverlay* GuideSet);
	void StartChoice2_BP(const class FName& TextWindowTitle, const class FName& TextMain, const class FName& TextYes, const class FName& TextNo, int32 DefaultCursor);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopChoice">();
	}
	static class UUIShopChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopChoice>();
	}
};
static_assert(alignof(UUIShopChoice) == 0x000008, "Wrong alignment on UUIShopChoice");
static_assert(sizeof(UUIShopChoice) == 0x000480, "Wrong size on UUIShopChoice");

// Class BattlePrototype.UIShopItemDetails
// 0x0070 (0x03F8 - 0x0388)
class UUIShopItemDetails : public UUIBase
{
public:
	uint8                                         Pad_388[0x70];                                     // 0x0388(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearItemInfo();
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDefaultMax, class UWidgetAnimation* AnimDefaultNoSet, class UImage* ImageNewIcon, class UImage* ImageItemIcon, class UImage* ImageRarityFrame, class UTextBlock* TextItemName, class UTextBlock* TextParameter, class UTextBlock* TextItemDescription, class UTextBlock* TextHave, class UTextBlock* TextItemHaveNum, class UTextBlock* TextItemMaxNum, class UTextBlock* TextItemNumSlash);
	bool SetItemInfo(const class FName& ItemId, int32 ItemIndex);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopItemDetails">();
	}
	static class UUIShopItemDetails* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopItemDetails>();
	}
};
static_assert(alignof(UUIShopItemDetails) == 0x000008, "Wrong alignment on UUIShopItemDetails");
static_assert(sizeof(UUIShopItemDetails) == 0x0003F8, "Wrong size on UUIShopItemDetails");

// Class BattlePrototype.UIShopListIndex
// 0x00E8 (0x0470 - 0x0388)
class UUIShopListIndex : public UUIBase
{
public:
	struct FLinearColor                           ColorNumHave;                                      // 0x0388(0x0010)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ColorMaxNumHave;                                   // 0x0398(0x0010)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0xC8];                                     // 0x03A8(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UImage* ImageNewIcon, class UTextBlock* TextItemName, class UTextBlock* TextNumHave, class UTextBlock* TextNumPrice, class UTextBlock* TextNumBuySell);
	bool SetItemInfo(const class FName& ItemId, int32 ItemIndex);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopListIndex">();
	}
	static class UUIShopListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopListIndex>();
	}
};
static_assert(alignof(UUIShopListIndex) == 0x000008, "Wrong alignment on UUIShopListIndex");
static_assert(sizeof(UUIShopListIndex) == 0x000470, "Wrong size on UUIShopListIndex");
static_assert(offsetof(UUIShopListIndex, ColorNumHave) == 0x000388, "Member 'UUIShopListIndex::ColorNumHave' has a wrong offset!");
static_assert(offsetof(UUIShopListIndex, ColorMaxNumHave) == 0x000398, "Member 'UUIShopListIndex::ColorMaxNumHave' has a wrong offset!");

// Class BattlePrototype.UIShopPayment
// 0x0048 (0x03D0 - 0x0388)
class UUIShopPayment : public UUIBase
{
public:
	uint8                                         Pad_388[0x48];                                     // 0x0388(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimDefault3, class UTextBlock* TextMoneyInHand, class UTextBlock* TextMoneyAfter, class UTextBlock* TextSubtotal, class UTextBlock* TextNumMoneyInHand, class UTextBlock* TextNumMoneyAfter, class UTextBlock* TextNumSubtotal);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopPayment">();
	}
	static class UUIShopPayment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopPayment>();
	}
};
static_assert(alignof(UUIShopPayment) == 0x000008, "Wrong alignment on UUIShopPayment");
static_assert(sizeof(UUIShopPayment) == 0x0003D0, "Wrong size on UUIShopPayment");

// Class BattlePrototype.UITips
// 0x00B8 (0x0440 - 0x0388)
class UUITips : public UUIBase
{
public:
	uint8                                         Pad_388[0xB8];                                     // 0x0388(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeAnime(class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	void InitializeArrow(int32 Index_0, class UUIHelpParts* Arrow);
	void InitializeTips(class UUIGuide* UGuide, class UTextBlock* TextGuide, class UUITutoTipsParts* Ututotipsdata, class UImage* ImageFade);
	void Start(EHelpTutorial HelpID, bool NotPauseControll, bool NotCloseOfPause, bool IsFade);
	void UpdateStateTips(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITips">();
	}
	static class UUITips* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITips>();
	}
};
static_assert(alignof(UUITips) == 0x000008, "Wrong alignment on UUITips");
static_assert(sizeof(UUITips) == 0x000440, "Wrong size on UUITips");

// Class BattlePrototype.UITitleCrossSave_UpdatingWidget
// 0x0030 (0x03B8 - 0x0388)
class UUITitleCrossSave_UpdatingWidget : public UUIBase
{
public:
	uint8                                         Pad_388[0x30];                                     // 0x0388(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimNoneDefault);
	void SetLoadingColor(const struct FLinearColor& Color);
	void UpdateLoadingMaterial();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleCrossSave_UpdatingWidget">();
	}
	static class UUITitleCrossSave_UpdatingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleCrossSave_UpdatingWidget>();
	}
};
static_assert(alignof(UUITitleCrossSave_UpdatingWidget) == 0x000008, "Wrong alignment on UUITitleCrossSave_UpdatingWidget");
static_assert(sizeof(UUITitleCrossSave_UpdatingWidget) == 0x0003B8, "Wrong size on UUITitleCrossSave_UpdatingWidget");

// Class BattlePrototype.UITitleFirstConfirm
// 0x0060 (0x03E8 - 0x0388)
class UUITitleFirstConfirm final : public UUIBase
{
public:
	uint8                                         Pad_388[0x60];                                     // 0x0388(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefault, class UUITitleFirstConfirmChildImage* ChildImage1, class UUITitleFirstConfirmChildImage* ChildImage2, class UUITitleFirstConfirmChildText* ChildText, class UUIGuide* UIGuide);
	void SetCeBank(bool Value);
	void SetTitleManager(class ARSTitleManager* TitleManager);
	void StartAnalytics();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleFirstConfirm">();
	}
	static class UUITitleFirstConfirm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleFirstConfirm>();
	}
};
static_assert(alignof(UUITitleFirstConfirm) == 0x000008, "Wrong alignment on UUITitleFirstConfirm");
static_assert(sizeof(UUITitleFirstConfirm) == 0x0003E8, "Wrong size on UUITitleFirstConfirm");

// Class BattlePrototype.UITitleFirstConfirmChildImage
// 0x0060 (0x0400 - 0x03A0)
class UUITitleFirstConfirmChildImage final : public UUITitleFirstConfirmChildBase
{
public:
	uint8                                         Pad_3A0[0x60];                                     // 0x03A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefault, class UImage* ImageEulaFull_1, class UImage* ImageEulaFull_2, class UImage* ImageEulaHalf_1, class UImage* ImageEulaHalf_2, class UImage* ImagePrivacyPolicy, class UREDTextBlock* TextTitle, class UREDTextBlock* TextHelp, class UREDScrollBoxSimple* ScrollBox, class UUITitleFirstConfirmSelect2* UiSelect2);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleFirstConfirmChildImage">();
	}
	static class UUITitleFirstConfirmChildImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleFirstConfirmChildImage>();
	}
};
static_assert(alignof(UUITitleFirstConfirmChildImage) == 0x000008, "Wrong alignment on UUITitleFirstConfirmChildImage");
static_assert(sizeof(UUITitleFirstConfirmChildImage) == 0x000400, "Wrong size on UUITitleFirstConfirmChildImage");

// Class BattlePrototype.UITitleFirstConfirmChildText
// 0x0040 (0x03E0 - 0x03A0)
class UUITitleFirstConfirmChildText final : public UUITitleFirstConfirmChildBase
{
public:
	uint8                                         Pad_3A0[0x40];                                     // 0x03A0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefault, class UREDTextBlock* TextMain, class UREDTextBlock* TextTitle, class UREDTextBlock* TextHelp, class UREDScrollBoxSimple* ScrollBox, class UUITitleFirstConfirmSelect2* UiSelect2);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleFirstConfirmChildText">();
	}
	static class UUITitleFirstConfirmChildText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleFirstConfirmChildText>();
	}
};
static_assert(alignof(UUITitleFirstConfirmChildText) == 0x000008, "Wrong alignment on UUITitleFirstConfirmChildText");
static_assert(sizeof(UUITitleFirstConfirmChildText) == 0x0003E0, "Wrong size on UUITitleFirstConfirmChildText");

// Class BattlePrototype.UITitleFirstConfirmSelect2
// 0x0130 (0x04B8 - 0x0388)
class UUITitleFirstConfirmSelect2 final : public UUIBase
{
public:
	uint8                                         Pad_388[0x130];                                    // 0x0388(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeIndex(int32 Index_0, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimEnable, class UWidgetAnimation* AnimEnableIn, class UWidgetAnimation* AnimEnableOut, class UREDTextBlock* TextIndex);
	void InitializeThis();
	void UpdateStateThis(int32 State);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleFirstConfirmSelect2">();
	}
	static class UUITitleFirstConfirmSelect2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleFirstConfirmSelect2>();
	}
};
static_assert(alignof(UUITitleFirstConfirmSelect2) == 0x000008, "Wrong alignment on UUITitleFirstConfirmSelect2");
static_assert(sizeof(UUITitleFirstConfirmSelect2) == 0x0004B8, "Wrong size on UUITitleFirstConfirmSelect2");

// Class BattlePrototype.UITitleFirstLangaugeChange
// 0x00F8 (0x0480 - 0x0388)
class UUITitleFirstLangaugeChange final : public UUIBase
{
public:
	uint8                                         Pad_388[0xF8];                                     // 0x0388(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeIndex(class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UREDTextBlock* TextIndex);
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefault, class UREDTextBlock* TextMain, class UREDTextBlock* TextLangauge);
	void SetTitleManager(class ARSTitleManager* TitleManager);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleFirstLangaugeChange">();
	}
	static class UUITitleFirstLangaugeChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleFirstLangaugeChange>();
	}
};
static_assert(alignof(UUITitleFirstLangaugeChange) == 0x000008, "Wrong alignment on UUITitleFirstLangaugeChange");
static_assert(sizeof(UUITitleFirstLangaugeChange) == 0x000480, "Wrong size on UUITitleFirstLangaugeChange");

// Class BattlePrototype.UITitleLicense
// 0x0040 (0x03C8 - 0x0388)
class UUITitleLicense final : public UUIBase
{
public:
	uint8                                         Pad_388[0x40];                                     // 0x0388(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefault, class UREDTextBlock* TextTitle, class UREDTextBlock* TextHelp, class UREDScrollBoxSimple* ScrollBox, class UUIGuide* UIGuide);
	void Start();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleLicense">();
	}
	static class UUITitleLicense* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleLicense>();
	}
};
static_assert(alignof(UUITitleLicense) == 0x000008, "Wrong alignment on UUITitleLicense");
static_assert(sizeof(UUITitleLicense) == 0x0003C8, "Wrong size on UUITitleLicense");

// Class BattlePrototype.UITitleLogo
// 0x00C0 (0x0448 - 0x0388)
class UUITitleLogo final : public UUIBase
{
public:
	uint8                                         Pad_388[0x28];                                     // 0x0388(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               TextureLogo[0x6];                                  // 0x03B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIGamerTag*                            M_UserTag;                                         // 0x03E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x18];                                     // 0x03E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSHUDBase*                             M_pRSHudBase;                                      // 0x0400(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URSSaveGame*                            M_pSaveGameSystem;                                 // 0x0408(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pSaveLoadSystemParamManager;                     // 0x0410(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x30];                                     // 0x0418(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefault, class UImage* ImageLogo);
	void SetUserTagWidget(class UUIGamerTag* UserTag);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleLogo">();
	}
	static class UUITitleLogo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleLogo>();
	}
};
static_assert(alignof(UUITitleLogo) == 0x000008, "Wrong alignment on UUITitleLogo");
static_assert(sizeof(UUITitleLogo) == 0x000448, "Wrong size on UUITitleLogo");
static_assert(offsetof(UUITitleLogo, TextureLogo) == 0x0003B0, "Member 'UUITitleLogo::TextureLogo' has a wrong offset!");
static_assert(offsetof(UUITitleLogo, M_UserTag) == 0x0003E0, "Member 'UUITitleLogo::M_UserTag' has a wrong offset!");
static_assert(offsetof(UUITitleLogo, M_pRSHudBase) == 0x000400, "Member 'UUITitleLogo::M_pRSHudBase' has a wrong offset!");
static_assert(offsetof(UUITitleLogo, M_pSaveGameSystem) == 0x000408, "Member 'UUITitleLogo::M_pSaveGameSystem' has a wrong offset!");
static_assert(offsetof(UUITitleLogo, M_pSaveLoadSystemParamManager) == 0x000410, "Member 'UUITitleLogo::M_pSaveLoadSystemParamManager' has a wrong offset!");

// Class BattlePrototype.UITitleMenu
// 0x0148 (0x04D0 - 0x0388)
class UUITitleMenu final : public UUIBase
{
public:
	TDelegate<void(ETitleFlow Cursor)>            M_OnEventCursorSelectStart;                        // 0x0388(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class UUIGamerTag*                            TitleUserTag;                                      // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x20];                                     // 0x03A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserParamManager*                      UserParamManager;                                  // 0x03C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDatabaseManager*                       DatabaseManager;                                   // 0x03C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARSTitleManager*                        M_pTitleManager;                                   // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMessageHudManager*                     MessageHudManager;                                 // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E0[0x78];                                     // 0x03E0(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      M_pPlayerController;                               // 0x0458(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARSHUDBase*                             M_pHudBase;                                        // 0x0460(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x68];                                     // 0x0468(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetMoviePlayFlag();
	void InitializeAnime(class UWidgetAnimation* _press_start_out_first, class UWidgetAnimation* _press_start_in_first, class UWidgetAnimation* _press_start_default_first, class UWidgetAnimation* _press_start_out, class UWidgetAnimation* _press_start_in, class UWidgetAnimation* _press_start_default_none, class UWidgetAnimation* _press_start_default_, class UWidgetAnimation* _start_menu_in, class UWidgetAnimation* _start_menu_default, class UWidgetAnimation* _start_menu_decision, class UWidgetAnimation* _change_press_start, class UWidgetAnimation* _start_menu_select_in);
	void InitializeText(class UTextBlock* Pressstart, class UTextBlock* Titlever, class UTextBlock* Titlecopyright);
	void InitializeTitleLogo(class UImage* Titlelogoimage);
	void InitializeTitleParts(int32 Index_0, class UUITitleMenuParts* Titleparts);
	void InitializeXboxOne(class UTextBlock* UserName);
	bool IsFirstDecideCheck();
	void OpenFirstPressMenu();
	void OpenLogoBP();
	void OpenSelectMenu();
	void SetTitleLogoWidget(class UUIScarletLogo* Titlelogowidget);
	void SetTitleManager(class ARSTitleManager* Ptitlemanager);
	void Start(bool IsStartMenu);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleMenu">();
	}
	static class UUITitleMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleMenu>();
	}
};
static_assert(alignof(UUITitleMenu) == 0x000008, "Wrong alignment on UUITitleMenu");
static_assert(sizeof(UUITitleMenu) == 0x0004D0, "Wrong size on UUITitleMenu");
static_assert(offsetof(UUITitleMenu, M_OnEventCursorSelectStart) == 0x000388, "Member 'UUITitleMenu::M_OnEventCursorSelectStart' has a wrong offset!");
static_assert(offsetof(UUITitleMenu, TitleUserTag) == 0x000398, "Member 'UUITitleMenu::TitleUserTag' has a wrong offset!");
static_assert(offsetof(UUITitleMenu, UserParamManager) == 0x0003C0, "Member 'UUITitleMenu::UserParamManager' has a wrong offset!");
static_assert(offsetof(UUITitleMenu, DatabaseManager) == 0x0003C8, "Member 'UUITitleMenu::DatabaseManager' has a wrong offset!");
static_assert(offsetof(UUITitleMenu, M_pTitleManager) == 0x0003D0, "Member 'UUITitleMenu::M_pTitleManager' has a wrong offset!");
static_assert(offsetof(UUITitleMenu, MessageHudManager) == 0x0003D8, "Member 'UUITitleMenu::MessageHudManager' has a wrong offset!");
static_assert(offsetof(UUITitleMenu, M_pPlayerController) == 0x000458, "Member 'UUITitleMenu::M_pPlayerController' has a wrong offset!");
static_assert(offsetof(UUITitleMenu, M_pHudBase) == 0x000460, "Member 'UUITitleMenu::M_pHudBase' has a wrong offset!");

// Class BattlePrototype.UITitleMenuParts
// 0x0090 (0x0418 - 0x0388)
class UUITitleMenuParts final : public UUIBase
{
public:
	uint8                                         Pad_388[0x90];                                     // 0x0388(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeNormalAnime(class UWidgetAnimation* _cursor_menu_out, class UWidgetAnimation* _cursor_menu_in, class UWidgetAnimation* _cursor_menu_default_none, class UWidgetAnimation* _cursor_menu_default_, class UWidgetAnimation* _cursor_menu_select, class UWidgetAnimation* _cursor_menu_decision);
	void InitializeText(class UTextBlock* Partsdatatext);
	void InitializeUnSelectAnime(class UWidgetAnimation* _cursor_menu_out, class UWidgetAnimation* _cursor_menu_in, class UWidgetAnimation* _cursor_menu_default_none, class UWidgetAnimation* _cursor_menu_default_, class UWidgetAnimation* _cursor_menu_select, class UWidgetAnimation* _cursor_menu_decision);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleMenuParts">();
	}
	static class UUITitleMenuParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleMenuParts>();
	}
};
static_assert(alignof(UUITitleMenuParts) == 0x000008, "Wrong alignment on UUITitleMenuParts");
static_assert(sizeof(UUITitleMenuParts) == 0x000418, "Wrong size on UUITitleMenuParts");

// Class BattlePrototype.UITownName
// 0x0058 (0x03E0 - 0x0388)
class UUITownName : public UUIBase
{
public:
	float                                         DrawSecond;                                        // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0x54];                                     // 0x038C(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextLocationName, class UTextBlock* TextLocationName2, class UTextBlock* TextLocationName3, class UTextBlock* TextLocationName4);
	void Start(int32 LocationId);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITownName">();
	}
	static class UUITownName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITownName>();
	}
};
static_assert(alignof(UUITownName) == 0x000008, "Wrong alignment on UUITownName");
static_assert(sizeof(UUITownName) == 0x0003E0, "Wrong size on UUITownName");
static_assert(offsetof(UUITownName, DrawSecond) == 0x000388, "Member 'UUITownName::DrawSecond' has a wrong offset!");

// Class BattlePrototype.UITutoOperation
// 0x0148 (0x04D0 - 0x0388)
class UUITutoOperation : public UUIBase
{
public:
	struct FVector2D                              baseOffset;                                        // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUITutoOperationParts>      M_pClassSelect;                                    // 0x0390(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           M_pPartsParent;                                    // 0x0398(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 OwnerActor;                                        // 0x03A0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                WorldOffset;                                       // 0x03A8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B4[0x114];                                    // 0x03B4(0x0114)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSHUDBase*                             M_pHudBase;                                        // 0x04C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializeAnime(class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	void InitializeTutoOperation(class UREDRetainerBox* REDRetainerBox, class UImage* boximage);
	void InitializeTutoOperationList(int32 ListIndex, class UOverlay* OverlayData, class UUITutoOperationParts* TextRight, class UUITutoOperationParts* Textleft);
	void OperationEnd();
	void Start(class FName HelpID);
	void UpdateStateTutoOperation(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITutoOperation">();
	}
	static class UUITutoOperation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITutoOperation>();
	}
};
static_assert(alignof(UUITutoOperation) == 0x000008, "Wrong alignment on UUITutoOperation");
static_assert(sizeof(UUITutoOperation) == 0x0004D0, "Wrong size on UUITutoOperation");
static_assert(offsetof(UUITutoOperation, baseOffset) == 0x000388, "Member 'UUITutoOperation::baseOffset' has a wrong offset!");
static_assert(offsetof(UUITutoOperation, M_pClassSelect) == 0x000390, "Member 'UUITutoOperation::M_pClassSelect' has a wrong offset!");
static_assert(offsetof(UUITutoOperation, M_pPartsParent) == 0x000398, "Member 'UUITutoOperation::M_pPartsParent' has a wrong offset!");
static_assert(offsetof(UUITutoOperation, OwnerActor) == 0x0003A0, "Member 'UUITutoOperation::OwnerActor' has a wrong offset!");
static_assert(offsetof(UUITutoOperation, WorldOffset) == 0x0003A8, "Member 'UUITutoOperation::WorldOffset' has a wrong offset!");
static_assert(offsetof(UUITutoOperation, M_pHudBase) == 0x0004C8, "Member 'UUITutoOperation::M_pHudBase' has a wrong offset!");

// Class BattlePrototype.UITutoOperationParts
// 0x0030 (0x03B8 - 0x0388)
class UUITutoOperationParts : public UUIBase
{
public:
	class FName                                   PathData;                                          // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHelpImageType                                ImageType;                                         // 0x0390(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x27];                                     // 0x0391(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeLeftText(class UImage* ImageLeft, class UTextBlock* Textleft, class USpacer* Spacer);
	void InitializeRightText(class UTextBlock* TextRight);
	void SetOperationLeftText(const class FString& LeftIconString);
	void SetOperationRightText(const class FString& RightText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITutoOperationParts">();
	}
	static class UUITutoOperationParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITutoOperationParts>();
	}
};
static_assert(alignof(UUITutoOperationParts) == 0x000008, "Wrong alignment on UUITutoOperationParts");
static_assert(sizeof(UUITutoOperationParts) == 0x0003B8, "Wrong size on UUITutoOperationParts");
static_assert(offsetof(UUITutoOperationParts, PathData) == 0x000388, "Member 'UUITutoOperationParts::PathData' has a wrong offset!");
static_assert(offsetof(UUITutoOperationParts, ImageType) == 0x000390, "Member 'UUITutoOperationParts::ImageType' has a wrong offset!");

// Class BattlePrototype.UIVitalityEN01
// 0x0030 (0x0418 - 0x03E8)
class UUIVitalityEN01 : public UUIHealthControl
{
public:
	uint8                                         Pad_3E8[0x30];                                     // 0x03E8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UImage* ImageIcon1, class UImage* ImageIcon2, class UImage* ImageIcon3, class UImage* ImageIcon4, class UImage* ImageIcon5, class UTextBlock* TextBossName, class UImage* ImageBarNormal, class UImage* ImageBarOverride, class UImage* ImageBarAdd);
	void SetLevel(int32 Level);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVitalityEN01">();
	}
	static class UUIVitalityEN01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVitalityEN01>();
	}
};
static_assert(alignof(UUIVitalityEN01) == 0x000008, "Wrong alignment on UUIVitalityEN01");
static_assert(sizeof(UUIVitalityEN01) == 0x000418, "Wrong size on UUIVitalityEN01");

// Class BattlePrototype.UIVitalityEN02
// 0x0060 (0x0448 - 0x03E8)
class UUIVitalityEN02 : public UUIHealthControl
{
public:
	uint8                                         Pad_3E8[0x48];                                     // 0x03E8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIBrainCrashGauge*                     BrainCrashGauge;                                   // 0x0430(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BrainCrashGaugeDrawFlag;                           // 0x0438(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_439[0xF];                                      // 0x0439(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault01, class UWidgetAnimation* AnimDefault02, class UWidgetAnimation* AnimDefault03, class UWidgetAnimation* AnimDefault04, class UWidgetAnimation* AnimDefault05, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UImage* ImageIcon1, class UImage* ImageIcon2, class UImage* ImageIcon3, class UImage* ImageIcon4, class UImage* ImageIcon5, class UImage* ImageBarNormal, class UImage* ImageBarOverride, class UImage* ImageBarAdd, class UTextBlock* TextEnemyName);
	void SetLevel(int32 Level);
	void SetSubQuestTarget(class FName Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVitalityEN02">();
	}
	static class UUIVitalityEN02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVitalityEN02>();
	}
};
static_assert(alignof(UUIVitalityEN02) == 0x000008, "Wrong alignment on UUIVitalityEN02");
static_assert(sizeof(UUIVitalityEN02) == 0x000448, "Wrong size on UUIVitalityEN02");
static_assert(offsetof(UUIVitalityEN02, BrainCrashGauge) == 0x000430, "Member 'UUIVitalityEN02::BrainCrashGauge' has a wrong offset!");
static_assert(offsetof(UUIVitalityEN02, BrainCrashGaugeDrawFlag) == 0x000438, "Member 'UUIVitalityEN02::BrainCrashGaugeDrawFlag' has a wrong offset!");

// Class BattlePrototype.UIVitalityPL03
// 0x0000 (0x0468 - 0x0468)
class UUIVitalityPL03 : public UUIVitalityPLBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVitalityPL03">();
	}
	static class UUIVitalityPL03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVitalityPL03>();
	}
};
static_assert(alignof(UUIVitalityPL03) == 0x000008, "Wrong alignment on UUIVitalityPL03");
static_assert(sizeof(UUIVitalityPL03) == 0x000468, "Wrong size on UUIVitalityPL03");

// Class BattlePrototype.UserDataAccessor
// 0x0020 (0x0048 - 0x0028)
class UUserDataAccessor final : public UObject
{
public:
	struct FUserData                              UserData;                                          // 0x0028(0x0020)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserDataAccessor">();
	}
	static class UUserDataAccessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserDataAccessor>();
	}
};
static_assert(alignof(UUserDataAccessor) == 0x000008, "Wrong alignment on UUserDataAccessor");
static_assert(sizeof(UUserDataAccessor) == 0x000048, "Wrong size on UUserDataAccessor");
static_assert(offsetof(UUserDataAccessor, UserData) == 0x000028, "Member 'UUserDataAccessor::UserData' has a wrong offset!");

// Class BattlePrototype.WeaponChargeInterface
// 0x0000 (0x0028 - 0x0028)
class IWeaponChargeInterface final : public IInterface
{
public:
	bool CheckWeaponChargeLevelDeficit(int32 CheckLevel) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponChargeInterface">();
	}
	static class IWeaponChargeInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IWeaponChargeInterface>();
	}
};
static_assert(alignof(IWeaponChargeInterface) == 0x000008, "Wrong alignment on IWeaponChargeInterface");
static_assert(sizeof(IWeaponChargeInterface) == 0x000028, "Wrong size on IWeaponChargeInterface");

// Class BattlePrototype.WorldmapBatchOpenData
// 0x0030 (0x0058 - 0x0028)
class UWorldmapBatchOpenData final : public UObject
{
public:
	class UDataTable*                             RefCheckTableM;                                    // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             RefCheckTableF;                                    // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetMainLocationIDFromSublocationID(int32 SubLocationID);
	bool IsValidResource();
	bool LoadDataTable();
	bool UnloadDataTable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldmapBatchOpenData">();
	}
	static class UWorldmapBatchOpenData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldmapBatchOpenData>();
	}
};
static_assert(alignof(UWorldmapBatchOpenData) == 0x000008, "Wrong alignment on UWorldmapBatchOpenData");
static_assert(sizeof(UWorldmapBatchOpenData) == 0x000058, "Wrong size on UWorldmapBatchOpenData");
static_assert(offsetof(UWorldmapBatchOpenData, RefCheckTableM) == 0x000028, "Member 'UWorldmapBatchOpenData::RefCheckTableM' has a wrong offset!");
static_assert(offsetof(UWorldmapBatchOpenData, RefCheckTableF) == 0x000030, "Member 'UWorldmapBatchOpenData::RefCheckTableF' has a wrong offset!");

// Class BattlePrototype.Wp0400AnimInstance
// 0x0320 (0x0590 - 0x0270)
class UWp0400AnimInstance : public UAnimInstance
{
public:
	TWeakObjectPtr<class USceneComponent>         OwnerMeshComponent;                                // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightForeArmLocation;                              // 0x0278(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightForeArmRotation;                              // 0x0284(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightForeArmScale;                                 // 0x0290(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightForeArmRollLocation;                          // 0x029C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightForeArmRollRotation;                          // 0x02A8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightForeArmRollScale;                             // 0x02B4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandLocation;                                 // 0x02C0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandRotation;                                 // 0x02CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandScale;                                    // 0x02D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandHelpLocation;                             // 0x02E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandHelpRotation;                             // 0x02F0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandHelpScale;                                // 0x02FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandThumb1Location;                           // 0x0308(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandThumb1Rotation;                           // 0x0314(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandThumb1Scale;                              // 0x0320(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandThumb2Location;                           // 0x032C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandThumb2Rotation;                           // 0x0338(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandThumb2Scale;                              // 0x0344(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandThumb3Location;                           // 0x0350(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandThumb3Rotation;                           // 0x035C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandThumb3Scale;                              // 0x0368(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandIndex1Location;                           // 0x0374(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandIndex1Rotation;                           // 0x0380(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandIndex1Scale;                              // 0x038C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandIndex2Location;                           // 0x0398(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandIndex2Rotation;                           // 0x03A4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandIndex2Scale;                              // 0x03B0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandIndex3Location;                           // 0x03BC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandIndex3Rotation;                           // 0x03C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandIndex3Scale;                              // 0x03D4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandMiddleLocation;                           // 0x03E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandMiddleRotation;                           // 0x03EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandMiddleScale;                              // 0x03F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandMiddle1Location;                          // 0x0404(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandMiddle1Rotation;                          // 0x0410(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandMiddle1Scale;                             // 0x041C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandMiddle2Location;                          // 0x0428(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandMiddle2Rotation;                          // 0x0434(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandMiddle2Scale;                             // 0x0440(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandMiddle3Location;                          // 0x044C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandMiddle3Rotation;                          // 0x0458(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandMiddle3Scale;                             // 0x0464(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandRingLocation;                             // 0x0470(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandRingRotation;                             // 0x047C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandRingScale;                                // 0x0488(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandRing1ocation;                             // 0x0494(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandRing1Rotation;                            // 0x04A0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandRing1Scale;                               // 0x04AC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandRing2Location;                            // 0x04B8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandRing2Rotation;                            // 0x04C4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandRing2Scale;                               // 0x04D0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandRing3Location;                            // 0x04DC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandRing3Rotation;                            // 0x04E8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandRing3Scale;                               // 0x04F4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandPinkyLocation;                            // 0x0500(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandPinkyRotation;                            // 0x050C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandPinkyScale;                               // 0x0518(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandPinky1Location;                           // 0x0524(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandPinky1Rotation;                           // 0x0530(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandPinky1Scale;                              // 0x053C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandPinky2Location;                           // 0x0548(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandPinky2Rotation;                           // 0x0554(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandPinky2Scale;                              // 0x0560(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandPinky3Location;                           // 0x056C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandPinky3Rotation;                           // 0x0578(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandPinky3Scale;                              // 0x0584(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Wp0400AnimInstance">();
	}
	static class UWp0400AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWp0400AnimInstance>();
	}
};
static_assert(alignof(UWp0400AnimInstance) == 0x000010, "Wrong alignment on UWp0400AnimInstance");
static_assert(sizeof(UWp0400AnimInstance) == 0x000590, "Wrong size on UWp0400AnimInstance");
static_assert(offsetof(UWp0400AnimInstance, OwnerMeshComponent) == 0x000270, "Member 'UWp0400AnimInstance::OwnerMeshComponent' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightForeArmLocation) == 0x000278, "Member 'UWp0400AnimInstance::RightForeArmLocation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightForeArmRotation) == 0x000284, "Member 'UWp0400AnimInstance::RightForeArmRotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightForeArmScale) == 0x000290, "Member 'UWp0400AnimInstance::RightForeArmScale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightForeArmRollLocation) == 0x00029C, "Member 'UWp0400AnimInstance::RightForeArmRollLocation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightForeArmRollRotation) == 0x0002A8, "Member 'UWp0400AnimInstance::RightForeArmRollRotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightForeArmRollScale) == 0x0002B4, "Member 'UWp0400AnimInstance::RightForeArmRollScale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandLocation) == 0x0002C0, "Member 'UWp0400AnimInstance::RightHandLocation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRotation) == 0x0002CC, "Member 'UWp0400AnimInstance::RightHandRotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandScale) == 0x0002D8, "Member 'UWp0400AnimInstance::RightHandScale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandHelpLocation) == 0x0002E4, "Member 'UWp0400AnimInstance::RightHandHelpLocation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandHelpRotation) == 0x0002F0, "Member 'UWp0400AnimInstance::RightHandHelpRotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandHelpScale) == 0x0002FC, "Member 'UWp0400AnimInstance::RightHandHelpScale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandThumb1Location) == 0x000308, "Member 'UWp0400AnimInstance::RightHandThumb1Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandThumb1Rotation) == 0x000314, "Member 'UWp0400AnimInstance::RightHandThumb1Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandThumb1Scale) == 0x000320, "Member 'UWp0400AnimInstance::RightHandThumb1Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandThumb2Location) == 0x00032C, "Member 'UWp0400AnimInstance::RightHandThumb2Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandThumb2Rotation) == 0x000338, "Member 'UWp0400AnimInstance::RightHandThumb2Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandThumb2Scale) == 0x000344, "Member 'UWp0400AnimInstance::RightHandThumb2Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandThumb3Location) == 0x000350, "Member 'UWp0400AnimInstance::RightHandThumb3Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandThumb3Rotation) == 0x00035C, "Member 'UWp0400AnimInstance::RightHandThumb3Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandThumb3Scale) == 0x000368, "Member 'UWp0400AnimInstance::RightHandThumb3Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandIndex1Location) == 0x000374, "Member 'UWp0400AnimInstance::RightHandIndex1Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandIndex1Rotation) == 0x000380, "Member 'UWp0400AnimInstance::RightHandIndex1Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandIndex1Scale) == 0x00038C, "Member 'UWp0400AnimInstance::RightHandIndex1Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandIndex2Location) == 0x000398, "Member 'UWp0400AnimInstance::RightHandIndex2Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandIndex2Rotation) == 0x0003A4, "Member 'UWp0400AnimInstance::RightHandIndex2Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandIndex2Scale) == 0x0003B0, "Member 'UWp0400AnimInstance::RightHandIndex2Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandIndex3Location) == 0x0003BC, "Member 'UWp0400AnimInstance::RightHandIndex3Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandIndex3Rotation) == 0x0003C8, "Member 'UWp0400AnimInstance::RightHandIndex3Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandIndex3Scale) == 0x0003D4, "Member 'UWp0400AnimInstance::RightHandIndex3Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddleLocation) == 0x0003E0, "Member 'UWp0400AnimInstance::RightHandMiddleLocation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddleRotation) == 0x0003EC, "Member 'UWp0400AnimInstance::RightHandMiddleRotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddleScale) == 0x0003F8, "Member 'UWp0400AnimInstance::RightHandMiddleScale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddle1Location) == 0x000404, "Member 'UWp0400AnimInstance::RightHandMiddle1Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddle1Rotation) == 0x000410, "Member 'UWp0400AnimInstance::RightHandMiddle1Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddle1Scale) == 0x00041C, "Member 'UWp0400AnimInstance::RightHandMiddle1Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddle2Location) == 0x000428, "Member 'UWp0400AnimInstance::RightHandMiddle2Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddle2Rotation) == 0x000434, "Member 'UWp0400AnimInstance::RightHandMiddle2Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddle2Scale) == 0x000440, "Member 'UWp0400AnimInstance::RightHandMiddle2Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddle3Location) == 0x00044C, "Member 'UWp0400AnimInstance::RightHandMiddle3Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddle3Rotation) == 0x000458, "Member 'UWp0400AnimInstance::RightHandMiddle3Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddle3Scale) == 0x000464, "Member 'UWp0400AnimInstance::RightHandMiddle3Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRingLocation) == 0x000470, "Member 'UWp0400AnimInstance::RightHandRingLocation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRingRotation) == 0x00047C, "Member 'UWp0400AnimInstance::RightHandRingRotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRingScale) == 0x000488, "Member 'UWp0400AnimInstance::RightHandRingScale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRing1ocation) == 0x000494, "Member 'UWp0400AnimInstance::RightHandRing1ocation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRing1Rotation) == 0x0004A0, "Member 'UWp0400AnimInstance::RightHandRing1Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRing1Scale) == 0x0004AC, "Member 'UWp0400AnimInstance::RightHandRing1Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRing2Location) == 0x0004B8, "Member 'UWp0400AnimInstance::RightHandRing2Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRing2Rotation) == 0x0004C4, "Member 'UWp0400AnimInstance::RightHandRing2Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRing2Scale) == 0x0004D0, "Member 'UWp0400AnimInstance::RightHandRing2Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRing3Location) == 0x0004DC, "Member 'UWp0400AnimInstance::RightHandRing3Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRing3Rotation) == 0x0004E8, "Member 'UWp0400AnimInstance::RightHandRing3Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRing3Scale) == 0x0004F4, "Member 'UWp0400AnimInstance::RightHandRing3Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinkyLocation) == 0x000500, "Member 'UWp0400AnimInstance::RightHandPinkyLocation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinkyRotation) == 0x00050C, "Member 'UWp0400AnimInstance::RightHandPinkyRotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinkyScale) == 0x000518, "Member 'UWp0400AnimInstance::RightHandPinkyScale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinky1Location) == 0x000524, "Member 'UWp0400AnimInstance::RightHandPinky1Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinky1Rotation) == 0x000530, "Member 'UWp0400AnimInstance::RightHandPinky1Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinky1Scale) == 0x00053C, "Member 'UWp0400AnimInstance::RightHandPinky1Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinky2Location) == 0x000548, "Member 'UWp0400AnimInstance::RightHandPinky2Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinky2Rotation) == 0x000554, "Member 'UWp0400AnimInstance::RightHandPinky2Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinky2Scale) == 0x000560, "Member 'UWp0400AnimInstance::RightHandPinky2Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinky3Location) == 0x00056C, "Member 'UWp0400AnimInstance::RightHandPinky3Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinky3Rotation) == 0x000578, "Member 'UWp0400AnimInstance::RightHandPinky3Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinky3Scale) == 0x000584, "Member 'UWp0400AnimInstance::RightHandPinky3Scale' has a wrong offset!");

}

