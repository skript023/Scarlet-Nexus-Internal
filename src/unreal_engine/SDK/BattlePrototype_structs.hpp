#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BattlePrototype

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "SlateCore_structs.hpp"


namespace SDK
{

// Enum BattlePrototype.ERSGamepadInputName
// NumValues: 0x0048
enum class ERSGamepadInputName : uint8
{
	R1                                       = 0,
	R2                                       = 1,
	R3                                       = 2,
	L1                                       = 3,
	L2                                       = 4,
	L3                                       = 5,
	RUP                                      = 6,
	RDOWN                                    = 7,
	RLEFT                                    = 8,
	RRIGHT                                   = 9,
	DPAD_UP                                  = 10,
	DPAD_DOWN                                = 11,
	DPAD_LEFT                                = 12,
	DPAD_RIGHT                               = 13,
	DPADEMU_UP                               = 14,
	DPADEMU_DOWN                             = 15,
	DPADEMU_LEFT                             = 16,
	DPADEMU_RIGHT                            = 17,
	RSTICKX                                  = 18,
	RSTICKY                                  = 19,
	LSTICKX                                  = 20,
	LSTICKY                                  = 21,
	SELECT                                   = 22,
	START                                    = 23,
	DECIDE                                   = 24,
	CANCEL                                   = 25,
	MOUSE_LEFT                               = 26,
	MOUSE_RIGHT                              = 27,
	MOUSE_MIDDLE                             = 28,
	MOUSE_WHEEL_UP                           = 29,
	MOUSE_WHEEL_DOWN                         = 30,
	MOVE_FORWARD                             = 31,
	MOVE_BACKWARD                            = 32,
	MOVE_LEFT                                = 33,
	MOVE_RIGHT                               = 34,
	ACTION                                   = 35,
	ACTION2                                  = 36,
	STEP_DASH                                = 37,
	WEAPON_ATTACK                            = 38,
	WEAPON_ATTACK_SUB                        = 39,
	JUMP                                     = 40,
	PSYCHIC                                  = 41,
	PSYCHIC_SPECIAL                          = 42,
	PSYCHICFIELD                             = 43,
	BRAINFIELD                               = 44,
	CAMERA_RESET                             = 45,
	LOCK_ON                                  = 46,
	LOCK_ON_SWITCH_L                         = 47,
	LOCK_ON_SWITCH_R                         = 48,
	ASSAULT_VISION                           = 49,
	SASMENU_PAGESWITCH                       = 50,
	SASMENU_OPENCLOSE                        = 51,
	SAS_ACTION_U                             = 52,
	SAS_ACTION_L                             = 53,
	SAS_ACTION_R                             = 54,
	SAS_ACTION_D                             = 55,
	STOP_SAS                                 = 56,
	CVMENU_OPENCLOSE                         = 57,
	CV_ACTION_U                              = 58,
	CV_ACTION_L                              = 59,
	CV_ACTION_R                              = 60,
	CV_ACTION_D                              = 61,
	ITEM_SELECT_L                            = 62,
	ITEM_SELECT_R                            = 63,
	ITEM_USE                                 = 64,
	OPEN_MENU                                = 65,
	OPEN_DETAILMAP                           = 66,
	OPEN_WORLDMAP                            = 67,
	OPEN_BRAIN_MESSAGE                       = 68,
	NONE                                     = 69,
	LAST_INDEX                               = 70,
	ERSGamepadInputName_MAX                  = 71,
};

// Enum BattlePrototype.ERSGamepadLayoutType
// NumValues: 0x0006
enum class ERSGamepadLayoutType : uint8
{
	RAW                                      = 0,
	UI                                       = 1,
	BATTLE                                   = 2,
	BATTLE_EVENT                             = 3,
	LAST_INDEX                               = 4,
	ERSGamepadLayoutType_MAX                 = 5,
};

// Enum BattlePrototype.E_SASKindNative
// NumValues: 0x000E
enum class E_SASKindNative : uint8
{
	Fire                                     = 0,
	Metal                                    = 1,
	SeeThrough                               = 2,
	Telepo                                   = 3,
	Stealth                                  = 4,
	Electric                                 = 5,
	Copy                                     = 6,
	Accelerator                              = 7,
	Psychic_ch0100                           = 8,
	Psychic_ch0200                           = 9,
	Invalid                                  = 10,
	Num                                      = 11,
	ValidNum                                 = 10,
	E_MAX                                    = 12,
};

// Enum BattlePrototype.EPlayerID
// NumValues: 0x001B
enum class EPlayerID : uint8
{
	Invalid                                  = 0,
	Ch0100                                   = 1,
	Ch0200                                   = 2,
	Ch0300                                   = 3,
	Ch0400                                   = 4,
	Ch0500                                   = 5,
	Ch0600                                   = 6,
	Ch0700                                   = 7,
	Ch0800                                   = 8,
	Ch0900                                   = 9,
	Ch1000                                   = 10,
	Np1100                                   = 11,
	Em8000                                   = 12,
	Em8010                                   = 13,
	Em8100                                   = 14,
	Em8200                                   = 15,
	Em8210                                   = 16,
	Em8290                                   = 17,
	Em8291                                   = 18,
	Np2100                                   = 19,
	Ch0900_Fort                              = 20,
	Ch0900_FullCopy                          = 21,
	Em8010_ph07                              = 22,
	Em8010_ph09                              = 23,
	Max                                      = 24,
	Start                                    = 1,
	FriendMax                                = 11,
};

// Enum BattlePrototype.ERenderTargetCustomFormat
// NumValues: 0x0003
enum class ERenderTargetCustomFormat : uint8
{
	RGBA8                                    = 0,
	RGBA16f                                  = 1,
	ERenderTargetCustomFormat_MAX            = 2,
};

// Enum BattlePrototype.EUIViewPrio
// NumValues: 0x003B
enum class EUIViewPrio : uint8
{
	None                                     = 255,
	ActionIcon_Etc                           = 0,
	ActionIcon_SubQuest                      = 1,
	ActionIcon_Resurrection                  = 2,
	ActionIcon_MainTalk                      = 3,
	ActionIcon_Prio                          = 4,
	AreaNextName                             = 5,
	DiscoverIcon                             = 6,
	WeightGauge_Normal                       = 7,
	WeightGauge_Strength                     = 8,
	WeightGauge_Prio                         = 9,
	Fade1                                    = 10,
	Movie                                    = 11,
	Telop                                    = 12,
	MapGimmick                               = 13,
	MapGimmick_Prio                          = 14,
	EnemyVitality                            = 15,
	Crashtrigger                             = 16,
	StaffRoll                                = 17,
	GameOver                                 = 18,
	MessageLog                               = 19,
	NoticeMessage                            = 20,
	BrainTalk                                = 21,
	TutoOperation                            = 22,
	BattleControl                            = 23,
	Code                                     = 24,
	Keyword                                  = 25,
	TitleLogoMenu                            = 26,
	TitleMenu                                = 27,
	CharaSelectMenu                          = 28,
	TitleCrossSave                           = 29,
	MainMenu                                 = 30,
	DetailMapMenu                            = 31,
	WorldMapMenu                             = 32,
	ShopMenu                                 = 33,
	ShopWeaponMenu                           = 34,
	ShopEnemyBooks                           = 35,
	Present                                  = 36,
	PresentNext                              = 37,
	SaveLoadMenu                             = 38,
	NoticeQuest                              = 39,
	AutoSave                                 = 40,
	HelpTutoMenu                             = 41,
	ScarletLogo                              = 42,
	LicensePopMenu                           = 43,
	FirstLanguagePopMenu                     = 44,
	FirstConfirmPopMenu                      = 45,
	Fade2                                    = 46,
	LoadingLow                               = 47,
	LoadingHigh                              = 48,
	SystemMessage                            = 49,
	TitleMovie                               = 50,
	TelopEventTitle                          = 51,
	FadeEventTitle                           = 52,
	GeneralMenu                              = 53,
	SystemNoticeMenu                         = 54,
	LetterBoxMask                            = 55,
	Num                                      = 56,
	EUIViewPrio_MAX                          = 256,
};

// Enum BattlePrototype.EUIInputType
// NumValues: 0x0005
enum class EUIInputType : uint8
{
	On                                       = 0,
	Off                                      = 1,
	Press                                    = 2,
	Repeat                                   = 3,
	EUIInputType_MAX                         = 4,
};

// Enum BattlePrototype.EUIInputButton
// NumValues: 0x0021
enum class EUIInputButton : uint8
{
	L_Up                                     = 0,
	L_Down                                   = 1,
	L_Left                                   = 2,
	L_Right                                  = 3,
	R_Up                                     = 4,
	R_Down                                   = 5,
	R_Left                                   = 6,
	R_Right                                  = 7,
	L1                                       = 8,
	R1                                       = 9,
	L2                                       = 10,
	R2                                       = 11,
	L3                                       = 12,
	R3                                       = 13,
	Start                                    = 14,
	Select                                   = 15,
	Up                                       = 16,
	Down                                     = 17,
	Left                                     = 18,
	Right                                    = 19,
	PadUp                                    = 20,
	PadDown                                  = 21,
	PadLeft                                  = 22,
	PadRight                                 = 23,
	Decide                                   = 24,
	Cancel                                   = 25,
	MouseL                                   = 26,
	MouseR                                   = 27,
	MouseM                                   = 28,
	MouseWUp                                 = 29,
	MouseWDown                               = 30,
	Num                                      = 31,
	EUIInputButton_MAX                       = 32,
};

// Enum BattlePrototype.EUI_SE
// NumValues: 0x0053
enum class EUI_SE : uint8
{
	Sys_menu_open                            = 0,
	Sys_menu_close                           = 1,
	Sys_main_decide                          = 2,
	Sys_main_cancel                          = 3,
	Sys_main_cursor                          = 4,
	Sys_main_tab                             = 5,
	Sys_main_beep                            = 6,
	Sys_sub_decide                           = 7,
	Sys_sub_cursor                           = 8,
	Sys_sub_tab                              = 9,
	Sys_member_decide                        = 10,
	Sys_tactics_decide                       = 11,
	Sys_equip_weapon                         = 12,
	Sys_equip_accessory                      = 13,
	Sys_equip_costume                        = 14,
	Sys_equip_attachment                     = 15,
	Sys_equip_remove                         = 16,
	Sys_map_open                             = 17,
	Sys_map_close                            = 18,
	Sys_map_position                         = 19,
	Sys_map_zoom                             = 20,
	Sys_map_area                             = 21,
	Sys_map_block                            = 22,
	Sys_worldmap_open                        = 23,
	Sys_worldmap_close                       = 24,
	Sys_worldmap_cursor                      = 25,
	Sys_worldmap_area                        = 26,
	Sys_worldmap_area_move                   = 27,
	Sys_worldmap_window_open                 = 28,
	Sys_worldmap_window_close                = 29,
	Sys_worldmap_beep                        = 30,
	Sys_shop_open                            = 31,
	Sys_shop_number                          = 32,
	Sys_shop_buy                             = 33,
	Sys_shop_warning                         = 34,
	Sys_shop_close                           = 35,
	Sys_shop_beep                            = 36,
	Sys_braintalk_start                      = 37,
	Sys_braintalk_page                       = 38,
	Sys_braintalk_end                        = 39,
	Sys_brain_message                        = 40,
	bt_icon_discover                         = 41,
	bt_icon_undiscover                       = 42,
	bt_icon_caution                          = 43,
	bt_icon_away                             = 44,
	Sys_bm_cursor                            = 45,
	Sys_bm_scroll                            = 46,
	Sys_bm_send                              = 47,
	Sys_chara_select_start                   = 48,
	Sys_chara_select_zoom                    = 49,
	Sys_cmn_window_close                     = 50,
	Sys_cmn_window_open                      = 51,
	Sys_event_message                        = 52,
	Sys_field_destination                    = 53,
	Sys_gameover                             = 54,
	Sys_kizuna_levelup                       = 55,
	Sys_license_open                         = 56,
	Sys_new_game_start                       = 57,
	Sys_psy_gauge_low                        = 58,
	Sys_sas_connect                          = 59,
	Sys_sas_remove                           = 60,
	Sys_title_first                          = 61,
	Sys_window_blue_close                    = 62,
	Sys_window_blue_open                     = 63,
	Sys_window_blue_page                     = 64,
	Sys_brainmap_open                        = 65,
	Sys_brainmap_cursor                      = 66,
	Sys_brainmap_beep                        = 67,
	Sys_brainmap_push                        = 68,
	Sys_press_any_button                     = 69,
	Sys_push_menu                            = 70,
	Sys_push_map                             = 71,
	Sys_map_icon_close                       = 72,
	Sys_map_icon_open                        = 73,
	Sys_map_zoom_out                         = 74,
	Sys_tips_close                           = 75,
	Sys_tips_open                            = 76,
	Sys_quest_complete                       = 77,
	Sys_subquest_complete                    = 78,
	Sys_mini_window                          = 79,
	bt_brain_recovery                        = 80,
	Num                                      = 81,
	EUI_MAX                                  = 82,
};

// Enum BattlePrototype.EUIMouseHitType
// NumValues: 0x0003
enum class EUIMouseHitType : uint8
{
	Rectangle                                = 0,
	Circle                                   = 1,
	EUIMouseHitType_MAX                      = 2,
};

// Enum BattlePrototype.EBattleSituationType
// NumValues: 0x0004
enum class EBattleSituationType : uint8
{
	Normal                                   = 0,
	Superiority                              = 1,
	Inferiority                              = 2,
	EBattleSituationType_MAX                 = 3,
};

// Enum BattlePrototype.EHCBadState
// NumValues: 0x0007
enum class EHCBadState : uint8
{
	State_None                               = 0,
	State_Flame                              = 1,
	State_Electric                           = 2,
	State_Flooded                            = 3,
	State_Oil                                = 4,
	State_Confusion                          = 5,
	State_MAX                                = 6,
};

// Enum BattlePrototype.EChangeAreaStatus
// NumValues: 0x000B
enum class EChangeAreaStatus : uint8
{
	Invalid                                  = 0,
	RequestedAreaChange                      = 1,
	StartDynamicLevelUnload                  = 2,
	StartLBPortalLevelLoad                   = 3,
	StartLevelsLoad                          = 4,
	StartLevelVisibleOn                      = 5,
	StartEventAssetLoad                      = 6,
	PreStartGame                             = 7,
	InScene                                  = 8,
	Num                                      = 9,
	EChangeAreaStatus_MAX                    = 10,
};

// Enum BattlePrototype.EUINoticeMessageCallType
// NumValues: 0x0006
enum class EUINoticeMessageCallType : uint8
{
	BrainMessage                             = 0,
	SubQuest_NotOrder                        = 1,
	SubQuest_CanReport                       = 2,
	SubQuest_ToImprogressFromCanReport       = 3,
	TradeItem                                = 4,
	EUINoticeMessageCallType_MAX             = 5,
};

// Enum BattlePrototype.PlayerAnimKind
// NumValues: 0x0026
enum class EPlayerAnimKind : uint8
{
	IdleWalkRun                              = 0,
	BoringIdle                               = 1,
	Damage                                   = 2,
	Dead                                     = 3,
	Step                                     = 4,
	Fall                                     = 5,
	Land                                     = 6,
	Attack                                   = 7,
	StartBattle                              = 8,
	EndBattle                                = 9,
	Jump                                     = 10,
	AirJump                                  = 11,
	Recover                                  = 12,
	Psychic                                  = 13,
	Sprint                                   = 14,
	Brake                                    = 15,
	JumpStepIn                               = 16,
	StepEnd                                  = 17,
	BlowFall                                 = 18,
	BlowLanding                              = 19,
	Down                                     = 20,
	WakeUp                                   = 21,
	UseItem                                  = 22,
	StartSprint                              = 23,
	BrainCrash                               = 24,
	Drive                                    = 25,
	ResurrectBegin                           = 26,
	Resurrect                                = 27,
	ResurrectEnd                             = 28,
	Revive                                   = 29,
	SprintTurnBack                           = 30,
	LaunchFall                               = 31,
	Event                                    = 32,
	TalkTurn                                 = 33,
	SasLink                                  = 34,
	NumKind                                  = 35,
	Invalid                                  = 255,
	PlayerAnimKind_MAX                       = 256,
};

// Enum BattlePrototype.PlayerWalkRunStateKind
// NumValues: 0x0006
enum class EPlayerWalkRunStateKind : uint8
{
	Idle                                     = 0,
	Start                                    = 1,
	Loop                                     = 2,
	End                                      = 3,
	Turn                                     = 4,
	PlayerWalkRunStateKind_MAX               = 5,
};

// Enum BattlePrototype.RSAttackInputKind
// NumValues: 0x005D
enum class ERSAttackInputKind : uint8
{
	Attack1                                  = 0,
	LongPressAttack1                         = 1,
	AirAttack                                = 2,
	FallAttack                               = 3,
	LaunchAttack                             = 4,
	Rush                                     = 5,
	LongPressRush                            = 6,
	AirRush                                  = 7,
	BackStepAttack                           = 8,
	BackStepAirAttack                        = 9,
	JustDodgeAttack                          = 10,
	JustDodgeAirAttack                       = 11,
	JustDodgePsychic                         = 12,
	TelepoApproach                           = 13,
	TelepoAttack                             = 14,
	TelepoAttack2                            = 15,
	AssassinAttack                           = 16,
	PsychicComboLV1                          = 17,
	PsychicComboLV2                          = 18,
	PsychicComboLV3                          = 19,
	PsychicComboLV4                          = 20,
	PsychicToWeaponLV1                       = 21,
	PsychicToWeaponLV2                       = 22,
	PsychicToWeaponLV3                       = 23,
	PsychicToWeaponLV4                       = 24,
	PsychicToWeaponLounch                    = 25,
	FlyingPsychic                            = 26,
	FlyingPsychicLeft                        = 27,
	FlyingPsychicRight                       = 28,
	FlyingPsychicComboLV1                    = 29,
	FlyingPsychicComboLV2                    = 30,
	FlyingPsychicToWeaponLV1                 = 31,
	FlyingPsychicToWeaponLV2                 = 32,
	PsychicUnique                            = 33,
	PsychicField                             = 34,
	SASHologramCh0100                        = 35,
	SASHologramCh0200                        = 36,
	SASHologramCh0300                        = 37,
	SASHologramCh0400                        = 38,
	SASHologramCh0500                        = 39,
	SASHologramCh0600                        = 40,
	SASHologramCh0700                        = 41,
	SASHologramCh0800                        = 42,
	SASHologramCh0900                        = 43,
	SASHologramCh1000                        = 44,
	CombinationVisionCh0100                  = 45,
	CombinationVisionCh0200                  = 46,
	CombinationVisionCh0300                  = 47,
	CombinationVisionCh0400                  = 48,
	CombinationVisionCh0500                  = 49,
	CombinationVisionCh0600                  = 50,
	CombinationVisionCh0700                  = 51,
	CombinationVisionCh0800                  = 52,
	CombinationVisionCh0900                  = 53,
	CombinationVisionCh1000                  = 54,
	BrainFieldAttack                         = 55,
	BrainFieldChaseAttack                    = 56,
	BrainFieldFallAttack                     = 57,
	BrainFieldBackStepAttack1                = 58,
	BrainFieldBackStepAttack2                = 59,
	BrainFieldBackStepAttack3                = 60,
	BrainFieldChargeAttack                   = 61,
	BrainFieldChargeAttack1                  = 62,
	BrainFieldChargeAttack2                  = 63,
	BrainFieldChargeAttack3                  = 64,
	BrainFieldFinishBlow                     = 65,
	BrainFieldThrow                          = 66,
	BrainFieldAirThrow                       = 67,
	ENPC_DirectShot                          = 68,
	NpcAttack1                               = 69,
	NpcAttack2                               = 70,
	NpcAttack3                               = 71,
	NpcAttack4                               = 72,
	NpcAttack5                               = 73,
	NpcAttack6                               = 74,
	NpcAttack7                               = 75,
	NpcAttack8                               = 76,
	NpcAttack9                               = 77,
	NpcAttack10                              = 78,
	NpcAttack11                              = 79,
	NpcAttack12                              = 80,
	NpcAttack13                              = 81,
	NpcAttack14                              = 82,
	NpcAttack15                              = 83,
	NpcIntercept                             = 84,
	NpcAttackChainDown                       = 85,
	NpcAttackChainLaunch                     = 86,
	NpcRush1                                 = 87,
	NpcCautionAttack                         = 88,
	EnpcDrive                                = 89,
	Invalid                                  = 90,
	NumOfEnum                                = 90,
	RSAttackInputKind_MAX                    = 91,
};

// Enum BattlePrototype.EBrainFieldEndType
// NumValues: 0x0007
enum class EBrainFieldEndType : uint8
{
	Normal                                   = 0,
	ReceiveBrainCrash                        = 1,
	EnemyBrainField                          = 2,
	GameOver                                 = 3,
	ReceiveBrainCrash_Override               = 4,
	Revive                                   = 5,
	Max                                      = 6,
};

// Enum BattlePrototype.ENotifyDriveEvent
// NumValues: 0x0010
enum class ENotifyDriveEvent : uint8
{
	SAS                                      = 0,
	JustDodge                                = 1,
	HitPsychicCombo                          = 2,
	Defeated                                 = 3,
	DefeatedBrainCrash                       = 4,
	DefeatedNpc                              = 5,
	TakeDamage                               = 6,
	WeaponHitCH0100                          = 7,
	WeaponHitCH0200                          = 8,
	PsychicAttack                            = 9,
	PsychicUnique                            = 10,
	HologramAttack                           = 11,
	BeginBrainField                          = 12,
	EndBrainField                            = 13,
	HitCombinationVision                     = 14,
	ENotifyDriveEvent_MAX                    = 15,
};

// Enum BattlePrototype.ECharacterEventType
// NumValues: 0x0006
enum class ECharacterEventType : uint8
{
	SpawnEnemyGroup                          = 0,
	KillEnemyGroup                           = 1,
	SpawnEnemySubGroup                       = 2,
	KillEnemySubGroup                        = 3,
	Num                                      = 4,
	ECharacterEventType_MAX                  = 5,
};

// Enum BattlePrototype.EPlayerBrainFieldState
// NumValues: 0x000A
enum class EPlayerBrainFieldState : uint8
{
	PlayAble                                 = 0,
	WarningWait                              = 1,
	Warning                                  = 2,
	TimeUpWait                               = 3,
	TimeUp                                   = 4,
	Help                                     = 5,
	GameOverWait                             = 6,
	GameOver                                 = 7,
	End                                      = 8,
	EPlayerBrainFieldState_MAX               = 9,
};

// Enum BattlePrototype.EPlayerBrainFieldDanger
// NumValues: 0x0004
enum class EPlayerBrainFieldDanger : uint8
{
	LV1                                      = 0,
	LV2                                      = 1,
	LV3                                      = 2,
	EPlayerBrainFieldDanger_MAX              = 3,
};

// Enum BattlePrototype.EPlayerInputSASReadyType
// NumValues: 0x0004
enum class EPlayerInputSASReadyType : uint8
{
	None                                     = 0,
	SAS                                      = 1,
	CombinationVision                        = 2,
	EPlayerInputSASReadyType_MAX             = 3,
};

// Enum BattlePrototype.E_SASButton
// NumValues: 0x000D
enum class E_SASButton : uint8
{
	SAS_BUTTON1                              = 0,
	SAS_BUTTON2                              = 1,
	SAS_BUTTON3                              = 2,
	SAS_BUTTON4                              = 3,
	SAS_BUTTON5                              = 4,
	SAS_BUTTON6                              = 5,
	SAS_BUTTON7                              = 6,
	SAS_BUTTON8                              = 7,
	SAS_BUTTON9                              = 8,
	SAS_BUTTON10                             = 9,
	SAS_BUTTON11                             = 10,
	SAS_BUTTON12                             = 11,
	SAS_MAX                                  = 12,
};

// Enum BattlePrototype.ESASEquipStatus
// NumValues: 0x0004
enum class ESASEquipStatus : uint8
{
	LinkAble                                 = 0,
	NotLink                                  = 1,
	RemoveParty                              = 2,
	ESASEquipStatus_MAX                      = 3,
};

// Enum BattlePrototype.HCHitEffectDir
// NumValues: 0x0004
enum class EHCHitEffectDir : uint8
{
	Default                                  = 0,
	AttackDir                                = 1,
	Fix                                      = 2,
	HCHitEffectDir_MAX                       = 3,
};

// Enum BattlePrototype.HCHitEffectType
// NumValues: 0x0004
enum class EHCHitEffectType : uint8
{
	Default                                  = 0,
	Slashed                                  = 1,
	NoEffect                                 = 2,
	HCHitEffectType_MAX                      = 3,
};

// Enum BattlePrototype.HCRestictedHitStopType
// NumValues: 0x0007
enum class EHCRestictedHitStopType : uint8
{
	None                                     = 0,
	Short                                    = 1,
	Middle                                   = 2,
	Large                                    = 3,
	XLarge                                   = 4,
	XXLarge                                  = 5,
	HCRestictedHitStopType_MAX               = 6,
};

// Enum BattlePrototype.HCHitStopCauseType
// NumValues: 0x0006
enum class EHCHitStopCauseType : uint8
{
	Default                                  = 0,
	None                                     = 1,
	PsychicObjPullAttack                     = 2,
	BrainFieldPsychicObjAttack               = 3,
	UniqueObjHitInvincible                   = 4,
	HCHitStopCauseType_MAX                   = 5,
};

// Enum BattlePrototype.HCHitControllerVibrationType
// NumValues: 0x0007
enum class EHCHitControllerVibrationType : uint8
{
	None                                     = 0,
	Shake_SS                                 = 1,
	Shake_S                                  = 2,
	Shake_M                                  = 3,
	Shake_L                                  = 4,
	Shake_XL                                 = 5,
	HCHitControllerVibrationType_MAX         = 6,
};

// Enum BattlePrototype.HCHitCameraShakeType
// NumValues: 0x0007
enum class EHCHitCameraShakeType : uint8
{
	Default                                  = 0,
	Shake_S                                  = 1,
	Shake_M                                  = 2,
	Shake_L                                  = 3,
	Shake_Object                             = 4,
	None                                     = 5,
	HCHitCameraShakeType_MAX                 = 6,
};

// Enum BattlePrototype.HCDamageReactionDirType
// NumValues: 0x0005
enum class EHCDamageReactionDirType : uint8
{
	Default                                  = 0,
	AttackDir                                = 1,
	AttackOwner                              = 2,
	FixDir                                   = 3,
	HCDamageReactionDirType_MAX              = 4,
};

// Enum BattlePrototype.HCSkillExtraType
// NumValues: 0x0061
enum class EHCSkillExtraType : uint8
{
	Default                                  = 0,
	NoDamageReaction                         = 1,
	PsychicObjectCombo                       = 2,
	PsychicObjectComboFinish                 = 3,
	ExPsychic                                = 4,
	PsychicObjectIntercept                   = 5,
	AllThrow                                 = 6,
	EffectUseHitNormal                       = 7,
	EffectUseHitInverseNormal                = 8,
	EffectUseAttackDir                       = 9,
	ReinforceFire                            = 10,
	ReinforceElectric                        = 11,
	IgnoreWeakPoint                          = 12,
	InterceptAble                            = 13,
	InterceptAttack                          = 14,
	BreakPsychicObjectShield                 = 15,
	StealthBoostChargeAttack                 = 16,
	CharacterForceBlow                       = 17,
	NoDamageDisplay                          = 18,
	HitEffectSpawnActor                      = 19,
	HitEffectSpawnSpine                      = 20,
	PenetrateArmor                           = 21,
	NoDead                                   = 22,
	PsychicObjectAttack                      = 23,
	PsychicObjectUnique                      = 24,
	DelayDeath                               = 25,
	ForceWince                               = 26,
	IgnoreAccelerator                        = 27,
	FlyFinishAttack                          = 28,
	LaunchTriggerAttack                      = 29,
	DisableCoverDamage                       = 30,
	ReactionLTriggerAttack                   = 31,
	DownTriggerAttack                        = 32,
	BlowTriggerAttack                        = 33,
	LargeBlow                                = 34,
	ForceDown                                = 35,
	WeakEnemyInstantKill                     = 36,
	OnGroundOnly                             = 37,
	EnpcSpTriggerAttack                      = 38,
	EnpcSpDamageAttack                       = 39,
	PlayerAIThreatAttack                     = 40,
	SASCopy                                  = 41,
	IgnoreJustDodge                          = 42,
	ForceDownLoop                            = 43,
	ForceReactionL                           = 44,
	ForceLaunch                              = 45,
	LaunchLTriggerAttack                     = 46,
	ForceLaunchL                             = 47,
	AddDamageReactionL                       = 48,
	NoMoveReactionS                          = 49,
	IgnoreArmor                              = 50,
	OnlyTargetDelayDeath                     = 51,
	UniqueLastAttack                         = 52,
	BrainFieldPsychicUp                      = 53,
	BrainFieldPsychicLeft                    = 54,
	BrainFieldPsychicRight                   = 55,
	CheckPlayerWince                         = 56,
	SASTelepoAttack                          = 57,
	SASStealthAttack                         = 58,
	OnlyFloatingLaunchTriggerAttack          = 59,
	AssassinAttack                           = 60,
	ChaseAttack                              = 61,
	JustDodgeAttack                          = 62,
	JustDodgeDown                            = 63,
	JustDodgePsychic                         = 64,
	NoScar                                   = 65,
	BrainCrash                               = 66,
	PsychicFieldAttack                       = 67,
	ChargeAttack                             = 68,
	MapGimmickLaserTrap                      = 69,
	PsychicObjectDropAttack                  = 70,
	StealthCritical                          = 71,
	OutEffectiveRange                        = 72,
	SecondHit                                = 73,
	IgnoreNoDamage                           = 74,
	PsychicObjectUniqueReaction              = 75,
	FallAttack                               = 76,
	DamageReactionAfterDead                  = 77,
	ArmorBreak                               = 78,
	StartHitSlowOnce                         = 79,
	IgnorePlayerSuperArmor                   = 80,
	SpecialKaren                             = 81,
	ArmorDamageUp                            = 82,
	NoRandomDamage                           = 83,
	IgnoreSasMetal                           = 84,
	AttractTarget                            = 85,
	CombinationVision                        = 86,
	ContinueSasStealth                       = 87,
	NoBattleBonus                            = 88,
	HitWeakPoint                             = 89,
	ThrustAway                               = 90,
	CircleMovingAttack                       = 91,
	BackStepAttack                           = 92,
	IgnoreDamageCollisionAngle               = 93,
	ObstacleHitCheckFromAttackOwner          = 94,
	AssaultVision                            = 95,
	HCSkillExtraType_MAX                     = 96,
};

// Enum BattlePrototype.HCSkillEnemyHitEffect
// NumValues: 0x0044
enum class EHCSkillEnemyHitEffect : uint8
{
	NoEffect                                 = 0,
	Default                                  = 1,
	AttackHit_Small                          = 2,
	CommonBullet                             = 3,
	CommonBlowSmall                          = 4,
	CommonBlowLarge                          = 5,
	CommonSlashSmall                         = 6,
	CommonSlashLarge                         = 7,
	CommonElectric                           = 8,
	CommonFire                               = 9,
	CommonOilSmall                           = 10,
	CommonOilLarge                           = 11,
	CommonWaterSmall                         = 12,
	CommonWaterLarge                         = 13,
	Em0110_ShockWave                         = 14,
	Em0120_DazzleShot                        = 15,
	Em0120_Shout                             = 16,
	Em0200_Petal                             = 17,
	Em420_FlameShot                          = 18,
	Em0700_MachineGun                        = 19,
	Em0710_Missile                           = 20,
	Em0710_Fire                              = 21,
	Em0710_Elec                              = 22,
	Em0720_Fire                              = 23,
	Em0720_Elec                              = 24,
	Em0800_Laser                             = 25,
	Em0800_Breath                            = 26,
	Em0810_FireBreath                        = 27,
	Em1000_AttackShot                        = 28,
	Np1100_Chakram                           = 29,
	Em1200_Insect                            = 30,
	Em1400_ConfusionBreath                   = 31,
	Em1400_NoseFencing                       = 32,
	Em1400_ShieldSpin                        = 33,
	Em1400_WaterBarrier                      = 34,
	Em8000_Sonic                             = 35,
	Em8000_ShockWave                         = 36,
	Em8010_FullSwing                         = 37,
	Em8010_FullSwing_Shockwave               = 38,
	Em8010_Pipe                              = 39,
	Em8200_HomingElec                        = 40,
	Em8200_PillarIce                         = 41,
	Em8300_ShockWave                         = 42,
	Em8300_MaskedManShockWave                = 43,
	Em8316_Chakram                           = 44,
	Em8317_Tornado                           = 45,
	Em8317_Fall                              = 46,
	Em8317_Shockwave                         = 47,
	Em8318_Appear                            = 48,
	Em8319_Appear                            = 49,
	Em8319_Elec                              = 50,
	Np0300_Shot                              = 51,
	Em1210_Ice                               = 52,
	Em1200_Shout                             = 53,
	Em1500_Beam                              = 54,
	Em1301_Bomb                              = 55,
	Em1301_Rifle                             = 56,
	Em1301_Rush                              = 57,
	Em1300_Shutter                           = 58,
	Em1100_Drainage                          = 59,
	Em1120_Oil                               = 60,
	ForceNpcPlayer                           = 61,
	CommonOilLoop                            = 62,
	CommonWaterLoop                          = 63,
	ForceCh0100                              = 64,
	ForceCh0200                              = 65,
	Num                                      = 66,
	HCSkillEnemyHitEffect_MAX                = 67,
};

// Enum BattlePrototype.HCSkillAttribute
// NumValues: 0x0007
enum class EHCSkillAttribute : uint8
{
	Default                                  = 0,
	Flame                                    = 1,
	Electric                                 = 2,
	Water                                    = 3,
	Oil                                      = 4,
	Confusion                                = 5,
	HCSkillAttribute_MAX                     = 6,
};

// Enum BattlePrototype.HCSkillType
// NumValues: 0x0018
enum class EHCSkillType : uint8
{
	Default                                  = 0,
	Slash                                    = 1,
	ThrowingKnife                            = 2,
	ThrowingKnifeOutRange                    = 3,
	Torch                                    = 4,
	Hammer                                   = 5,
	Gun                                      = 6,
	Glove                                    = 7,
	Crossbow                                 = 8,
	Chainsaw                                 = 9,
	Stick                                    = 10,
	Knife                                    = 11,
	PsychicObjectStart                       = 12,
	Throw                                    = 12,
	Drop                                     = 13,
	Brandish                                 = 14,
	Unique                                   = 15,
	UniqueWater                              = 16,
	PsychicObjectEnd                         = 16,
	EnemyHorn                                = 17,
	EnemyCoatingPunch                        = 18,
	EnpcSpTrigger                            = 19,
	Num                                      = 20,
	HCSkillType_MAX                          = 21,
};

// Enum BattlePrototype.HCSkillMaterial
// NumValues: 0x0004
enum class EHCSkillMaterial : uint8
{
	Default                                  = 0,
	Iron                                     = 1,
	Wood                                     = 2,
	HCSkillMaterial_MAX                      = 3,
};

// Enum BattlePrototype.HCSkillAttackType
// NumValues: 0x0007
enum class EHCSkillAttackType : uint8
{
	Default                                  = 0,
	Physics                                  = 1,
	Psychic                                  = 2,
	Obj                                      = 3,
	Etc                                      = 4,
	MapGimmick                               = 5,
	HCSkillAttackType_MAX                    = 6,
};

// Enum BattlePrototype.HCCollisionHitTeam
// NumValues: 0x0004
enum class EHCCollisionHitTeam : uint8
{
	NotFriend                                = 0,
	Friend                                   = 1,
	Both                                     = 2,
	HCCollisionHitTeam_MAX                   = 3,
};

// Enum BattlePrototype.HCCollisionValueKind
// NumValues: 0x0002
enum class EHCCollisionValueKind : uint8
{
	CpyPower                                 = 0,
	HCCollisionValueKind_MAX                 = 1,
};

// Enum BattlePrototype.ConditionKind
// NumValues: 0x0007
enum class EConditionKind : uint8
{
	Flames                                   = 0,
	Ice                                      = 1,
	Tumble                                   = 2,
	DamageFly                                = 3,
	Faint                                    = 4,
	Destroy                                  = 5,
	ConditionKind_MAX                        = 6,
};

// Enum BattlePrototype.HCElementKind
// NumValues: 0x0007
enum class EHCElementKind : uint8
{
	Fire                                     = 0,
	Water                                    = 1,
	Wind                                     = 2,
	Earth                                    = 3,
	Light                                    = 4,
	Dark                                     = 5,
	HCElementKind_MAX                        = 6,
};

// Enum BattlePrototype.HCDamageKind
// NumValues: 0x0003
enum class EHCDamageKind : uint8
{
	DamageLight                              = 0,
	DamageHeavy                              = 1,
	HCDamageKind_MAX                         = 2,
};

// Enum BattlePrototype.DamagePointKind
// NumValues: 0x0003
enum class EDamagePointKind : uint8
{
	Default                                  = 0,
	Enemy                                    = 1,
	DamagePointKind_MAX                      = 2,
};

// Enum BattlePrototype.EDebuggingPage
// NumValues: 0x000C
enum class EDebuggingPage : uint8
{
	System                                   = 0,
	UI                                       = 1,
	Battle                                   = 2,
	Player                                   = 3,
	Party                                    = 4,
	Enemy                                    = 5,
	Scene                                    = 6,
	Render                                   = 7,
	Sound                                    = 8,
	Event                                    = 9,
	Ajito                                    = 10,
	Max                                      = 11,
};

// Enum BattlePrototype.EOutgameDebuggingPage
// NumValues: 0x0003
enum class EOutgameDebuggingPage : uint8
{
	System                                   = 0,
	UI                                       = 1,
	Max                                      = 2,
};

// Enum BattlePrototype.EContentsOpening
// NumValues: 0x0019
enum class EContentsOpening : uint8
{
	Invalid                                  = 0,
	BattleItem                               = 1,
	SAS                                      = 2,
	Braincrash                               = 3,
	BrainField                               = 4,
	BrainFieldClose                          = 5,
	Drive                                    = 6,
	SASMenu                                  = 7,
	BrainMapMenu                             = 8,
	BrainMessageSubTab                       = 9,
	WishListSubTab                           = 10,
	MainMenu                                 = 11,
	WorldMap                                 = 12,
	DetailMap                                = 13,
	Psychic                                  = 14,
	WeaponAttack                             = 15,
	PsychicCombo                             = 16,
	PsychicToWeaponAttack                    = 17,
	ItemTrade                                = 18,
	SubquestSubTab                           = 19,
	BondsEpisodeSubTab                       = 20,
	TeamBondLevel                            = 21,
	Present                                  = 22,
	MaxNum                                   = 128,
	EContentsOpening_MAX                     = 129,
};

// Enum BattlePrototype.EOperationRestriction
// NumValues: 0x000B
enum class EOperationRestriction : uint8
{
	NotOpenMainMenu                          = 0,
	NotOpenDetailMap                         = 1,
	NotOpenWorldMap                          = 2,
	NotUseBattleItem                         = 3,
	NotUseSAS                                = 4,
	NotUseBraincrash                         = 5,
	NotUseBrainField                         = 6,
	NotUseDrive                              = 7,
	NotOpenPartyMenu                         = 8,
	MaxNum                                   = 128,
	EOperationRestriction_MAX                = 129,
};

// Enum BattlePrototype.EGimmickObjectStatus
// NumValues: 0x0007
enum class EGimmickObjectStatus : uint8
{
	GIMMICK_STATUS_NONE                      = 0,
	GIMMICK_STATUS_OPEN                      = 1,
	GIMMICK_STATUS_OPENING                   = 2,
	GIMMICK_STATUS_CLOSE                     = 3,
	GIMMICK_STATUS_CLOSING                   = 4,
	GIMMICK_STATUS_NUM                       = 5,
	GIMMICK_STATUS_MAX                       = 6,
};

// Enum BattlePrototype.EChangeMinimapStateType
// NumValues: 0x0004
enum class EChangeMinimapStateType : uint8
{
	OnRepop                                  = 0,
	OnAccess                                 = 1,
	OnItemGet                                = 2,
	EChangeMinimapStateType_MAX              = 3,
};

// Enum BattlePrototype.ERSInputDeviceType
// NumValues: 0x0006
enum class ERSInputDeviceType : uint8
{
	ENone                                    = 0,
	EPad                                     = 1,
	EKey1                                    = 2,
	EKey2                                    = 3,
	EMouse                                   = 4,
	ERSInputDeviceType_MAX                   = 5,
};

// Enum BattlePrototype.ETitleFlow
// NumValues: 0x000A
enum class ETitleFlow : uint8
{
	Invalid                                  = 0,
	NewGame                                  = 1,
	ExNewGame                                = 2,
	LoadGame                                 = 3,
	ConfigMenu                               = 4,
	AnalyticsMenu                            = 5,
	License                                  = 6,
	QuitGame                                 = 7,
	CrossSave                                = 8,
	ETitleFlow_MAX                           = 9,
};

// Enum BattlePrototype.EUIMapIconNative
// NumValues: 0x001E
enum class EUIMapIconNative : uint8
{
	Player                                   = 0,
	Enemy                                    = 1,
	Footprint                                = 2,
	TreasureClose                            = 3,
	TreasureOpen                             = 4,
	AreaChange                               = 5,
	MainQuest                                = 6,
	SubQuest                                 = 7,
	SubQuestActive                           = 8,
	SubQuestComplete                         = 9,
	SubQuestCompleteActive                   = 10,
	CameraDirection                          = 11,
	PlayerDirection                          = 12,
	NPC                                      = 13,
	Object                                   = 14,
	SAS                                      = 15,
	Shop                                     = 16,
	PickActive                               = 17,
	PickDisable                              = 18,
	SavePoint                                = 19,
	TownNpc                                  = 20,
	AreaChangeBer                            = 21,
	BoundsEp                                 = 22,
	Enemy0630                                = 23,
	AreaPortal                               = 24,
	AreaPortalBefore                         = 25,
	WorldPortal                              = 26,
	MaxValue                                 = 26,
	Num                                      = 27,
	EUIMapIconNative_MAX                     = 28,
};

// Enum BattlePrototype.EAddContentsType
// NumValues: 0x0006
enum class EAddContentsType : uint8
{
	None                                     = 0,
	Item                                     = 1,
	Mission                                  = 2,
	KizunaEp                                 = 3,
	Money                                    = 4,
	EAddContentsType_MAX                     = 5,
};

// Enum BattlePrototype.EAnimeInterlockingsType
// NumValues: 0x0006
enum class EAnimeInterlockingsType : uint8
{
	None                                     = 0,
	Item                                     = 1,
	Mission                                  = 2,
	KizunaEp                                 = 3,
	Money                                    = 4,
	EAnimeInterlockingsType_MAX              = 5,
};

// Enum BattlePrototype.ENotifyRadialBlurModulateType
// NumValues: 0x0005
enum class ENotifyRadialBlurModulateType : uint8
{
	Default                                  = 0,
	Electric                                 = 1,
	Fire                                     = 2,
	Num                                      = 3,
	ENotifyRadialBlurModulateType_MAX        = 4,
};

// Enum BattlePrototype.EArrangeItemBrainTalkType
// NumValues: 0x0004
enum class EArrangeItemBrainTalkType : uint8
{
	None                                     = 0,
	Treasure                                 = 1,
	Gathering                                = 2,
	EArrangeItemBrainTalkType_MAX            = 3,
};

// Enum BattlePrototype.EDirectionOfRotation
// NumValues: 0x0005
enum class EDirectionOfRotation : uint8
{
	None                                     = 0,
	Right                                    = 1,
	Left                                     = 2,
	NumOfEnum                                = 3,
	EDirectionOfRotation_MAX                 = 4,
};

// Enum BattlePrototype.EnemyCrashChanceAnimKind
// NumValues: 0x0004
enum class EnemyCrashChanceAnimKind : uint8
{
	Start                                    = 0,
	BrainLoop                                = 1,
	Up                                       = 2,
	EnemyCrashChanceAnimKind_MAX             = 3,
};

// Enum BattlePrototype.EnemyEventAnimKind
// NumValues: 0x0002
enum class EnemyEventAnimKind : uint8
{
	Event1                                   = 0,
	EnemyEventAnimKind_MAX                   = 1,
};

// Enum BattlePrototype.EnemyInitLayoutAnimKind
// NumValues: 0x0002
enum class EnemyInitLayoutAnimKind : uint8
{
	Wait                                     = 0,
	EnemyInitLayoutAnimKind_MAX              = 1,
};

// Enum BattlePrototype.EnemyDeadAnimKind
// NumValues: 0x0006
enum class EnemyDeadAnimKind : uint8
{
	Dead1                                    = 0,
	Dead2                                    = 1,
	Dead3                                    = 2,
	Dead4                                    = 3,
	Dead5                                    = 4,
	EnemyDeadAnimKind_MAX                    = 5,
};

// Enum BattlePrototype.EnemyBrainCrashAnimKind
// NumValues: 0x0004
enum class EnemyBrainCrashAnimKind : uint8
{
	Start                                    = 0,
	Wait                                     = 1,
	Up                                       = 2,
	EnemyBrainCrashAnimKind_MAX              = 3,
};

// Enum BattlePrototype.EnemyDamageDownAnimKind
// NumValues: 0x0013
enum class EnemyDamageDownAnimKind : uint8
{
	Start                                    = 0,
	Wait                                     = 1,
	Up                                       = 2,
	LaunchUp                                 = 3,
	LaunchDown                               = 4,
	Blow1                                    = 5,
	Blow2                                    = 6,
	Landing                                  = 7,
	SpecialDown1                             = 8,
	SpecialDown2                             = 9,
	SpecialDownFly1                          = 10,
	SpecialDownFly2                          = 11,
	ElectricDown                             = 12,
	FlyChaseDown                             = 13,
	FlyFinishDown                            = 14,
	PressDown                                = 15,
	PressDown02                              = 16,
	PressDownLoop                            = 17,
	EnemyDamageDownAnimKind_MAX              = 18,
};

// Enum BattlePrototype.EnemyDamageAnimKind
// NumValues: 0x0012
enum class EnemyDamageAnimKind : uint8
{
	Wince1                                   = 0,
	Wince2                                   = 1,
	Wince3                                   = 2,
	Wince4                                   = 3,
	KnockBack1                               = 4,
	KnockBack2                               = 5,
	KnockBack3                               = 6,
	KnockBack4                               = 7,
	SpecialDamage1                           = 8,
	SpecialDamage2                           = 9,
	ObjWince1                                = 10,
	ObjWince2                                = 11,
	ObjWince3                                = 12,
	DamageChance1                            = 13,
	DamageChance2                            = 14,
	DamageChance3                            = 15,
	DamageChance4                            = 16,
	EnemyDamageAnimKind_MAX                  = 17,
};

// Enum BattlePrototype.EnemyKind
// NumValues: 0x000A
enum class EnemyKind : uint8
{
	Default                                  = 0,
	Kind1                                    = 1,
	Kind2                                    = 2,
	Kind3                                    = 3,
	Kind4                                    = 4,
	Simple1                                  = 5,
	Simple2                                  = 6,
	Simple3                                  = 7,
	Invalid                                  = 8,
	EnemyKind_MAX                            = 9,
};

// Enum BattlePrototype.EnemySwitchAnimKind
// NumValues: 0x0004
enum class EnemySwitchAnimKind : uint8
{
	Default                                  = 0,
	Switch1                                  = 1,
	Switch2                                  = 2,
	EnemySwitchAnimKind_MAX                  = 3,
};

// Enum BattlePrototype.EnemyActionAnimKind
// NumValues: 0x001A
enum class EnemyActionAnimKind : uint8
{
	Action1                                  = 0,
	Action2                                  = 1,
	Action3                                  = 2,
	Action4                                  = 3,
	Action5                                  = 4,
	Action6                                  = 5,
	Action7                                  = 6,
	Action8                                  = 7,
	Action9                                  = 8,
	Action10                                 = 9,
	Action11                                 = 10,
	Action12                                 = 11,
	Action13                                 = 12,
	Action14                                 = 13,
	Action15                                 = 14,
	Action16                                 = 15,
	Action17                                 = 16,
	Action18                                 = 17,
	Action19                                 = 18,
	Action20                                 = 19,
	Action21                                 = 20,
	Action22                                 = 21,
	Action23                                 = 22,
	Action24                                 = 23,
	Action25                                 = 24,
	EnemyActionAnimKind_MAX                  = 25,
};

// Enum BattlePrototype.EnemyAttackAnimKind
// NumValues: 0x0029
enum class EnemyAttackAnimKind : uint8
{
	Attack1                                  = 0,
	Attack2                                  = 1,
	Attack3                                  = 2,
	Attack4                                  = 3,
	Attack5                                  = 4,
	Attack6                                  = 5,
	Attack7                                  = 6,
	Attack8                                  = 7,
	Attack9                                  = 8,
	Attack10                                 = 9,
	Attack11                                 = 10,
	Attack12                                 = 11,
	Attack13                                 = 12,
	Attack14                                 = 13,
	Attack15                                 = 14,
	Attack16                                 = 15,
	Attack17                                 = 16,
	Attack18                                 = 17,
	Attack19                                 = 18,
	Attack20                                 = 19,
	Attack21                                 = 20,
	Attack22                                 = 21,
	Attack23                                 = 22,
	Attack24                                 = 23,
	Attack25                                 = 24,
	Attack26                                 = 25,
	Attack27                                 = 26,
	Attack28                                 = 27,
	Attack29                                 = 28,
	Attack30                                 = 29,
	Attack31                                 = 30,
	Attack32                                 = 31,
	Attack33                                 = 32,
	Attack34                                 = 33,
	Attack35                                 = 34,
	Attack36                                 = 35,
	Attack37                                 = 36,
	Attack38                                 = 37,
	Attack39                                 = 38,
	Attack40                                 = 39,
	EnemyAttackAnimKind_MAX                  = 40,
};

// Enum BattlePrototype.EnemyMoveAnimKind
// NumValues: 0x0011
enum class EnemyMoveAnimKind : uint8
{
	Default                                  = 0,
	Walk1                                    = 1,
	Walk2                                    = 2,
	Run1                                     = 3,
	Run2                                     = 4,
	Wait1                                    = 5,
	Wait2                                    = 6,
	Other                                    = 7,
	RotR1                                    = 8,
	RotR2                                    = 9,
	RotL1                                    = 10,
	RotL2                                    = 11,
	Fall                                     = 12,
	Land                                     = 13,
	Takeoff                                  = 14,
	FlyUp                                    = 15,
	EnemyMoveAnimKind_MAX                    = 16,
};

// Enum BattlePrototype.EnemyAliveAnimKind
// NumValues: 0x000C
enum class EnemyAliveAnimKind : uint8
{
	IdleMove                                 = 0,
	Attack                                   = 1,
	Action                                   = 2,
	Damage                                   = 3,
	DamageDown                               = 4,
	BrainCrash                               = 5,
	Dead                                     = 6,
	InitLayout                               = 7,
	Event                                    = 8,
	CrashChance                              = 9,
	NumKind                                  = 10,
	EnemyAliveAnimKind_MAX                   = 11,
};

// Enum BattlePrototype.PlayerUpperAnimTransitionKind
// NumValues: 0x0004
enum class EPlayerUpperAnimTransitionKind : uint8
{
	None                                     = 0,
	StartToPsychic                           = 1,
	EndToNone                                = 2,
	PlayerUpperAnimTransitionKind_MAX        = 3,
};

// Enum BattlePrototype.PlayerAnimTransitionKind
// NumValues: 0x0025
enum class EPlayerAnimTransitionKind : uint8
{
	None                                     = 0,
	StartToIdleWalkRun                       = 1,
	StartToBoringIdle                        = 2,
	StartToDamage                            = 3,
	StartToStep                              = 4,
	StartToAttack                            = 5,
	StartToFall                              = 6,
	StartToLand                              = 7,
	StartToStartBattle                       = 8,
	StartToEndBattle                         = 9,
	StartToDead                              = 10,
	StartToJump                              = 11,
	StartToAirJump                           = 12,
	StartToRecover                           = 13,
	StartToPsychic                           = 14,
	StartToSprint                            = 15,
	StartToSprintBrake                       = 16,
	StartToJumpStepIn                        = 17,
	StartToStepEnd                           = 18,
	StartToBlowFall                          = 19,
	StartToBlowLanding                       = 20,
	StartToDown                              = 21,
	StartToWakeUp                            = 22,
	StartToUseItem                           = 23,
	StartToStartSprint                       = 24,
	StartToBrainCrash                        = 25,
	StartToDrive                             = 26,
	StartToResurrectBegin                    = 27,
	StartToResurrect                         = 28,
	StartToResurrectEnd                      = 29,
	StartToRevive                            = 30,
	StartToSprintTurnBack                    = 31,
	StartToLaunchFall                        = 32,
	StartToEvent                             = 33,
	StartToTalkTurn                          = 34,
	StartToSasLink                           = 35,
	PlayerAnimTransitionKind_MAX             = 36,
};

// Enum BattlePrototype.PlayerUpperAnimKind
// NumValues: 0x0004
enum class EPlayerUpperAnimKind : uint8
{
	None                                     = 0,
	Psychic                                  = 1,
	NumKind                                  = 2,
	PlayerUpperAnimKind_MAX                  = 3,
};

// Enum BattlePrototype.EBattlefieldFenceStat
// NumValues: 0x0006
enum class EBattlefieldFenceStat : uint8
{
	START                                    = 0,
	EXEC                                     = 1,
	END                                      = 2,
	NONE                                     = 3,
	NUM                                      = 4,
	EBattlefieldFenceStat_MAX                = 5,
};

// Enum BattlePrototype.EBattleEventType
// NumValues: 0x0005
enum class EBattleEventType : uint8
{
	SPAWN_ENEMY_SUBGROUP                     = 0,
	KILL_ENEMY_GROUP                         = 1,
	NONE                                     = 2,
	NUM                                      = 3,
	EBattleEventType_MAX                     = 4,
};

// Enum BattlePrototype.EBattlefieldStat
// NumValues: 0x0007
enum class EBattlefieldStat : uint8
{
	INIT                                     = 0,
	START                                    = 1,
	EXEC                                     = 2,
	END                                      = 3,
	NONE                                     = 4,
	NUM                                      = 5,
	EBattlefieldStat_MAX                     = 6,
};

// Enum BattlePrototype.EBattlefieldEventType
// NumValues: 0x0006
enum class EBattlefieldEventType : uint8
{
	WIPEOUT_GROUP                            = 0,
	CONTROL_BY_EVENT                         = 1,
	RUSH_SUBGROUPS                           = 2,
	WIPEOUT_KEEP_ENEMY_NUM                   = 3,
	NUM                                      = 4,
	EBattlefieldEventType_MAX                = 5,
};

// Enum BattlePrototype.EBattleEndResult
// NumValues: 0x0008
enum class EBattleEndResult : uint8
{
	None                                     = 0,
	Win                                      = 1,
	Escape                                   = 2,
	Stealth                                  = 3,
	WinBattleFieldStrong                     = 4,
	WinBattleFieldSpeedRun                   = 5,
	WinBattleFieldHorde                      = 6,
	EBattleEndResult_MAX                     = 7,
};

// Enum BattlePrototype.EReasonBattleEnd
// NumValues: 0x0006
enum class EReasonBattleEnd : uint8
{
	Other                                    = 0,
	Dead                                     = 1,
	DeadByPlayer                             = 2,
	Lost                                     = 3,
	StealthLost                              = 4,
	EReasonBattleEnd_MAX                     = 5,
};

// Enum BattlePrototype.EBattleLogMode
// NumValues: 0x0004
enum class EBattleLogMode : uint8
{
	NoRecord                                 = 0,
	Battle                                   = 1,
	BattleField                              = 2,
	EBattleLogMode_MAX                       = 3,
};

// Enum BattlePrototype.ELocalizedKeyboardType
// NumValues: 0x0006
enum class ELocalizedKeyboardType : uint8
{
	QWERTY                                   = 0,
	AZERTY                                   = 1,
	QWERTZ                                   = 2,
	QWERTY_J                                 = 3,
	Num                                      = 4,
	ELocalizedKeyboardType_MAX               = 5,
};

// Enum BattlePrototype.EPlatFormConsoleType
// NumValues: 0x000C
enum class EPlatFormConsoleType : uint8
{
	Invalid                                  = 0,
	Steam                                    = 1,
	PS4                                      = 2,
	PS4Pro                                   = 3,
	PS5                                      = 4,
	XboxOne                                  = 5,
	XboxOneS                                 = 6,
	XboxOneX                                 = 7,
	XSXAnaconda                              = 8,
	XSXLockhart                              = 9,
	Num                                      = 10,
	EPlatFormConsoleType_MAX                 = 11,
};

// Enum BattlePrototype.EPlatFormType
// NumValues: 0x0007
enum class EPlatFormType : uint8
{
	Windows                                  = 0,
	PS4                                      = 1,
	XboxOne                                  = 2,
	PS5                                      = 3,
	XSX                                      = 4,
	Num                                      = 5,
	EPlatFormType_MAX                        = 6,
};

// Enum BattlePrototype.ERegionType
// NumValues: 0x0007
enum class ERegionType : uint8
{
	ALL                                      = 0,
	JP                                       = 1,
	NA                                       = 2,
	EU                                       = 3,
	AS                                       = 4,
	Num                                      = 5,
	ERegionType_MAX                          = 6,
};

// Enum BattlePrototype.ETextLanguage
// NumValues: 0x000F
enum class ETextLanguage : uint8
{
	Japanese                                 = 0,
	English                                  = 1,
	French                                   = 2,
	Italian                                  = 3,
	Deutsch                                  = 4,
	Espanol                                  = 5,
	NeutralEspanol                           = 6,
	PortugalBR                               = 7,
	Russian                                  = 8,
	ChineseT                                 = 9,
	ChineseS                                 = 10,
	Korean                                   = 11,
	Num                                      = 12,
	Invalid                                  = 13,
	ETextLanguage_MAX                        = 14,
};

// Enum BattlePrototype.EBattleSituationActionType
// NumValues: 0x0006
enum class EBattleSituationActionType : uint8
{
	HitWeak                                  = 0,
	JustDodge                                = 1,
	PsychicCombo                             = 2,
	Damage                                   = 3,
	DamageDown                               = 4,
	EBattleSituationActionType_MAX           = 5,
};

// Enum BattlePrototype.EBrainFieldSequencerType
// NumValues: 0x000D
enum class EBrainFieldSequencerType : uint8
{
	BFS_Invalid                              = 0,
	BFS_Ch0100                               = 1,
	BFS_Ch0200                               = 2,
	BFS_Np1100                               = 3,
	BFS_Em8000                               = 4,
	BFS_Em8010                               = 5,
	BFS_Em8300                               = 6,
	BFS_Em8000Twin                           = 7,
	BFS_Em8200                               = 8,
	BFS_ENPC_Ch0100                          = 9,
	BFS_ENPC_Ch0200                          = 10,
	BFE_Max                                  = 11,
	EBrainFieldSequencerType_MAX             = 12,
};

// Enum BattlePrototype.EBrainFieldENPCType
// NumValues: 0x0004
enum class EBrainFieldENPCType : uint8
{
	BFE_Normal                               = 0,
	BFE_Twins                                = 1,
	BFE_Em8300                               = 2,
	BFE_Max                                  = 3,
};

// Enum BattlePrototype.EBrainFieldMonitorState
// NumValues: 0x0006
enum class EBrainFieldMonitorState : uint8
{
	Normal                                   = 0,
	AdvantagePlayer                          = 1,
	DisadvantagePlayer                       = 2,
	BrainTalk                                = 3,
	Event                                    = 4,
	Max                                      = 5,
};

// Enum BattlePrototype.EBrainMesSortType
// NumValues: 0x0004
enum class EBrainMesSortType : uint8
{
	NewArraival                              = 0,
	OldOrder                                 = 1,
	Unreplied                                = 2,
	EBrainMesSortType_MAX                    = 3,
};

// Enum BattlePrototype.EBrainTalkKizunaLvUpFlow
// NumValues: 0x0003
enum class EBrainTalkKizunaLvUpFlow : uint8
{
	Standby                                  = 0,
	PlayableWait                             = 1,
	EBrainTalkKizunaLvUpFlow_MAX             = 2,
};

// Enum BattlePrototype.EBrainTalkEmFile
// NumValues: 0x000A
enum class EBrainTalkEmFile : uint8
{
	BrainTalkEm_Boss1                        = 0,
	BrainTalkEm_Boss2                        = 1,
	BrainTalkEm_Boss3                        = 2,
	BrainTalkEm_Boss4                        = 3,
	BrainTalkEm_Boss5                        = 4,
	BrainTalkEm_Boss6                        = 5,
	BrainTalkEm_ZakoGeneral                  = 6,
	BrainTalkEm_ZakoIndiv1                   = 7,
	BrainTalkEm_ZakoIndiv2                   = 8,
	Max                                      = 9,
};

// Enum BattlePrototype.EBrainTalkPriority
// NumValues: 0x0007
enum class EBrainTalkPriority : uint8
{
	Sensitive                                = 0,
	Low                                      = 1,
	Normal                                   = 2,
	High                                     = 3,
	Extreme                                  = 4,
	Num                                      = 5,
	EBrainTalkPriority_MAX                   = 6,
};

// Enum BattlePrototype.EBrainTalkChGroup
// NumValues: 0x000C
enum class EBrainTalkChGroup : uint8
{
	GroupCh_None                             = 0,
	GroupCh_0100                             = 1,
	GroupCh_0200                             = 2,
	GroupCh_0300                             = 3,
	GroupCh_0400                             = 4,
	GroupCh_0500                             = 5,
	GroupCh_0600                             = 6,
	GroupCh_0700                             = 7,
	GroupCh_0800                             = 8,
	GroupCh_0900                             = 9,
	GroupCh_1000                             = 10,
	GroupCh_MAX                              = 11,
};

// Enum BattlePrototype.EBrainTalkBtGroup
// NumValues: 0x0005
enum class EBrainTalkBtGroup : uint8
{
	Group_None                               = 0,
	Group_A                                  = 1,
	Group_B                                  = 2,
	Group_C                                  = 3,
	Group_MAX                                = 4,
};

// Enum BattlePrototype.EBrainTalkCategory
// NumValues: 0x000D
enum class EBrainTalkCategory : uint8
{
	Main                                     = 0,
	Sub                                      = 1,
	Battle                                   = 2,
	Zako                                     = 3,
	Boss                                     = 4,
	BrainField                               = 5,
	Tutorial                                 = 6,
	Kizuna                                   = 7,
	Map                                      = 8,
	Gimmick                                  = 9,
	Other                                    = 10,
	Debug                                    = 11,
	Max                                      = 12,
};

// Enum BattlePrototype.EBrainTalkBtTag
// NumValues: 0x0005
enum class EBrainTalkBtTag : uint8
{
	NoSet                                    = 0,
	SallyTimes                               = 1,
	NoSallyTimes                             = 2,
	SasNoUse                                 = 3,
	EBrainTalkBtTag_MAX                      = 4,
};

// Enum BattlePrototype.EBrainTalkPriorityCheckResult
// NumValues: 0x0004
enum class EBrainTalkPriorityCheckResult : uint8
{
	Play                                     = 0,
	Stock                                    = 1,
	Discard                                  = 2,
	EBrainTalkPriorityCheckResult_MAX        = 3,
};

// Enum BattlePrototype.EBrainTalkGimmickCondition
// NumValues: 0x0025
enum class EBrainTalkGimmickCondition : uint8
{
	BrainTalkGimmick_0                       = 0,
	BrainTalkGimmick_1                       = 1,
	BrainTalkGimmick_2                       = 2,
	BrainTalkGimmick_3                       = 3,
	BrainTalkGimmick_4                       = 4,
	BrainTalkGimmick_5                       = 5,
	BrainTalkGimmick_6                       = 6,
	BrainTalkGimmick_7                       = 7,
	BrainTalkGimmick_8                       = 8,
	BrainTalkGimmick_9                       = 9,
	BrainTalkGimmick_10                      = 10,
	BrainTalkGimmick_11                      = 11,
	BrainTalkGimmick_12                      = 12,
	BrainTalkGimmick_13                      = 13,
	BrainTalkGimmick_14                      = 14,
	BrainTalkGimmick_15                      = 15,
	BrainTalkGimmick_16                      = 16,
	BrainTalkGimmick_17                      = 17,
	BrainTalkGimmick_18                      = 18,
	BrainTalkGimmick_19                      = 19,
	BrainTalkGimmick_20                      = 20,
	BrainTalkGimmick_21                      = 21,
	BrainTalkGimmick_22                      = 22,
	BrainTalkGimmick_23                      = 23,
	BrainTalkGimmick_24                      = 24,
	BrainTalkGimmick_25                      = 25,
	BrainTalkGimmick_26                      = 26,
	BrainTalkGimmick_27                      = 27,
	BrainTalkGimmick_28                      = 28,
	BrainTalkGimmick_29                      = 29,
	BrainTalkGimmick_30                      = 30,
	BrainTalkGimmick_31                      = 31,
	BrainTalkGimmick_32                      = 32,
	BrainTalkGimmick_33                      = 33,
	BrainTalkGimmick_34                      = 34,
	BrainTalkGimmick_35                      = 35,
	Max                                      = 36,
};

// Enum BattlePrototype.EBrainTalkTutorialCondition
// NumValues: 0x000C
enum class EBrainTalkTutorialCondition : uint8
{
	BrainTalkTutorial_0                      = 0,
	BrainTalkTutorial_1                      = 1,
	BrainTalkTutorial_2                      = 2,
	BrainTalkTutorial_3                      = 3,
	BrainTalkTutorial_4                      = 4,
	BrainTalkTutorial_5                      = 5,
	BrainTalkTutorial_6                      = 6,
	BrainTalkTutorial_7                      = 7,
	BrainTalkTutorial_8                      = 8,
	BrainTalkTutorial_9                      = 9,
	BrainTalkTutorial_10                     = 10,
	Max                                      = 11,
};

// Enum BattlePrototype.EBrainTalkEmCondition
// NumValues: 0x0056
enum class EBrainTalkEmCondition : uint8
{
	BrainTalkEm_0                            = 0,
	BrainTalkEm_1                            = 1,
	BrainTalkEm_2                            = 2,
	BrainTalkEm_3                            = 3,
	BrainTalkEm_4                            = 4,
	BrainTalkEm_5                            = 5,
	BrainTalkEm_6                            = 6,
	BrainTalkEm_7                            = 7,
	BrainTalkEm_8                            = 8,
	BrainTalkEm_9                            = 9,
	BrainTalkEm_10                           = 10,
	BrainTalkEm_11                           = 11,
	BrainTalkEm_12                           = 12,
	BrainTalkEm_13                           = 13,
	BrainTalkEm_14                           = 14,
	BrainTalkEm_15                           = 15,
	BrainTalkEm_16                           = 16,
	BrainTalkEm_17                           = 17,
	BrainTalkEm_18                           = 18,
	BrainTalkEm_19                           = 19,
	BrainTalkEm_20                           = 20,
	BrainTalkEm_21                           = 21,
	BrainTalkEm_22                           = 22,
	BrainTalkEm_23                           = 23,
	BrainTalkEm_24                           = 24,
	BrainTalkEm_25                           = 25,
	BrainTalkEm_26                           = 26,
	BrainTalkEm_27                           = 27,
	BrainTalkEm_28                           = 28,
	BrainTalkEm_29                           = 29,
	BrainTalkEm_30                           = 30,
	BrainTalkEm_31                           = 31,
	BrainTalkEm_32                           = 32,
	BrainTalkEm_33                           = 33,
	BrainTalkEm_34                           = 34,
	BrainTalkEm_35                           = 35,
	BrainTalkEm_36                           = 36,
	BrainTalkEm_37                           = 37,
	BrainTalkEm_38                           = 38,
	BrainTalkEm_39                           = 39,
	BrainTalkEm_40                           = 40,
	BrainTalkEm_41                           = 41,
	BrainTalkEm_42                           = 42,
	BrainTalkEm_43                           = 43,
	BrainTalkEm_44                           = 44,
	BrainTalkEm_45                           = 45,
	BrainTalkEm_46                           = 46,
	BrainTalkEm_47                           = 47,
	BrainTalkEm_48                           = 48,
	BrainTalkEm_49                           = 49,
	BrainTalkEm_50                           = 50,
	BrainTalkEm_51                           = 51,
	BrainTalkEm_52                           = 52,
	BrainTalkEm_53                           = 53,
	BrainTalkEm_54                           = 54,
	BrainTalkEm_55                           = 55,
	BrainTalkEm_56                           = 56,
	BrainTalkEm_57                           = 57,
	BrainTalkEm_58                           = 58,
	BrainTalkEm_59                           = 59,
	BrainTalkEm_60                           = 60,
	BrainTalkEm_61                           = 61,
	BrainTalkEm_62                           = 62,
	BrainTalkEm_63                           = 63,
	BrainTalkEm_64                           = 64,
	BrainTalkEm_65                           = 65,
	BrainTalkEm_66                           = 66,
	BrainTalkEm_67                           = 67,
	BrainTalkEm_68                           = 68,
	BrainTalkEm_69                           = 69,
	BrainTalkEm_70                           = 70,
	BrainTalkEm_71                           = 71,
	BrainTalkEm_72                           = 72,
	BrainTalkEm_73                           = 73,
	BrainTalkEm_74                           = 74,
	BrainTalkEm_75                           = 75,
	BrainTalkEm_76                           = 76,
	BrainTalkEm_77                           = 77,
	BrainTalkEm_78                           = 78,
	BrainTalkEm_79                           = 79,
	BrainTalkEm_80                           = 80,
	BrainTalkEm_81                           = 81,
	BrainTalkEm_82                           = 82,
	BrainTalkEm_83                           = 83,
	BrainTalkEm_84                           = 84,
	Max                                      = 85,
};

// Enum BattlePrototype.EBrainTalkBtCondition
// NumValues: 0x0058
enum class EBrainTalkBtCondition : uint8
{
	Dummy_0                                  = 0,
	BrainTalkBt_Hp30p                        = 1,
	BrainTalkBt_KillByEn                     = 2,
	BrainTalkBt_BrainCrashByEn               = 3,
	BrainTalkBt_BadStateByEn                 = 4,
	Dummy_5                                  = 5,
	Dummy_6                                  = 6,
	Dummy_7                                  = 7,
	Dummy_8                                  = 8,
	BrainTalkBt_Recovery                     = 9,
	BrainTalkBt_Revival_FromPL               = 10,
	BrainTalkBt_Revival_ToPL                 = 11,
	BrainTalkBt_BFActivate                   = 12,
	BrainTalkBt_SasCombo                     = 13,
	BrainTalkBt_PsychicCombo                 = 14,
	BrainTalkBt_DriveActive                  = 15,
	BrainTalkBt_HiKizunaEffect               = 16,
	BrainTalkBt_TouchBFWall                  = 17,
	BrainTalkBt_NearCC                       = 18,
	BrainTalkBt_BattleEscape                 = 19,
	BrainTalkBt_KizunaLvUp                   = 20,
	BrainTalkBt_DamageTakeOver               = 21,
	BrainTalkBt_LvUp                         = 22,
	BrainTalkBt_DeadInarow                   = 23,
	BrainTalkBt_SallyTimes                   = 24,
	BrainTalkBt_NoSallyTimes                 = 25,
	BrainTalkBt_JumpOff                      = 26,
	BrainTalkBt_PLChangeAttachment           = 27,
	BrainTalkBt_PLDead                       = 28,
	BrainTalkBt_KillEnRest                   = 29,
	BrainTalkBt_KillAllEnForPT               = 30,
	BrainTalkBt_DiscStrEn                    = 31,
	BrainTalkBt_DestroyShell                 = 32,
	BrainTalkBt_EnemyDown                    = 33,
	BrainTalkBt_DiscEn                       = 34,
	BrainTalkBt_DispCrashTrg                 = 35,
	BrainTalkBt_KillEnemyBC                  = 36,
	BrainTalkBt_BadStateForEn                = 37,
	Dummy_38                                 = 38,
	Dummy_39                                 = 39,
	Dummy_40                                 = 40,
	Dummy_41                                 = 41,
	BrainTalkBt_EnBerserkSign                = 42,
	BrainTalkBt_EnBerserk                    = 43,
	BrainTalkBt_AttackEnShell                = 44,
	BrainTalkBt_AttackEnWeak                 = 45,
	BrainTalkBt_FirstStrike                  = 46,
	BrainTalkBt_OilEnAtkFire                 = 47,
	BrainTalkBt_WaterEnAtkElectric           = 48,
	BrainTalkBt_KillAllEnShortTime           = 49,
	BrainTalkBt_KillAllEnStrEn               = 50,
	BrainTalkBt_KillAllEnManyEn              = 51,
	BrainTalkBt_KillAllEnManyWeakEn          = 52,
	BrainTalkBt_KillAllEnForPL               = 53,
	BrainTalkBt_KillEnStrategy               = 54,
	BrainTalkBt_DiscStealth                  = 55,
	BrainTalkBt_DiscSasValidEn_Fire          = 56,
	BrainTalkBt_DiscSasValidEn_Electric      = 57,
	BrainTalkBt_DiscSasValidEn_Metal         = 58,
	BrainTalkBt_DiscSasValidEn_Telepo        = 59,
	BrainTalkBt_DiscSasValidEn_Stealth       = 60,
	BrainTalkBt_DiscSasValidEn_Accelerator   = 61,
	BrainTalkBt_DiscSasValidEn_Copy          = 62,
	BrainTalkBt_DiscSasValidEn_SeeThrough    = 63,
	BrainTalkBt_StealthLosePL                = 64,
	BrainTalkBt_SasNoUse                     = 65,
	BrainTalkBt_SasContinuity                = 66,
	BrainTalkBt_SasHoloPossible              = 67,
	BrainTalkBt_SasHoloPursuit               = 68,
	BrainTalkBt_GetItem                      = 69,
	Dummy_70                                 = 70,
	BrainTalkBt_EnemyDrop                    = 71,
	Dummy_72                                 = 72,
	BrainTalkBt_UnopenedTreasure             = 73,
	BrainTalkBt_GatherPoint                  = 74,
	BrainTalkBt_RecoveryItemZero             = 75,
	BrainTalkBt_DiscQuestEnemy               = 76,
	BrainTalkBt_ClearQuest                   = 77,
	BrainTalkBt_BirthKizunaEp                = 78,
	BrainTalkBt_KillQuestTgtEn               = 79,
	BrainTalkBt_GetQuestTgtItem              = 80,
	BrainTalkBt_PTChangeAttachment           = 81,
	BrainTalkBt_DriveGaugeMax                = 82,
	BrainTalkBt_EquipStrongestWeapon         = 83,
	BrainTalkBt_WaitingVoice                 = 84,
	BrainTalkBt_RecoveryHpToPL               = 85,
	BrainTalkBt_RecoveryAbToPL               = 86,
	Max                                      = 87,
};

// Enum BattlePrototype.EBrainTalkSystemType
// NumValues: 0x0005
enum class EBrainTalkSystemType : uint8
{
	Battle                                   = 0,
	EnemyCapture                             = 1,
	Tutorial                                 = 2,
	MapGimmick                               = 3,
	EBrainTalkSystemType_MAX                 = 4,
};

// Enum BattlePrototype.Enum_EnemySpawnStateNative
// NumValues: 0x0006
enum class Enum_EnemySpawnStateNative : uint8
{
	None                                     = 0,
	Wait                                     = 1,
	Start                                    = 2,
	Update                                   = 3,
	End                                      = 4,
	Enum_MAX                                 = 5,
};

// Enum BattlePrototype.CalcTarget
// NumValues: 0x0007
enum class ECalcTarget : uint8
{
	Player                                   = 0,
	NPC                                      = 1,
	Enemy                                    = 2,
	Object                                   = 3,
	Level                                    = 4,
	Num                                      = 5,
	CalcTarget_MAX                           = 6,
};

// Enum BattlePrototype.CalcMode
// NumValues: 0x0003
enum class ECalcMode : uint8
{
	Default                                  = 0,
	Individual                               = 1,
	CalcMode_MAX                             = 2,
};

// Enum BattlePrototype.CalcProcess
// NumValues: 0x000E
enum class ECalcProcess : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Start                                    = 2,
	PreClean                                 = 3,
	PreWait                                  = 4,
	PreMeasure                               = 5,
	CreateObject                             = 6,
	WaitContinue                             = 7,
	PostMeasure                              = 8,
	DestroyObject                            = 9,
	PostClean                                = 10,
	FinishOne                                = 11,
	Term                                     = 12,
	CalcProcess_MAX                          = 13,
};

// Enum BattlePrototype.ECharacterMaterialLightType
// NumValues: 0x0005
enum class ECharacterMaterialLightType : uint8
{
	CaptureField                             = 0,
	SASStart                                 = 1,
	PsychicCombo                             = 2,
	Num                                      = 3,
	ECharacterMaterialLightType_MAX          = 4,
};

// Enum BattlePrototype.EHpDownLimitType
// NumValues: 0x0004
enum class EHpDownLimitType : uint8
{
	NotUse                                   = 0,
	Rate                                     = 1,
	Immediate                                = 2,
	EHpDownLimitType_MAX                     = 3,
};

// Enum BattlePrototype.EClearGetterType
// NumValues: 0x0088
enum class EClearGetterType : uint8
{
	ClearGetter_Type_001                     = 0,
	ClearGetter_Type_002                     = 1,
	ClearGetter_Type_003                     = 2,
	ClearGetter_Type_004                     = 3,
	ClearGetter_Type_005                     = 4,
	ClearGetter_Type_006                     = 5,
	ClearGetter_Type_007                     = 6,
	ClearGetter_Type_008                     = 7,
	ClearGetter_Type_009                     = 8,
	ClearGetter_Type_010                     = 9,
	ClearGetter_Type_011                     = 10,
	ClearGetter_Type_012                     = 11,
	ClearGetter_Type_013                     = 12,
	ClearGetter_Type_014                     = 13,
	ClearGetter_Type_015                     = 14,
	ClearGetter_Type_016                     = 15,
	ClearGetter_Type_017                     = 16,
	ClearGetter_Type_018                     = 17,
	ClearGetter_Type_019                     = 18,
	ClearGetter_Type_020                     = 19,
	ClearGetter_Type_021                     = 20,
	ClearGetter_Type_022                     = 21,
	ClearGetter_Type_023                     = 22,
	ClearGetter_Type_024                     = 23,
	ClearGetter_Type_025                     = 24,
	ClearGetter_Type_026                     = 25,
	ClearGetter_Type_027                     = 26,
	ClearGetter_Type_028                     = 27,
	ClearGetter_Type_029                     = 28,
	ClearGetter_Type_030                     = 29,
	ClearGetter_Type_031                     = 30,
	ClearGetter_Type_032                     = 31,
	ClearGetter_Type_033                     = 32,
	ClearGetter_Type_034                     = 33,
	ClearGetter_Type_035                     = 34,
	ClearGetter_Type_036                     = 35,
	ClearGetter_Type_037                     = 36,
	ClearGetter_Type_038                     = 37,
	ClearGetter_Type_039                     = 38,
	ClearGetter_Type_040                     = 39,
	ClearGetter_Type_041                     = 40,
	ClearGetter_Type_042                     = 41,
	ClearGetter_Type_043                     = 42,
	ClearGetter_Type_044                     = 43,
	ClearGetter_Type_045                     = 44,
	ClearGetter_Type_046                     = 45,
	ClearGetter_Type_047                     = 46,
	ClearGetter_Type_048                     = 47,
	ClearGetter_Type_049                     = 48,
	ClearGetter_Type_050                     = 49,
	ClearGetter_Type_051                     = 50,
	ClearGetter_Type_052                     = 51,
	ClearGetter_Type_053                     = 52,
	ClearGetter_Type_054                     = 53,
	ClearGetter_Type_055                     = 54,
	ClearGetter_Type_056                     = 55,
	ClearGetter_Type_057                     = 56,
	ClearGetter_Type_058                     = 57,
	ClearGetter_Type_059                     = 58,
	ClearGetter_Type_060                     = 59,
	ClearGetter_Type_061                     = 60,
	ClearGetter_Type_062                     = 61,
	ClearGetter_Type_063                     = 62,
	ClearGetter_Type_064                     = 63,
	ClearGetter_Type_065                     = 64,
	ClearGetter_Type_066                     = 65,
	ClearGetter_Type_067                     = 66,
	ClearGetter_Type_068                     = 67,
	ClearGetter_Type_069                     = 68,
	ClearGetter_Type_070                     = 69,
	ClearGetter_Type_071                     = 70,
	ClearGetter_Type_072                     = 71,
	ClearGetter_Type_073                     = 72,
	ClearGetter_Type_074                     = 73,
	ClearGetter_Type_075                     = 74,
	ClearGetter_Type_076                     = 75,
	ClearGetter_Type_077                     = 76,
	ClearGetter_Type_078                     = 77,
	ClearGetter_Type_079                     = 78,
	ClearGetter_Type_080                     = 79,
	ClearGetter_Type_081                     = 80,
	ClearGetter_Type_082                     = 81,
	ClearGetter_Type_083                     = 82,
	ClearGetter_Type_084                     = 83,
	ClearGetter_Type_085                     = 84,
	ClearGetter_Type_086                     = 85,
	ClearGetter_Type_087                     = 86,
	ClearGetter_Type_088                     = 87,
	ClearGetter_Type_089                     = 88,
	ClearGetter_Type_090                     = 89,
	ClearGetter_Type_091                     = 90,
	ClearGetter_Type_092                     = 91,
	ClearGetter_Type_093                     = 92,
	ClearGetter_Type_094                     = 93,
	ClearGetter_Type_095                     = 94,
	ClearGetter_Type_096                     = 95,
	ClearGetter_Type_097                     = 96,
	ClearGetter_Type_098                     = 97,
	ClearGetter_Type_099                     = 98,
	ClearGetter_Type_100                     = 99,
	ClearGetter_Type_101                     = 100,
	ClearGetter_Type_102                     = 101,
	ClearGetter_Type_103                     = 102,
	ClearGetter_Type_104                     = 103,
	ClearGetter_Type_105                     = 104,
	ClearGetter_Type_106                     = 105,
	ClearGetter_Type_107                     = 106,
	ClearGetter_Type_108                     = 107,
	ClearGetter_Type_109                     = 108,
	ClearGetter_Type_110                     = 109,
	ClearGetter_Type_111                     = 110,
	ClearGetter_Type_112                     = 111,
	ClearGetter_Type_113                     = 112,
	ClearGetter_Type_114                     = 113,
	ClearGetter_Type_115                     = 114,
	ClearGetter_Type_116                     = 115,
	ClearGetter_Type_117                     = 116,
	ClearGetter_Type_118                     = 117,
	ClearGetter_Type_119                     = 118,
	ClearGetter_Type_120                     = 119,
	ClearGetter_Type_121                     = 120,
	ClearGetter_Type_122                     = 121,
	ClearGetter_Type_123                     = 122,
	ClearGetter_Type_124                     = 123,
	ClearGetter_Type_125                     = 124,
	ClearGetter_Type_126                     = 125,
	ClearGetter_Type_127                     = 126,
	ClearGetter_Type_128                     = 127,
	ClearGetter_Type_129                     = 128,
	ClearGetter_Type_130                     = 129,
	ClearGetter_Type_131                     = 130,
	ClearGetter_Type_132                     = 131,
	ClearGetter_Type_133                     = 132,
	Num                                      = 133,
	ContentMaxNum                            = 255,
	EClearGetterType_MAX                     = 256,
};

// Enum BattlePrototype.EScenarioType
// NumValues: 0x0006
enum class EScenarioType : uint8
{
	Invalid                                  = 0,
	SenarioMale                              = 1,
	SenarioFemale                            = 2,
	SenarioCommon                            = 3,
	SenarioBoth                              = 4,
	EScenarioType_MAX                        = 5,
};

// Enum BattlePrototype.ConditionExclusionKind
// NumValues: 0x0004
enum class EConditionExclusionKind : uint8
{
	None                                     = 0,
	FinishSelf                               = 1,
	FinishOther                              = 2,
	ConditionExclusionKind_MAX               = 3,
};

// Enum BattlePrototype.EAnimeInterlockingErrorType
// NumValues: 0x0005
enum class EAnimeInterlockingErrorType : uint8
{
	None                                     = 0,
	TimeOut                                  = 1,
	Maintenance                              = 2,
	Other                                    = 3,
	EAnimeInterlockingErrorType_MAX          = 4,
};

// Enum BattlePrototype.EAnimeInterlockingState
// NumValues: 0x0005
enum class EAnimeInterlockingState : uint8
{
	Success                                  = 0,
	Loading                                  = 1,
	Error                                    = 2,
	Invalid                                  = 3,
	EAnimeInterlockingState_MAX              = 4,
};

// Enum BattlePrototype.ECosmosRegistType
// NumValues: 0x0005
enum class ECosmosRegistType : uint8
{
	Invalid                                  = 0,
	AlreadyRegist                            = 1,
	NewRegist                                = 2,
	NewTitleRegist                           = 3,
	Max                                      = 4,
};

// Enum BattlePrototype.ECosmosWebAPIType
// NumValues: 0x0011
enum class ECosmosWebAPIType : uint8
{
	SysGetEnv                                = 0,
	SysKPI                                   = 1,
	SysAgreeKPI                              = 2,
	UserCreate                               = 3,
	UserLogin                                = 4,
	UserConvertUserId                        = 5,
	TusRead                                  = 6,
	TusWrite                                 = 7,
	RankingGetMaster                         = 8,
	RankingSetScore                          = 9,
	RankingGetByRange                        = 10,
	SavedataUpload                           = 11,
	SavedataMultipartUpload                  = 12,
	SavedataDownload                         = 13,
	SavedataDelete                           = 14,
	HugeTssMultiReadList                     = 15,
	Max                                      = 16,
};

// Enum BattlePrototype.ECutsceneRootTransformID
// NumValues: 0x0007
enum class ECutsceneRootTransformID : uint8
{
	BrainField                               = 0,
	Trigger                                  = 1,
	SpecialAttack                            = 2,
	Extra                                    = 3,
	PsychicBattle_ElectricPole               = 4,
	BrainCrash                               = 5,
	Max                                      = 6,
};

// Enum BattlePrototype.HitRearDecideType
// NumValues: 0x0003
enum class EHitRearDecideType : uint8
{
	OpponentActorLocation                    = 0,
	AttackSourceActorLocation                = 1,
	HitRearDecideType_MAX                    = 2,
};

// Enum BattlePrototype.HPartNo
// NumValues: 0x000F
enum class EHPartNo : uint8
{
	Default                                  = 0,
	Head                                     = 1,
	UpperBody                                = 2,
	LowerBody                                = 3,
	RightHand                                = 4,
	LeftHand                                 = 5,
	RightFoot                                = 6,
	LeftFoot                                 = 7,
	WeakPoint                                = 8,
	AddPart1                                 = 9,
	AddPart2                                 = 10,
	AddPart3                                 = 11,
	AddPart4                                 = 12,
	AddPart5                                 = 13,
	HPartNo_MAX                              = 14,
};

// Enum BattlePrototype.HDamageEffectType
// NumValues: 0x000E
enum class EHDamageEffectType : uint8
{
	Default                                  = 0,
	Slash                                    = 1,
	Armor                                    = 2,
	OutRange                                 = 3,
	Invincible                               = 4,
	Weak                                     = 5,
	Human                                    = 6,
	HumanOutRange                            = 7,
	Penetrate                                = 8,
	NoEffect                                 = 9,
	Water                                    = 10,
	Ice                                      = 11,
	IceOutRange                              = 12,
	Max                                      = 13,
};

// Enum BattlePrototype.EHitZeroEffectSpawnType
// NumValues: 0x0003
enum class EHitZeroEffectSpawnType : uint8
{
	Default                                  = 0,
	NormalDir                                = 1,
	EHitZeroEffectSpawnType_MAX              = 2,
};

// Enum BattlePrototype.QuestProgressState
// NumValues: 0x0006
enum class EQuestProgressState : uint8
{
	QpNotOpen                                = 0,
	QpNotOrders                              = 1,
	QpInProgress                             = 2,
	QpCanReport                              = 3,
	QpCleared                                = 4,
	QuestProgressState_MAX                   = 5,
};

// Enum BattlePrototype.ETextType
// NumValues: 0x000A
enum class ETextType : uint8
{
	Invalid                                  = 0,
	Name                                     = 1,
	Description                              = 2,
	MenuCommon                               = 3,
	Quest                                    = 4,
	TutoHelp                                 = 5,
	Event                                    = 6,
	BrainMessage                             = 7,
	Books                                    = 8,
	MAX                                      = 9,
};

// Enum BattlePrototype.ShowDestinationApplicationType
// NumValues: 0x0004
enum class EShowDestinationApplicationType : uint8
{
	All                                      = 0,
	WorldMapOnly                             = 1,
	WithoutWorldMap                          = 2,
	ShowDestinationApplicationType_MAX       = 3,
};

// Enum BattlePrototype.ShowDestinationBoolCheckType
// NumValues: 0x0005
enum class EShowDestinationBoolCheckType : uint8
{
	None                                     = 0,
	Or                                       = 1,
	And                                      = 2,
	FirstCheck                               = 3,
	ShowDestinationBoolCheckType_MAX         = 4,
};

// Enum BattlePrototype.ShowDestinationCheckType
// NumValues: 0x0005
enum class EShowDestinationCheckType : uint8
{
	ScenarioFlag                             = 0,
	ProgressID                               = 1,
	BondsEPProgressID                        = 2,
	NoCheck                                  = 3,
	ShowDestinationCheckType_MAX             = 4,
};

// Enum BattlePrototype.EBTLoadAsyncFlow
// NumValues: 0x0005
enum class EBTLoadAsyncFlow : uint8
{
	Stanby                                   = 0,
	PreWork                                  = 1,
	TaskStart                                = 2,
	TaskFinishWait                           = 3,
	EBTLoadAsyncFlow_MAX                     = 4,
};

// Enum BattlePrototype.EDebugCharacterPresetState
// NumValues: 0x0004
enum class EDebugCharacterPresetState : uint8
{
	NotEntry                                 = 0,
	Entry                                    = 1,
	Remove                                   = 2,
	EDebugCharacterPresetState_MAX           = 3,
};

// Enum BattlePrototype.DropItemParticleName
// NumValues: 0x0004
enum class EDropItemParticleName : uint8
{
	DpDrop                                   = 0,
	DpLanding                                = 1,
	DpGet                                    = 2,
	DropItemParticleName_MAX                 = 3,
};

// Enum BattlePrototype.DropItemStateName
// NumValues: 0x0005
enum class EDropItemStateName : uint8
{
	DsNon                                    = 0,
	DsDrop                                   = 1,
	DsLanding                                = 2,
	DsAdsorption                             = 3,
	DropItemStateName_MAX                    = 4,
};

// Enum BattlePrototype.EEnemyTribe
// NumValues: 0x000C
enum class EEnemyTribe : uint8
{
	Other                                    = 0,
	Sabbat                                   = 1,
	Paws                                     = 2,
	Rummy                                    = 3,
	Rut                                      = 4,
	Pool                                     = 5,
	Pendu                                    = 6,
	Yawn                                     = 7,
	Santa                                    = 8,
	Pound                                    = 9,
	Chinery                                  = 10,
	EEnemyTribe_MAX                          = 11,
};

// Enum BattlePrototype.EEm0800EffectType
// NumValues: 0x0009
enum class EEm0800EffectType : uint8
{
	None                                     = 0,
	GroundWait                               = 1,
	GroundNotWait                            = 2,
	Appear                                   = 3,
	Laser                                    = 4,
	GroundDash                               = 5,
	JumpOutSignNormal                        = 6,
	JumpOutSignSeeThrough                    = 7,
	EEm0800EffectType_MAX                    = 8,
};

// Enum BattlePrototype.EEnemyAttractType
// NumValues: 0x0006
enum class EEnemyAttractType : uint8
{
	Invalid                                  = 0,
	SmallEnemy                               = 1,
	MediumEnemy                              = 2,
	LargeEnemy                               = 3,
	FixEnemy                                 = 4,
	EEnemyAttractType_MAX                    = 5,
};

// Enum BattlePrototype.EEnemyGoalType
// NumValues: 0x0004
enum class EEnemyGoalType : uint8
{
	Invalid                                  = 0,
	Character                                = 1,
	Location                                 = 2,
	EEnemyGoalType_MAX                       = 3,
};

// Enum BattlePrototype.EEnemyDamageType
// NumValues: 0x0005
enum class EEnemyDamageType : uint8
{
	Wince                                    = 0,
	KnockBack                                = 1,
	Launch                                   = 2,
	Down                                     = 3,
	EEnemyDamageType_MAX                     = 4,
};

// Enum BattlePrototype.EEnemyTickPriorityType
// NumValues: 0x0006
enum class EEnemyTickPriorityType : uint8
{
	Default                                  = 0,
	Everytime                                = 1,
	SometimeTop                              = 2,
	SometimeMiddle                           = 3,
	SometimeBottom                           = 4,
	EEnemyTickPriorityType_MAX               = 5,
};

// Enum BattlePrototype.EEnemyFindPlayerType
// NumValues: 0x0005
enum class EEnemyFindPlayerType : uint8
{
	NonBattle                                = 0,
	Notice                                   = 1,
	Battle                                   = 2,
	Lost                                     = 3,
	EEnemyFindPlayerType_MAX                 = 4,
};

// Enum BattlePrototype.EEnemyGrade
// NumValues: 0x0006
enum class EEnemyGrade : uint8
{
	Default                                  = 0,
	Boss                                     = 1,
	Simple                                   = 2,
	High                                     = 3,
	Low                                      = 4,
	EEnemyGrade_MAX                          = 5,
};

// Enum BattlePrototype.EEnemyThinkActionType
// NumValues: 0x0006
enum class EEnemyThinkActionType : uint8
{
	Default                                  = 0,
	Move                                     = 1,
	Action                                   = 2,
	Attack                                   = 3,
	Unique                                   = 4,
	EEnemyThinkActionType_MAX                = 5,
};

// Enum BattlePrototype.EEnemyCoreState
// NumValues: 0x0009
enum class EEnemyCoreState : uint8
{
	Free                                     = 0,
	Spawn                                    = 1,
	Stay                                     = 2,
	DestroyWait                              = 3,
	Destroy                                  = 4,
	BrainCrash                               = 5,
	BrainCrashVanish                         = 6,
	BrainCrashEnd                            = 7,
	EEnemyCoreState_MAX                      = 8,
};

// Enum BattlePrototype.EEnemyFormType
// NumValues: 0x0006
enum class EEnemyFormType : uint8
{
	Invalid                                  = 0,
	Form1                                    = 1,
	Form2                                    = 2,
	Form3                                    = 3,
	Form4                                    = 4,
	EEnemyFormType_MAX                       = 5,
};

// Enum BattlePrototype.EEnemyGuardType_em0320
// NumValues: 0x0004
enum class EEnemyGuardType_em0320 : uint8
{
	GuardFront_Top                           = 0,
	GuardToBack                              = 1,
	GuardBack_Top                            = 2,
	EEnemyGuardType_MAX                      = 3,
};

// Enum BattlePrototype.EEnemyStealthState
// NumValues: 0x0005
enum class EEnemyStealthState : uint8
{
	Invalid                                  = 0,
	StealthStart                             = 1,
	InStealth                                = 2,
	StealthEnd                               = 3,
	EEnemyStealthState_MAX                   = 4,
};

// Enum BattlePrototype.EEnemyWeaponMoveKind
// NumValues: 0x0009
enum class EEnemyWeaponMoveKind : uint8
{
	Invalid                                  = 0,
	Curve                                    = 1,
	Common                                   = 2,
	Projectile                               = 3,
	Gravity                                  = 4,
	Custom                                   = 5,
	Horming                                  = 6,
	Intercept                                = 7,
	EEnemyWeaponMoveKind_MAX                 = 8,
};

// Enum BattlePrototype.EEventPlMaterialType
// NumValues: 0x0011
enum class EEventPlMaterialType : uint8
{
	All                                      = 0,
	OffF                                     = 1,
	OffB                                     = 2,
	OffFB                                    = 3,
	OffO                                     = 4,
	OffFO                                    = 5,
	OffBO                                    = 6,
	OffFBO                                   = 7,
	OffG                                     = 8,
	OffFG                                    = 9,
	OffBG                                    = 10,
	OffFBG                                   = 11,
	OffOG                                    = 12,
	OffFOG                                   = 13,
	OffBOG                                   = 14,
	OffFBOG                                  = 15,
	EEventPlMaterialType_MAX                 = 16,
};

// Enum BattlePrototype.EEventCaptureType
// NumValues: 0x0004
enum class EEventCaptureType : uint8
{
	None                                     = 0,
	CharaFace                                = 1,
	Sequencer                                = 2,
	EEventCaptureType_MAX                    = 3,
};

// Enum BattlePrototype.EEventCaptureRenderType
// NumValues: 0x0005
enum class EEventCaptureRenderType : uint8
{
	Default                                  = 0,
	HighRes                                  = 1,
	ManyCaptureTAA                           = 2,
	HighResManyCapture                       = 3,
	EEventCaptureRenderType_MAX              = 4,
};

// Enum BattlePrototype.EEventUnControlManagerType
// NumValues: 0x0004
enum class EEventUnControlManagerType : uint8
{
	PlayerManager                            = 0,
	EnemyManager                             = 1,
	PsychicObjManager                        = 2,
	EEventUnControlManagerType_MAX           = 3,
};

// Enum BattlePrototype.EEventTriggerCheckType
// NumValues: 0x000E
enum class EEventTriggerCheckType : uint8
{
	Time                                     = 0,
	EnemyAllDie                              = 1,
	EnemyNumCheck                            = 2,
	EndBrainTalk                             = 3,
	IsTriggerPlayerAnimMontage               = 4,
	ObstructActionNumOrTime                  = 5,
	WinOrLose                                = 6,
	TagEnemyHpRateCheck                      = 7,
	DimensionTangleCheck                     = 8,
	BrainFieldClose                          = 9,
	EnpcBrainFieldTimeLimitEnd               = 10,
	BrainFieldRemainingTime                  = 11,
	None                                     = 12,
	Max                                      = 13,
};

// Enum BattlePrototype.EStaticEventType
// NumValues: 0x0005
enum class EStaticEventType : uint8
{
	Unknown                                  = 0,
	Easy                                     = 1,
	General                                  = 2,
	Special                                  = 3,
	Max                                      = 4,
};

// Enum BattlePrototype.EEventType
// NumValues: 0x0004
enum class EEventType : uint8
{
	Unknown                                  = 0,
	Static                                   = 1,
	Dynamic                                  = 2,
	Max                                      = 3,
};

// Enum BattlePrototype.EEventPostProcessID
// NumValues: 0x0027
enum class EEventPostProcessID : uint8
{
	PPM_Accelerator                          = 0,
	PPM_SeeThrough                           = 1,
	PPM_VisionFog                            = 2,
	PPM_RadialBlur                           = 3,
	PPM_Sepia                                = 4,
	PPM_Mono                                 = 5,
	PPM_Glitch                               = 6,
	PPM_VignetteMask                         = 7,
	PPM_ScreenLight                          = 8,
	PPM_ScreenMask                           = 9,
	PPM_ScreenMask_GradFilter                = 10,
	PPM_SoftFocus                            = 11,
	PPM_HeartBeat                            = 12,
	PPM_LightShaft                           = 13,
	PPM_AlphaMovie                           = 14,
	PPM_AnimeBlur                            = 15,
	PPM_FieldBlur                            = 16,
	PPM_FishEye                              = 17,
	PPM_ScreenMask_AfterDOF                  = 18,
	PPM_ScreenMask_GradFilter_AfterDOF       = 19,
	PPM_KaiiFilter                           = 20,
	PPM_BothSideLim                          = 21,
	PPM_LightUp                              = 22,
	PPM_FuturePrediction                     = 23,
	PPM_OutlineAfterimage                    = 24,
	PPM_Diffusion                            = 25,
	PPM_Shadowmap                            = 26,
	PPM_Stream                               = 27,
	PPM_KarenMemory                          = 28,
	PPM_REDStringsSignACBeat                 = 29,
	PPM_REDStringsSignBearding               = 30,
	PPM_REDStringsSignDotCraw                = 31,
	PPM_REDStringsSignDropout                = 32,
	PPM_REDStringsSignGhosting               = 33,
	PPM_REDStringsSignStrobing               = 34,
	PPM_REDStringsSignTapeDistortion         = 35,
	PPM_REDStringsSignYIQManipulation        = 36,
	PPM_REDStringsSignTapeDistortionVertical = 37,
	PPM_MAX                                  = 38,
};

// Enum BattlePrototype.EExporterType
// NumValues: 0x0004
enum class EExporterType : uint8
{
	MapIcon                                  = 0,
	ArrangeItem                              = 1,
	ShowDestination                          = 2,
	EExporterType_MAX                        = 3,
};

// Enum BattlePrototype.ESystemSaveDataCommonFlag
// NumValues: 0x0004
enum class ESystemSaveDataCommonFlag : uint8
{
	ExNewGame_Release_Message_Reading        = 0,
	EndContents_Release_Message_Reading      = 1,
	ExNewGame_Load_FirstMessage_Reading      = 2,
	Max                                      = 3,
};

// Enum BattlePrototype.ECharacterPhysicalActionType
// NumValues: 0x0010
enum class ECharacterPhysicalActionType : uint8
{
	Walk                                     = 0,
	Run                                      = 1,
	Dash                                     = 2,
	Leap                                     = 3,
	Jump                                     = 4,
	Rub                                      = 5,
	Landing                                  = 6,
	Down                                     = 7,
	Sliding                                  = 8,
	Hand                                     = 9,
	Knee                                     = 10,
	Weapon                                   = 11,
	Utility01                                = 12,
	Utility02                                = 13,
	Utility03                                = 14,
	MAX                                      = 15,
};

// Enum BattlePrototype.EGamePhysicalSurfaceType
// NumValues: 0x001B
enum class EGamePhysicalSurfaceType : uint8
{
	Default                                  = 0,
	Dummy01                                  = 1,
	Stone                                    = 2,
	Metal_Hard                               = 3,
	Metal_Board                              = 4,
	Metal_Net                                = 5,
	Metal_Box                                = 6,
	Metal_Stick                              = 7,
	Plastic                                  = 8,
	Marble                                   = 9,
	Water                                    = 10,
	Water_Deep                               = 11,
	Water_StrongViscosity                    = 12,
	Rubber                                   = 13,
	Snow                                     = 14,
	Ice                                      = 15,
	Ground                                   = 16,
	Grass                                    = 17,
	Wood_Dry                                 = 18,
	Wood_Wet                                 = 19,
	Rubble                                   = 20,
	Electric                                 = 21,
	Projection                               = 22,
	Fire                                     = 23,
	Concrete                                 = 24,
	Fabric                                   = 25,
	MAX                                      = 26,
};

// Enum BattlePrototype.EGimmickHorrorType
// NumValues: 0x0005
enum class EGimmickHorrorType : uint8
{
	GIMMICK_HORROR_TYPE_INVALID              = 0,
	GIMMICK_HORROR_TYPE_DISTANCE             = 1,
	GIMMICK_HORROR_TYPE_VISION               = 2,
	GIMMICK_HORROR_TYPE_DISTANCE2            = 3,
	GIMMICK_HORROR_TYPE_MAX                  = 4,
};

// Enum BattlePrototype.EHATETYPE
// NumValues: 0x0021
enum class EHATETYPE : uint8
{
	Attack                                   = 0,
	FirstAttack                              = 1,
	DownPlayer                               = 2,
	DownFriend                               = 3,
	DownOthers                               = 4,
	FirstPlayer                              = 5,
	FirstFriend                              = 6,
	FirstOthers                              = 7,
	TargetLockTime                           = 8,
	TargetLockRange                          = 9,
	TargetLockUpdateTime                     = 10,
	TargetLockNearTime                       = 11,
	TargetLockNearRange                      = 12,
	TargetLockNearUpdateTime                 = 13,
	FreeHateNum1                             = 14,
	FreeHateNum2                             = 15,
	FreeHateNum3                             = 16,
	Provoke                                  = 17,
	DecreaseAccumulationHate                 = 18,
	DecreaseTemporaryHate                    = 19,
	PlayerHateRate                           = 20,
	NpcHateRate                              = 21,
	DefaultBerserkHateRate                   = 22,
	SubHateRate                              = 23,
	FlameAddHate                             = 24,
	ElecAddHate                              = 25,
	FloodedAddHate                           = 26,
	OilAddHate                               = 27,
	ConfusionAddHate                         = 28,
	Basis                                    = 29,
	BasisDistance                            = 30,
	BasisPlayer                              = 31,
	EHATETYPE_MAX                            = 32,
};

// Enum BattlePrototype.EHelpImageDisplayPattern
// NumValues: 0x0003
enum class EHelpImageDisplayPattern : uint8
{
	None                                     = 0,
	Exist                                    = 1,
	EHelpImageDisplayPattern_MAX             = 2,
};

// Enum BattlePrototype.EHelpImageType
// NumValues: 0x0004
enum class EHelpImageType : uint8
{
	None                                     = 0,
	Picture                                  = 1,
	Movie                                    = 2,
	EHelpImageType_MAX                       = 3,
};

// Enum BattlePrototype.EHelpListCategory
// NumValues: 0x0005
enum class EHelpListCategory : uint8
{
	Battle                                   = 0,
	System                                   = 1,
	Num                                      = 2,
	All                                      = 2,
	EHelpListCategory_MAX                    = 3,
};

// Enum BattlePrototype.EDisplayedFlagOnTimming
// NumValues: 0x0003
enum class EDisplayedFlagOnTimming : uint8
{
	BeginedDisplay                           = 0,
	AfterDisplayed                           = 1,
	EDisplayedFlagOnTimming_MAX              = 2,
};

// Enum BattlePrototype.EHelpTutorial
// NumValues: 0x008E
enum class EHelpTutorial : uint8
{
	Tips_None                                = 0,
	Tips_Move                                = 1,
	Tips_ATK_yuito                           = 2,
	Tips_ATK_kasane                          = 3,
	Tips_Jump                                = 4,
	Tips_ATK_air_yuito                       = 5,
	Tips_ATK_air_kasane                      = 6,
	Tips_Lock                                = 7,
	Tips_UseItem                             = 8,
	Tips_Revive                              = 9,
	Tips_PSY                                 = 10,
	Tips_Special_OBJ                         = 11,
	Tips_PSYCombo                            = 12,
	Tips_BrainCrash                          = 13,
	Tips_Drive                               = 14,
	Tips_DriveBonus                          = 15,
	Tips_BrainField_01                       = 16,
	Tips_BrainField_02                       = 17,
	Tips_BrainField_enemy                    = 18,
	Tips_UseSAS                              = 19,
	Tips_SASRelease                          = 20,
	Tips_Hologram                            = 21,
	Tips_SASFire                             = 22,
	Tips_SASMetal                            = 23,
	Tips_SASTelepo                           = 24,
	Tips_SAS_SeeThrough                      = 25,
	Tips_SASCopy                             = 26,
	Tips_SASAccelerator                      = 27,
	Tips_SASElectric                         = 28,
	Tips_SASStealth                          = 29,
	Tips_SASPsy                              = 30,
	Tips_Debuff_Fire                         = 31,
	Tips_Debuff_Electric                     = 32,
	Tips_Debuff_Oil                          = 33,
	Tips_Debuff_Water                        = 34,
	Tips_Debuff_Confusion                    = 35,
	Tips_BattleField                         = 36,
	Tips_Stand_by                            = 37,
	Tips_Ajito                               = 38,
	Tips_BondsEpisode                        = 39,
	Tips_BondsLevel                          = 40,
	Tips_TeamBondsLevel                      = 41,
	Tips_Present                             = 42,
	Tips_Trade                               = 43,
	Tips_WishList                            = 44,
	Tips_Quest                               = 45,
	Tips_BrainMap_01                         = 46,
	Tips_BrainMap_02                         = 47,
	Tips_Party                               = 48,
	Tips_BrainMessage                        = 49,
	Tips_BrainMessage_Reply                  = 50,
	Tips_WorldMap                            = 51,
	Tips_Map                                 = 52,
	Tips_MiniMap                             = 53,
	Tips_Goal                                = 54,
	Tips_Collect                             = 55,
	Tips_MapGimmick_A                        = 56,
	Tips_MapGimmick_B                        = 57,
	Tips_Save                                = 58,
	Tips_EnemyBook                           = 59,
	Tips_CharBook                            = 60,
	Tips_Config                              = 61,
	Tips_DataTransfer                        = 62,
	Tips_ClearWorld                          = 63,
	Tips_Lock_PSY                            = 64,
	Tips_LockChange                          = 65,
	Tips_Dash                                = 66,
	Tips_ChaseAttack                         = 67,
	Tips_DriveEffect                         = 68,
	Tips_BattleLog                           = 69,
	Tips_Weakness                            = 70,
	Tips_Down                                = 71,
	Tips_BondsDeepen                         = 72,
	Tips_SASChange                           = 73,
	Tips_SASPageChange                       = 74,
	Tips_Profile_Yuito                       = 75,
	Tips_Profile_Kasane                      = 76,
	Tips_PSYCombo_mini                       = 77,
	Tips_ChaseAttack_mini                    = 78,
	Tips_BrainCrash_mini                     = 79,
	Tips_MapGimmick_C                        = 80,
	Tips_MapGimmick_D                        = 81,
	Tips_BrainCrash_Boss                     = 82,
	Tips_SASPsy_Kasane                       = 83,
	Tips_MapGimmick_E                        = 84,
	Tips_TeamBondsEpisode                    = 85,
	Tips_BrainField_03                       = 86,
	Tips_TacticsChange                       = 87,
	Tips_PsychicField                        = 88,
	Tips_ChaseAttack_Help                    = 89,
	Tips_MiniMap_Help                        = 90,
	Tips_Plugin                              = 91,
	Tips_JustAvoid                           = 92,
	Tips_JustAvoidAttack                     = 93,
	Tips_AssassinAttack                      = 94,
	Tips_AttackStage                         = 95,
	Tips_Help                                = 96,
	Tips_CourtMort                           = 97,
	Tips_SASFire_Kasane                      = 98,
	Tips_SASElectric_Kasane                  = 99,
	Tips_BrainCrash_02                       = 100,
	Tips_Lock_PSY_02                         = 101,
	Tips_Step                                = 102,
	Tips_ATK_yuito_02                        = 103,
	Tips_Slash                               = 104,
	Tips_ATK_All                             = 105,
	Tips_Lock_mini                           = 106,
	Tips_UseSAS_02                           = 107,
	Tips_SASRelease_02                       = 108,
	Tips_SASFire_02                          = 109,
	Tips_SASFire_Kasane_02                   = 110,
	Tips_SASElectric_02                      = 111,
	Tips_SASElectric_Kasane_02               = 112,
	Tips_SASMetal_02                         = 113,
	Tips_SASAccelerator_02                   = 114,
	Tips_SASTelepo_02                        = 115,
	Tips_SASCopy_02                          = 116,
	Tips_Profile_Yuito_02                    = 117,
	Tips_Profile_Yuito_02_mini               = 118,
	Tips_Profile_Kasane_02                   = 119,
	Tips_CombinationVision                   = 120,
	Tips_CombinationVision_mini              = 121,
	Tips_Intercept                           = 122,
	Tips_DefenseEnemy_yuito                  = 123,
	Tips_DefenseEnemy_kasane                 = 124,
	Tips_CombinationVision_02                = 125,
	Tips_Move_mini                           = 126,
	Tips_QuestIntroduction                   = 127,
	Tips_AddItemEnemy                        = 128,
	Tips_SpecialBondsEpisode                 = 129,
	Tips_CrashVision                         = 130,
	Tips_NexusDrive                          = 131,
	Tips_ClearGetter                         = 132,
	Tips_WeaponSkin                          = 133,
	Tips_BattleSimulator_01                  = 134,
	Tips_BattleSimulator_02                  = 135,
	Tips_AnimeKaren_01                       = 136,
	Tips_AnimeKaren_02                       = 137,
	Tips_DeepBond_01                         = 138,
	Tips_DeepBond_02                         = 139,
	Tips_KeyWordQuest                        = 140,
	Tips_Max                                 = 141,
};

// Enum BattlePrototype.HitBitKind
// NumValues: 0x0005
enum class EHitBitKind : uint8
{
	None                                     = 0,
	Character                                = 1,
	Flames                                   = 2,
	Destroy                                  = 4,
	HitBitKind_MAX                           = 5,
};

// Enum BattlePrototype.ECharacterHitPriority
// NumValues: 0x000E
enum class ECharacterHitPriority : uint8
{
	Fix                                      = 0,
	Telepo                                   = 1,
	Highest                                  = 2,
	EnemyHigh                                = 3,
	EnemyMiddle                              = 4,
	EnemyLow                                 = 5,
	PlayerHigh                               = 6,
	PlayerMiddle                             = 7,
	PlayerLow                                = 8,
	NpcMoveLeft                              = 9,
	NpcMoveRight                             = 10,
	NpcMoveEx                                = 11,
	Lowest                                   = 12,
	ECharacterHitPriority_MAX                = 13,
};

// Enum BattlePrototype.EHitParticleRotateType
// NumValues: 0x0004
enum class EHitParticleRotateType : uint8
{
	Default                                  = 0,
	CameraY                                  = 1,
	Random                                   = 2,
	EHitParticleRotateType_MAX               = 3,
};

// Enum BattlePrototype.ESpecialDamageTableType
// NumValues: 0x0004
enum class ESpecialDamageTableType : uint8
{
	Player                                   = 0,
	Npc                                      = 1,
	Enemy                                    = 2,
	ESpecialDamageTableType_MAX              = 3,
};

// Enum BattlePrototype.ESpecialDamageParticleType
// NumValues: 0x0007
enum class ESpecialDamageParticleType : uint8
{
	None                                     = 0,
	PlayerNormal                             = 1,
	PlayerObject                             = 2,
	EnemyNormal                              = 3,
	EnemyObject                              = 4,
	Num                                      = 5,
	ESpecialDamageParticleType_MAX           = 6,
};

// Enum BattlePrototype.EDamageSEType
// NumValues: 0x0007
enum class EDamageSEType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Object                                   = 2,
	Npc                                      = 3,
	MapGimmick                               = 4,
	Num                                      = 5,
	EDamageSEType_MAX                        = 6,
};

// Enum BattlePrototype.EDamageParticleType
// NumValues: 0x0012
enum class EDamageParticleType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Normal_Fire                              = 2,
	Normal_Electric                          = 3,
	Ch0200                                   = 4,
	Ch0200_Fire                              = 5,
	Ch0200_Electric                          = 6,
	Npc                                      = 7,
	Npc_Fire                                 = 8,
	Npc_Electric                             = 9,
	Object                                   = 10,
	Object_Fire                              = 11,
	Object_Electric                          = 12,
	MapGimmick                               = 13,
	MapGimmick_Fire                          = 14,
	MapGimmick_Electric                      = 15,
	Num                                      = 16,
	EDamageParticleType_MAX                  = 17,
};

// Enum BattlePrototype.EIntroTutorialType
// NumValues: 0x000E
enum class EIntroTutorialType : uint8
{
	Invalid                                  = 0,
	Move                                     = 1,
	Jump                                     = 2,
	PKAttack                                 = 3,
	LockOn                                   = 4,
	WPAttack                                 = 5,
	Step                                     = 6,
	TargetChange                             = 7,
	UpAttack                                 = 8,
	Dash                                     = 9,
	StepIn                                   = 10,
	ChaseAttack                              = 11,
	SpecialAttack                            = 12,
	EIntroTutorialType_MAX                   = 13,
};

// Enum BattlePrototype.EItemPresentSender
// NumValues: 0x0006
enum class EItemPresentSender : uint8
{
	Both                                     = 0,
	Male                                     = 1,
	Female                                   = 2,
	Event                                    = 3,
	Num                                      = 4,
	EItemPresentSender_MAX                   = 5,
};

// Enum BattlePrototype.EItemFavorability
// NumValues: 0x0005
enum class EItemFavorability : uint8
{
	Normal                                   = 0,
	Likely                                   = 1,
	Lovely                                   = 2,
	Num                                      = 3,
	EItemFavorability_MAX                    = 4,
};

// Enum BattlePrototype.EEffecacyRange
// NumValues: 0x0008
enum class EEffecacyRange : uint8
{
	Invalid                                  = 0,
	FriendSimple                             = 1,
	FriendAll                                = 2,
	EnemySimple                              = 3,
	EnemyAll                                 = 4,
	All                                      = 5,
	Num                                      = 6,
	EEffecacyRange_MAX                       = 7,
};

// Enum BattlePrototype.EItemRarity
// NumValues: 0x0008
enum class EItemRarity : uint8
{
	Invalid                                  = 0,
	None                                     = 1,
	Common                                   = 2,
	Rare                                     = 3,
	Epic                                     = 4,
	Legendary                                = 5,
	Num                                      = 6,
	EItemRarity_MAX                          = 7,
};

// Enum BattlePrototype.EEffecacyType
// NumValues: 0x003C
enum class EEffecacyType : uint8
{
	Invalid                                  = 0,
	Recovery                                 = 1,
	Buff                                     = 2,
	Attack                                   = 3,
	Weapon                                   = 4,
	Accessory                                = 5,
	AC_FlameAttenuation                      = 6,
	AC_OilAttenuation                        = 7,
	AC_ElectricAttenuation                   = 8,
	AC_FloodedAttenuation                    = 9,
	AC_ConfutionAttenuation                  = 10,
	AC_FlameShort                            = 11,
	AC_OilShort                              = 12,
	AC_ElectricShort                         = 13,
	AC_FloodedShort                          = 14,
	AC_ConfusionShort                        = 15,
	AC_BonusBonds                            = 16,
	AC_BonuxExp                              = 17,
	AC_BonuxBrainFieldGauge                  = 18,
	AC_NonBattleRecastUp                     = 19,
	AC_BonusGold                             = 20,
	AC_AttackUp                              = 21,
	AC_PsychicUp                             = 22,
	AC_DefenceUp                             = 23,
	AC_HPUp                                  = 24,
	AC_BonusOil                              = 25,
	AC_BonusFlame                            = 26,
	AC_BonusElectric                         = 27,
	AC_BonusFlooded                          = 28,
	AC_BonusConfusion                        = 29,
	AC_BonusCrash                            = 30,
	AC_BonusDrive                            = 31,
	AC_AttackAndDamageUp                     = 32,
	AC_PinchPowerUp                          = 33,
	AC_InvincibleAfterDamage                 = 34,
	AC_DrainHP                               = 35,
	AC_RecoveryDefeatEnemy                   = 36,
	AC_DodgeInvincibleUp                     = 37,
	AC_AutoCapture                           = 38,
	AC_AttackDownAndObjectUp                 = 39,
	AC_AttackUpAndObjectDown                 = 40,
	AC_EnchantOil                            = 41,
	AC_EnchantFlooded                        = 42,
	AC_EnchantConfusion                      = 43,
	AC_AttackDownAndCrashUp                  = 44,
	AC_AttackUpAndCrashDown                  = 45,
	AC_AutoRecovery                          = 46,
	AC_ArmorAttack                           = 47,
	AC_ArmorDodge                            = 48,
	ParameterUpMaxHP                         = 49,
	ParameterUpDying                         = 50,
	AC_SASRecastUp                           = 51,
	AC_SASExtendTime                         = 52,
	AC_BonusExpAndMoney                      = 53,
	AC_HpAndDefenceUp                        = 54,
	AC_DamageLimitter                        = 55,
	AC_CrashLimitter                         = 56,
	NotUse                                   = 57,
	Num                                      = 58,
	EEffecacyType_MAX                        = 59,
};

// Enum BattlePrototype.EItemIcon
// NumValues: 0x0024
enum class EItemIcon : uint8
{
	NONE                                     = 0,
	CURE_S_SOLO                              = 1,
	CURE_S_PARTY                             = 2,
	CURE_M_SOLO                              = 3,
	CURE_M_PARTY                             = 4,
	CURE_L_SOLO                              = 5,
	CURE_L_PARTY                             = 6,
	MEDICINE_SOLO                            = 7,
	MEDICINE_PARTY                           = 8,
	BRAIN_GAUGE_FULL                         = 9,
	SAS_GAUGE_FULL                           = 10,
	SPECIAL_OBJECT_TELEPORT_KEY              = 11,
	AGITATION                                = 12,
	KEY_ITEM                                 = 13,
	MATERIAL_0000                            = 14,
	MATERIAL_1000                            = 15,
	WEAPON_SWORD                             = 16,
	WEAPON_THROWING_KNIFE                    = 17,
	WEAPON_TORCH                             = 18,
	WEAPON_GLOBE                             = 19,
	WEAPON_REVOLVER                          = 20,
	WEAPON_HAMMER                            = 21,
	WEAPON_KNIFE                             = 22,
	WEAPON_METAL_ROD                         = 23,
	WEAPON_CROSSBOW                          = 24,
	WEAPON_CHAINSAW                          = 25,
	ACCESSORY_NECKLACE                       = 26,
	ACCESSORY_BANGLE                         = 27,
	ACCESSORY_RING                           = 28,
	ACCESSORY_TALISMAN                       = 29,
	COSTUME                                  = 30,
	ATTACHMENT_1                             = 31,
	AGITATION_LOOP                           = 32,
	DUMMY                                    = 33,
	CURRENCY                                 = 34,
	EItemIcon_MAX                            = 35,
};

// Enum BattlePrototype.EConsumeItemID
// NumValues: 0x0015
enum class EConsumeItemID : uint8
{
	None                                     = 0,
	It_0001                                  = 1,
	It_0002                                  = 2,
	It_0003                                  = 3,
	It_0004                                  = 4,
	It_0005                                  = 5,
	It_0006                                  = 6,
	It_0007                                  = 7,
	It_0008                                  = 8,
	It_0009                                  = 9,
	It_0010                                  = 10,
	It_0011                                  = 11,
	It_0012                                  = 12,
	It_0013                                  = 13,
	It_0014                                  = 14,
	It_0015                                  = 15,
	It_0016                                  = 16,
	It_0017                                  = 17,
	It_0018                                  = 18,
	It_0019                                  = 19,
	EConsumeItemID_MAX                       = 20,
};

// Enum BattlePrototype.EItemCategory
// NumValues: 0x0018
enum class EItemCategory : uint8
{
	Invalid                                  = 0,
	BattleItem                               = 1,
	Weapon                                   = 2,
	Accessory                                = 3,
	MaterialEN                               = 4,
	MaterialLC                               = 5,
	Base                                     = 6,
	KeyItem                                  = 7,
	Costume                                  = 8,
	Attachment_BackHead                      = 9,
	Attachment_FrontHead                     = 10,
	Attachment_Head                          = 11,
	Attachment_Eye                           = 12,
	Attachment_Ear                           = 13,
	Attachment_Mouth                         = 14,
	Attachment_Face                          = 15,
	Attachment_FrontBody                     = 16,
	Attachment_BackBody                      = 17,
	Attachment_Arm                           = 18,
	Attachment_Leg                           = 19,
	Food                                     = 20,
	Num                                      = 21,
	Attachment                               = 9,
	EItemCategory_MAX                        = 22,
};

// Enum BattlePrototype.EAreaInfoTweakType
// NumValues: 0x0005
enum class EAreaInfoTweakType : uint8
{
	TWEAKTYPE_ADD                            = 0,
	TWEAKTYPE_DELETE                         = 1,
	TWEAKTYPE_REPLACE                        = 2,
	NUM                                      = 3,
	EAreaInfoTweakType_MAX                   = 4,
};

// Enum BattlePrototype.EAreaInfoTweakConditionType
// NumValues: 0x000A
enum class EAreaInfoTweakConditionType : uint8
{
	EQUAL                                    = 0,
	NOT_EQUAL                                = 1,
	GREATER                                  = 2,
	GREATER_EQUAL                            = 3,
	LESSER                                   = 4,
	LESSER_EQUAL                             = 5,
	IS_ON                                    = 6,
	IS_OFF                                   = 7,
	NUM                                      = 8,
	EAreaInfoTweakConditionType_MAX          = 9,
};

// Enum BattlePrototype.EAreaInfoTweakCheckType
// NumValues: 0x001B
enum class EAreaInfoTweakCheckType : uint8
{
	PROGRESS                                 = 0,
	FLAG_BOOL                                = 1,
	FLAG_NUM                                 = 2,
	ITEM_NUM                                 = 3,
	FUNCTION                                 = 4,
	KIZUNA_PROGRESS_Y_KASANE                 = 5,
	KIZUNA_PROGRESS_Y_HANABI                 = 6,
	KIZUNA_PROGRESS_Y_GENMA                  = 7,
	KIZUNA_PROGRESS_Y_TSUGUMI                = 8,
	KIZUNA_PROGRESS_Y_LUKA                   = 9,
	KIZUNA_PROGRESS_Y_KAGEROU                = 10,
	KIZUNA_PROGRESS_Y_SHIDEN                 = 11,
	KIZUNA_PROGRESS_Y_KYOUKA                 = 12,
	KIZUNA_PROGRESS_Y_ARASHI                 = 13,
	KIZUNA_PROGRESS_K_YUITO                  = 14,
	KIZUNA_PROGRESS_K_HANABI                 = 15,
	KIZUNA_PROGRESS_K_GENMA                  = 16,
	KIZUNA_PROGRESS_K_TSUGUMI                = 17,
	KIZUNA_PROGRESS_K_LUKA                   = 18,
	KIZUNA_PROGRESS_K_KAGEROU                = 19,
	KIZUNA_PROGRESS_K_SHIDEN                 = 20,
	KIZUNA_PROGRESS_K_KYOUKA                 = 21,
	KIZUNA_PROGRESS_K_ARASHI                 = 22,
	PLAYER_IS_YUITO                          = 23,
	PLAYER_IS_KASANE                         = 24,
	NUM                                      = 25,
	EAreaInfoTweakCheckType_MAX              = 26,
};

// Enum BattlePrototype.EAreaInfoType
// NumValues: 0x0009
enum class EAreaInfoType : uint8
{
	BG                                       = 0,
	Enemy                                    = 1,
	Event                                    = 2,
	NPC                                      = 3,
	NObj                                     = 4,
	ArrangePoint                             = 5,
	SceneType                                = 6,
	NUM                                      = 7,
	EAreaInfoType_MAX                        = 8,
};

// Enum BattlePrototype.ELibraryFlagType
// NumValues: 0x0101
enum class ELibraryFlagType : uint8
{
	Invalid                                  = 0,
	LIBRARY_FLAG_001                         = 1,
	LIBRARY_FLAG_002                         = 2,
	LIBRARY_FLAG_003                         = 3,
	LIBRARY_FLAG_004                         = 4,
	LIBRARY_FLAG_005                         = 5,
	LIBRARY_FLAG_006                         = 6,
	LIBRARY_FLAG_007                         = 7,
	LIBRARY_FLAG_008                         = 8,
	LIBRARY_FLAG_009                         = 9,
	LIBRARY_FLAG_010                         = 10,
	LIBRARY_FLAG_011                         = 11,
	LIBRARY_FLAG_012                         = 12,
	LIBRARY_FLAG_013                         = 13,
	LIBRARY_FLAG_014                         = 14,
	LIBRARY_FLAG_015                         = 15,
	LIBRARY_FLAG_016                         = 16,
	LIBRARY_FLAG_017                         = 17,
	LIBRARY_FLAG_018                         = 18,
	LIBRARY_FLAG_019                         = 19,
	LIBRARY_FLAG_020                         = 20,
	LIBRARY_FLAG_021                         = 21,
	LIBRARY_FLAG_022                         = 22,
	LIBRARY_FLAG_023                         = 23,
	LIBRARY_FLAG_024                         = 24,
	LIBRARY_FLAG_025                         = 25,
	LIBRARY_FLAG_026                         = 26,
	LIBRARY_FLAG_027                         = 27,
	LIBRARY_FLAG_028                         = 28,
	LIBRARY_FLAG_029                         = 29,
	LIBRARY_FLAG_030                         = 30,
	LIBRARY_FLAG_031                         = 31,
	LIBRARY_FLAG_032                         = 32,
	LIBRARY_FLAG_033                         = 33,
	LIBRARY_FLAG_034                         = 34,
	LIBRARY_FLAG_035                         = 35,
	LIBRARY_FLAG_036                         = 36,
	LIBRARY_FLAG_037                         = 37,
	LIBRARY_FLAG_038                         = 38,
	LIBRARY_FLAG_039                         = 39,
	LIBRARY_FLAG_040                         = 40,
	LIBRARY_FLAG_041                         = 41,
	LIBRARY_FLAG_042                         = 42,
	LIBRARY_FLAG_043                         = 43,
	LIBRARY_FLAG_044                         = 44,
	LIBRARY_FLAG_045                         = 45,
	LIBRARY_FLAG_046                         = 46,
	LIBRARY_FLAG_047                         = 47,
	LIBRARY_FLAG_048                         = 48,
	LIBRARY_FLAG_049                         = 49,
	LIBRARY_FLAG_050                         = 50,
	LIBRARY_FLAG_051                         = 51,
	LIBRARY_FLAG_052                         = 52,
	LIBRARY_FLAG_053                         = 53,
	LIBRARY_FLAG_054                         = 54,
	LIBRARY_FLAG_055                         = 55,
	LIBRARY_FLAG_056                         = 56,
	LIBRARY_FLAG_057                         = 57,
	LIBRARY_FLAG_058                         = 58,
	LIBRARY_FLAG_059                         = 59,
	LIBRARY_FLAG_060                         = 60,
	LIBRARY_FLAG_061                         = 61,
	LIBRARY_FLAG_062                         = 62,
	LIBRARY_FLAG_063                         = 63,
	LIBRARY_FLAG_064                         = 64,
	LIBRARY_FLAG_065                         = 65,
	LIBRARY_FLAG_066                         = 66,
	LIBRARY_FLAG_067                         = 67,
	LIBRARY_FLAG_068                         = 68,
	LIBRARY_FLAG_069                         = 69,
	LIBRARY_FLAG_070                         = 70,
	LIBRARY_FLAG_071                         = 71,
	LIBRARY_FLAG_072                         = 72,
	LIBRARY_FLAG_073                         = 73,
	LIBRARY_FLAG_074                         = 74,
	LIBRARY_FLAG_075                         = 75,
	LIBRARY_FLAG_076                         = 76,
	LIBRARY_FLAG_077                         = 77,
	LIBRARY_FLAG_078                         = 78,
	LIBRARY_FLAG_079                         = 79,
	LIBRARY_FLAG_080                         = 80,
	LIBRARY_FLAG_081                         = 81,
	LIBRARY_FLAG_082                         = 82,
	LIBRARY_FLAG_083                         = 83,
	LIBRARY_FLAG_084                         = 84,
	LIBRARY_FLAG_085                         = 85,
	LIBRARY_FLAG_086                         = 86,
	LIBRARY_FLAG_087                         = 87,
	LIBRARY_FLAG_088                         = 88,
	LIBRARY_FLAG_089                         = 89,
	LIBRARY_FLAG_090                         = 90,
	LIBRARY_FLAG_091                         = 91,
	LIBRARY_FLAG_092                         = 92,
	LIBRARY_FLAG_093                         = 93,
	LIBRARY_FLAG_094                         = 94,
	LIBRARY_FLAG_095                         = 95,
	LIBRARY_FLAG_096                         = 96,
	LIBRARY_FLAG_097                         = 97,
	LIBRARY_FLAG_098                         = 98,
	LIBRARY_FLAG_099                         = 99,
	LIBRARY_FLAG_100                         = 100,
	LIBRARY_FLAG_101                         = 101,
	LIBRARY_FLAG_102                         = 102,
	LIBRARY_FLAG_103                         = 103,
	LIBRARY_FLAG_104                         = 104,
	LIBRARY_FLAG_105                         = 105,
	LIBRARY_FLAG_106                         = 106,
	LIBRARY_FLAG_107                         = 107,
	LIBRARY_FLAG_108                         = 108,
	LIBRARY_FLAG_109                         = 109,
	LIBRARY_FLAG_110                         = 110,
	LIBRARY_FLAG_111                         = 111,
	LIBRARY_FLAG_112                         = 112,
	LIBRARY_FLAG_113                         = 113,
	LIBRARY_FLAG_114                         = 114,
	LIBRARY_FLAG_115                         = 115,
	LIBRARY_FLAG_116                         = 116,
	LIBRARY_FLAG_117                         = 117,
	LIBRARY_FLAG_118                         = 118,
	LIBRARY_FLAG_119                         = 119,
	LIBRARY_FLAG_120                         = 120,
	LIBRARY_FLAG_121                         = 121,
	LIBRARY_FLAG_122                         = 122,
	LIBRARY_FLAG_123                         = 123,
	LIBRARY_FLAG_124                         = 124,
	LIBRARY_FLAG_125                         = 125,
	LIBRARY_FLAG_126                         = 126,
	LIBRARY_FLAG_127                         = 127,
	LIBRARY_FLAG_128                         = 128,
	LIBRARY_FLAG_129                         = 129,
	LIBRARY_FLAG_130                         = 130,
	LIBRARY_FLAG_131                         = 131,
	LIBRARY_FLAG_132                         = 132,
	LIBRARY_FLAG_133                         = 133,
	LIBRARY_FLAG_134                         = 134,
	LIBRARY_FLAG_135                         = 135,
	LIBRARY_FLAG_136                         = 136,
	LIBRARY_FLAG_137                         = 137,
	LIBRARY_FLAG_138                         = 138,
	LIBRARY_FLAG_139                         = 139,
	LIBRARY_FLAG_140                         = 140,
	LIBRARY_FLAG_141                         = 141,
	LIBRARY_FLAG_142                         = 142,
	LIBRARY_FLAG_143                         = 143,
	LIBRARY_FLAG_144                         = 144,
	LIBRARY_FLAG_145                         = 145,
	LIBRARY_FLAG_146                         = 146,
	LIBRARY_FLAG_147                         = 147,
	LIBRARY_FLAG_148                         = 148,
	LIBRARY_FLAG_149                         = 149,
	LIBRARY_FLAG_150                         = 150,
	LIBRARY_FLAG_151                         = 151,
	LIBRARY_FLAG_152                         = 152,
	LIBRARY_FLAG_153                         = 153,
	LIBRARY_FLAG_154                         = 154,
	LIBRARY_FLAG_155                         = 155,
	LIBRARY_FLAG_156                         = 156,
	LIBRARY_FLAG_157                         = 157,
	LIBRARY_FLAG_158                         = 158,
	LIBRARY_FLAG_159                         = 159,
	LIBRARY_FLAG_160                         = 160,
	LIBRARY_FLAG_161                         = 161,
	LIBRARY_FLAG_162                         = 162,
	LIBRARY_FLAG_163                         = 163,
	LIBRARY_FLAG_164                         = 164,
	LIBRARY_FLAG_165                         = 165,
	LIBRARY_FLAG_166                         = 166,
	LIBRARY_FLAG_167                         = 167,
	LIBRARY_FLAG_168                         = 168,
	LIBRARY_FLAG_169                         = 169,
	LIBRARY_FLAG_170                         = 170,
	LIBRARY_FLAG_171                         = 171,
	LIBRARY_FLAG_172                         = 172,
	LIBRARY_FLAG_173                         = 173,
	LIBRARY_FLAG_174                         = 174,
	LIBRARY_FLAG_175                         = 175,
	LIBRARY_FLAG_176                         = 176,
	LIBRARY_FLAG_177                         = 177,
	LIBRARY_FLAG_178                         = 178,
	LIBRARY_FLAG_179                         = 179,
	LIBRARY_FLAG_180                         = 180,
	LIBRARY_FLAG_181                         = 181,
	LIBRARY_FLAG_182                         = 182,
	LIBRARY_FLAG_183                         = 183,
	LIBRARY_FLAG_184                         = 184,
	LIBRARY_FLAG_185                         = 185,
	LIBRARY_FLAG_186                         = 186,
	LIBRARY_FLAG_187                         = 187,
	LIBRARY_FLAG_188                         = 188,
	LIBRARY_FLAG_189                         = 189,
	LIBRARY_FLAG_190                         = 190,
	LIBRARY_FLAG_191                         = 191,
	LIBRARY_FLAG_192                         = 192,
	LIBRARY_FLAG_193                         = 193,
	LIBRARY_FLAG_194                         = 194,
	LIBRARY_FLAG_195                         = 195,
	LIBRARY_FLAG_196                         = 196,
	LIBRARY_FLAG_197                         = 197,
	LIBRARY_FLAG_198                         = 198,
	LIBRARY_FLAG_199                         = 199,
	LIBRARY_FLAG_200                         = 200,
	LIBRARY_FLAG_201                         = 201,
	LIBRARY_FLAG_202                         = 202,
	LIBRARY_FLAG_203                         = 203,
	LIBRARY_FLAG_204                         = 204,
	LIBRARY_FLAG_205                         = 205,
	LIBRARY_FLAG_206                         = 206,
	LIBRARY_FLAG_207                         = 207,
	LIBRARY_FLAG_208                         = 208,
	LIBRARY_FLAG_209                         = 209,
	LIBRARY_FLAG_210                         = 210,
	LIBRARY_FLAG_211                         = 211,
	LIBRARY_FLAG_212                         = 212,
	LIBRARY_FLAG_213                         = 213,
	LIBRARY_FLAG_214                         = 214,
	LIBRARY_FLAG_215                         = 215,
	LIBRARY_FLAG_216                         = 216,
	LIBRARY_FLAG_217                         = 217,
	LIBRARY_FLAG_218                         = 218,
	LIBRARY_FLAG_219                         = 219,
	LIBRARY_FLAG_220                         = 220,
	LIBRARY_FLAG_221                         = 221,
	LIBRARY_FLAG_222                         = 222,
	LIBRARY_FLAG_223                         = 223,
	LIBRARY_FLAG_224                         = 224,
	LIBRARY_FLAG_225                         = 225,
	LIBRARY_FLAG_226                         = 226,
	LIBRARY_FLAG_227                         = 227,
	LIBRARY_FLAG_228                         = 228,
	LIBRARY_FLAG_229                         = 229,
	LIBRARY_FLAG_230                         = 230,
	LIBRARY_FLAG_231                         = 231,
	LIBRARY_FLAG_232                         = 232,
	LIBRARY_FLAG_233                         = 233,
	LIBRARY_FLAG_234                         = 234,
	LIBRARY_FLAG_235                         = 235,
	LIBRARY_FLAG_236                         = 236,
	LIBRARY_FLAG_237                         = 237,
	LIBRARY_FLAG_238                         = 238,
	LIBRARY_FLAG_239                         = 239,
	LIBRARY_FLAG_240                         = 240,
	LIBRARY_FLAG_241                         = 241,
	LIBRARY_FLAG_242                         = 242,
	LIBRARY_FLAG_243                         = 243,
	LIBRARY_FLAG_244                         = 244,
	LIBRARY_FLAG_245                         = 245,
	LIBRARY_FLAG_246                         = 246,
	LIBRARY_FLAG_247                         = 247,
	LIBRARY_FLAG_248                         = 248,
	LIBRARY_FLAG_249                         = 249,
	LIBRARY_FLAG_250                         = 250,
	LIBRARY_FLAG_251                         = 251,
	LIBRARY_FLAG_252                         = 252,
	LIBRARY_FLAG_253                         = 253,
	LIBRARY_FLAG_254                         = 254,
	LIBRARY_FLAG_255                         = 255,
	ELibraryFlagType_MAX                     = 256,
};

// Enum BattlePrototype.ELoadingTipsCategory
// NumValues: 0x0008
enum class ELoadingTipsCategory : uint8
{
	Scenario                                 = 0,
	System                                   = 1,
	Info                                     = 2,
	Location                                 = 3,
	RetryBoss                                = 4,
	RetryBrainField                          = 5,
	Num                                      = 6,
	ELoadingTipsCategory_MAX                 = 7,
};

// Enum BattlePrototype.ELoadingTipsPriority
// NumValues: 0x0003
enum class ELoadingTipsPriority : uint8
{
	Normal                                   = 0,
	High                                     = 1,
	ELoadingTipsPriority_MAX                 = 2,
};

// Enum BattlePrototype.EEventSaveLoadExType
// NumValues: 0x0004
enum class EEventSaveLoadExType : uint8
{
	EVENTSAVELOADSUBTYPE_NORMAL              = 0,
	EVENTSAVELOADSUBTYPE_EXMODE              = 1,
	EVENTSHOPTYPE_NUM                        = 2,
	EEventSaveLoadExType_MAX                 = 3,
};

// Enum BattlePrototype.EEventSaveLoadType
// NumValues: 0x0004
enum class EEventSaveLoadType : uint8
{
	EVENTSAVELOADTYPE_SAVE                   = 0,
	EVENTSAVELOADTYPE_LOAD                   = 1,
	EVENTSHOPTYPE_NUM                        = 2,
	EEventSaveLoadType_MAX                   = 3,
};

// Enum BattlePrototype.EEventShopType
// NumValues: 0x0005
enum class EEventShopType : uint8
{
	EVENTSHOPTYPE_BUY                        = 0,
	EVENTSHOPTYPE_SELL                       = 1,
	EVENTSHOPTYPE_TRADE                      = 2,
	EVENTSHOPTYPE_NUM                        = 3,
	EVENTSHOPTYPE_MAX                        = 4,
};

// Enum BattlePrototype.EStaticPlType
// NumValues: 0x000C
enum class EStaticPlType : uint8
{
	None                                     = 0,
	MovieTexture                             = 1,
	BrainTalk                                = 2,
	Telepathy                                = 3,
	Naomi                                    = 4,
	Image                                    = 5,
	NoRandomPlSet                            = 6,
	ChangeBackGroundPl                       = 7,
	BloodDecalPl                             = 8,
	WireOffPl                                = 9,
	WireOnPl                                 = 10,
	EStaticPlType_MAX                        = 11,
};

// Enum BattlePrototype.ESequenceSkipPhase
// NumValues: 0x0003
enum class ESequenceSkipPhase : uint8
{
	None                                     = 0,
	WaitSkip                                 = 1,
	ESequenceSkipPhase_MAX                   = 2,
};

// Enum BattlePrototype.EStoreSeqCapStatus
// NumValues: 0x0005
enum class EStoreSeqCapStatus : uint8
{
	None                                     = 0,
	WaitFadeOut                              = 1,
	WaitStoreSeq                             = 2,
	EndFade                                  = 3,
	EStoreSeqCapStatus_MAX                   = 4,
};

// Enum BattlePrototype.EEventWaitMode
// NumValues: 0x002D
enum class EEventWaitMode : uint8
{
	None                                     = 0,
	Timer                                    = 1,
	Message                                  = 2,
	GeneralChoice                            = 3,
	Input                                    = 4,
	EndMotion                                = 5,
	DynamicCutscene                          = 6,
	PostProcessSequencer                     = 7,
	AnimMontage                              = 8,
	LoadAsset                                = 9,
	LoadAssetAll                             = 10,
	Fade                                     = 11,
	Shop                                     = 12,
	SaveLoad                                 = 13,
	LoadChangeScene                          = 14,
	BrainField                               = 15,
	BrainFieldTuto                           = 16,
	SubQuestReward                           = 17,
	PhaseAnimation                           = 18,
	NewStaticInGeneralAnimation              = 19,
	TutoTips                                 = 20,
	TutoOperationTips                        = 21,
	SequencerCapture                         = 22,
	SequencerCaptureBG                       = 23,
	EndSubMenu                               = 24,
	EndBrainTalk                             = 25,
	EndPrepareMovie                          = 26,
	CharacterEventMoveEnd                    = 27,
	SkipEvent                                = 28,
	WaitBrainFieldButton                     = 29,
	WaitSASCutinExtra                        = 30,
	WaitEventTips                            = 31,
	WaitCreditEvent                          = 32,
	WaitLoadMakeEventAsset                   = 33,
	WaitSASCutinCh0500_0700                  = 34,
	WaitSASCutinCH0400_0600                  = 35,
	WaitLogMessage                           = 36,
	WaitSasWindow                            = 37,
	WaitBrainFieldDangerLV                   = 38,
	WaitMipLoadReady                         = 39,
	WaitMipLoadReadyMesh                     = 40,
	WaitCloseSystemMessage                   = 41,
	EndCode                                  = 42,
	EndKeyword                               = 43,
	EEventWaitMode_MAX                       = 44,
};

// Enum BattlePrototype.EManagerProcTiming
// NumValues: 0x000C
enum class EManagerProcTiming : uint8
{
	Launch                                   = 0,
	StartLogo                                = 1,
	FinishLogo                               = 2,
	StartTitle                               = 3,
	FinishTitle                              = 4,
	StartIngame                              = 5,
	FinishIngame                             = 6,
	StartDebug                               = 7,
	FinishDebug                              = 8,
	StartPersistentLevel                     = 9,
	Num                                      = 10,
	EManagerProcTiming_MAX                   = 11,
};

// Enum BattlePrototype.EManagerTypeID
// NumValues: 0x0032
enum class EManagerTypeID : uint8
{
	RenderTarget                             = 0,
	Input                                    = 1,
	Resource                                 = 2,
	Scene                                    = 3,
	Level                                    = 4,
	PostProcess                              = 5,
	ParallelObject                           = 6,
	Database                                 = 7,
	AddContentManager                        = 8,
	AnimeInterlockingManager                 = 9,
	Achievement                              = 10,
	RSAccountManager                         = 11,
	Sound                                    = 12,
	ParticleSystem                           = 13,
	Movie                                    = 14,
	MessageHud                               = 15,
	UserParam                                = 16,
	Flag                                     = 17,
	Event                                    = 18,
	Player                                   = 19,
	Hit                                      = 20,
	BrainCrash                               = 21,
	SAS                                      = 22,
	PsychicObject                            = 23,
	BlendableVolume                          = 24,
	Enemy                                    = 25,
	BrainField                               = 26,
	RadialBlur                               = 27,
	Bsp                                      = 28,
	Battle                                   = 29,
	Battlefield                              = 30,
	Stage                                    = 31,
	Action                                   = 32,
	BrainTalk                                = 33,
	ArrangeItem                              = 34,
	DropItem                                 = 35,
	GameMain                                 = 36,
	GameSystem                               = 37,
	SaveLoadParamClass                       = 38,
	InGameFlow                               = 39,
	FinishManager                            = 40,
	MapGimmick                               = 41,
	LC21MapGimmick                           = 42,
	CosmosWeb                                = 43,
	TriggerEffect                            = 44,
	ActivityManager                          = 45,
	XGameStreaming                           = 46,
	ClearGetter                              = 47,
	Num                                      = 48,
	EManagerTypeID_MAX                       = 49,
};

// Enum BattlePrototype.EMapGimmickFinishDir
// NumValues: 0x0006
enum class EMapGimmickFinishDir : uint8
{
	MGDIR_FORWARD                            = 0,
	MGDIR_RIGHT                              = 1,
	MGDIR_LEFT                               = 2,
	MGDIR_BACK                               = 3,
	Num                                      = 4,
	EMapGimmickFinishDir_MAX                 = 5,
};

// Enum BattlePrototype.EMapGimmickStatusFunc
// NumValues: 0x0006
enum class EMapGimmickStatusFunc : uint8
{
	MGSTATUS_STATE_BEGIN                     = 0,
	MGSTATUS_TICK                            = 1,
	MGSTATUS_STATE_END                       = 2,
	MGSTATUS_ON_REQUEST_CANCEL               = 3,
	Num                                      = 4,
	EMapGimmickStatusFunc_MAX                = 5,
};

// Enum BattlePrototype.EMapGimmickPlayerPlace
// NumValues: 0x0005
enum class EMapGimmickPlayerPlace : uint8
{
	MG_PLAYER_PLACE_DEFAULT                  = 0,
	MG_PLAYER_PLACE_UP                       = 0,
	MG_PLAYER_PLACE_DOWN                     = 1,
	Num                                      = 2,
	EMapGimmickPlayerPlace_MAX               = 3,
};

// Enum BattlePrototype.EMapGimmickPlayerAnimType
// NumValues: 0x0006
enum class EMapGimmickPlayerAnimType : uint8
{
	MG_PLANIM_START                          = 0,
	MG_PLANIM_LOOP                           = 1,
	MG_PLANIM_END                            = 2,
	MG_PLANIM_FINISH                         = 3,
	Num                                      = 4,
	EMapGimmickPlayerAnimType_MAX            = 5,
};

// Enum BattlePrototype.EMapGimmickType
// NumValues: 0x001D
enum class EMapGimmickType : uint8
{
	MGIMMICKTYPE_UNKNOWN                     = 0,
	MGIMMICKTYPE_HANGED_RESOURCE             = 1,
	MGIMMICKTYPE_TRAIN                       = 2,
	MGIMMICKTYPE_HOOK                        = 3,
	MGIMMICKTYPE_HIGHWAY_FENCE               = 4,
	MGIMMICKTYPE_TANKLORRY                   = 5,
	MGIMMICKTYPE_BELTCONVEYOR                = 6,
	MGIMMICKTYPE_MOVABLEBRIDGE               = 7,
	MGIMMICKTYPE_TELEPORTWALL                = 8,
	MGIMMICKTYPE_CAMERAGATE                  = 9,
	MGIMMICKTYPE_GATE                        = 10,
	MGIMMICKTYPE_CONSOLE                     = 11,
	MGIMMICKTYPE_LASERGATE                   = 12,
	MGIMMICKTYPE_STEELMESH                   = 13,
	MGIMMICKTYPE_CARDDOOR                    = 14,
	MGIMMICKTYPE_STEAMPIPE                   = 15,
	MGIMMICKTYPE_BIGICE                      = 16,
	MGIMMICKTYPE_BIGICEOBJECT                = 17,
	MGIMMICKTYPE_PSYCHICMOVEROAD             = 18,
	MGIMMICKTYPE_SWITCHBOARD                 = 19,
	MGIMMICKTYPE_SWITCHBOARDGATE             = 20,
	MGIMMICKTYPE_TRANSFORMER                 = 21,
	MGIMMICKTYPE_DUMPCAR                     = 22,
	MGIMMICKTYPE_SIMPLEGATE                  = 23,
	MGIMMICKTYPE_OBSERVATOR                  = 24,
	MGIMMICKTYPE_ELECTRICLOCK                = 25,
	MGIMMICKTYPE_BIGICE_ATTACK               = 26,
	Num                                      = 27,
	EMapGimmickType_MAX                      = 28,
};

// Enum BattlePrototype.ELiftFloorInfoId
// NumValues: 0x0004
enum class ELiftFloorInfoId : uint8
{
	Invalid                                  = 0,
	LC07                                     = 0,
	LC09                                     = 1,
	ELiftFloorInfoId_MAX                     = 2,
};

// Enum BattlePrototype.EMapGimmickStateRequest
// NumValues: 0x0004
enum class EMapGimmickStateRequest : uint8
{
	MGEVENT_START_CHARGE                     = 0,
	MGEVENT_CANCEL_CHARGE                    = 1,
	Num                                      = 2,
	EMapGimmickStateRequest_MAX              = 3,
};

// Enum BattlePrototype.EMaterialAccessorSetupID
// NumValues: 0x0004
enum class EMaterialAccessorSetupID : uint8
{
	NoWrite                                  = 0,
	TakeDefault                              = 1,
	Overwrite                                = 2,
	EMaterialAccessorSetupID_MAX             = 3,
};

// Enum BattlePrototype.EMaterialShadowOffsetID
// NumValues: 0x0005
enum class EMaterialShadowOffsetID : uint8
{
	Default                                  = 0,
	ShadowOffsetMap_R                        = 1,
	ShadowOffsetMap_G                        = 2,
	ShadowOffsetMap_B                        = 3,
	EMaterialShadowOffsetID_MAX              = 4,
};

// Enum BattlePrototype.EMsgViewerDataType
// NumValues: 0x0003
enum class EMsgViewerDataType : uint8
{
	MsgViewerMessage                         = 0,
	MsgViewerText                            = 1,
	EMsgViewerDataType_MAX                   = 2,
};

// Enum BattlePrototype.ENormalFixedCameraType
// NumValues: 0x0004
enum class ENormalFixedCameraType : uint8
{
	NFC_NowCamera                            = 0,
	NFC_Direct                               = 1,
	NumOfEnum                                = 2,
	ENormalFixedCameraType_MAX               = 3,
};

// Enum BattlePrototype.ENpcMeshSkeletonType
// NumValues: 0x0005
enum class ENpcMeshSkeletonType : uint8
{
	Man                                      = 0,
	Woman                                    = 1,
	Child                                    = 2,
	Special                                  = 3,
	Max                                      = 4,
};

// Enum BattlePrototype.EOptimizeMaterialCheckResultType
// NumValues: 0x0004
enum class EOptimizeMaterialCheckResultType : uint8
{
	OMCR_OFF                                 = 0,
	OMCR_ON                                  = 1,
	OMCR_ON_REVERSE                          = 2,
	OMCR_MAX                                 = 3,
};

// Enum BattlePrototype.EOptimizeMaterialConditionBranch
// NumValues: 0x0003
enum class EOptimizeMaterialConditionBranch : uint8
{
	AND                                      = 0,
	OR                                       = 1,
	EOptimizeMaterialConditionBranch_MAX     = 2,
};

// Enum BattlePrototype.EOptimizeMaterialConditionType
// NumValues: 0x0007
enum class EOptimizeMaterialConditionType : uint8
{
	LESS                                     = 0,
	LESS_EQUAL                               = 1,
	EQUAL                                    = 2,
	NOT_EQUAL                                = 3,
	GREATOR                                  = 4,
	GREATOR_EQUAL                            = 5,
	EOptimizeMaterialConditionType_MAX       = 6,
};

// Enum BattlePrototype.ECameraAfterMoveType
// NumValues: 0x0005
enum class ECameraAfterMoveType : uint8
{
	On                                       = 0,
	Off                                      = 1,
	Num                                      = 2,
	Default                                  = 1,
	ECameraAfterMoveType_MAX                 = 3,
};

// Enum BattlePrototype.ELockonActionType
// NumValues: 0x0005
enum class ELockonActionType : uint8
{
	R1R3                                     = 0,
	R3                                       = 1,
	Num                                      = 2,
	Default                                  = 0,
	ELockonActionType_MAX                    = 3,
};

// Enum BattlePrototype.ETargetAutoChange
// NumValues: 0x0005
enum class ETargetAutoChange : uint8
{
	On                                       = 0,
	Off                                      = 1,
	Num                                      = 2,
	Default                                  = 0,
	ETargetAutoChange_MAX                    = 3,
};

// Enum BattlePrototype.ETargetCameraTrace
// NumValues: 0x0005
enum class ETargetCameraTrace : uint8
{
	On                                       = 0,
	Off                                      = 1,
	Num                                      = 2,
	Default                                  = 1,
	ETargetCameraTrace_MAX                   = 3,
};

// Enum BattlePrototype.EAttackAutoLockOn
// NumValues: 0x0005
enum class EAttackAutoLockOn : uint8
{
	On                                       = 0,
	Off                                      = 1,
	Num                                      = 2,
	Default                                  = 0,
	EAttackAutoLockOn_MAX                    = 3,
};

// Enum BattlePrototype.EEventMessageAutoPlay
// NumValues: 0x0005
enum class EEventMessageAutoPlay : uint8
{
	On                                       = 0,
	Off                                      = 1,
	Num                                      = 2,
	Default                                  = 0,
	EEventMessageAutoPlay_MAX                = 3,
};

// Enum BattlePrototype.EChangeableControllerDefaultKeys
// NumValues: 0x000B
enum class EChangeableControllerDefaultKeys : uint8
{
	Invalid                                  = 0,
	WeaponAttackDefault                      = 8,
	JumpDefault                              = 7,
	PsychicDefault                           = 1,
	PsychicSpecialDefault                    = 4,
	CombiVisionMenuOpenDefault               = 3,
	SasMenuOpenCloseDefault                  = 0,
	StepDashDefault                          = 9,
	WeaponAttackSubDefault                   = 6,
	SasChangeDefault                         = 50,
	EChangeableControllerDefaultKeys_MAX     = 51,
};

// Enum BattlePrototype.EChangeableControllerKey
// NumValues: 0x000C
enum class EChangeableControllerKey : uint8
{
	WeaponAttack                             = 0,
	Jump                                     = 1,
	Psychic                                  = 2,
	PsychicSpecial                           = 3,
	CombiVisionMenuOpen                      = 4,
	SasMenuOpenClose                         = 5,
	StepDash                                 = 6,
	WeaponAttackSub                          = 7,
	SasChange                                = 8,
	Num                                      = 9,
	Default                                  = 0,
	EChangeableControllerKey_MAX             = 10,
};

// Enum BattlePrototype.EFPSType
// NumValues: 0x0006
enum class EFPSType : uint8
{
	Thirty                                   = 0,
	Sixty                                    = 1,
	NotFixed                                 = 2,
	Num                                      = 3,
	Default                                  = 1,
	EFPSType_MAX                             = 4,
};

// Enum BattlePrototype.EGradualQuality
// NumValues: 0x0009
enum class EGradualQuality : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Num                                      = 3,
	Default                                  = 2,
	DefaultTextureQuality                    = 2,
	DefaultShadowQuality                     = 2,
	DefaultPosproQuality                     = 2,
	EGradualQuality_MAX                      = 4,
};

// Enum BattlePrototype.EOptionAAQuality
// NumValues: 0x0006
enum class EOptionAAQuality : uint8
{
	None                                     = 0,
	FXAA                                     = 1,
	TXAA                                     = 2,
	Num                                      = 3,
	Default                                  = 2,
	EOptionAAQuality_MAX                     = 4,
};

// Enum BattlePrototype.EOptionDisplayEnemyDamage
// NumValues: 0x0005
enum class EOptionDisplayEnemyDamage : uint8
{
	On                                       = 0,
	Off                                      = 1,
	Num                                      = 2,
	Default                                  = 0,
	EOptionDisplayEnemyDamage_MAX            = 3,
};

// Enum BattlePrototype.EOptionControllerVibration
// NumValues: 0x0005
enum class EOptionControllerVibration : uint8
{
	On                                       = 0,
	Off                                      = 1,
	Num                                      = 2,
	Default                                  = 0,
	EOptionControllerVibration_MAX           = 3,
};

// Enum BattlePrototype.EOptionCameraYaw
// NumValues: 0x0005
enum class EOptionCameraYaw : uint8
{
	Normal                                   = 0,
	Reverse                                  = 1,
	Num                                      = 2,
	Default                                  = 0,
	EOptionCameraYaw_MAX                     = 3,
};

// Enum BattlePrototype.EOptionCameraPitch
// NumValues: 0x0005
enum class EOptionCameraPitch : uint8
{
	Normal                                   = 0,
	Reverse                                  = 1,
	Num                                      = 2,
	Default                                  = 0,
	EOptionCameraPitch_MAX                   = 3,
};

// Enum BattlePrototype.EOptionCameraRotateSpeed
// NumValues: 0x0004
enum class EOptionCameraRotateSpeed : uint8
{
	Invalid                                  = 0,
	Min                                      = 1,
	Max                                      = 5,
	Default                                  = 4,
};

// Enum BattlePrototype.EOptionSoundOutput
// NumValues: 0x0006
enum class EOptionSoundOutput : uint8
{
	Stereo                                   = 0,
	Monaural                                 = 1,
	Surround                                 = 2,
	Num                                      = 3,
	Default                                  = 0,
	EOptionSoundOutput_MAX                   = 4,
};

// Enum BattlePrototype.EOptionVolumeParam
// NumValues: 0x0003
enum class EOptionVolumeParam : uint8
{
	Min                                      = 0,
	Max                                      = 100,
	Default                                  = 50,
};

// Enum BattlePrototype.EOptionVoiceLanguage
// NumValues: 0x0005
enum class EOptionVoiceLanguage : uint8
{
	Invalid                                  = 0,
	Japanese                                 = 0,
	English                                  = 1,
	Num                                      = 2,
	EOptionVoiceLanguage_MAX                 = 3,
};

// Enum BattlePrototype.EOptionDisplayLanguageAll
// NumValues: 0x000F
enum class EOptionDisplayLanguageAll : uint8
{
	Invalid                                  = 0,
	Japanese                                 = 0,
	English                                  = 1,
	French                                   = 2,
	Italian                                  = 3,
	Deutsch                                  = 4,
	Espanol                                  = 5,
	PortugalBR                               = 7,
	NeutralEspanol                           = 6,
	Russian                                  = 8,
	ChineseT                                 = 9,
	ChineseS                                 = 10,
	Korean                                   = 11,
	Num                                      = 12,
	EOptionDisplayLanguageAll_MAX            = 13,
};

// Enum BattlePrototype.EOptionDisplayLanguageASIA
// NumValues: 0x0006
enum class EOptionDisplayLanguageASIA : uint8
{
	Invalid                                  = 0,
	English                                  = 1,
	ChineseT                                 = 9,
	ChineseS                                 = 10,
	Num                                      = 11,
	EOptionDisplayLanguageASIA_MAX           = 12,
};

// Enum BattlePrototype.EOptionDisplayLanguageEURO
// NumValues: 0x0009
enum class EOptionDisplayLanguageEURO : uint8
{
	Invalid                                  = 0,
	English                                  = 1,
	French                                   = 2,
	Italian                                  = 3,
	Deutsch                                  = 4,
	Espanol                                  = 5,
	Russian                                  = 8,
	Num                                      = 9,
	EOptionDisplayLanguageEURO_MAX           = 10,
};

// Enum BattlePrototype.EOptionDisplayLanguageUS
// NumValues: 0x0006
enum class EOptionDisplayLanguageUS : uint8
{
	Invalid                                  = 0,
	English                                  = 1,
	PortugalBR                               = 7,
	NeutralEspanol                           = 6,
	Num                                      = 7,
	EOptionDisplayLanguageUS_MAX             = 8,
};

// Enum BattlePrototype.EOptionDisplayLanguageJP
// NumValues: 0x0005
enum class EOptionDisplayLanguageJP : uint8
{
	Invalid                                  = 0,
	Japanese                                 = 0,
	English                                  = 1,
	Num                                      = 2,
	EOptionDisplayLanguageJP_MAX             = 3,
};

// Enum BattlePrototype.EOptionMinimapScaling
// NumValues: 0x0005
enum class EOptionMinimapScaling : uint8
{
	Normal                                   = 0,
	Expansion                                = 1,
	Num                                      = 2,
	Default                                  = 1,
	EOptionMinimapScaling_MAX                = 3,
};

// Enum BattlePrototype.EOptionMinimapRotation
// NumValues: 0x0005
enum class EOptionMinimapRotation : uint8
{
	On                                       = 0,
	Off                                      = 1,
	Num                                      = 2,
	Default                                  = 1,
	EOptionMinimapRotation_MAX               = 3,
};

// Enum BattlePrototype.EOptionMinimapDisplay
// NumValues: 0x0005
enum class EOptionMinimapDisplay : uint8
{
	On                                       = 0,
	Off                                      = 1,
	Num                                      = 2,
	Default                                  = 0,
	EOptionMinimapDisplay_MAX                = 3,
};

// Enum BattlePrototype.HCGameDifficulty
// NumValues: 0x0006
enum class EHCGameDifficulty : uint8
{
	Easy                                     = 0,
	Normal                                   = 1,
	Hard                                     = 2,
	Num                                      = 3,
	Default                                  = 1,
	HCGameDifficulty_MAX                     = 4,
};

// Enum BattlePrototype.EOptionParamType
// NumValues: 0x0017
enum class EOptionParamType : uint8
{
	Difficulty                               = 0,
	MinimapDisp                              = 1,
	MinimapRotate                            = 2,
	MinimapScale                             = 3,
	DisplayLanguage                          = 4,
	VoiceLanguage                            = 5,
	VoiceVolume                              = 6,
	BGMVolume                                = 7,
	SEVolume                                 = 8,
	SoundSetting                             = 9,
	CameraRotateSpeed                        = 10,
	CameraPitch                              = 11,
	CameraYaw                                = 12,
	DisplayEnemyDamage                       = 13,
	ControllerVibration                      = 14,
	EventMessageAutoPlay                     = 15,
	AttackAutoLockOn                         = 16,
	TargetCameraTrace                        = 17,
	TargetAutoChange                         = 18,
	LockonActionType                         = 19,
	CameraAfterMoveType                      = 20,
	Num                                      = 21,
	EOptionParamType_MAX                     = 22,
};

// Enum BattlePrototype.EPartyMemberIndex
// NumValues: 0x0004
enum class EPartyMemberIndex : uint8
{
	Main                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	EPartyMemberIndex_MAX                    = 3,
};

// Enum BattlePrototype.EInformedPatchDefine
// NumValues: 0x0005
enum class EInformedPatchDefine : uint8
{
	Day1                                     = 0,
	DLC1                                     = 1,
	DLC2                                     = 2,
	DLC3                                     = 3,
	EInformedPatchDefine_MAX                 = 4,
};

// Enum BattlePrototype.EPerformShotType
// NumValues: 0x000A
enum class EPerformShotType : uint8
{
	InterceptChance                          = 0,
	BrainCrashLastChance                     = 1,
	JustAvoid                                = 2,
	SAS_SeeThrough                           = 3,
	SAS_Accelerator                          = 4,
	PsychicUnique                            = 5,
	PsychicCombo                             = 6,
	RecoverNPC                               = 7,
	ENPC_SeeThrough                          = 8,
	Max                                      = 9,
};

// Enum BattlePrototype.EDebugGameActivityDisplayFlag
// NumValues: 0x0004
enum class EDebugGameActivityDisplayFlag : uint8
{
	ProgressObjectName                       = 0,
	ProgressDataForCrossSave                 = 1,
	ConvertFromOtherPlatform                 = 2,
	EDebugGameActivityDisplayFlag_MAX        = 3,
};

// Enum BattlePrototype.EGameActivityDisableFlag
// NumValues: 0x0002
enum class EGameActivityDisableFlag : uint8
{
	DebugChapterJump                         = 0,
	EGameActivityDisableFlag_MAX             = 1,
};

// Enum BattlePrototype.EGameActivityOutcome
// NumValues: 0x0004
enum class EGameActivityOutcome : uint8
{
	Completed                                = 0,
	Failed                                   = 1,
	Cancelled                                = 2,
	EGameActivityOutcome_MAX                 = 3,
};

// Enum BattlePrototype.EPlayerAIBattleThinkTransitionCPP
// NumValues: 0x0036
enum class EPlayerAIBattleThinkTransitionCPP : uint8
{
	None                                     = 0,
	TargetDistNear                           = 1,
	TargetDistMiddle                         = 2,
	TargetDistFar                            = 3,
	TargetDistTooFar                         = 4,
	TargetDamageWince                        = 5,
	AttackHit                                = 6,
	NotTargetActionAttack                    = 7,
	TargetActionAttack                       = 8,
	AttachAbleCH1000                         = 9,
	HardenMode                               = 10,
	Targeted                                 = 11,
	NotTargeted                              = 12,
	FogApply                                 = 13,
	IsENpcBarrier                            = 14,
	CanSpecialMoveTrigger                    = 15,
	TargetDamageDown                         = 16,
	CommonBranchNone                         = 17,
	CommonBranch1                            = 18,
	CommonBranch2                            = 19,
	TargetDir4Front                          = 20,
	TargetDir4Back                           = 21,
	ChangeBrainField                         = 22,
	CaptureAble                              = 23,
	TargetFloating                           = 24,
	UnderSiege                               = 25,
	ControlPlayerStealth                     = 26,
	EnableSeeThrough                         = 27,
	DriveMode                                = 28,
	LevelLearnAttack                         = 29,
	InterruptAction                          = 30,
	Stealth                                  = 31,
	FinishMetamorphosis                      = 32,
	ThinkPhaseTransition0                    = 33,
	ThinkPhaseTransition1                    = 34,
	ThinkPhaseTransition2                    = 35,
	ThinkPhaseTransition3                    = 36,
	UniqueCondition0                         = 37,
	UniqueCondition1                         = 38,
	UniqueCondition2                         = 39,
	UniqueCondition3                         = 40,
	EnableCreateCopy                         = 41,
	NotPlayerBrainField                      = 42,
	NearDeadNpc                              = 43,
	FarDeadNpc                               = 44,
	EnableDrive                              = 45,
	EnableRegistSAS                          = 46,
	SasFire                                  = 47,
	SasElectric                              = 48,
	SasTeleport                              = 49,
	InScreen                                 = 50,
	TargetCanBeAttacked                      = 51,
	StartBattleTimer                         = 52,
	EPlayerAIBattleThinkTransitionCPP_MAX    = 53,
};

// Enum BattlePrototype.EPlayerAIThinkTableTypeCPP
// NumValues: 0x0009
enum class EPlayerAIThinkTableTypeCPP : uint8
{
	Free                                     = 0,
	Brainfield                               = 1,
	BrainfieldEnd                            = 2,
	Strong                                   = 3,
	Drive                                    = 4,
	Unique00                                 = 5,
	Unique01                                 = 6,
	Unique02                                 = 7,
	EPlayerAIThinkTableTypeCPP_MAX           = 8,
};

// Enum BattlePrototype.EPlayerAIBattleThinkTypeCPP
// NumValues: 0x002F
enum class EPlayerAIBattleThinkTypeCPP : uint8
{
	MainThink_Move                           = 0,
	MainThink_AttackNear                     = 1,
	MainThink_AttackMiddle                   = 2,
	MainThink_AttackFar                      = 3,
	MainThink_Other                          = 4,
	SubThink_Move_Near                       = 5,
	SubThink_Move_Middle                     = 6,
	SubThink_Move_Far                        = 7,
	SubThink_Other_MoveCircle                = 8,
	SubThink_Other_MoveRandom                = 9,
	SubThink_Dodge                           = 10,
	SubThink_Attack1                         = 11,
	SubThink_Attack2                         = 12,
	SubThink_Attack3                         = 13,
	SubThink_Attack4                         = 14,
	SubThink_Attack5                         = 15,
	SubThink_Attack6                         = 16,
	SubThink_Attack7                         = 17,
	SubThink_Attack8                         = 18,
	SubThink_Attack9                         = 19,
	SubThink_Attack10                        = 20,
	SubThink_Attack11                        = 21,
	SubThink_Attack12                        = 22,
	SubThink_Attack13                        = 23,
	SubThink_Attack14                        = 24,
	SubThink_Attack15                        = 25,
	SubThink_Attack_Chain1                   = 26,
	SubThink_UseItem                         = 27,
	SubThink_Revival                         = 28,
	SubThink_Special_EndAttackTelepo         = 29,
	SubThink_Wait                            = 30,
	SubThink_MoveAttack                      = 31,
	SubThink_MoveAim                         = 32,
	SubThink_RushAttack                      = 33,
	SubThink_EscapeKeepOutArea               = 34,
	SubThink_Caution                         = 35,
	SubThink_Psychic                         = 36,
	SubThink_PsychicCombo                    = 37,
	SubThink_PsychicCombo2                   = 38,
	SubThink_BattleStart                     = 39,
	SubThink_SeeThrough                      = 40,
	SubThink_Intercept                       = 41,
	SubThink_CautionAttack                   = 42,
	SubThink_ReviveNpc                       = 43,
	SubThink_EnpcDrive                       = 44,
	Num                                      = 45,
	EPlayerAIBattleThinkTypeCPP_MAX          = 46,
};

// Enum BattlePrototype.EPlayerAIMoveModeCPP
// NumValues: 0x000C
enum class EPlayerAIMoveModeCPP : uint8
{
	Wait                                     = 0,
	FollowPlayer                             = 1,
	ApproachTargetNear                       = 2,
	ApproachTargetMiddle                     = 3,
	ApproachTargetFar                        = 4,
	MoveCircle                               = 5,
	MoveRandom                               = 6,
	MoveAim                                  = 7,
	MoveAttack                               = 8,
	EscapeKeepOutArea                        = 9,
	ReviveNpc                                = 10,
	EPlayerAIMoveModeCPP_MAX                 = 11,
};

// Enum BattlePrototype.EPlayerAITargetSearchModeCPP
// NumValues: 0x0006
enum class EPlayerAITargetSearchModeCPP : uint8
{
	Near                                     = 0,
	Free                                     = 1,
	SamePlayerTarget                         = 2,
	OtherPlayerTarget                        = 3,
	ENPC                                     = 4,
	EPlayerAITargetSearchModeCPP_MAX         = 5,
};

// Enum BattlePrototype.EPlayerAIMoveWallCPP
// NumValues: 0x0008
enum class EPlayerAIMoveWallCPP : uint8
{
	None                                     = 0,
	Wall                                     = 1,
	Step                                     = 2,
	DetourLeft                               = 3,
	DetourRight                              = 4,
	DetourLeftShort                          = 5,
	DetourRightShort                         = 6,
	EPlayerAIMoveWallCPP_MAX                 = 7,
};

// Enum BattlePrototype.EPlayerAIBattleThinkParamCPP
// NumValues: 0x0007
enum class EPlayerAIBattleThinkParamCPP : uint8
{
	None                                     = 0,
	Near                                     = 1,
	Middle                                   = 2,
	Far                                      = 3,
	Move                                     = 4,
	RotateToTarget                           = 5,
	EPlayerAIBattleThinkParamCPP_MAX         = 6,
};

// Enum BattlePrototype.EEvaluateActorStatus
// NumValues: 0x0003
enum class EEvaluateActorStatus : uint8
{
	None                                     = 0,
	Attack                                   = 1,
	EEvaluateActorStatus_MAX                 = 2,
};

// Enum BattlePrototype.EAIBattleRange
// NumValues: 0x0004
enum class EAIBattleRange : uint8
{
	Near                                     = 0,
	Middle                                   = 1,
	Far                                      = 2,
	EAIBattleRange_MAX                       = 3,
};

// Enum BattlePrototype.EEvaluateActorType
// NumValues: 0x0004
enum class EEvaluateActorType : uint8
{
	Enemy                                    = 0,
	Player                                   = 1,
	Friend                                   = 2,
	EEvaluateActorType_MAX                   = 3,
};

// Enum BattlePrototype.EPlayerCollisionCheckType
// NumValues: 0x001B
enum class EPlayerCollisionCheckType : uint8
{
	Enemy                                    = 0,
	InputDirEnemy                            = 1,
	EnemyForward                             = 2,
	EnemyBackward                            = 3,
	EnemyLeft                                = 4,
	EnemyRight                               = 5,
	EnemyForwardGround                       = 6,
	EnemyBackwardGround                      = 7,
	EnemyLeftGround                          = 8,
	EnemyRightGround                         = 9,
	Input                                    = 10,
	Forward                                  = 11,
	Backward                                 = 12,
	Left                                     = 13,
	Right                                    = 14,
	PlayerGround                             = 15,
	ForwardGround                            = 16,
	BackwardGround                           = 17,
	LeftGround                               = 18,
	RightGround                              = 19,
	CopyRight                                = 20,
	CopyLeft                                 = 21,
	InputDirEnemyForMoveTo                   = 22,
	InputDirForCorrectMoveInputToWall        = 23,
	FallCheck                                = 24,
	MaxNum                                   = 25,
	EPlayerCollisionCheckType_MAX            = 26,
};

// Enum BattlePrototype.EPlayerCameraUnqObjCamPhase
// NumValues: 0x0004
enum class EPlayerCameraUnqObjCamPhase : uint8
{
	StartLerp                                = 0,
	Idling                                   = 1,
	EndLerp                                  = 2,
	Max                                      = 3,
};

// Enum BattlePrototype.EPlayerCameraTraceType
// NumValues: 0x0009
enum class EPlayerCameraTraceType : uint8
{
	Up1                                      = 0,
	Up2                                      = 1,
	Dn1                                      = 2,
	Dn2                                      = 3,
	Rt1                                      = 4,
	Rt2                                      = 5,
	Lt1                                      = 6,
	Lt2                                      = 7,
	Max                                      = 8,
};

// Enum BattlePrototype.EPlayerCameraLookAtMode
// NumValues: 0x0004
enum class EPlayerCameraLookAtMode : uint8
{
	Normal                                   = 0,
	BattleLockOn                             = 1,
	TestFixOffset                            = 2,
	Max                                      = 3,
};

// Enum BattlePrototype.EFindTargetBrainTalkType
// NumValues: 0x000D
enum class EFindTargetBrainTalkType : uint8
{
	None                                     = 0,
	Common                                   = 1,
	Strong                                   = 2,
	WeakFire                                 = 3,
	WeakElectric                             = 4,
	WeakMetal                                = 5,
	WeakTelepo                               = 6,
	WeakAccelerate                           = 7,
	WeakCopy                                 = 8,
	WeakSeeThrough                           = 9,
	WeakStealth                              = 10,
	QuestEnemy                               = 11,
	EFindTargetBrainTalkType_MAX             = 12,
};

// Enum BattlePrototype.ECharacterAttribute
// NumValues: 0x000C
enum class ECharacterAttribute : uint8
{
	Default                                  = 0,
	Strong                                   = 1,
	WeakFire                                 = 2,
	WeakElectric                             = 3,
	WeakMetal                                = 4,
	WeakTelepo                               = 5,
	WeakAccelerate                           = 6,
	WeakCopy                                 = 7,
	WeakSeeThrough                           = 8,
	WeakStealth                              = 9,
	WeakPsychic                              = 10,
	ECharacterAttribute_MAX                  = 11,
};

// Enum BattlePrototype.EAddBondsType
// NumValues: 0x0004
enum class EAddBondsType : uint8
{
	KillEnemy                                = 0,
	Revive                                   = 1,
	Recovery                                 = 2,
	EAddBondsType_MAX                        = 3,
};

// Enum BattlePrototype.EFriendLotType
// NumValues: 0x0004
enum class EFriendLotType : uint8
{
	BrainFieldHelp                           = 0,
	CoverDamage                              = 1,
	CoverDeadDamage                          = 2,
	EFriendLotType_MAX                       = 3,
};

// Enum BattlePrototype.EPlayerBattleParticleType
// NumValues: 0x0005
enum class EPlayerBattleParticleType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Drive                                    = 2,
	BrainField                               = 3,
	EPlayerBattleParticleType_MAX            = 4,
};

// Enum BattlePrototype.EPlayerNeonNotifyType
// NumValues: 0x0004
enum class EPlayerNeonNotifyType : uint8
{
	DriveMax                                 = 0,
	Dying                                    = 1,
	ActionFailed                             = 2,
	EPlayerNeonNotifyType_MAX                = 3,
};

// Enum BattlePrototype.ESASHologramAttackTiming
// NumValues: 0x0007
enum class ESASHologramAttackTiming : uint8
{
	BadStatusOil                             = 0,
	BadStatusFlooded                         = 1,
	DamageReactionL                          = 2,
	Down                                     = 3,
	DriveHologramRush                        = 4,
	Invalid                                  = 5,
	ESASHologramAttackTiming_MAX             = 6,
};

// Enum BattlePrototype.EWireNeonPlayerState
// NumValues: 0x0004
enum class EWireNeonPlayerState : uint8
{
	Standard                                 = 0,
	Drive                                    = 1,
	BrainField                               = 2,
	Max                                      = 3,
};

// Enum BattlePrototype.EPlayerCameraActionPriority
// NumValues: 0x0006
enum class EPlayerCameraActionPriority : uint8
{
	Invalid                                  = 0,
	Low                                      = 1,
	Middle                                   = 2,
	High                                     = 3,
	Top                                      = 4,
	EPlayerCameraActionPriority_MAX          = 5,
};

// Enum BattlePrototype.EPlayerCameraActionType
// NumValues: 0x0020
enum class EPlayerCameraActionType : uint8
{
	Default                                  = 0,
	Jump                                     = 1,
	DoubleJump                               = 2,
	Evade                                    = 3,
	EvadeAttack                              = 4,
	JustEvade                                = 5,
	JustEvadeAttack                          = 6,
	PlayerCameraActionType07                 = 7,
	PlayerCameraActionType08                 = 8,
	PlayerCameraActionType09                 = 9,
	PlayerCameraActionType10                 = 10,
	PlayerCameraActionType11                 = 11,
	PlayerCameraActionType12                 = 12,
	PlayerCameraActionType13                 = 13,
	PlayerCameraActionType14                 = 14,
	PlayerCameraActionType15                 = 15,
	PlayerCameraActionType16                 = 16,
	PlayerCameraActionType17                 = 17,
	PlayerCameraActionType18                 = 18,
	PlayerCameraActionType19                 = 19,
	PlayerCameraActionType20                 = 20,
	PlayerCameraActionType21                 = 21,
	PlayerCameraActionType22                 = 22,
	PlayerCameraActionType23                 = 23,
	PlayerCameraActionType24                 = 24,
	PlayerCameraActionType25                 = 25,
	PlayerCameraActionType26                 = 26,
	PlayerCameraActionType27                 = 27,
	PlayerCameraActionType28                 = 28,
	PlayerCameraActionType29                 = 29,
	PlayerCameraActionType30                 = 30,
	Max                                      = 31,
};

// Enum BattlePrototype.EPlayerCameraMode
// NumValues: 0x0004
enum class EPlayerCameraMode : uint8
{
	PlayerCamera                             = 0,
	CutEvent                                 = 1,
	SceneEvent                               = 2,
	Max                                      = 3,
};

// Enum BattlePrototype.EPlayerCameraPreset
// NumValues: 0x002E
enum class EPlayerCameraPreset : uint8
{
	Default                                  = 0,
	Outdoor                                  = 1,
	Indoor                                   = 2,
	AssemblyRoom                             = 3,
	Elevator                                 = 4,
	BrainField                               = 5,
	LC22_Default                             = 6,
	LC22_Indoor                              = 7,
	LC22_Outdoor                             = 8,
	LC56_Default                             = 9,
	LC56_Outdoor                             = 10,
	UniqueObjectDrone                        = 11,
	UniqueObjectFence                        = 12,
	Em1300_in                                = 13,
	Em1300_out                               = 14,
	Em03xx_out                               = 15,
	ENPC_Default_1                           = 16,
	ENPC_Default_2                           = 17,
	ENPC_Default_3                           = 18,
	Mg_Transformer                           = 19,
	Mg_DumpCar                               = 20,
	Mg_CeilingScaffold                       = 21,
	PlayerCameraPreset13                     = 22,
	PlayerCameraPreset14                     = 23,
	PlayerCameraPreset15                     = 24,
	PlayerCameraPreset16                     = 25,
	PlayerCameraPreset17                     = 26,
	PlayerCameraPreset18                     = 27,
	PlayerCameraPreset19                     = 28,
	PlayerCameraPreset20                     = 29,
	PlayerCameraPreset21                     = 30,
	PlayerCameraPreset22                     = 31,
	PlayerCameraPreset23                     = 32,
	PlayerCameraPreset24                     = 33,
	PlayerCameraPreset25                     = 34,
	PlayerCameraPreset26                     = 35,
	PlayerCameraPreset27                     = 36,
	PlayerCameraPreset28                     = 37,
	PlayerCameraPreset29                     = 38,
	PlayerCameraPreset30                     = 39,
	Em03xx_ceiling                           = 40,
	UniqueObjectDrone_Attack                 = 41,
	DefaultNew                               = 42,
	OutdoorNew                               = 43,
	IndoorNew                                = 44,
	Max                                      = 45,
};

// Enum BattlePrototype.EPartyJoinStatus
// NumValues: 0x0005
enum class EPartyJoinStatus : uint8
{
	NotJoin                                  = 0,
	Join                                     = 1,
	Remove                                   = 2,
	TempRemove                               = 3,
	EPartyJoinStatus_MAX                     = 4,
};

// Enum BattlePrototype.EFallActionParam
// NumValues: 0x0007
enum class EFallActionParam : uint8
{
	Jump                                     = 0,
	MoveJump                                 = 1,
	SprintJump                               = 2,
	AirSprintJump                            = 3,
	Dodge                                    = 4,
	Other                                    = 5,
	EFallActionParam_MAX                     = 6,
};

// Enum BattlePrototype.EJumpActionParam
// NumValues: 0x0006
enum class EJumpActionParam : uint8
{
	Default                                  = 0,
	MoveJump                                 = 1,
	SprintJump                               = 2,
	AirJump                                  = 3,
	AirSprintJump                            = 4,
	EJumpActionParam_MAX                     = 5,
};

// Enum BattlePrototype.EDodgeActionParam
// NumValues: 0x0004
enum class EDodgeActionParam : uint8
{
	Default                                  = 0,
	JustDodge                                = 1,
	Telepo                                   = 2,
	EDodgeActionParam_MAX                    = 3,
};

// Enum BattlePrototype.EPlayerAnimDir
// NumValues: 0x0009
enum class EPlayerAnimDir : uint8
{
	Forward                                  = 0,
	Backward                                 = 1,
	Left                                     = 2,
	Right                                    = 3,
	ForwardLeft                              = 4,
	ForwardRight                             = 5,
	BackwardLeft                             = 6,
	BackwardRight                            = 7,
	EPlayerAnimDir_MAX                       = 8,
};

// Enum BattlePrototype.EPlayerCaptureAnimPattern
// NumValues: 0x000D
enum class EPlayerCaptureAnimPattern : uint8
{
	StartL_CaptureL_EndR                     = 0,
	StartL_CaptureL_EndL                     = 1,
	StartL_CaptureA_EndL                     = 2,
	StartL_CaptureA_EndR                     = 3,
	StartL_CaptureR_EndR                     = 4,
	StartL_CaptureR_EndL                     = 5,
	StartR_CaptureL_EndL                     = 6,
	StartR_CaptureL_EndR                     = 7,
	StartR_CaptureA_EndL                     = 8,
	StartR_CaptureA_EndR                     = 9,
	StartR_CaptureR_EndL                     = 10,
	StartR_CaptureR_EndR                     = 11,
	EPlayerCaptureAnimPattern_MAX            = 12,
};

// Enum BattlePrototype.ENpcKind
// NumValues: 0x0006
enum class ENpcKind : uint8
{
	ENpcKind1                                = 0,
	ENpcKind2                                = 1,
	ENpcKind3                                = 2,
	ENpcKind4                                = 3,
	ENpcKindBrainField                       = 4,
	ENpcKind_MAX                             = 5,
};

// Enum BattlePrototype.EPlayerAttachment
// NumValues: 0x0004
enum class EPlayerAttachment : uint8
{
	Attachment0                              = 0,
	Attachment1                              = 1,
	Attachment2                              = 2,
	EPlayerAttachment_MAX                    = 3,
};

// Enum BattlePrototype.EPlayerAccessory
// NumValues: 0x0004
enum class EPlayerAccessory : uint8
{
	Accessory0                               = 0,
	Accessory1                               = 1,
	Accessory2                               = 2,
	EPlayerAccessory_MAX                     = 3,
};

// Enum BattlePrototype.EPlayerAIOrder
// NumValues: 0x0007
enum class EPlayerAIOrder : uint8
{
	Free                                     = 0,
	SameTarget                               = 1,
	OtherTarget                              = 2,
	Escape                                   = 3,
	Wary                                     = 4,
	Limit                                    = 5,
	EPlayerAIOrder_MAX                       = 6,
};

// Enum BattlePrototype.EPlayerHitStopType
// NumValues: 0x002D
enum class EPlayerHitStopType : uint8
{
	NormalAttack                             = 0,
	WeakMaterialChange                       = 1,
	EnemyBadStatus                           = 2,
	BrainCrashTrigger                        = 3,
	ArmorBreak                               = 4,
	PlayerBadStatus                          = 5,
	PsychicObjectAttack                      = 6,
	DelayDead                                = 7,
	WeakExPsychic                            = 8,
	ExPsychic                                = 9,
	EnemyDeadNormalAttack                    = 10,
	EnemyDeadPsychicAttack                   = 11,
	UniqueObject                             = 12,
	EnablePsychicAttack                      = 13,
	EnableNormalAttack                       = 14,
	ComboPsychicAttack                       = 15,
	DirectShot                               = 16,
	InterceptAttack                          = 17,
	EnemyUniqueAttack                        = 18,
	EnemyDownAttack                          = 19,
	EnemyReactionLAttack                     = 20,
	EnemyBlowAttack                          = 21,
	EnemyAddDamageAttack                     = 22,
	EnemyDownPsychicAttack                   = 23,
	EnemyReactionLPsychicAttack              = 24,
	ENPCUniqueReactionAttack                 = 25,
	ENPCReactionSAttack                      = 26,
	ENPCNormalAttack                         = 27,
	ENPCSpTriggerAttack                      = 28,
	SlamPsychicAttack                        = 29,
	BrainfieldDropPsychicAttack              = 30,
	StealthCritical                          = 31,
	FullInactiveWeak                         = 32,
	DropMapGimmick                           = 33,
	DumpCarMapGimmick                        = 34,
	HookMapGimmick                           = 35,
	HookSecondHitMapGimmick                  = 36,
	TrainMapGimmick                          = 37,
	TrainSecondHitMapGimmick                 = 38,
	TankLorryMapGimmick                      = 39,
	ScalptureMapGimmick                      = 40,
	TransformerHitMapGimmick                 = 41,
	CeilingScaffoldMapGimmick                = 42,
	AssassinAttack                           = 43,
	EPlayerHitStopType_MAX                   = 44,
};

// Enum BattlePrototype.EPlayerSkill
// NumValues: 0x0046
enum class EPlayerSkill : uint8
{
	WeaponAttackUp1                          = 0,
	WeaponAttackUp2                          = 1,
	PsychicAttackUp1                         = 2,
	PsychicAttackUp2                         = 3,
	WeaponCrashUp1                           = 4,
	WeaponCrashUp2                           = 5,
	PsychicCrashUp1                          = 6,
	PsychicCrashUp2                          = 7,
	CrashBonusMoney                          = 8,
	CrashBonusExp                            = 9,
	DownEnemyDamageUp                        = 10,
	PsychicGaugeGainUpAerialCombo            = 11,
	AirJump                                  = 12,
	AirDodge1                                = 13,
	AirDodge2                                = 14,
	AddAirCombo1                             = 15,
	AirLongPressAttack                       = 16,
	AirDodgeAttack                           = 17,
	ChargeAttack1                            = 18,
	ChargeAttack2                            = 19,
	ChargeAttack3                            = 20,
	JustDodgeAttack                          = 21,
	AddWeaponCombo1                          = 22,
	AddWeaponCombo2                          = 23,
	AddPsychicCombo1                         = 24,
	AddPsychicCombo2                         = 25,
	AddAirPsychicCombo1                      = 26,
	AddAirPsychicCombo2                      = 27,
	CircleAttack                             = 28,
	BackStepAttack                           = 29,
	PsychicSlam                              = 30,
	BlowRecovery                             = 31,
	JustDodgeUP                              = 32,
	PsychicGaugeUp1                          = 33,
	PsychicGaugeUp2                          = 34,
	ItemCoolTime                             = 35,
	ItemUseInvincible                        = 36,
	AutoPickUpItem                           = 37,
	AutoRecoveryHP                           = 38,
	PinchStatusUp                            = 39,
	BrainCrashExtendTime                     = 40,
	ResurrectSpeedUp                         = 41,
	AddAccessory1                            = 42,
	AddAccessory2                            = 43,
	SASStack1                                = 44,
	SASStack2                                = 45,
	OverKillBonus                            = 46,
	SASRecover                               = 47,
	DriveGaugeUp                             = 48,
	DriveStatusUp                            = 49,
	DriveRecoveryHP                          = 50,
	DriveRecastSAS                           = 51,
	DriveCrashUp                             = 52,
	DriveExtendTime1                         = 53,
	DriveExtendTime2                         = 54,
	BattleBonusUp                            = 55,
	DriveRecoveryBadStatus                   = 56,
	DriveHologramRush                        = 57,
	BrainFieldExtendTime1                    = 58,
	BrainFieldExtendTime2                    = 59,
	BrainFieldThrowLV1                       = 60,
	BrainFieldThrowLV2                       = 61,
	BrainFieldSwingLV1                       = 62,
	BrainFieldChargeLV1                      = 63,
	BrainFieldChargeLV2                      = 64,
	BrainFieldOverKill                       = 65,
	NoStockBrainField                        = 66,
	BrainFieldDamageCut1                     = 67,
	BrainFieldDamageCut2                     = 68,
	Max                                      = 69,
};

// Enum BattlePrototype.EPlayerSkillIconCategory
// NumValues: 0x000C
enum class EPlayerSkillIconCategory : uint8
{
	WeaponAttackUp                           = 0,
	PsychicAttackUp                          = 1,
	CrashUp                                  = 2,
	BrainCrash                               = 3,
	EnhancedBody                             = 4,
	ExtendAction                             = 5,
	ExtendWeaponAttack                       = 6,
	ExtendPsychic                            = 7,
	ExtendPsychicCombo                       = 8,
	EnhancedGauge                            = 9,
	Item                                     = 10,
	EPlayerSkillIconCategory_MAX             = 11,
};

// Enum BattlePrototype.EPlayerSkillCategory
// NumValues: 0x0006
enum class EPlayerSkillCategory : uint8
{
	Boost                                    = 0,
	Extend                                   = 1,
	Assist                                   = 2,
	Drive                                    = 3,
	BrainField                               = 4,
	Max                                      = 5,
};

// Enum BattlePrototype.EAssassinAttackHit
// NumValues: 0x0006
enum class EAssassinAttackHit : uint8
{
	Invalid                                  = 0,
	EffectiveLV0                             = 1,
	EffectiveLV1                             = 2,
	EffectiveLV2                             = 3,
	EffectiveLV3                             = 4,
	EAssassinAttackHit_MAX                   = 5,
};

// Enum BattlePrototype.ESASEffectTiming
// NumValues: 0x0004
enum class ESASEffectTiming : uint8
{
	Passive                                  = 0,
	Active                                   = 1,
	PassiveWithFriend                        = 2,
	ESASEffectTiming_MAX                     = 3,
};

// Enum BattlePrototype.ESASEffect
// NumValues: 0x0033
enum class ESASEffect : uint8
{
	RecastSec                                = 0,
	ActivationSec                            = 1,
	HologramSkill                            = 2,
	CoverDamage                              = 3,
	WeaponElectric                           = 4,
	ObjectElectric                           = 5,
	ElectricSkillCharge                      = 6,
	ElectricSkillDome                        = 7,
	ReinforceElectric                        = 8,
	GuardElectric                            = 9,
	WeaponFire                               = 10,
	ObjectFire                               = 11,
	FireSkillPiller                          = 12,
	FireSkillThrower                         = 13,
	ReinforceFire                            = 14,
	GuardFire                                = 15,
	Accelerate_LV1                           = 16,
	FastItem                                 = 17,
	AccelerateRecover                        = 18,
	DodgeTelepo                              = 19,
	DodgeTelepoAir                           = 20,
	AttackTelepo                             = 21,
	ChargeTelepo                             = 22,
	Metal                                    = 23,
	BadStatusGuard                           = 24,
	AutoGuard                                = 25,
	SeeThrough                               = 26,
	EaseJustDodge                            = 27,
	JustDodgeAttackDown                      = 28,
	LargeCaptureArea                         = 29,
	BrainCrashUp                             = 30,
	DropUp                                   = 31,
	JustDodgeAttack                          = 32,
	JustDodgePsychic                         = 33,
	JustDodgeArmorBreak                      = 34,
	Stealth                                  = 35,
	AssassinAttack                           = 36,
	AutoStealth                              = 37,
	ExtendStealth                            = 38,
	ExtendStealthLong                        = 39,
	ArmorBreakAssassinAttack                 = 40,
	ObjectCopy                               = 41,
	ObjectCopy2                              = 42,
	SelfCopy                                 = 43,
	SelfCopy2                                = 44,
	PsychicCostZero                          = 45,
	PsychicField_LV1                         = 46,
	PsychicField_LV2                         = 47,
	Intercept                                = 48,
	None                                     = 49,
	ESASEffect_MAX                           = 50,
};

// Enum BattlePrototype.EGetPlayerWeaponType
// NumValues: 0x0004
enum class EGetPlayerWeaponType : uint8
{
	Weapon0                                  = 0,
	Weapon1                                  = 1,
	ThrowingWeapon                           = 2,
	EGetPlayerWeaponType_MAX                 = 3,
};

// Enum BattlePrototype.EWeaponThrowType
// NumValues: 0x0003
enum class EWeaponThrowType : uint8
{
	ToPoint                                  = 0,
	ToTarget                                 = 1,
	EWeaponThrowType_MAX                     = 2,
};

// Enum BattlePrototype.EPlayerDownType
// NumValues: 0x0009
enum class EPlayerDownType : uint8
{
	Front                                    = 0,
	Back                                     = 1,
	ShockFront                               = 2,
	ShockBack                                = 3,
	Dead                                     = 4,
	SpecialDown                              = 5,
	BrainCrash                               = 6,
	BrainFieldTimeUp                         = 7,
	EPlayerDownType_MAX                      = 8,
};

// Enum BattlePrototype.EPlayerDamageDir
// NumValues: 0x0003
enum class EPlayerDamageDir : uint8
{
	Front                                    = 0,
	Back                                     = 1,
	EPlayerDamageDir_MAX                     = 2,
};

// Enum BattlePrototype.EPlayerDamageKind
// NumValues: 0x001D
enum class EPlayerDamageKind : uint8
{
	None                                     = 0,
	NormalFront                              = 1,
	NormalBack                               = 2,
	NormalLeft                               = 3,
	NormalRight                              = 4,
	KnockbackFront                           = 5,
	KnockbackBack                            = 6,
	KnockbackLeft                            = 7,
	KnockbackRight                           = 8,
	BlowFront                                = 9,
	BlowBack                                 = 10,
	ShockFront                               = 11,
	ShockBack                                = 12,
	BrainCrash                               = 13,
	SpecialDown                              = 14,
	CoverDamage                              = 15,
	CoverDamageBlow                          = 16,
	Launch                                   = 17,
	AerialDamage                             = 18,
	BrainFieldWarning                        = 19,
	BrainFieldTimeUp                         = 20,
	Dead                                     = 21,
	BrainFieldTimeUpDead                     = 22,
	Down                                     = 23,
	KnockbackLongFront                       = 24,
	KnockbackLongBack                        = 25,
	KnockbackLongLeft                        = 26,
	KnockbackLongRight                       = 27,
	EPlayerDamageKind_MAX                    = 28,
};

// Enum BattlePrototype.EPlayerCommonStatus
// NumValues: 0x0018
enum class EPlayerCommonStatus : uint8
{
	EVENT                                    = 0,
	BATTLE                                   = 1,
	OPEN_BRAINFIELD                          = 2,
	BATTLE_READY                             = 3,
	OPEN_CAPTUREFIELD                        = 4,
	EXIST_TARGET_ACTOR_TO_MOVEDIR            = 5,
	MOVE_DEAD_END                            = 6,
	AI_USE_ADD_MOVE_INPUT                    = 7,
	ACCUMLATED_BRAINCRASH                    = 8,
	EVENT_MOVE                               = 9,
	DISABLE_INPUT_BUTTON                     = 10,
	RESERVE_WALK_MAXSPEED                    = 11,
	DEAD                                     = 12,
	PSYCHIC_OBJECT_READY                     = 13,
	ATTACK_BEHAVIOR_ON_GROUND                = 14,
	REQUEST_ALLOWANCE                        = 15,
	DRIVE_SEQUENCE                           = 16,
	AREA_CHANGE                              = 17,
	AJITO_MODE                               = 18,
	CHILD_YUITO                              = 19,
	DISABLE_MOVEMENT_FLYING                  = 20,
	EXEC_TELEPO                              = 21,
	TALK_EVENT                               = 22,
	EPlayerCommonStatus_MAX                  = 23,
};

// Enum BattlePrototype.EPlayerUpperActionStatus
// NumValues: 0x0009
enum class EPlayerUpperActionStatus : uint8
{
	END_ACTION                               = 0,
	UPPER_PSYCHIC_ACTION                     = 1,
	UPPER_ACTION                             = 2,
	DISABLE_MOVE                             = 3,
	CHANGE_BATTLE                            = 4,
	CAPTURE                                  = 5,
	PSYCHIC_LEFT                             = 6,
	PSYCHIC_RIGHT                            = 7,
	EPlayerUpperActionStatus_MAX             = 8,
};

// Enum BattlePrototype.EPlayerActionStatus
// NumValues: 0x0020
enum class EPlayerActionStatus : uint8
{
	END_ACTION                               = 0,
	FULL_ACTION                              = 1,
	AIR_ACTIONABLE                           = 2,
	DODGE                                    = 3,
	JUST_DODGE                               = 4,
	NOT_FALL                                 = 5,
	ATTACK                                   = 6,
	SPRINT                                   = 7,
	IGNORE_LAND_CHECK                        = 8,
	DOWN                                     = 9,
	DAMAGE                                   = 10,
	BLOW_DAMAGE                              = 11,
	ENABLE_MOVEMENTINPUT                     = 12,
	PSYCHIC_COMBO                            = 13,
	PERMIT_DODGE                             = 14,
	BRAIN_CRASH_DAMAGE                       = 15,
	WAKEUP                                   = 16,
	BRAIN_CRASH                              = 17,
	CANCEL_PSYCHIC_COMBO                     = 18,
	CAPTURE_MAPGIMMICK                       = 19,
	CONTROL_PSYCHIC_OBJECT                   = 20,
	EXEC_MAPGIMMICK                          = 21,
	ENABLE_BACKSTEP_ATTACK                   = 22,
	JUMP                                     = 23,
	SKIP_WALK_START                          = 24,
	LAUNCH_DAMAGE                            = 25,
	EVENT_END_DOWN                           = 26,
	LANDINGABLE                              = 27,
	DISABLE_SAS_CONTROL                      = 28,
	DISABLE_ATTACK_STEALTH_OFF               = 29,
	EXEC_UNIQUE_PSYCHIC                      = 30,
	EPlayerActionStatus_MAX                  = 31,
};

// Enum BattlePrototype.EPlayerUpperActionKind
// NumValues: 0x0007
enum class EPlayerUpperActionKind : uint8
{
	None                                     = 0,
	ChangeBattle                             = 1,
	DamageSAS                                = 2,
	Attack                                   = 3,
	PsychicObjCapture                        = 4,
	PsychicObjAttack                         = 5,
	EPlayerUpperActionKind_MAX               = 6,
};

// Enum BattlePrototype.EPlayerActionKind
// NumValues: 0x001F
enum class EPlayerActionKind : uint8
{
	Event                                    = 0,
	Idle                                     = 1,
	BoringIdle                               = 2,
	WalkRun                                  = 3,
	Sprint                                   = 4,
	SprintBrake                              = 5,
	Jump                                     = 6,
	Fall                                     = 7,
	Land                                     = 8,
	Dodge                                    = 9,
	Attack                                   = 10,
	Damage                                   = 11,
	DamageBlow                               = 12,
	Down                                     = 13,
	WakeUp                                   = 14,
	UseItem                                  = 15,
	Dead                                     = 16,
	BrainCrash                               = 17,
	AfterEvent                               = 18,
	BrainCrashDamage                         = 19,
	CaptureMapGimmick                        = 20,
	CancelMapGimmick                         = 21,
	Drive                                    = 22,
	RecoverBlowDamage                        = 23,
	EventMotion                              = 24,
	ControlPsychicObject                     = 25,
	Ressurect                                = 26,
	Revive                                   = 27,
	SprintTurnBack                           = 28,
	EnpcSas                                  = 29,
	EPlayerActionKind_MAX                    = 30,
};

// Enum BattlePrototype.RSPartyPlayerKind
// NumValues: 0x0006
enum class ERSPartyPlayerKind : uint8
{
	Main                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	Invalid                                  = 3,
	NumOfEnum                                = 3,
	RSPartyPlayerKind_MAX                    = 4,
};

// Enum BattlePrototype.ENpcDriveCheckType
// NumValues: 0x0007
enum class ENpcDriveCheckType : uint8
{
	BattleStart                              = 0,
	TargetDamageReaction                     = 1,
	DriveMax                                 = 2,
	PlayerHP30                               = 3,
	PlayerHP20                               = 4,
	PlayerHP10                               = 5,
	ENpcDriveCheckType_MAX                   = 6,
};

// Enum BattlePrototype.EPlayerInputRestrictionType
// NumValues: 0x000B
enum class EPlayerInputRestrictionType : uint8
{
	NoBattle                                 = 0,
	OnlyWalk                                 = 1,
	DisableInput                             = 2,
	EventDisableInput                        = 3,
	EventMove                                = 4,
	BrainFieldWarning                        = 5,
	BrainFieldTimeUp                         = 6,
	BattleEm1500                             = 7,
	EventState                               = 8,
	ChildYuito                               = 9,
	EPlayerInputRestrictionType_MAX          = 10,
};

// Enum BattlePrototype.EPlayerInputType
// NumValues: 0x0006
enum class EPlayerInputType : uint8
{
	Default                                  = 0,
	Keyboard                                 = 1,
	Mouse                                    = 2,
	Test                                     = 3,
	Invalid                                  = 4,
	EPlayerInputType_MAX                     = 5,
};

// Enum BattlePrototype.ESASHologramAttackCallType
// NumValues: 0x0008
enum class ESASHologramAttackCallType : uint8
{
	BadStatusFlooded                         = 0,
	FloodedDamageReaction                    = 1,
	BadStatusOil                             = 2,
	OilDamageReaction                        = 3,
	DamageReactionL                          = 4,
	DamageReactionDown                       = 5,
	DriveHologramRush                        = 6,
	ESASHologramAttackCallType_MAX           = 7,
};

// Enum BattlePrototype.EPerformShotState
// NumValues: 0x0005
enum class EPerformShotState : uint8
{
	PerformShotState_Invalid                 = 0,
	PerformShotState_Start                   = 1,
	PerformShotState_Loop                    = 2,
	PerformShotState_Finish                  = 3,
	PerformShotState_MAX                     = 4,
};

// Enum BattlePrototype.PsychicBattleAnimationPhaseType
// NumValues: 0x0008
enum class EPsychicBattleAnimationPhaseType : uint8
{
	Invalid                                  = 0,
	Start                                    = 1,
	Win                                      = 2,
	Lose                                     = 3,
	WinToLose                                = 4,
	LoseToWin                                = 5,
	NumOfEnum                                = 6,
	PsychicBattleAnimationPhaseType_MAX      = 7,
};

// Enum BattlePrototype.PsychicBattleType
// NumValues: 0x0003
enum class EPsychicBattleType : uint8
{
	PB_ElectricPole                          = 0,
	NumOfEnum                                = 1,
	PsychicBattleType_MAX                    = 2,
};

// Enum BattlePrototype.EPsychicObjectID
// NumValues: 0x00D8
enum class BattlePrototype::EPsychicObjectID : uint8
{
	S_CafeChair01_A                          = 0,
	S_CafeTable01_A                          = 1,
	S_Child01_A                              = 2,
	S_FancyChair01_A                         = 3,
	S_FloorDebris01_A                        = 4,
	S_FoodStands01_Chair_A                   = 5,
	S_GasCylinder01_A                        = 6,
	S_GasCylinder02_A                        = 7,
	S_Pipe01_A                               = 8,
	S_Planter01_A                            = 9,
	S_Rock01_A                               = 10,
	S_ShoppingCart01_A                       = 11,
	S_Tire01_A                               = 12,
	S_Trashbin01_A                           = 13,
	S_Trashbin02_A                           = 14,
	S_TV01_A                                 = 15,
	M_Beam01_A                               = 16,
	M_Bicycle01A_A                           = 17,
	M_Bicycle01B_A                           = 18,
	M_Bicycle01C_A                           = 19,
	M_CafeParasol01_A                        = 20,
	M_Child01_A                              = 21,
	M_Child02_A                              = 22,
	M_Cushiondram01_A                        = 23,
	M_Cushiondram01_B                        = 24,
	M_Cushiondram01_C                        = 25,
	M_Cushiondram02A_A                       = 26,
	M_Cushiondram02A_B                       = 27,
	M_Cushiondram02A_C                       = 28,
	M_Cushiondram02B_A                       = 29,
	M_Cushiondram02B_B                       = 30,
	M_Cushiondram02B_C                       = 31,
	M_Drum01_A                               = 32,
	M_Drum02_A                               = 33,
	M_Drum02_B                               = 34,
	M_DrumFuel01_A                           = 35,
	M_DrumSet01_A                            = 36,
	M_DrumSet01_B                            = 37,
	M_DrumSet01_C                            = 38,
	M_DrumSet02_A                            = 39,
	M_DrumSet02_B                            = 40,
	M_DrumSet02_C                            = 41,
	M_DrumWater01_A                          = 42,
	M_Em1200Chair01_A                        = 43,
	M_FuelDrum01_A                           = 44,
	M_Ladder01_A                             = 45,
	M_LampPole01_A                           = 46,
	M_MetalBox01A_A                          = 47,
	M_MetalBox01B_A                          = 48,
	M_MetalCrate01_A                         = 49,
	M_MetalCrate02_A                         = 50,
	M_MetalFence01_A                         = 51,
	M_MuseumFactoryDevice01_A                = 52,
	M_RoadBlock01_A                          = 53,
	M_RoadBlock02A_A                         = 54,
	M_RoadBlock02B_A                         = 55,
	M_RoadFence01_A                          = 56,
	M_Rock01_A                               = 57,
	M_SubwayRubble01S_A                      = 58,
	M_Switchboard01A_A                       = 59,
	M_Switchboard01B_A                       = 60,
	M_Switchboard01C_A                       = 61,
	M_Tire01_A                               = 62,
	L_Antenna01_A                            = 63,
	L_Beams01_A                              = 64,
	L_Beams01_B                              = 65,
	L_Bench01_A                              = 66,
	L_Bench02_A                              = 67,
	L_Bench03_A                              = 68,
	L_Bench04_A                              = 69,
	L_Child02_A                              = 70,
	L_Child03_A                              = 71,
	L_ClawMachine01_A                        = 72,
	L_Couch01_A                              = 73,
	L_Couch01d01_A                           = 74,
	L_DisplayStand01_A                       = 75,
	L_Dumpster01_A                           = 76,
	L_HospitalScreen01_A                     = 77,
	L_IceStatue01_A                          = 78,
	L_IceStatue01_B                          = 79,
	L_IceStatue01_C                          = 80,
	L_IceStatue01_D                          = 81,
	L_IceStatue01_E                          = 82,
	L_IceStatue01_F                          = 83,
	L_IceStatue01_G                          = 84,
	L_IceStatue01_H                          = 85,
	L_MaitreyaCylinder01_A                   = 86,
	L_MaitreyaLantern01_A                    = 87,
	L_MetalBoxDbl01_A                        = 88,
	L_MetalCrate01A_A                        = 89,
	L_MetalCrate01B_A                        = 90,
	L_MetalCrate03_A                         = 91,
	L_MetalCrateDbl01_A                      = 92,
	L_Rail01_A                               = 93,
	L_Rock01_A                               = 94,
	L_Scooters01_A                           = 95,
	L_Scooters01_B                           = 96,
	L_Scooters01_C                           = 97,
	L_Scooters01_D                           = 98,
	L_Scooters01_E                           = 99,
	L_Switchboard01_A                        = 100,
	L_Table01_A                              = 101,
	L_VendingMachine01_A                     = 102,
	L_VendingMachine01_B                     = 103,
	L_VendingMachine01_C                     = 104,
	L_VendingMachine01_D                     = 105,
	L_VendingMachine02_A                     = 106,
	L_VendingMachine02_B                     = 107,
	L_VendingMachine02_C                     = 108,
	L_VendingMachine02_D                     = 109,
	L_VendingMachine03_A                     = 110,
	L_VendingMachine03_B                     = 111,
	L_WheelChair01_A                         = 112,
	XL_CarDeliveryTruck01_A                  = 113,
	XL_CarDeliveryTruck01_B                  = 114,
	XL_CarDeliveryTruck01_C                  = 115,
	XL_CarDeliveryTruck01_D                  = 116,
	XL_CarDeliveryTruck01_E                  = 117,
	XL_CarDeliveryTruck01_F                  = 118,
	XL_CarKTruck01_A                         = 119,
	XL_CarKTruck01_B                         = 120,
	XL_CarSedan01_A                          = 121,
	XL_CarSedan01_B                          = 122,
	XL_CarSedan01_C                          = 123,
	XL_CarSedan01_D                          = 124,
	XL_CarSedan01_E                          = 125,
	XL_CarStandard01_A                       = 126,
	XL_CarStandard01_B                       = 127,
	XL_CarStandard01_C                       = 128,
	XL_CarStandard01_D                       = 129,
	XL_CarStandard01_E                       = 130,
	XL_CarStandardTaxi01_A                   = 131,
	XL_ElectricPole_A                        = 132,
	XL_ElectricPole_B                        = 133,
	XL_FoodStands01_A                        = 134,
	XL_FoodStands01_B                        = 135,
	XL_FoodStands01_C                        = 136,
	XL_IceStatue01_A                         = 137,
	XL_IceStatue01_B                         = 138,
	XL_IceStatue01_C                         = 139,
	XL_IceStatue01_D                         = 140,
	XL_IceStatue01_E                         = 141,
	XL_IceStatue01_F                         = 142,
	XL_IceStatue01_G                         = 143,
	XL_IceStatue01_H                         = 144,
	XL_OrbitBike01_A                         = 145,
	XL_Rock01_A                              = 146,
	XL_Rubble01_A                            = 147,
	XXL_Container01_A                        = 148,
	XXL_Container01_B                        = 149,
	XXL_Container01_C                        = 150,
	XXL_Container01_D                        = 151,
	EM_IceRock01_A                           = 152,
	EM_IceRock01_B                           = 153,
	EM_IceRock01_C                           = 154,
	EM_Cube_A                                = 155,
	EM_Bomb_A                                = 156,
	UQ_ElectricPole01_A                      = 157,
	UQ_ElectricPole01_A_Wreckage             = 158,
	UQ_VendingMachine01_A                    = 159,
	UQ_VendingMachine01_A_Cover              = 160,
	UQ_SteelBeams01_A                        = 161,
	UQ_SteelBeams01_A_Beam                   = 162,
	UQ_SteelBeams02_A                        = 163,
	UQ_SteelBeams02_A_Beam                   = 164,
	UQ_TankSet01_A                           = 165,
	UQ_TankSet01_A_Tank                      = 166,
	UQ_TankSet01_A_Liquid                    = 167,
	UQ_TankSet02_A                           = 168,
	UQ_TankSet02_A_Tank                      = 169,
	UQ_TankSet02_A_Liquid                    = 170,
	UQ_Fence01_A                             = 171,
	UQ_Fence02_A                             = 172,
	UQ_Drone01_A                             = 173,
	UQ_Container01_A                         = 174,
	UQ_Vehicle01_A                           = 175,
	UQ_Pillar01_A                            = 176,
	UQ_Statue01_A                            = 177,
	UQ_Bulldozer01_A                         = 178,
	UQ_DuelPole01_A                          = 179,
	UQ_FloorFragment01_A                     = 180,
	UQ_FloorFragment01_A_Debris              = 181,
	UQ_Cube01_A                              = 182,
	UQ_Cube01_A_Parts                        = 183,
	UQ_Rock01_A                              = 184,
	UQ_Rock01_A_Debris                       = 185,
	UQ_Rock02_A                              = 186,
	UQ_Rock02_A_Debris                       = 187,
	UQ_ElectronicParts01_A                   = 188,
	UQ_Chandelier01_A                        = 189,
	UQ_IronRailing01_A                       = 190,
	UQ_IronRailing01_A_Baluster              = 191,
	UQ_DimensionEntanglement01_A             = 192,
	UQ_Chakram01_A                           = 193,
	UQ_Chakram01_A_Frame                     = 194,
	UQ_LightningRod01_A                      = 195,
	UQ_LightningRod01_A_Wreckage             = 196,
	UQ_Truck01_A                             = 197,
	UQ_Truck01_A_Parts                       = 198,
	UQ_Crystal01_A                           = 199,
	UQ_Mask01_A                              = 200,
	UQ_Mask01_B                              = 201,
	UQ_Mask01_C                              = 202,
	UQ_Mask01_D                              = 203,
	MG_BigIce                                = 204,
	MG_BigIceMiddle                          = 205,
	MG_CeilingScaffold                       = 206,
	MG_DumpCar                               = 207,
	MG_Hanged                                = 208,
	MG_Hook                                  = 209,
	MG_IceScalpture                          = 210,
	MG_TankLorry                             = 211,
	MG_Train                                 = 212,
	MG_MovableBridge                         = 213,
	EX_InterceptObj                          = 214,
	Max                                      = 215,
};

// Enum BattlePrototype.EPsychicObjectUniqueMontageIndex
// NumValues: 0x0008
enum class EPsychicObjectUniqueMontageIndex : uint8
{
	Capture                                  = 0,
	CaptureFinish                            = 1,
	FirstAttack                              = 2,
	UniqueAttack1                            = 3,
	UniqueAttack2                            = 4,
	UniqueAttack3                            = 5,
	InputFailure                             = 6,
	Max                                      = 7,
};

// Enum BattlePrototype.EPsychicObjectUniqueMontageType
// NumValues: 0x0003
enum class EPsychicObjectUniqueMontageType : uint8
{
	ElectricPole                             = 0,
	VendingMachine                           = 1,
	Max                                      = 2,
};

// Enum BattlePrototype.EPsychicObjectUniqueInputType
// NumValues: 0x000B
enum class EPsychicObjectUniqueInputType : uint8
{
	None                                     = 0,
	Up                                       = 1,
	Down                                     = 2,
	Left                                     = 3,
	Right                                    = 4,
	Press                                    = 5,
	Hold                                     = 6,
	Repeat                                   = 7,
	LRoll                                    = 8,
	RRoll                                    = 9,
	Max                                      = 10,
};

// Enum BattlePrototype.EPsychicObjectUniqueInputButton
// NumValues: 0x000D
enum class EPsychicObjectUniqueInputButton : uint8
{
	LeftStick                                = 0,
	RightStick                               = 1,
	L1                                       = 2,
	L2                                       = 3,
	R1                                       = 4,
	R2                                       = 5,
	RUp                                      = 6,
	RDown                                    = 7,
	RLeft                                    = 8,
	RRight                                   = 9,
	LeftStickHold                            = 10,
	RightStickHold                           = 11,
	Max                                      = 12,
};

// Enum BattlePrototype.EPsychicObjectUniqueType
// NumValues: 0x0015
enum class EPsychicObjectUniqueType : uint8
{
	None                                     = 0,
	ElectricPole                             = 1,
	VendingMachine                           = 2,
	SteelBeams                               = 3,
	TankSet                                  = 4,
	Fence                                    = 5,
	Drone                                    = 6,
	Container                                = 7,
	Vehicle                                  = 8,
	Pillar                                   = 9,
	Statue                                   = 10,
	Bulldozer                                = 11,
	DuelPole                                 = 12,
	FloorFragment                            = 13,
	Cube                                     = 14,
	Rock                                     = 15,
	ElectronicParts                          = 16,
	Chandelier                               = 17,
	IronRailing                              = 18,
	DimensionEntanglement                    = 19,
	Max                                      = 20,
};

// Enum BattlePrototype.EPsychicObjectProcedure
// NumValues: 0x0009
enum class EPsychicObjectProcedure : uint8
{
	None                                     = 0,
	Capture                                  = 1,
	PullOut                                  = 2,
	LiftUp                                   = 3,
	Attract                                  = 4,
	Attack                                   = 5,
	Input                                    = 6,
	Destroy                                  = 7,
	Max                                      = 8,
};

// Enum BattlePrototype.EPsychicObjectState
// NumValues: 0x000A
enum class EPsychicObjectState : uint8
{
	None                                     = 0,
	Wait                                     = 1,
	Capturing                                = 2,
	Capture                                  = 3,
	PullOut                                  = 4,
	Attracting                               = 5,
	Attract                                  = 6,
	Attack                                   = 7,
	Input                                    = 8,
	Max                                      = 9,
};

// Enum BattlePrototype.EPsychicObjectBrainFieldAttackType
// NumValues: 0x0016
enum class EPsychicObjectBrainFieldAttackType : uint8
{
	SwingCombo1                              = 0,
	SwingCombo2                              = 1,
	SwingCombo3                              = 2,
	SwingComboEx                             = 3,
	SwingAir                                 = 4,
	ThrowLt                                  = 5,
	ThrowRt                                  = 6,
	ThrowCombo1                              = 7,
	ThrowCombo2                              = 8,
	ThrowCombo3                              = 9,
	ThrowAirLt                               = 10,
	ThrowAirRt                               = 11,
	Drop                                     = 12,
	DropCombo                                = 13,
	DropFinish                               = 14,
	DropCombo1                               = 15,
	DropCombo2                               = 16,
	DropCombo3                               = 17,
	SwingRight                               = 18,
	SwingLeft                                = 19,
	Throw                                    = 20,
	Max                                      = 21,
};

// Enum BattlePrototype.EPsychicObjectAttackType
// NumValues: 0x000C
enum class BattlePrototype::EPsychicObjectAttackType : uint8
{
	Throw                                    = 0,
	Drop                                     = 1,
	Swing                                    = 2,
	ThrowAll                                 = 3,
	Boomerang                                = 4,
	Scissors                                 = 5,
	Chipsaw                                  = 6,
	Firearm                                  = 7,
	Scales                                   = 8,
	Shield                                   = 9,
	VendingMachine                           = 10,
	Max                                      = 11,
};

// Enum BattlePrototype.EPsychicObjectButtonType
// NumValues: 0x0006
enum class EPsychicObjectButtonType : uint8
{
	Throw                                    = 0,
	Drop                                     = 1,
	Swing                                    = 2,
	Unique                                   = 3,
	ThrowAll                                 = 4,
	Max                                      = 5,
};

// Enum BattlePrototype.EPsychicObjectSizeType
// NumValues: 0x0006
enum class EPsychicObjectSizeType : uint8
{
	SizeS                                    = 0,
	SizeM                                    = 1,
	SizeL                                    = 2,
	SizeXL                                   = 3,
	SizeXXL                                  = 4,
	Max                                      = 5,
};

// Enum BattlePrototype.EPsychicObjectCategory
// NumValues: 0x0004
enum class EPsychicObjectCategory : uint8
{
	Normal                                   = 0,
	Unique                                   = 1,
	Huge                                     = 2,
	Max                                      = 3,
};

// Enum BattlePrototype.QuestType
// NumValues: 0x0004
enum class EQuestType : uint8
{
	QtMain                                   = 0,
	QtSub                                    = 1,
	QtBonds                                  = 2,
	QuestType_MAX                            = 3,
};

// Enum BattlePrototype.EMeansOfKillType
// NumValues: 0x003A
enum class EMeansOfKillType : uint8
{
	Invalid                                  = 0,
	Attack_Weapon                            = 1,
	Attack_Charge                            = 2,
	Attack_Air                               = 3,
	Attack_Assassin                          = 4,
	Attack_Psychic                           = 5,
	Attack_PsyCombo                          = 6,
	Attack_BrainCrash                        = 7,
	Attack_BrainCrashMulti                   = 8,
	Attack_Drive                             = 9,
	Attack_BrainField                        = 10,
	Attack_JustDodgeAttack                   = 11,
	Attack_JustDodgePsychic                  = 12,
	Attack_PsychicField                      = 13,
	Attack_PsychicObjectDropAttack           = 14,
	Attack_Intercept                         = 15,
	SpecialOBJ_All                           = 16,
	SpecialOBJ_ElectricPole                  = 17,
	SpecialOBJ_VendingMachine                = 18,
	SpecialOBJ_SteelBeams                    = 19,
	SpecialOBJ_TankSet                       = 20,
	SpecialOBJ_Fence                         = 21,
	SpecialOBJ_Drone                         = 22,
	SpecialOBJ_Container                     = 23,
	SpecialOBJ_Vehicle                       = 24,
	SpecialOBJ_Pillar                        = 25,
	SpecialOBJ_Statue                        = 26,
	SpecialOBJ_Bulldozer                     = 27,
	SpecialOBJ_DuelPole                      = 28,
	SpecialOBJ_FloorFragment                 = 29,
	SpecialOBJ_Cube                          = 30,
	SpecialOBJ_Rock                          = 31,
	SpecialOBJ_ElectronicParts               = 32,
	SpecialOBJ_Chandelier                    = 33,
	SpecialOBJ_IronRailing                   = 34,
	SpecialOBJ_DimensionEntanglement         = 35,
	SAS_All                                  = 36,
	SAS_Fire                                 = 37,
	SAS_Electric                             = 38,
	SAS_Telepo                               = 39,
	SAS_Accelerator                          = 40,
	SAS_Metal                                = 41,
	SAS_Stealth                              = 42,
	SAS_SeeThrough                           = 43,
	SAS_Copy                                 = 44,
	SAS_Psychic                              = 45,
	Attack_FallAttack                        = 46,
	CombiVision_All                          = 47,
	CombiVision_Fire                         = 48,
	CombiVision_Electric                     = 49,
	CombiVision_Telepo                       = 50,
	CombiVision_Accelerator                  = 51,
	CombiVision_Metal                        = 52,
	CombiVision_Stealth                      = 53,
	CombiVision_SeeThrough                   = 54,
	CombiVision_Copy                         = 55,
	CombiVision_Psychic                      = 56,
	EMeansOfKillType_MAX                     = 57,
};

// Enum BattlePrototype.ESubQuestRewardType
// NumValues: 0x0004
enum class ESubQuestRewardType : uint8
{
	Invalid                                  = 0,
	RewardItem                               = 1,
	RewardMoney                              = 2,
	ESubQuestRewardType_MAX                  = 3,
};

// Enum BattlePrototype.ESubQuestRequestType
// NumValues: 0x0004
enum class ESubQuestRequestType : uint8
{
	Invalid                                  = 0,
	GatherItem                               = 1,
	SupressEnemy                             = 2,
	ESubQuestRequestType_MAX                 = 3,
};

// Enum BattlePrototype.EQuestDataType
// NumValues: 0x0005
enum class EQuestDataType : uint8
{
	Invalid                                  = 0,
	MainQuest                                = 1,
	SubQuest                                 = 2,
	BondsEpisode                             = 3,
	EQuestDataType_MAX                       = 4,
};

// Enum BattlePrototype.SortType
// NumValues: 0x0006
enum class ESortType : uint8
{
	StNormal                                 = 0,
	StReverce                                = 1,
	StActiveTop                              = 2,
	StCanReport                              = 3,
	StCleared                                = 4,
	SortType_MAX                             = 5,
};

// Enum BattlePrototype.ELuaWaitMode
// NumValues: 0x000D
enum class ELuaWaitMode : uint8
{
	None                                     = 0,
	Timer                                    = 1,
	Message                                  = 2,
	Input                                    = 3,
	EndMotion                                = 4,
	DynamicCutscene                          = 5,
	AnimMontage                              = 6,
	LoadAsset                                = 7,
	LoadAssetAll                             = 8,
	Fade                                     = 9,
	Shop                                     = 10,
	GeneralChoice                            = 11,
	ELuaWaitMode_MAX                         = 12,
};

// Enum BattlePrototype.ETextAlign
// NumValues: 0x0004
enum class ETextAlign : uint8
{
	Default                                  = 0,
	Center                                   = 1,
	Right                                    = 2,
	ETextAlign_MAX                           = 3,
};

// Enum BattlePrototype.ETextColor
// NumValues: 0x000D
enum class ETextColor : uint8
{
	RED                                      = 0,
	GREEN                                    = 1,
	BLUE                                     = 2,
	YELLOW                                   = 3,
	BLUE_GREEN                               = 4,
	PARAMETER_YELLOW                         = 5,
	PARAMETER_RED                            = 6,
	PARAMETER_BLUE                           = 7,
	RARITY_2                                 = 8,
	RARITY_3                                 = 9,
	RARITY_4                                 = 10,
	LOADING_RED                              = 11,
	ETextColor_MAX                           = 12,
};

// Enum BattlePrototype.ELanguageTextPattern
// NumValues: 0x000E
enum class ELanguageTextPattern : uint8
{
	Nothing                                  = 0,
	EFIGSR                                   = 1,
	JPN                                      = 2,
	CHN                                      = 3,
	CK                                       = 4,
	FR                                       = 5,
	IT                                       = 6,
	DE                                       = 7,
	EsES                                     = 8,
	EsUS                                     = 9,
	PtBR                                     = 10,
	RU                                       = 11,
	CJK_Deprecated                           = 12,
	ELanguageTextPattern_MAX                 = 13,
};

// Enum BattlePrototype.EUI_UV_BUtton_N1
// NumValues: 0x0022
enum class EUI_UV_BUtton_N1 : uint8
{
	RRight_M                                 = 0,
	RDown_M                                  = 1,
	RUP_M                                    = 2,
	RLeft_M                                  = 3,
	L1_M                                     = 4,
	R1_M                                     = 5,
	L2_M                                     = 6,
	R2_M                                     = 7,
	RRight_L                                 = 8,
	RDown_L                                  = 9,
	RUP_L                                    = 10,
	RLeft_L                                  = 11,
	L1_L                                     = 12,
	R1_L                                     = 13,
	L2_L                                     = 14,
	R2_L                                     = 15,
	LStick_L                                 = 16,
	RStick_L                                 = 17,
	L3_L                                     = 18,
	R3_L                                     = 19,
	L3_R3                                    = 20,
	Button_Base                              = 21,
	L1_Base                                  = 22,
	R1_Base                                  = 23,
	L2_Base                                  = 24,
	R2_Base                                  = 25,
	Key_Base                                 = 26,
	Mouse                                    = 27,
	Mouse_L                                  = 28,
	Mouse_R                                  = 29,
	Mouse_M                                  = 30,
	Mouse_4                                  = 31,
	Mouse_5                                  = 32,
	MAX                                      = 33,
};

// Enum BattlePrototype.ERenderingVisibilityType
// NumValues: 0x0003
enum class ERenderingVisibilityType : uint8
{
	Default                                  = 0,
	Hide                                     = 1,
	ERenderingVisibilityType_MAX             = 2,
};

// Enum BattlePrototype.ERenderingShadowType
// NumValues: 0x0004
enum class ERenderingShadowType : uint8
{
	Default                                  = 0,
	CharacterHide                            = 1,
	AllHide                                  = 2,
	ERenderingShadowType_MAX                 = 3,
};

// Enum BattlePrototype.ERenderingSettingsType
// NumValues: 0x0004
enum class ERenderingSettingsType : uint8
{
	Default                                  = 0,
	Middle                                   = 1,
	Low                                      = 2,
	ERenderingSettingsType_MAX               = 3,
};

// Enum BattlePrototype.ECheckAccountFlag
// NumValues: 0x0006
enum class ECheckAccountFlag : uint8
{
	SaveLoad                                 = 0,
	Movie                                    = 1,
	Suspend                                  = 2,
	Loading                                  = 3,
	BackToTitle                              = 4,
	ECheckAccountFlag_MAX                    = 5,
};

// Enum BattlePrototype.EAchievementsType
// NumValues: 0x0037
enum class EAchievementsType : uint8
{
	Trophy_Title_00                          = 0,
	Trophy_Title_01                          = 1,
	Trophy_Title_02                          = 2,
	Trophy_Title_03                          = 3,
	Trophy_Title_04                          = 4,
	Trophy_Title_05                          = 5,
	Trophy_Title_06                          = 6,
	Trophy_Title_07                          = 7,
	Trophy_Title_08                          = 8,
	Trophy_Title_09                          = 9,
	Trophy_Title_10                          = 10,
	Trophy_Title_11                          = 11,
	Trophy_Title_12                          = 12,
	Trophy_Title_13                          = 13,
	Trophy_Title_14                          = 14,
	Trophy_Title_15                          = 15,
	Trophy_Title_16                          = 16,
	Trophy_Title_17                          = 17,
	Trophy_Title_18                          = 18,
	Trophy_Title_19                          = 19,
	Trophy_Title_20                          = 20,
	Trophy_Title_21                          = 21,
	Trophy_Title_22                          = 22,
	Trophy_Title_23                          = 23,
	Trophy_Title_24                          = 24,
	Trophy_Title_25                          = 25,
	Trophy_Title_26                          = 26,
	Trophy_Title_27                          = 27,
	Trophy_Title_28                          = 28,
	Trophy_Title_29                          = 29,
	Trophy_Title_30                          = 30,
	Trophy_Title_31                          = 31,
	Trophy_Title_32                          = 32,
	Trophy_Title_33                          = 33,
	Trophy_Title_34                          = 34,
	Trophy_Title_35                          = 35,
	Trophy_Title_36                          = 36,
	Trophy_Title_37                          = 37,
	Trophy_Title_38                          = 38,
	Trophy_Title_39                          = 39,
	Trophy_Title_40                          = 40,
	Trophy_Title_41                          = 41,
	Trophy_Title_42                          = 42,
	Trophy_Title_43                          = 43,
	Trophy_Title_44                          = 44,
	Trophy_Title_45                          = 45,
	Trophy_Title_46                          = 46,
	Trophy_Title_47                          = 47,
	Trophy_Title_48                          = 48,
	Trophy_Title_49                          = 49,
	Trophy_Title_50                          = 50,
	Trophy_Title_51                          = 51,
	Trophy_Title_52                          = 52,
	Num                                      = 53,
	EAchievementsType_MAX                    = 54,
};

// Enum BattlePrototype.EAjitoMemberAnimType
// NumValues: 0x000A
enum class EAjitoMemberAnimType : uint8
{
	AJITOANIM_IDLE_LOOP1                     = 0,
	AJITOANIM_IDLE_START1                    = 1,
	AJITOANIM_IDLE_END1                      = 2,
	AJITOANIM_IDLE_LOOP2                     = 3,
	AJITOANIM_IDLE_START2                    = 4,
	AJITOANIM_IDLE_END2                      = 5,
	AJITOANIM_TALK_LOOP                      = 6,
	AJITOANIM_TALK_START                     = 7,
	AJITOANIM_TALK_END                       = 8,
	AJITOANIM_MAX                            = 9,
};

// Enum BattlePrototype.EAjitoMemberTalkStateType
// NumValues: 0x0004
enum class EAjitoMemberTalkStateType : uint8
{
	AJITOSTATE_TALK_LOOP                     = 0,
	AJITOSTATE_TALK_START                    = 1,
	AJITOSTATE_TALK_START_END                = 2,
	AJITOSTATE_TALK_MAX                      = 3,
};

// Enum BattlePrototype.EAjitoMemberIdleStateType
// NumValues: 0x0004
enum class EAjitoMemberIdleStateType : uint8
{
	AJITOSTATE_IDLE                          = 0,
	AJITOSTATE_IDLE_START                    = 1,
	AJITOSTATE_IDLE_START_END                = 2,
	AJITOSTATE_MAX                           = 3,
};

// Enum BattlePrototype.EAjitoMemberState
// NumValues: 0x0008
enum class EAjitoMemberState : uint8
{
	Invalid                                  = 0,
	Entry                                    = 1,
	Idle                                     = 2,
	Talking                                  = 3,
	Conduit                                  = 4,
	Start                                    = 5,
	Wait                                     = 6,
	MAX                                      = 7,
};

// Enum BattlePrototype.ERSAutoTestResult
// NumValues: 0x0007
enum class ERSAutoTestResult : uint8
{
	Default                                  = 0,
	Invalid                                  = 1,
	Error                                    = 2,
	Running                                  = 3,
	Failed                                   = 4,
	Succeeded                                = 5,
	ERSAutoTestResult_MAX                    = 6,
};

// Enum BattlePrototype.EBootLevelFlow
// NumValues: 0x001C
enum class EBootLevelFlow : uint8
{
	Initialize                               = 0,
	UpdateSaveDataCheck                      = 1,
	UpdateSaveDataCheckWait                  = 2,
	UpdateSaveDataStorageCheck               = 3,
	UpdateSaveDataStorageCheckWait           = 4,
	UpdateSystemSaveDataCreate               = 5,
	UpdateSystemSaveDataCreateWait           = 6,
	UpdateSaveDataExist                      = 7,
	UpdateSaveDataExistWait                  = 8,
	UpdateSaveDataCreate                     = 9,
	UpdateSaveDataCreateWait                 = 10,
	UpdateSystemSaveDataLoadCheck            = 11,
	UpdateSystemSaveDataLoadCheckWait        = 12,
	UpdateAutoDataLoadCheck                  = 13,
	UpdateAutoSaveDataLoadCheckWait          = 14,
	UpdateSaveDataLoadCheck                  = 15,
	UpdateSaveDataLoadCheckWait              = 16,
	UpdateSaveErrorMessWait                  = 17,
	UpdateSaveDataDelete                     = 18,
	UpdateDLCCheck                           = 19,
	UpdateDLCRightsCheckWait                 = 20,
	UpdateDLCRightsCheckWait2                = 21,
	UpdateDLCCheckWait                       = 22,
	UpdateDLCCheckWaitNotReceived            = 23,
	UpdateDLCCheckAfterSystemSabeWait        = 24,
	FlowFailedSaveLoad                       = 25,
	FlowSuccess                              = 26,
	EBootLevelFlow_MAX                       = 27,
};

// Enum BattlePrototype.ERSCableGravityType
// NumValues: 0x0007
enum class ERSCableGravityType : uint8
{
	None                                     = 0,
	Capture                                  = 1,
	Run                                      = 2,
	Dash                                     = 3,
	HeavyGravity                             = 4,
	BrainCrash                               = 5,
	ERSCableGravityType_MAX                  = 6,
};

// Enum BattlePrototype.ERSCableAnimationState
// NumValues: 0x0003
enum class ERSCableAnimationState : uint8
{
	Normal                                   = 0,
	Sprint                                   = 1,
	Max                                      = 2,
};

// Enum BattlePrototype.ECharacterDeadType
// NumValues: 0x0003
enum class ECharacterDeadType : uint8
{
	Dead                                     = 0,
	BrainCrashDead                           = 1,
	ECharacterDeadType_MAX                   = 2,
};

// Enum BattlePrototype.ETargetFailedReason
// NumValues: 0x0006
enum class ETargetFailedReason : uint8
{
	None                                     = 0,
	Dead                                     = 1,
	NotExist                                 = 2,
	Lost                                     = 3,
	Other                                    = 4,
	ETargetFailedReason_MAX                  = 5,
};

// Enum BattlePrototype.ECharacterIgnoreDamageType
// NumValues: 0x0005
enum class ECharacterIgnoreDamageType : uint8
{
	Nothing                                  = 0,
	Damage                                   = 1,
	Reaction                                 = 2,
	BadState                                 = 3,
	ECharacterIgnoreDamageType_MAX           = 4,
};

// Enum BattlePrototype.ECharacterIgnoreDamage
// NumValues: 0x000C
enum class ECharacterIgnoreDamage : uint8
{
	Nothing                                  = 0,
	Damage                                   = 1,
	ReactionS                                = 2,
	ReactionL                                = 3,
	Down                                     = 4,
	Crash                                    = 5,
	Flame                                    = 6,
	Electric                                 = 7,
	Flooded                                  = 8,
	Oil                                      = 9,
	NoDeath                                  = 10,
	ECharacterIgnoreDamage_MAX               = 11,
};

// Enum BattlePrototype.RSCharaRestrictionState
// NumValues: 0x0005
enum class ERSCharaRestrictionState : uint8
{
	Normal                                   = 0,
	Restricted                               = 1,
	Blessed                                  = 2,
	NumOfEnum                                = 3,
	RSCharaRestrictionState_MAX              = 4,
};

// Enum BattlePrototype.EPlayingEventType
// NumValues: 0x0006
enum class EPlayingEventType : uint8
{
	Main                                     = 0,
	Bonds                                    = 1,
	TeamBonds                                = 2,
	StandBy                                  = 3,
	EventType                                = 4,
	EPlayingEventType_MAX                    = 5,
};

// Enum BattlePrototype.FHitEffectPriority
// NumValues: 0x0006
enum class EFHitEffectPriority : uint8
{
	Other                                    = 0,
	Npc                                      = 1,
	Enemy                                    = 2,
	MainPlayer                               = 3,
	Special                                  = 4,
	FHitEffectPriority_MAX                   = 5,
};

// Enum BattlePrototype.EEffectConnectPoint
// NumValues: 0x0006
enum class EEffectConnectPoint : uint8
{
	Owner                                    = 0,
	Pos                                      = 1,
	Weapon0                                  = 2,
	Weapon1                                  = 3,
	ThrowWeapon                              = 4,
	EEffectConnectPoint_MAX                  = 5,
};

// Enum BattlePrototype.EEffectObjectDebrisType
// NumValues: 0x0005
enum class EEffectObjectDebrisType : uint8
{
	Small                                    = 0,
	Medium                                   = 1,
	Large                                    = 2,
	Num                                      = 3,
	EEffectObjectDebrisType_MAX              = 4,
};

// Enum BattlePrototype.EFrameGrabType
// NumValues: 0x0003
enum class EFrameGrabType : uint8
{
	Screen                                   = 0,
	PostRender3D                             = 1,
	EFrameGrabType_MAX                       = 2,
};

// Enum BattlePrototype.EInGameFlowType
// NumValues: 0x0004
enum class EInGameFlowType : uint8
{
	Invalid                                  = 0,
	InGame                                   = 1,
	Num                                      = 2,
	EInGameFlowType_MAX                      = 3,
};

// Enum BattlePrototype.ERSGamepadType
// NumValues: 0x0005
enum class ERSGamepadType : uint8
{
	BUTTON                                   = 0,
	STICK                                    = 1,
	WHEEL                                    = 2,
	LAST_INDEX                               = 3,
	ERSGamepadType_MAX                       = 4,
};

// Enum BattlePrototype.EGeneralSpeed
// NumValues: 0x0004
enum class EGeneralSpeed : uint8
{
	Slow                                     = 0,
	Normal                                   = 1,
	Fast                                     = 2,
	EGeneralSpeed_MAX                        = 3,
};

// Enum BattlePrototype.EGeneralDistance
// NumValues: 0x0004
enum class EGeneralDistance : uint8
{
	Near                                     = 0,
	Normal                                   = 1,
	Far                                      = 2,
	EGeneralDistance_MAX                     = 3,
};

// Enum BattlePrototype.EGeneralLength
// NumValues: 0x0004
enum class EGeneralLength : uint8
{
	Short                                    = 0,
	Normal                                   = 1,
	Long                                     = 2,
	EGeneralLength_MAX                       = 3,
};

// Enum BattlePrototype.EGeneralSize
// NumValues: 0x0004
enum class EGeneralSize : uint8
{
	Small                                    = 0,
	Middle                                   = 1,
	Large                                    = 2,
	EGeneralSize_MAX                         = 3,
};

// Enum BattlePrototype.ESubMenuType
// NumValues: 0x0010
enum class ESubMenuType : uint8
{
	None                                     = 0,
	PartyMenu                                = 1,
	MapDetail                                = 2,
	ShopBuy                                  = 3,
	ShopSell                                 = 4,
	ShopTrade                                = 5,
	MapWorld                                 = 6,
	SaveMenu                                 = 7,
	LoadMenu                                 = 8,
	WeaponMenu                               = 9,
	EnemyBooks                               = 10,
	Present                                  = 11,
	PresentCheck                             = 12,
	BrainMessage                             = 13,
	SystemOrChoice                           = 14,
	ESubMenuType_MAX                         = 15,
};

// Enum BattlePrototype.ESkipEnum
// NumValues: 0x0004
enum class ESkipEnum : uint8
{
	TEST1                                    = 0,
	TEST2                                    = 1,
	TEST3                                    = 2,
	ESkipEnum_MAX                            = 3,
};

// Enum BattlePrototype.EPhaseAlphaCurveType
// NumValues: 0x0004
enum class EPhaseAlphaCurveType : uint8
{
	None                                     = 0,
	After30FFade                             = 1,
	After0FFade                              = 2,
	EPhaseAlphaCurveType_MAX                 = 3,
};

// Enum BattlePrototype.EWaitPhaseMotionFrameType
// NumValues: 0x0004
enum class EWaitPhaseMotionFrameType : uint8
{
	None                                     = 0,
	Start                                    = 1,
	Wait                                     = 2,
	EWaitPhaseMotionFrameType_MAX            = 3,
};

// Enum BattlePrototype.ECurveParamType
// NumValues: 0x0009
enum class ECurveParamType : uint8
{
	None                                     = 0,
	AlphaFade                                = 1,
	CrossFade                                = 2,
	ScaleU                                   = 3,
	ScaleV                                   = 4,
	OffsetU                                  = 5,
	OffsetV                                  = 6,
	Rotation                                 = 7,
	ECurveParamType_MAX                      = 8,
};

// Enum BattlePrototype.ENpcAnimationKind
// NumValues: 0x001C
enum class ENpcAnimationKind : uint8
{
	NPCANIM_IDLE                             = 0,
	NPCANIM_WALK                             = 1,
	NPCANIM_RUN                              = 2,
	NPCANIM_JOY                              = 3,
	NPCANIM_SCARED                           = 4,
	NPCANIM_SITDOWN                          = 5,
	NPCANIM_ANIMEX1                          = 6,
	NPCANIM_ANIMEX2                          = 7,
	NPCANIM_ANIMEX3                          = 8,
	NPCANIM_ANIMEX4                          = 9,
	NPCANIM_ANIMEX5                          = 10,
	NPCANIM_ANIMEX6                          = 11,
	NPCANIM_ANIMEX7                          = 12,
	NPCANIM_ANIMEX8                          = 13,
	NPCANIM_ANIMEX9                          = 14,
	NPCANIM_ANIMEX10                         = 15,
	NPCANIM_AJITO01                          = 16,
	NPCANIM_AJITO02                          = 17,
	NPCANIM_AJITO03                          = 18,
	NPCANIM_AJITO04                          = 19,
	NPCANIM_AJITO05                          = 20,
	NPCANIM_AJITO06                          = 21,
	NPCANIM_AJITO07                          = 22,
	NPCANIM_AJITO08                          = 23,
	NPCANIM_AJITO09                          = 24,
	NPCANIM_AJITO10                          = 25,
	NPCANIM_NUM                              = 26,
	NPCANIM_MAX                              = 27,
};

// Enum BattlePrototype.ERSParallelTiming
// NumValues: 0x0003
enum class ERSParallelTiming : uint8
{
	AfterPrePhysics1                         = 0,
	AfterDuringPhysics1                      = 1,
	ERSParallelTiming_MAX                    = 2,
};

// Enum BattlePrototype.ERSParticleSystemAttachRotationOffMode
// NumValues: 0x0003
enum class ERSParticleSystemAttachRotationOffMode : uint8
{
	RotationOffComponent                     = 0,
	RotationOffParent                        = 1,
	ERSParticleSystemAttachRotationOffMode_MAX = 2,
};

// Enum BattlePrototype.EPlayerHologramAnimKind
// NumValues: 0x0004
enum class EPlayerHologramAnimKind : uint8
{
	Invalid                                  = 0,
	CoverDamage                              = 1,
	CoverDamageAerial                        = 2,
	EPlayerHologramAnimKind_MAX              = 3,
};

// Enum BattlePrototype.ERedSaveExistsResult
// NumValues: 0x0007
enum class ERedSaveExistsResult : uint8
{
	OK                                       = 0,
	DoesNotExist                             = 1,
	Corrupt                                  = 2,
	UnspecifiedError                         = 3,
	NONE                                     = 4,
	NoSpace                                  = 5,
	Max                                      = 6,
};

// Enum BattlePrototype.ERSSaveGameSaveType
// NumValues: 0x0010
enum class ERSSaveGameSaveType : uint8
{
	Invalid                                  = 0,
	Normal                                   = 1,
	NormalOnly                               = 2,
	Auto                                     = 3,
	System                                   = 4,
	RetryData                                = 5,
	AsyncAutoSaveData                        = 6,
	AsyncSystem                              = 7,
	Normal_Header_Xbox                       = 8,
	Normal_Xbox                              = 9,
	NormalOnly_Xbox                          = 10,
	Debug                                    = 11,
	DebugTime                                = 12,
	TrialSystem                              = 13,
	Num                                      = 14,
	ERSSaveGameSaveType_MAX                  = 15,
};

// Enum BattlePrototype.EDspBus
// NumValues: 0x0009
enum class EDspBus : uint8
{
	MasterOut                                = 0,
	Psy                                      = 1,
	Pitchdown                                = 2,
	Hit_accel                                = 3,
	Motion_accel                             = 4,
	bgm_accel                                = 5,
	Reverb                                   = 6,
	Justdodge                                = 7,
	EDspBus_MAX                              = 8,
};

// Enum BattlePrototype.ESoundSelectorLabel
// NumValues: 0x0007
enum class ESoundSelectorLabel : uint8
{
	None                                     = 0,
	Area01                                   = 1,
	Area01_Bt                                = 2,
	Area01_Ev                                = 3,
	Area02                                   = 4,
	Area03                                   = 5,
	Max                                      = 6,
};

// Enum BattlePrototype.ESoundSelector
// NumValues: 0x0003
enum class ESoundSelector : uint8
{
	None                                     = 0,
	TrackTransition                          = 1,
	Max                                      = 2,
};

// Enum BattlePrototype.ESoundAisacControlId
// NumValues: 0x0012
enum class ESoundAisacControlId : uint8
{
	None                                     = 0,
	SAS_Accelerate                           = 1,
	Pitch_down                               = 2,
	AisacControl02                           = 3,
	AisacControl03                           = 4,
	AisacControl04                           = 5,
	AisacControl05                           = 6,
	AisacControl06                           = 7,
	AisacControl07                           = 8,
	AisacControl08                           = 9,
	AisacControl09                           = 10,
	Distance                                 = 11,
	AisacControl11                           = 12,
	AisacControl12                           = 13,
	AisacControl13                           = 14,
	Drive                                    = 15,
	Battle_Location                          = 16,
	Max                                      = 17,
};

// Enum BattlePrototype.ESoundSnapshot
// NumValues: 0x001C
enum class ESoundSnapshot : uint8
{
	None                                     = 0,
	Outside_Defalut                          = 1,
	AccelerateOn                             = 2,
	AccelerateOff                            = 3,
	ElectricOn                               = 4,
	JustDodgeOn                              = 5,
	Le007_Area01                             = 6,
	Room_Defalut                             = 7,
	Le001_Area01                             = 8,
	Le008_Area01                             = 9,
	Le008_Area03                             = 10,
	Le008_Area03_2                           = 11,
	Le009_Area01                             = 12,
	Le012_Area01                             = 13,
	Le013_Area01                             = 14,
	Le013_Area03                             = 15,
	Le014_Area01                             = 16,
	Le017_Area01                             = 17,
	Le017_Area02                             = 18,
	Le019_Area01                             = 19,
	Le020_Area01                             = 20,
	Le021_Area01                             = 21,
	Le022_Area01                             = 22,
	Le022_Area02                             = 23,
	Le022_Area03                             = 24,
	Le022_Area04                             = 25,
	Le029_Area01                             = 26,
	Max                                      = 27,
};

// Enum BattlePrototype.ESoundCategory
// NumValues: 0x0008
enum class ESoundCategory : uint8
{
	None                                     = 0,
	Bgm                                      = 1,
	Me                                       = 2,
	Se                                       = 3,
	Voice                                    = 4,
	Se_env                                   = 5,
	Through                                  = 6,
	Max                                      = 7,
};

// Enum BattlePrototype.ESoundState
// NumValues: 0x000A
enum class ESoundState : uint8
{
	Stage                                    = 0,
	Menu                                     = 1,
	Title                                    = 2,
	GameOver                                 = 3,
	Revitalizetion                           = 4,
	Loading                                  = 5,
	Map                                      = 6,
	StaffRoll                                = 7,
	SoundStateMax                            = 8,
	ESoundState_MAX                          = 9,
};

// Enum BattlePrototype.ENotifySoundReplace_EnStr
// NumValues: 0x0004
enum class ENotifySoundReplace_EnStr : uint8
{
	None                                     = 0,
	Middle                                   = 1,
	High                                     = 2,
	ENotifySoundReplace_MAX                  = 3,
};

// Enum BattlePrototype.EBgmCategory
// NumValues: 0x0007
enum class EBgmCategory : uint8
{
	Stage                                    = 0,
	Boss                                     = 1,
	Event                                    = 2,
	BrainField                               = 3,
	Shop                                     = 4,
	BgmCategoryMax                           = 5,
	EBgmCategory_MAX                         = 6,
};

// Enum BattlePrototype.ETitleSaveCheck
// NumValues: 0x0004
enum class ETitleSaveCheck : uint8
{
	SaveData                                 = 0,
	AutoSave                                 = 1,
	SystemSave                               = 2,
	ETitleSaveCheck_MAX                      = 3,
};

// Enum BattlePrototype.ETitleLevelFlow
// NumValues: 0x0009
enum class ETitleLevelFlow : uint8
{
	SaveDataPreLoad                          = 0,
	SaveDataPreLoadCheck                     = 1,
	AutoSaveDataPreLoad                      = 2,
	AutoSaveDataPreLoadCheck                 = 3,
	Initialize                               = 4,
	FirstFlow                                = 5,
	TitleMenu                                = 6,
	EndingFlow                               = 7,
	ETitleLevelFlow_MAX                      = 8,
};

// Enum BattlePrototype.EEditorMobility
// NumValues: 0x0004
enum class EEditorMobility : uint8
{
	Static                                   = 0,
	Stationary                               = 1,
	Movable                                  = 2,
	EEditorMobility_MAX                      = 3,
};

// Enum BattlePrototype.EMapIconType
// NumValues: 0x0003
enum class EMapIconType : uint8
{
	TreasureBox                              = 0,
	MaterialPoint                            = 1,
	Max                                      = 2,
};

// Enum BattlePrototype.EAreaName
// NumValues: 0x0010
enum class EAreaName : uint8
{
	Area01                                   = 0,
	Area02                                   = 1,
	Area03                                   = 2,
	Area04                                   = 3,
	Area05                                   = 4,
	Area06                                   = 5,
	Area07                                   = 6,
	Area08                                   = 7,
	Area09                                   = 8,
	Area10                                   = 9,
	Area11                                   = 10,
	Area12                                   = 11,
	Area13                                   = 12,
	Area14                                   = 13,
	Area15                                   = 14,
	Max                                      = 15,
};

// Enum BattlePrototype.ELocationName
// NumValues: 0x0064
enum class ELocationName : uint8
{
	LC01                                     = 0,
	LC02                                     = 1,
	LC03                                     = 2,
	LC04                                     = 3,
	LC05                                     = 4,
	LC06                                     = 5,
	LC07                                     = 6,
	LC08                                     = 7,
	LC09                                     = 8,
	LC10                                     = 9,
	LC11                                     = 10,
	LC12                                     = 11,
	LC13                                     = 12,
	LC14                                     = 13,
	LC15                                     = 14,
	LC16                                     = 15,
	LC17                                     = 16,
	LC18                                     = 17,
	LC19                                     = 18,
	LC20                                     = 19,
	LC21                                     = 20,
	LC22                                     = 21,
	LC23                                     = 22,
	LC24                                     = 23,
	LC25                                     = 24,
	LC26                                     = 25,
	LC27                                     = 26,
	LC28                                     = 27,
	LC29                                     = 28,
	LC30                                     = 29,
	LC31                                     = 30,
	LC32                                     = 31,
	LC33                                     = 32,
	LC34                                     = 33,
	LC35                                     = 34,
	LC36                                     = 35,
	LC37                                     = 36,
	LC38                                     = 37,
	LC39                                     = 38,
	LC40                                     = 39,
	LC41                                     = 40,
	LC42                                     = 41,
	LC43                                     = 42,
	LC44                                     = 43,
	LC45                                     = 44,
	LC46                                     = 45,
	LC47                                     = 46,
	LC48                                     = 47,
	LC49                                     = 48,
	LC50                                     = 49,
	LC51                                     = 50,
	LC52                                     = 51,
	LC53                                     = 52,
	LC54                                     = 53,
	LC55                                     = 54,
	LC56                                     = 55,
	LC57                                     = 56,
	LC58                                     = 57,
	LC59                                     = 58,
	LC60                                     = 59,
	LC61                                     = 60,
	LC62                                     = 61,
	LC63                                     = 62,
	LC64                                     = 63,
	LC65                                     = 64,
	LC66                                     = 65,
	LC67                                     = 66,
	LC68                                     = 67,
	LC69                                     = 68,
	LC70                                     = 69,
	LC71                                     = 70,
	LC72                                     = 71,
	LC73                                     = 72,
	LC74                                     = 73,
	LC75                                     = 74,
	LC76                                     = 75,
	LC77                                     = 76,
	LC78                                     = 77,
	LC79                                     = 78,
	LC80                                     = 79,
	LC81                                     = 80,
	LC82                                     = 81,
	LC83                                     = 82,
	LC84                                     = 83,
	LC85                                     = 84,
	LC86                                     = 85,
	LC87                                     = 86,
	LC88                                     = 87,
	LC89                                     = 88,
	LC90                                     = 89,
	LC91                                     = 90,
	LC92                                     = 91,
	LC93                                     = 92,
	LC94                                     = 93,
	LC95                                     = 94,
	LC96                                     = 95,
	LC97                                     = 96,
	LC98                                     = 97,
	LC99                                     = 98,
	Max                                      = 99,
};

// Enum BattlePrototype.ESASCutinExtraID
// NumValues: 0x0006
enum class ESASCutinExtraID : uint8
{
	Invalid                                  = 0,
	SASE_ch0300_0800                         = 1,
	SASE_ch0500_0700                         = 2,
	SASE_ch0400_0600                         = 3,
	SASE_ch0900_1000                         = 4,
	ESASCutinExtraID_MAX                     = 5,
};

// Enum BattlePrototype.SaveLoadDebugType
// NumValues: 0x0009
enum class ESaveLoadDebugType : uint8
{
	NormalMode                               = 0,
	BreakMode                                = 1,
	ClearKasaneMode                          = 2,
	ClearYuitoMode                           = 3,
	ClearYuitoKasaneMode                     = 4,
	ClearDataMode                            = 5,
	ClearExMode                              = 6,
	ClearEndContentMode                      = 7,
	SaveLoadDebugType_MAX                    = 8,
};

// Enum BattlePrototype.ESaveLoadSubType
// NumValues: 0x0003
enum class ESaveLoadSubType : uint8
{
	NormalMode                               = 0,
	EXMode                                   = 1,
	ESaveLoadSubType_MAX                     = 2,
};

// Enum BattlePrototype.ESaveLoad
// NumValues: 0x0003
enum class ESaveLoad : uint8
{
	Save                                     = 0,
	Load                                     = 1,
	ESaveLoad_MAX                            = 2,
};

// Enum BattlePrototype.ELoadingScreenType
// NumValues: 0x0007
enum class ELoadingScreenType : uint8
{
	None                                     = 0,
	Global                                   = 1,
	GlobalEasy                               = 2,
	ChapterStart                             = 3,
	Interlude                                = 4,
	Num                                      = 5,
	ELoadingScreenType_MAX                   = 6,
};

// Enum BattlePrototype.EMainScenarioType
// NumValues: 0x0005
enum class EMainScenarioType : uint8
{
	Male                                     = 0,
	Female                                   = 1,
	Confluence                               = 2,
	None                                     = 3,
	Max                                      = 4,
};

// Enum BattlePrototype.ESequencerDilationOwner
// NumValues: 0x0005
enum class ESequencerDilationOwner : uint8
{
	Dilation_MainPlayer                      = 0,
	Dilation_AttachActor                     = 1,
	Dilation_World                           = 2,
	Dilation_None                            = 3,
	Dilation_MAX                             = 4,
};

// Enum BattlePrototype.ESequencerSoundDemoType
// NumValues: 0x0006
enum class ESequencerSoundDemoType : uint8
{
	Other                                    = 0,
	BrainFieldOpen                           = 1,
	BrainFieldIn                             = 2,
	BrainFieldOut                            = 3,
	SASCutIn                                 = 4,
	ESequencerSoundDemoType_MAX              = 5,
};

// Enum BattlePrototype.EAsrRackConfigElementId
// NumValues: 0x0003
enum class EAsrRackConfigElementId : uint8
{
	None                                     = 0,
	PadSpk                                   = 1,
	EAsrRackConfigElementId_MAX              = 2,
};

// Enum BattlePrototype.EFilterCallbackType
// NumValues: 0x0003
enum class EFilterCallbackType : uint8
{
	None                                     = 0,
	StaticCutScene                           = 1,
	EFilterCallbackType_MAX                  = 2,
};

// Enum BattlePrototype.ESoundActionOnFadeOutEnd
// NumValues: 0x0004
enum class ESoundActionOnFadeOutEnd : uint8
{
	None                                     = 0,
	Stop                                     = 1,
	Pause                                    = 2,
	ESoundActionOnFadeOutEnd_MAX             = 3,
};

// Enum BattlePrototype.ESoundFadeState
// NumValues: 0x0007
enum class ESoundFadeState : uint8
{
	None                                     = 0,
	FadeIn                                   = 1,
	FadeInEnd                                = 2,
	FadeOut                                  = 3,
	FadeOutEnd                               = 4,
	End                                      = 5,
	Max                                      = 6,
};

// Enum BattlePrototype.TargetListType
// NumValues: 0x0003
enum class ETargetListType : uint8
{
	TargetListLockon                         = 0,
	TargetListBrainCrash                     = 1,
	TargetListType_MAX                       = 2,
};

// Enum BattlePrototype.TeamKind
// NumValues: 0x0004
enum class ETeamKind : uint8
{
	Player                                   = 0,
	Enemy                                    = 1,
	Mob                                      = 2,
	TeamKind_MAX                             = 3,
};

// Enum BattlePrototype.ETitleAnime
// NumValues: 0x0007
enum class ETitleAnime : uint8
{
	Default_Idle                             = 0,
	StartAnime_Idle                          = 1,
	FastAnime                                = 2,
	EndingAnime                              = 3,
	StandUpAnime                             = 4,
	Num                                      = 5,
	ETitleAnime_MAX                          = 6,
};

// Enum BattlePrototype.ETrgEffMode
// NumValues: 0x0005
enum class ETrgEffMode : uint8
{
	Off                                      = 0,
	Feedback                                 = 1,
	Weapon                                   = 2,
	Vibration                                = 3,
	ETrgEffMode_MAX                          = 4,
};

// Enum BattlePrototype.EVibSndPrio
// NumValues: 0x0018
enum class EVibSndPrio : uint8
{
	Default                                  = 0,
	Compatible                               = 1,
	NormalL                                  = 2,
	NormalM                                  = 3,
	NormalH                                  = 4,
	FootL                                    = 5,
	FootM                                    = 6,
	FootH                                    = 7,
	AttackL                                  = 8,
	AttackM                                  = 9,
	AttackH                                  = 10,
	DamageL                                  = 11,
	DamageM                                  = 12,
	DamageH                                  = 13,
	DirectShotL                              = 14,
	DirectShotM                              = 15,
	DirectShotH                              = 16,
	BrainCrashL                              = 17,
	BrainCrashM                              = 18,
	BrainCrashH                              = 19,
	BrainFieldL                              = 20,
	BrainFieldM                              = 21,
	BrainFieldH                              = 22,
	EVibSndPrio_MAX                          = 23,
};

// Enum BattlePrototype.EVibSndMode
// NumValues: 0x000C
enum class EVibSndMode : uint8
{
	Normal                                   = 0,
	DirectShot                               = 1,
	DirectShotForPsyObj                      = 2,
	Strength                                 = 3,
	MapGimmick                               = 4,
	BrainCrash                               = 5,
	BrainField                               = 6,
	Sequencer                                = 7,
	UI                                       = 8,
	Location                                 = 9,
	Compatible                               = 10,
	EVibSndMode_MAX                          = 11,
};

// Enum BattlePrototype.EActionIconSubQuestState
// NumValues: 0x0004
enum class EActionIconSubQuestState : uint8
{
	NonAccept                                = 0,
	Achieved                                 = 1,
	None                                     = 2,
	EActionIconSubQuestState_MAX             = 3,
};

// Enum BattlePrototype.EActionIconType
// NumValues: 0x000C
enum class EActionIconType : uint8
{
	Check                                    = 0,
	Talk                                     = 1,
	Quest                                    = 2,
	SubQuest                                 = 3,
	Shop                                     = 4,
	Save                                     = 5,
	SubQuestNavi                             = 6,
	Resurrection                             = 7,
	Bonds                                    = 8,
	News                                     = 9,
	Num                                      = 10,
	EActionIconType_MAX                      = 11,
};

// Enum BattlePrototype.EActionIconMode
// NumValues: 0x0005
enum class EActionIconMode : uint8
{
	End                                      = 0,
	Near                                     = 1,
	Actionable                               = 2,
	Decide                                   = 3,
	EActionIconMode_MAX                      = 4,
};

// Enum BattlePrototype.EBossNameMode
// NumValues: 0x0004
enum class EBossNameMode : uint8
{
	Default                                  = 0,
	FreeTime                                 = 1,
	WaitInput                                = 2,
	EBossNameMode_MAX                        = 3,
};

// Enum BattlePrototype.ECharaSelectType
// NumValues: 0x0003
enum class ECharaSelectType : uint8
{
	Normal                                   = 0,
	ExSelect                                 = 1,
	ECharaSelectType_MAX                     = 2,
};

// Enum BattlePrototype.EChromaticAberrationType
// NumValues: 0x0003
enum class EChromaticAberrationType : uint8
{
	CA_RGB                                   = 0,
	CA_RB                                    = 1,
	CA_MAX                                   = 2,
};

// Enum BattlePrototype.EDiscoverIconType
// NumValues: 0x0006
enum class EDiscoverIconType : uint8
{
	Invalid                                  = 0,
	Surprised                                = 1,
	Question                                 = 2,
	DiscoverAwareness                        = 3,
	DiscoverOver                             = 4,
	EDiscoverIconType_MAX                    = 5,
};

// Enum BattlePrototype.EDiscoverType
// NumValues: 0x0006
enum class EDiscoverType : uint8
{
	Invalid                                  = 0,
	Discover                                 = 1,
	UnDiscoverAwareness                      = 2,
	UnDiscoverOver                           = 3,
	UnDiscover                               = 4,
	EDiscoverType_MAX                        = 5,
};

// Enum BattlePrototype.EUIFadeColorType
// NumValues: 0x0003
enum class EUIFadeColorType : uint8
{
	Black                                    = 0,
	White                                    = 1,
	MAX                                      = 2,
};

// Enum BattlePrototype.EUIFadeType
// NumValues: 0x0003
enum class EUIFadeType : uint8
{
	FadeOut                                  = 0,
	FadeIn                                   = 1,
	EUIFadeType_MAX                          = 2,
};

// Enum BattlePrototype.EGameOverResult
// NumValues: 0x0004
enum class EGameOverResult : uint8
{
	Invalid                                  = 0,
	Retry                                    = 1,
	ReturnToTitle                            = 2,
	EGameOverResult_MAX                      = 3,
};

// Enum BattlePrototype.EGuideKey
// NumValues: 0x0025
enum class EGuideKey : uint8
{
	Invalid                                  = 0,
	DECIDE                                   = 1,
	CANCEL                                   = 2,
	CROSS                                    = 3,
	CIRCLE                                   = 4,
	SQUARE                                   = 5,
	TRIANGLE                                 = 6,
	L1                                       = 7,
	R1                                       = 8,
	L2                                       = 9,
	R2                                       = 10,
	L3                                       = 11,
	R3                                       = 12,
	ARROW                                    = 13,
	UP                                       = 14,
	DOWN                                     = 15,
	LEFT                                     = 16,
	RIGHT                                    = 17,
	UP_DOWN                                  = 18,
	LEFT_RIGHT                               = 19,
	L_STICK                                  = 20,
	L_STICK_UP                               = 21,
	L_STICK_DOWN                             = 22,
	L_STICK_LEFT                             = 23,
	L_STICK_RIGHT                            = 24,
	L_STICK_UP_DOWN                          = 25,
	L_STICK_LEFT_RIGHT                       = 26,
	R_STICK                                  = 27,
	R_STICK_UP                               = 28,
	R_STICK_DOWN                             = 29,
	R_STICK_LEFT                             = 30,
	R_STICK_RIGHT                            = 31,
	R_STICK_UP_DOWN                          = 32,
	R_STICK_LEFT_RIGHT                       = 33,
	OPTION                                   = 34,
	TOUCH_PAD                                = 35,
	EGuideKey_MAX                            = 36,
};

// Enum BattlePrototype.EWishListAction
// NumValues: 0x0006
enum class EWishListAction : uint8
{
	None                                     = 0,
	L2                                       = 1,
	R2                                       = 2,
	EnemyBooks                               = 3,
	End                                      = 4,
	EWishListAction_MAX                      = 5,
};

// Enum BattlePrototype.EItemTradeAction
// NumValues: 0x0007
enum class EItemTradeAction : uint8
{
	None                                     = 0,
	L1                                       = 1,
	R1                                       = 2,
	Equipment                                = 3,
	EnemyBooks                               = 4,
	End                                      = 6,
	EItemTradeAction_MAX                     = 7,
};

// Enum BattlePrototype.EUIMain3DCharacterSceneID
// NumValues: 0x0005
enum class EUIMain3DCharacterSceneID : uint8
{
	Default                                  = 0,
	ChangeBase                               = 1,
	ChangeTarget                             = 2,
	Equip                                    = 3,
	MAX                                      = 4,
};

// Enum BattlePrototype.EUIMain3DEquipCameraID
// NumValues: 0x000A
enum class EUIMain3DEquipCameraID : uint8
{
	MEC_Default                              = 0,
	MEC_Costume                              = 1,
	MEC_Weapon                               = 2,
	MEC_Att_Face                             = 3,
	MEC_Att_Breast                           = 4,
	MEC_Att_Back                             = 5,
	MEC_Att_Hips                             = 6,
	MEC_Att_Hand                             = 7,
	MEC_Att_Foot                             = 8,
	MEC_Max                                  = 9,
};

// Enum BattlePrototype.EUIMain3DEquipSelectID
// NumValues: 0x0005
enum class EUIMain3DEquipSelectID : uint8
{
	MES_Default                              = 0,
	MES_Costume                              = 1,
	MES_Weapon                               = 2,
	MES_Attachment                           = 3,
	MES_Max                                  = 4,
};

// Enum BattlePrototype.EUIMain3DPlayerAnimationType
// NumValues: 0x0004
enum class EUIMain3DPlayerAnimationType : uint8
{
	MPAT_Party                               = 0,
	MPAT_Weapon                              = 1,
	MPAT_Costume                             = 2,
	MPAT_Max                                 = 3,
};

// Enum BattlePrototype.EMainContentsLoopSubState
// NumValues: 0x0007
enum class EMainContentsLoopSubState : uint8
{
	Init                                     = 0,
	MainLoop                                 = 1,
	CloseOldTab                              = 2,
	OpenNewTab                               = 3,
	WaitOpenNewTab                           = 4,
	ChangeDrawMode                           = 5,
	EMainContentsLoopSubState_MAX            = 6,
};

// Enum BattlePrototype.EMainContentsState
// NumValues: 0x0006
enum class EMainContentsState : uint8
{
	None                                     = 0,
	Open                                     = 1,
	Loop                                     = 2,
	Close                                    = 3,
	Information                              = 4,
	EMainContentsState_MAX                   = 5,
};

// Enum BattlePrototype.EMainContentsAnim
// NumValues: 0x000B
enum class EMainContentsAnim : uint8
{
	Default                                  = 0,
	DefaultNone                              = 1,
	In                                       = 2,
	Out                                      = 3,
	DefaultView                              = 4,
	ChangeView                               = 5,
	ChangeDefault                            = 6,
	InfoWindow                               = 7,
	InfoWindowIn                             = 8,
	InfoWindowOut                            = 9,
	EMainContentsAnim_MAX                    = 10,
};

// Enum BattlePrototype.EUIMinmapDistanceIconColor
// NumValues: 0x0003
enum class EUIMinmapDistanceIconColor : uint8
{
	Red                                      = 0,
	Normal                                   = 1,
	EUIMinmapDistanceIconColor_MAX           = 2,
};

// Enum BattlePrototype.EUIMinmapDistanceIcon
// NumValues: 0x0005
enum class EUIMinmapDistanceIcon : uint8
{
	Main                                     = 0,
	Bonds                                    = 1,
	Sub                                      = 2,
	SubComp                                  = 3,
	EUIMinmapDistanceIcon_MAX                = 4,
};

// Enum BattlePrototype.EMouseIconType
// NumValues: 0x0009
enum class EMouseIconType : uint8
{
	Invalid                                  = 0,
	Move                                     = 1,
	Left                                     = 2,
	Right                                    = 3,
	Center                                   = 4,
	Ex1                                      = 5,
	Ex2                                      = 6,
	Num                                      = 7,
	EMouseIconType_MAX                       = 8,
};

// Enum BattlePrototype.EPsychicWeightGaugeSize
// NumValues: 0x0004
enum class EPsychicWeightGaugeSize : uint8
{
	Small                                    = 0,
	Middle                                   = 1,
	Large                                    = 2,
	EPsychicWeightGaugeSize_MAX              = 3,
};

// Enum BattlePrototype.EPsychicWeightGaugeButton
// NumValues: 0x0004
enum class EPsychicWeightGaugeButton : uint8
{
	Button1                                  = 0,
	Button2                                  = 1,
	Button3                                  = 2,
	EPsychicWeightGaugeButton_MAX            = 3,
};

// Enum BattlePrototype.EResurrectionIconMode
// NumValues: 0x0005
enum class EResurrectionIconMode : uint8
{
	End                                      = 0,
	Near                                     = 1,
	Active                                   = 2,
	Execute                                  = 3,
	EResurrectionIconMode_MAX                = 4,
};

// Enum BattlePrototype.ESASActionIconType
// NumValues: 0x0008
enum class ESASActionIconType : uint8
{
	None                                     = 0,
	Fire                                     = 1,
	Stealth                                  = 2,
	Electric                                 = 3,
	Accelerate                               = 4,
	Teleport                                 = 5,
	Unusable                                 = 6,
	ESASActionIconType_MAX                   = 7,
};

// Enum BattlePrototype.E_SASIconStatus
// NumValues: 0x0004
enum class E_SASIconStatus : uint8
{
	Disable                                  = 0,
	Inactive                                 = 1,
	Active                                   = 2,
	E_MAX                                    = 3,
};

// Enum BattlePrototype.ESasKeyType
// NumValues: 0x0007
enum class ESasKeyType : uint8
{
	MenuOpenClose                            = 0,
	MenuPageSwitch                           = 1,
	ExecKey1                                 = 2,
	ExecKey2                                 = 3,
	ExecKey3                                 = 4,
	ExecKey4                                 = 5,
	ESasKeyType_MAX                          = 6,
};

// Enum BattlePrototype.SaveLoadListClearType
// NumValues: 0x0004
enum class ESaveLoadListClearType : uint8
{
	KasaneClear                              = 0,
	YuitoClear                               = 1,
	AllClear                                 = 2,
	SaveLoadListClearType_MAX                = 3,
};

// Enum BattlePrototype.SaveLoadListType
// NumValues: 0x0005
enum class ESaveLoadListType : uint8
{
	NoData                                   = 0,
	BreakData                                = 1,
	ClearData                                = 2,
	Data                                     = 3,
	SaveLoadListType_MAX                     = 4,
};

// Enum BattlePrototype.EAreaInfoDetaileConditionType
// NumValues: 0x000B
enum class EAreaInfoDetaileConditionType : uint8
{
	NONE                                     = 0,
	EQUAL                                    = 1,
	NOT_EQUAL                                = 2,
	GREATER                                  = 3,
	GREATER_EQUAL                            = 4,
	LESSER                                   = 5,
	LESSER_EQUAL                             = 6,
	IS_ON                                    = 7,
	IS_OFF                                   = 8,
	NUM                                      = 9,
	EAreaInfoDetaileConditionType_MAX        = 10,
};

// Enum BattlePrototype.EAreaInfoDetaileCheckType
// NumValues: 0x0004
enum class EAreaInfoDetaileCheckType : uint8
{
	PROGRESS                                 = 0,
	FLAG_BOOL                                = 1,
	NUM                                      = 2,
	EAreaInfoDetaileCheckType_MAX            = 3,
};

// Enum BattlePrototype.EUiSceneMapIconType
// NumValues: 0x000B
enum class EUiSceneMapIconType : uint8
{
	Invalid                                  = 0,
	AreaChange                               = 1,
	TreasureBox                              = 2,
	MaterialPoint                            = 3,
	SavePoint                                = 4,
	Shop                                     = 5,
	MapGimmick                               = 6,
	TownNPC                                  = 7,
	WorldmapChange                           = 8,
	Num                                      = 9,
	EUiSceneMapIconType_MAX                  = 10,
};

// Enum BattlePrototype.EShopMode
// NumValues: 0x0005
enum class EShopMode : uint8
{
	Buy                                      = 0,
	Sell                                     = 1,
	Trade                                    = 2,
	GetContents                              = 3,
	EShopMode_MAX                            = 4,
};

// Enum BattlePrototype.EGetContentsAction
// NumValues: 0x0005
enum class EGetContentsAction : uint8
{
	None                                     = 0,
	L1                                       = 1,
	R1                                       = 2,
	End                                      = 4,
	EGetContentsAction_MAX                   = 5,
};

// Enum BattlePrototype.EEquipOrLoveIcon
// NumValues: 0x0004
enum class EEquipOrLoveIcon : uint8
{
	Equip                                    = 0,
	Like                                     = 1,
	Love                                     = 2,
	EEquipOrLoveIcon_MAX                     = 3,
};

// Enum BattlePrototype.TitleCursorType
// NumValues: 0x0004
enum class ETitleCursorType : uint8
{
	NormalData                               = 0,
	UnSelectData                             = 1,
	Num                                      = 2,
	TitleCursorType_MAX                      = 3,
};

// Enum BattlePrototype.EUITitleSequencer
// NumValues: 0x000D
enum class EUITitleSequencer : uint8
{
	Default                                  = 0,
	FastNewGame                              = 1,
	EndingStart                              = 2,
	YuitoSelectStart                         = 3,
	YuitoSelect                              = 4,
	YuitoSelectCancel                        = 5,
	YuitoDecide                              = 6,
	KasaneSelectStart                        = 7,
	KasaneSelect                             = 8,
	KasaneSelectCancel                       = 9,
	KasaneDecide                             = 10,
	Num                                      = 11,
	EUITitleSequencer_MAX                    = 12,
};

// Enum BattlePrototype.TutoMoviePlayType
// NumValues: 0x0004
enum class ETutoMoviePlayType : uint8
{
	Invalid                                  = 0,
	Play                                     = 1,
	Stop                                     = 2,
	TutoMoviePlayType_MAX                    = 3,
};

// Enum BattlePrototype.EGameClearState
// NumValues: 0x0005
enum class EGameClearState : uint8
{
	NotClearBoth                             = 0,
	ClearMale                                = 1,
	ClearFemale                              = 2,
	ClearBoth                                = 3,
	EGameClearState_MAX                      = 4,
};

// Enum BattlePrototype.LIBRARY_FLAG
// NumValues: 0x0005
enum class ELIBRARY_FLAG : uint8
{
	Invalid                                  = 0,
	Open                                     = 1,
	READ                                     = 2,
	NEW                                      = 4,
	LIBRARY_FLAG_MAX                         = 5,
};

// Enum BattlePrototype.ECanBeAddedItems
// NumValues: 0x0004
enum class ECanBeAddedItems : uint8
{
	CannotBeAdded                            = 0,
	CanBeAdded                               = 1,
	Overflow                                 = 2,
	ECanBeAddedItems_MAX                     = 3,
};

// Enum BattlePrototype.EVisionFogID
// NumValues: 0x0008
enum class EVisionFogID : uint8
{
	VF_em1020                                = 0,
	VF_em1210                                = 1,
	VF_np1100                                = 2,
	VF_em1400                                = 3,
	VF_em1300                                = 4,
	VF_em8300                                = 5,
	VF_em1200                                = 6,
	Max                                      = 7,
};

// Enum BattlePrototype.ETouchControlLayout
// NumValues: 0x0017
enum class ETouchControlLayout : uint8
{
	Hide                                     = 0,
	Default                                  = 1,
	BattleXA                                 = 2,
	BattleXAn                                = 3,
	BattleYB                                 = 4,
	BattleYBn                                = 5,
	BattleXY                                 = 6,
	BattleXYn                                = 7,
	BattleAB                                 = 8,
	BattleABn                                = 9,
	BattleXB                                 = 10,
	BattleXBn                                = 11,
	BattleYA                                 = 12,
	BattleYAn                                = 13,
	Field                                    = 14,
	Menu                                     = 15,
	Event                                    = 16,
	Talk                                     = 17,
	CutScene                                 = 18,
	Pause                                    = 19,
	Map                                      = 20,
	WMap                                     = 21,
	ETouchControlLayout_MAX                  = 22,
};

// ScriptStruct BattlePrototype.AjitoMemberPlaceCandicateInfo
// 0x0048 (0x0050 - 0x0008)
struct FAjitoMemberPlaceCandicateInfo final : public FTableRowBase
{
public:
	class FString                                 Description;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SubDescription;                                    // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ArrangementMasterKey;                              // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAjitoMemberPlaceCandicateInfo) == 0x000008, "Wrong alignment on FAjitoMemberPlaceCandicateInfo");
static_assert(sizeof(FAjitoMemberPlaceCandicateInfo) == 0x000050, "Wrong size on FAjitoMemberPlaceCandicateInfo");
static_assert(offsetof(FAjitoMemberPlaceCandicateInfo, Description) == 0x000008, "Member 'FAjitoMemberPlaceCandicateInfo::Description' has a wrong offset!");
static_assert(offsetof(FAjitoMemberPlaceCandicateInfo, SubDescription) == 0x000018, "Member 'FAjitoMemberPlaceCandicateInfo::SubDescription' has a wrong offset!");
static_assert(offsetof(FAjitoMemberPlaceCandicateInfo, ArrangementMasterKey) == 0x000028, "Member 'FAjitoMemberPlaceCandicateInfo::ArrangementMasterKey' has a wrong offset!");

// ScriptStruct BattlePrototype.BondsEpisodeRawDBDataCell
// 0x0058 (0x0060 - 0x0008)
struct FBondsEpisodeRawDBDataCell final : public FTableRowBase
{
public:
	class FName                                   BondsEpisodeID;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScenarioType                                 ScenarioType;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MsgListTitle;                                      // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgDetailTitle;                                    // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTeam;                                            // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TargetBondsCharID;                                 // 0x0025(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MsgContent;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ImagePath;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConditionProgressNo;                               // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConditionFlag;                                     // 0x0044(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BondsProgressId;                                   // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShowDestinationBoolCheckType                 RelationshipOfConditions;                          // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     PresentCheckPlayer;                                // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PresentID;                                         // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBondsEpisodeRawDBDataCell) == 0x000008, "Wrong alignment on FBondsEpisodeRawDBDataCell");
static_assert(sizeof(FBondsEpisodeRawDBDataCell) == 0x000060, "Wrong size on FBondsEpisodeRawDBDataCell");
static_assert(offsetof(FBondsEpisodeRawDBDataCell, BondsEpisodeID) == 0x000008, "Member 'FBondsEpisodeRawDBDataCell::BondsEpisodeID' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeRawDBDataCell, ScenarioType) == 0x000010, "Member 'FBondsEpisodeRawDBDataCell::ScenarioType' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeRawDBDataCell, MsgListTitle) == 0x000014, "Member 'FBondsEpisodeRawDBDataCell::MsgListTitle' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeRawDBDataCell, MsgDetailTitle) == 0x00001C, "Member 'FBondsEpisodeRawDBDataCell::MsgDetailTitle' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeRawDBDataCell, IsTeam) == 0x000024, "Member 'FBondsEpisodeRawDBDataCell::IsTeam' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeRawDBDataCell, TargetBondsCharID) == 0x000025, "Member 'FBondsEpisodeRawDBDataCell::TargetBondsCharID' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeRawDBDataCell, MsgContent) == 0x000028, "Member 'FBondsEpisodeRawDBDataCell::MsgContent' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeRawDBDataCell, ImagePath) == 0x000030, "Member 'FBondsEpisodeRawDBDataCell::ImagePath' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeRawDBDataCell, ConditionProgressNo) == 0x000040, "Member 'FBondsEpisodeRawDBDataCell::ConditionProgressNo' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeRawDBDataCell, ConditionFlag) == 0x000044, "Member 'FBondsEpisodeRawDBDataCell::ConditionFlag' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeRawDBDataCell, BondsProgressId) == 0x00004C, "Member 'FBondsEpisodeRawDBDataCell::BondsProgressId' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeRawDBDataCell, RelationshipOfConditions) == 0x000050, "Member 'FBondsEpisodeRawDBDataCell::RelationshipOfConditions' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeRawDBDataCell, PresentCheckPlayer) == 0x000051, "Member 'FBondsEpisodeRawDBDataCell::PresentCheckPlayer' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeRawDBDataCell, PresentID) == 0x000054, "Member 'FBondsEpisodeRawDBDataCell::PresentID' has a wrong offset!");

// ScriptStruct BattlePrototype.OneTutoOperationIndex
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FOneTutoOperationIndex final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOneTutoOperationIndex) == 0x000008, "Wrong alignment on FOneTutoOperationIndex");
static_assert(sizeof(FOneTutoOperationIndex) == 0x000018, "Wrong size on FOneTutoOperationIndex");

// ScriptStruct BattlePrototype.HCHitEffectInfo
// 0x0008 (0x0008 - 0x0000)
struct FHCHitEffectInfo final
{
public:
	EHCHitEffectType                              EffectType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCHitEffectDir                               EffectDir;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixAngle;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHCHitEffectInfo) == 0x000004, "Wrong alignment on FHCHitEffectInfo");
static_assert(sizeof(FHCHitEffectInfo) == 0x000008, "Wrong size on FHCHitEffectInfo");
static_assert(offsetof(FHCHitEffectInfo, EffectType) == 0x000000, "Member 'FHCHitEffectInfo::EffectType' has a wrong offset!");
static_assert(offsetof(FHCHitEffectInfo, EffectDir) == 0x000001, "Member 'FHCHitEffectInfo::EffectDir' has a wrong offset!");
static_assert(offsetof(FHCHitEffectInfo, FixAngle) == 0x000004, "Member 'FHCHitEffectInfo::FixAngle' has a wrong offset!");

// ScriptStruct BattlePrototype.AreaInfoTweakCondition
// 0x0010 (0x0010 - 0x0000)
struct FAreaInfoTweakCondition final
{
public:
	EAreaInfoTweakCheckType                       CheckType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAreaInfoTweakConditionType                   ConditionType;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Num;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAreaInfoTweakCondition) == 0x000004, "Wrong alignment on FAreaInfoTweakCondition");
static_assert(sizeof(FAreaInfoTweakCondition) == 0x000010, "Wrong size on FAreaInfoTweakCondition");
static_assert(offsetof(FAreaInfoTweakCondition, CheckType) == 0x000000, "Member 'FAreaInfoTweakCondition::CheckType' has a wrong offset!");
static_assert(offsetof(FAreaInfoTweakCondition, ConditionType) == 0x000001, "Member 'FAreaInfoTweakCondition::ConditionType' has a wrong offset!");
static_assert(offsetof(FAreaInfoTweakCondition, Num) == 0x000004, "Member 'FAreaInfoTweakCondition::Num' has a wrong offset!");
static_assert(offsetof(FAreaInfoTweakCondition, Name) == 0x000008, "Member 'FAreaInfoTweakCondition::Name' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainMessageJumpMessage
// 0x0014 (0x0014 - 0x0000)
struct FBrainMessageJumpMessage final
{
public:
	struct FAreaInfoTweakCondition                TweakInfo;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         JumpMessageNum;                                    // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainMessageJumpMessage) == 0x000004, "Wrong alignment on FBrainMessageJumpMessage");
static_assert(sizeof(FBrainMessageJumpMessage) == 0x000014, "Wrong size on FBrainMessageJumpMessage");
static_assert(offsetof(FBrainMessageJumpMessage, TweakInfo) == 0x000000, "Member 'FBrainMessageJumpMessage::TweakInfo' has a wrong offset!");
static_assert(offsetof(FBrainMessageJumpMessage, JumpMessageNum) == 0x000010, "Member 'FBrainMessageJumpMessage::JumpMessageNum' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainMessageContentData
// 0x0088 (0x0090 - 0x0008)
struct FBrainMessageContentData final : public FTableRowBase
{
public:
	class FName                                   CharID;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageID;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAreaInfoTweakCondition>        OpenConditions;                                    // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReplyMessageFlg;                                   // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 bondsBPReference;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyAfterClearing;                                 // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAreaInfoTweakCondition>        ReplyConditions;                                   // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAreaInfoTweakCondition>        banReplyConditions;                                // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBrainMessageJumpMessage>       JumpMessage;                                       // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReplyDelayTime;                                    // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           IconCharID;                                        // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainMessageContentData) == 0x000008, "Wrong alignment on FBrainMessageContentData");
static_assert(sizeof(FBrainMessageContentData) == 0x000090, "Wrong size on FBrainMessageContentData");
static_assert(offsetof(FBrainMessageContentData, CharID) == 0x000008, "Member 'FBrainMessageContentData::CharID' has a wrong offset!");
static_assert(offsetof(FBrainMessageContentData, MessageID) == 0x000010, "Member 'FBrainMessageContentData::MessageID' has a wrong offset!");
static_assert(offsetof(FBrainMessageContentData, OpenConditions) == 0x000018, "Member 'FBrainMessageContentData::OpenConditions' has a wrong offset!");
static_assert(offsetof(FBrainMessageContentData, ReplyMessageFlg) == 0x000028, "Member 'FBrainMessageContentData::ReplyMessageFlg' has a wrong offset!");
static_assert(offsetof(FBrainMessageContentData, bondsBPReference) == 0x000030, "Member 'FBrainMessageContentData::bondsBPReference' has a wrong offset!");
static_assert(offsetof(FBrainMessageContentData, OnlyAfterClearing) == 0x000040, "Member 'FBrainMessageContentData::OnlyAfterClearing' has a wrong offset!");
static_assert(offsetof(FBrainMessageContentData, ReplyConditions) == 0x000048, "Member 'FBrainMessageContentData::ReplyConditions' has a wrong offset!");
static_assert(offsetof(FBrainMessageContentData, banReplyConditions) == 0x000058, "Member 'FBrainMessageContentData::banReplyConditions' has a wrong offset!");
static_assert(offsetof(FBrainMessageContentData, JumpMessage) == 0x000068, "Member 'FBrainMessageContentData::JumpMessage' has a wrong offset!");
static_assert(offsetof(FBrainMessageContentData, ReplyDelayTime) == 0x000078, "Member 'FBrainMessageContentData::ReplyDelayTime' has a wrong offset!");
static_assert(offsetof(FBrainMessageContentData, IconCharID) == 0x000080, "Member 'FBrainMessageContentData::IconCharID' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainMessageDBDataCell
// 0x0028 (0x0030 - 0x0008)
struct FBrainMessageDBDataCell final : public FTableRowBase
{
public:
	class FName                                   ThreadID;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TitleID;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBrainMessageContentData>       MessageData;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBothThread;                                       // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimThread;                                       // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainMessageDBDataCell) == 0x000008, "Wrong alignment on FBrainMessageDBDataCell");
static_assert(sizeof(FBrainMessageDBDataCell) == 0x000030, "Wrong size on FBrainMessageDBDataCell");
static_assert(offsetof(FBrainMessageDBDataCell, ThreadID) == 0x000008, "Member 'FBrainMessageDBDataCell::ThreadID' has a wrong offset!");
static_assert(offsetof(FBrainMessageDBDataCell, TitleID) == 0x000010, "Member 'FBrainMessageDBDataCell::TitleID' has a wrong offset!");
static_assert(offsetof(FBrainMessageDBDataCell, MessageData) == 0x000018, "Member 'FBrainMessageDBDataCell::MessageData' has a wrong offset!");
static_assert(offsetof(FBrainMessageDBDataCell, bBothThread) == 0x000028, "Member 'FBrainMessageDBDataCell::bBothThread' has a wrong offset!");
static_assert(offsetof(FBrainMessageDBDataCell, bAnimThread) == 0x000029, "Member 'FBrainMessageDBDataCell::bAnimThread' has a wrong offset!");

// ScriptStruct BattlePrototype.StageParameterSettings
// 0x00E0 (0x00E0 - 0x0000)
struct FStageParameterSettings final
{
public:
	uint8                                         bOverride_SpecularPowerAdd : 1;                    // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SpecularApetureAdd : 1;                  // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ReflectionPowerAdd : 1;                  // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ReflectionApertureAdd : 1;               // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SpecularColorAdd : 1;                    // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BaseColorAdd : 1;                        // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientColorAdd : 1;                     // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SkylightRatioAdd : 1;                    // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BodyHeightGradation1Add : 1;             // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SkinHeightGradation1Add : 1;             // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SkinCelVolumeRateAddBaseToAmb : 1;       // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SkinCelVolumeRateAddAmbToBase : 1;       // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientLightAdjustXY : 1;                // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientLightAdjustZ : 1;                 // 0x0001(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientLightAperture : 1;                // 0x0001(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientLightGradationMidpoint : 1;       // 0x0001(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientLightOffset : 1;                  // 0x0002(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientLightSmooth : 1;                  // 0x0002(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientLightColor : 1;                   // 0x0002(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientLightShadowColor : 1;             // 0x0002(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ABNromal_MaskResultThreshold : 1;        // 0x0002(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ABNormal_LightMaskScale : 1;             // 0x0002(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_HemisphereSkyColor : 1;                  // 0x0002(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_HemisphereGroundColor : 1;               // 0x0002(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_EffectColor : 1;                         // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	float                                         SpecularPowerAdd;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecularApetureAdd;                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReflectionPowerAdd;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReflectionApertureAdd;                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SpecularColorAdd;                                  // 0x0014(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BaseColorAdd;                                      // 0x0024(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmbientColorAdd;                                   // 0x0034(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkylightRatioAdd;                                  // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyHeightGradation1Add;                           // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkinHeightGradation1Add;                           // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkinCelVolumeRateAddBaseToAmb;                     // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkinCelVolumeRateAddAmbToBase;                     // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientLightAdjustXY;                              // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientLightAdjustZ;                               // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientLightAperture;                              // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientLightGradationMidpoint;                     // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientLightOffset;                                // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientLightSmooth;                                // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmbientLightColor;                                 // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmbientLightShadowColor;                           // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ABNromal_MaskResultThreshold;                      // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ABNormal_LightMaskScale;                           // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HemisphereSkyColor;                                // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HemisphereGroundColor;                             // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EffectColor;                                       // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AmbientLightVector;                                // 0x00C8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AmbientLightShadowVector;                          // 0x00D4(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStageParameterSettings) == 0x000004, "Wrong alignment on FStageParameterSettings");
static_assert(sizeof(FStageParameterSettings) == 0x0000E0, "Wrong size on FStageParameterSettings");
static_assert(offsetof(FStageParameterSettings, SpecularPowerAdd) == 0x000004, "Member 'FStageParameterSettings::SpecularPowerAdd' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, SpecularApetureAdd) == 0x000008, "Member 'FStageParameterSettings::SpecularApetureAdd' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, ReflectionPowerAdd) == 0x00000C, "Member 'FStageParameterSettings::ReflectionPowerAdd' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, ReflectionApertureAdd) == 0x000010, "Member 'FStageParameterSettings::ReflectionApertureAdd' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, SpecularColorAdd) == 0x000014, "Member 'FStageParameterSettings::SpecularColorAdd' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, BaseColorAdd) == 0x000024, "Member 'FStageParameterSettings::BaseColorAdd' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, AmbientColorAdd) == 0x000034, "Member 'FStageParameterSettings::AmbientColorAdd' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, SkylightRatioAdd) == 0x000044, "Member 'FStageParameterSettings::SkylightRatioAdd' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, BodyHeightGradation1Add) == 0x000048, "Member 'FStageParameterSettings::BodyHeightGradation1Add' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, SkinHeightGradation1Add) == 0x00004C, "Member 'FStageParameterSettings::SkinHeightGradation1Add' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, SkinCelVolumeRateAddBaseToAmb) == 0x000050, "Member 'FStageParameterSettings::SkinCelVolumeRateAddBaseToAmb' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, SkinCelVolumeRateAddAmbToBase) == 0x000054, "Member 'FStageParameterSettings::SkinCelVolumeRateAddAmbToBase' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, AmbientLightAdjustXY) == 0x000058, "Member 'FStageParameterSettings::AmbientLightAdjustXY' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, AmbientLightAdjustZ) == 0x00005C, "Member 'FStageParameterSettings::AmbientLightAdjustZ' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, AmbientLightAperture) == 0x000060, "Member 'FStageParameterSettings::AmbientLightAperture' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, AmbientLightGradationMidpoint) == 0x000064, "Member 'FStageParameterSettings::AmbientLightGradationMidpoint' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, AmbientLightOffset) == 0x000068, "Member 'FStageParameterSettings::AmbientLightOffset' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, AmbientLightSmooth) == 0x00006C, "Member 'FStageParameterSettings::AmbientLightSmooth' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, AmbientLightColor) == 0x000070, "Member 'FStageParameterSettings::AmbientLightColor' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, AmbientLightShadowColor) == 0x000080, "Member 'FStageParameterSettings::AmbientLightShadowColor' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, ABNromal_MaskResultThreshold) == 0x000090, "Member 'FStageParameterSettings::ABNromal_MaskResultThreshold' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, ABNormal_LightMaskScale) == 0x000094, "Member 'FStageParameterSettings::ABNormal_LightMaskScale' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, HemisphereSkyColor) == 0x000098, "Member 'FStageParameterSettings::HemisphereSkyColor' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, HemisphereGroundColor) == 0x0000A8, "Member 'FStageParameterSettings::HemisphereGroundColor' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, EffectColor) == 0x0000B8, "Member 'FStageParameterSettings::EffectColor' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, AmbientLightVector) == 0x0000C8, "Member 'FStageParameterSettings::AmbientLightVector' has a wrong offset!");
static_assert(offsetof(FStageParameterSettings, AmbientLightShadowVector) == 0x0000D4, "Member 'FStageParameterSettings::AmbientLightShadowVector' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoAvailableMotion
// 0x0010 (0x0018 - 0x0008)
struct FAjitoAvailableMotion final : public FTableRowBase
{
public:
	TArray<ENpcAnimationKind>                     AvailableMotionIds;                                // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAjitoAvailableMotion) == 0x000008, "Wrong alignment on FAjitoAvailableMotion");
static_assert(sizeof(FAjitoAvailableMotion) == 0x000018, "Wrong size on FAjitoAvailableMotion");
static_assert(offsetof(FAjitoAvailableMotion, AvailableMotionIds) == 0x000008, "Member 'FAjitoAvailableMotion::AvailableMotionIds' has a wrong offset!");

// ScriptStruct BattlePrototype.AchievementParam
// 0x0130 (0x0130 - 0x0000)
struct FAchievementParam final
{
public:
	class URSGameInstance*                        M_gameInstance;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAchievementManager*                    M_achievementManager;                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAchievementParamDBAsset*               M_achievementDBAsset;                              // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18[0x118];                                     // 0x0018(0x0118)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAchievementParam) == 0x000008, "Wrong alignment on FAchievementParam");
static_assert(sizeof(FAchievementParam) == 0x000130, "Wrong size on FAchievementParam");
static_assert(offsetof(FAchievementParam, M_gameInstance) == 0x000000, "Member 'FAchievementParam::M_gameInstance' has a wrong offset!");
static_assert(offsetof(FAchievementParam, M_achievementManager) == 0x000008, "Member 'FAchievementParam::M_achievementManager' has a wrong offset!");
static_assert(offsetof(FAchievementParam, M_achievementDBAsset) == 0x000010, "Member 'FAchievementParam::M_achievementDBAsset' has a wrong offset!");

// ScriptStruct BattlePrototype.ScreenResolutionSetting
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FScreenResolutionSetting final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScreenResolutionSetting) == 0x000004, "Wrong alignment on FScreenResolutionSetting");
static_assert(sizeof(FScreenResolutionSetting) == 0x00000C, "Wrong size on FScreenResolutionSetting");

// ScriptStruct BattlePrototype.MainQuestFlagConditionData
// 0x000C (0x000C - 0x0000)
struct FMainQuestFlagConditionData final
{
public:
	class FName                                   ConditionFlag;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCheck;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMainQuestFlagConditionData) == 0x000004, "Wrong alignment on FMainQuestFlagConditionData");
static_assert(sizeof(FMainQuestFlagConditionData) == 0x00000C, "Wrong size on FMainQuestFlagConditionData");
static_assert(offsetof(FMainQuestFlagConditionData, ConditionFlag) == 0x000000, "Member 'FMainQuestFlagConditionData::ConditionFlag' has a wrong offset!");
static_assert(offsetof(FMainQuestFlagConditionData, IsCheck) == 0x000008, "Member 'FMainQuestFlagConditionData::IsCheck' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkGimmick
// 0x0028 (0x0030 - 0x0008)
struct FBrainTalkGimmick final : public FTableRowBase
{
public:
	class FString                                 Label;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     Player;                                            // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWataruHaruka;                                    // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember1;                                       // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember2;                                       // 0x001B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember3;                                       // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WaitTime;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkGimmick) == 0x000008, "Wrong alignment on FBrainTalkGimmick");
static_assert(sizeof(FBrainTalkGimmick) == 0x000030, "Wrong size on FBrainTalkGimmick");
static_assert(offsetof(FBrainTalkGimmick, Label) == 0x000008, "Member 'FBrainTalkGimmick::Label' has a wrong offset!");
static_assert(offsetof(FBrainTalkGimmick, Player) == 0x000018, "Member 'FBrainTalkGimmick::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkGimmick, IsWataruHaruka) == 0x000019, "Member 'FBrainTalkGimmick::IsWataruHaruka' has a wrong offset!");
static_assert(offsetof(FBrainTalkGimmick, TalkMember1) == 0x00001A, "Member 'FBrainTalkGimmick::TalkMember1' has a wrong offset!");
static_assert(offsetof(FBrainTalkGimmick, TalkMember2) == 0x00001B, "Member 'FBrainTalkGimmick::TalkMember2' has a wrong offset!");
static_assert(offsetof(FBrainTalkGimmick, TalkMember3) == 0x00001C, "Member 'FBrainTalkGimmick::TalkMember3' has a wrong offset!");
static_assert(offsetof(FBrainTalkGimmick, WaitTime) == 0x000020, "Member 'FBrainTalkGimmick::WaitTime' has a wrong offset!");
static_assert(offsetof(FBrainTalkGimmick, Category) == 0x000024, "Member 'FBrainTalkGimmick::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkGimmick, DatatableId) == 0x000028, "Member 'FBrainTalkGimmick::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBattle_ConditionsParam_BTParam
// 0x0008 (0x0008 - 0x0000)
struct FBrainTalkBattle_ConditionsParam_BTParam final
{
public:
	float                                         M_occurRate;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_isOnce;                                          // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBattle_ConditionsParam_BTParam) == 0x000004, "Wrong alignment on FBrainTalkBattle_ConditionsParam_BTParam");
static_assert(sizeof(FBrainTalkBattle_ConditionsParam_BTParam) == 0x000008, "Wrong size on FBrainTalkBattle_ConditionsParam_BTParam");
static_assert(offsetof(FBrainTalkBattle_ConditionsParam_BTParam, M_occurRate) == 0x000000, "Member 'FBrainTalkBattle_ConditionsParam_BTParam::M_occurRate' has a wrong offset!");
static_assert(offsetof(FBrainTalkBattle_ConditionsParam_BTParam, M_isOnce) == 0x000004, "Member 'FBrainTalkBattle_ConditionsParam_BTParam::M_isOnce' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBattle_ConditionsParam
// 0x0010 (0x0010 - 0x0000)
struct FBrainTalkBattle_ConditionsParam final
{
public:
	TArray<struct FBrainTalkBattle_ConditionsParam_BTParam> M_BTParam;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBattle_ConditionsParam) == 0x000008, "Wrong alignment on FBrainTalkBattle_ConditionsParam");
static_assert(sizeof(FBrainTalkBattle_ConditionsParam) == 0x000010, "Wrong size on FBrainTalkBattle_ConditionsParam");
static_assert(offsetof(FBrainTalkBattle_ConditionsParam, M_BTParam) == 0x000000, "Member 'FBrainTalkBattle_ConditionsParam::M_BTParam' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkGimmick_ConditionParam
// 0x0020 (0x0028 - 0x0008)
struct FBrainTalkGimmick_ConditionParam final : public FTableRowBase
{
public:
	TArray<struct FBrainTalkGimmick>              M_DataList;                                        // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBrainTalkBattle_ConditionsParam       M_DataList_Param;                                  // 0x0018(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkGimmick_ConditionParam) == 0x000008, "Wrong alignment on FBrainTalkGimmick_ConditionParam");
static_assert(sizeof(FBrainTalkGimmick_ConditionParam) == 0x000028, "Wrong size on FBrainTalkGimmick_ConditionParam");
static_assert(offsetof(FBrainTalkGimmick_ConditionParam, M_DataList) == 0x000008, "Member 'FBrainTalkGimmick_ConditionParam::M_DataList' has a wrong offset!");
static_assert(offsetof(FBrainTalkGimmick_ConditionParam, M_DataList_Param) == 0x000018, "Member 'FBrainTalkGimmick_ConditionParam::M_DataList_Param' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_BrainCrashByEn
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_BrainCrashByEn final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_BrainCrashByEn) == 0x000008, "Wrong alignment on FBrainTalkBt_BrainCrashByEn");
static_assert(sizeof(FBrainTalkBt_BrainCrashByEn) == 0x000018, "Wrong size on FBrainTalkBt_BrainCrashByEn");
static_assert(offsetof(FBrainTalkBt_BrainCrashByEn, Player) == 0x000008, "Member 'FBrainTalkBt_BrainCrashByEn::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BrainCrashByEn, Category) == 0x000009, "Member 'FBrainTalkBt_BrainCrashByEn::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BrainCrashByEn, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_BrainCrashByEn::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoMemberAvailableInfo
// 0x0010 (0x0018 - 0x0008)
struct FAjitoMemberAvailableInfo final : public FTableRowBase
{
public:
	TArray<EPlayerID>                             AvailablePlayers;                                  // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAjitoMemberAvailableInfo) == 0x000008, "Wrong alignment on FAjitoMemberAvailableInfo");
static_assert(sizeof(FAjitoMemberAvailableInfo) == 0x000018, "Wrong size on FAjitoMemberAvailableInfo");
static_assert(offsetof(FAjitoMemberAvailableInfo, AvailablePlayers) == 0x000008, "Member 'FAjitoMemberAvailableInfo::AvailablePlayers' has a wrong offset!");

// ScriptStruct BattlePrototype.UserItemInfo
// 0x0010 (0x0010 - 0x0000)
struct FUserItemInfo final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastAcquisitionTime;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUserItemInfo) == 0x000004, "Wrong alignment on FUserItemInfo");
static_assert(sizeof(FUserItemInfo) == 0x000010, "Wrong size on FUserItemInfo");
static_assert(offsetof(FUserItemInfo, ID) == 0x000000, "Member 'FUserItemInfo::ID' has a wrong offset!");
static_assert(offsetof(FUserItemInfo, Num) == 0x000008, "Member 'FUserItemInfo::Num' has a wrong offset!");
static_assert(offsetof(FUserItemInfo, LastAcquisitionTime) == 0x00000C, "Member 'FUserItemInfo::LastAcquisitionTime' has a wrong offset!");

// ScriptStruct BattlePrototype.HCRuntimeData
// 0x0008 (0x0008 - 0x0000)
struct FHCRuntimeData final
{
public:
	TWeakObjectPtr<class AActor>                  WpAttackSourceActor;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHCRuntimeData) == 0x000004, "Wrong alignment on FHCRuntimeData");
static_assert(sizeof(FHCRuntimeData) == 0x000008, "Wrong size on FHCRuntimeData");
static_assert(offsetof(FHCRuntimeData, WpAttackSourceActor) == 0x000000, "Member 'FHCRuntimeData::WpAttackSourceActor' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_RecoveryHpToPL
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_RecoveryHpToPL final : public FTableRowBase
{
public:
	EPlayerID                                     RecoveryFrom;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_RecoveryHpToPL) == 0x000008, "Wrong alignment on FBrainTalkBt_RecoveryHpToPL");
static_assert(sizeof(FBrainTalkBt_RecoveryHpToPL) == 0x000018, "Wrong size on FBrainTalkBt_RecoveryHpToPL");
static_assert(offsetof(FBrainTalkBt_RecoveryHpToPL, RecoveryFrom) == 0x000008, "Member 'FBrainTalkBt_RecoveryHpToPL::RecoveryFrom' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_RecoveryHpToPL, Category) == 0x000009, "Member 'FBrainTalkBt_RecoveryHpToPL::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_RecoveryHpToPL, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_RecoveryHpToPL::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.HCCollisionValueData
// 0x0008 (0x0008 - 0x0000)
struct FHCCollisionValueData final
{
public:
	EHCCollisionValueKind                         Kind;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHCCollisionValueData) == 0x000004, "Wrong alignment on FHCCollisionValueData");
static_assert(sizeof(FHCCollisionValueData) == 0x000008, "Wrong size on FHCCollisionValueData");
static_assert(offsetof(FHCCollisionValueData, Kind) == 0x000000, "Member 'FHCCollisionValueData::Kind' has a wrong offset!");
static_assert(offsetof(FHCCollisionValueData, Value) == 0x000004, "Member 'FHCCollisionValueData::Value' has a wrong offset!");

// ScriptStruct BattlePrototype.HCCollisionElementData
// 0x0008 (0x0008 - 0x0000)
struct FHCCollisionElementData final
{
public:
	EHCElementKind                                Kind;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHCCollisionElementData) == 0x000004, "Wrong alignment on FHCCollisionElementData");
static_assert(sizeof(FHCCollisionElementData) == 0x000008, "Wrong size on FHCCollisionElementData");
static_assert(offsetof(FHCCollisionElementData, Kind) == 0x000000, "Member 'FHCCollisionElementData::Kind' has a wrong offset!");
static_assert(offsetof(FHCCollisionElementData, Value) == 0x000004, "Member 'FHCCollisionElementData::Value' has a wrong offset!");

// ScriptStruct BattlePrototype.HCCollisionConditionData
// 0x0008 (0x0008 - 0x0000)
struct FHCCollisionConditionData final
{
public:
	EConditionKind                                Kind;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHCCollisionConditionData) == 0x000004, "Wrong alignment on FHCCollisionConditionData");
static_assert(sizeof(FHCCollisionConditionData) == 0x000008, "Wrong size on FHCCollisionConditionData");
static_assert(offsetof(FHCCollisionConditionData, Kind) == 0x000000, "Member 'FHCCollisionConditionData::Kind' has a wrong offset!");
static_assert(offsetof(FHCCollisionConditionData, Value) == 0x000004, "Member 'FHCCollisionConditionData::Value' has a wrong offset!");

// ScriptStruct BattlePrototype.HCCollisionCommonInfo
// 0x0070 (0x0070 - 0x0000)
struct FHCCollisionCommonInfo final
{
public:
	int32                                         Power;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               blowAngle;                                         // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         blowPower;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopSec;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopActionSpeedRate;                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCDamageKind                                 DamageKind;                                        // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageStiffenSec;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stagger;                                           // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReduceGuard;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCHitEffectType                              HitEffectType;                                     // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHCCollisionElementData>        ElementDatas;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHCCollisionConditionData>      ConditionDatas;                                    // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHCCollisionValueData>          ValueDatas;                                        // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCCollisionHitTeam                           HitTeam;                                           // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GroupNo;                                           // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroupInfoKeepSec;                                  // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepeatHitSec;                                      // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHCCollisionCommonInfo) == 0x000008, "Wrong alignment on FHCCollisionCommonInfo");
static_assert(sizeof(FHCCollisionCommonInfo) == 0x000070, "Wrong size on FHCCollisionCommonInfo");
static_assert(offsetof(FHCCollisionCommonInfo, Power) == 0x000000, "Member 'FHCCollisionCommonInfo::Power' has a wrong offset!");
static_assert(offsetof(FHCCollisionCommonInfo, blowAngle) == 0x000004, "Member 'FHCCollisionCommonInfo::blowAngle' has a wrong offset!");
static_assert(offsetof(FHCCollisionCommonInfo, blowPower) == 0x000010, "Member 'FHCCollisionCommonInfo::blowPower' has a wrong offset!");
static_assert(offsetof(FHCCollisionCommonInfo, HitStopSec) == 0x000014, "Member 'FHCCollisionCommonInfo::HitStopSec' has a wrong offset!");
static_assert(offsetof(FHCCollisionCommonInfo, HitStopActionSpeedRate) == 0x000018, "Member 'FHCCollisionCommonInfo::HitStopActionSpeedRate' has a wrong offset!");
static_assert(offsetof(FHCCollisionCommonInfo, DamageKind) == 0x00001C, "Member 'FHCCollisionCommonInfo::DamageKind' has a wrong offset!");
static_assert(offsetof(FHCCollisionCommonInfo, DamageStiffenSec) == 0x000020, "Member 'FHCCollisionCommonInfo::DamageStiffenSec' has a wrong offset!");
static_assert(offsetof(FHCCollisionCommonInfo, Stagger) == 0x000024, "Member 'FHCCollisionCommonInfo::Stagger' has a wrong offset!");
static_assert(offsetof(FHCCollisionCommonInfo, ReduceGuard) == 0x000028, "Member 'FHCCollisionCommonInfo::ReduceGuard' has a wrong offset!");
static_assert(offsetof(FHCCollisionCommonInfo, HitEffectType) == 0x00002C, "Member 'FHCCollisionCommonInfo::HitEffectType' has a wrong offset!");
static_assert(offsetof(FHCCollisionCommonInfo, ElementDatas) == 0x000030, "Member 'FHCCollisionCommonInfo::ElementDatas' has a wrong offset!");
static_assert(offsetof(FHCCollisionCommonInfo, ConditionDatas) == 0x000040, "Member 'FHCCollisionCommonInfo::ConditionDatas' has a wrong offset!");
static_assert(offsetof(FHCCollisionCommonInfo, ValueDatas) == 0x000050, "Member 'FHCCollisionCommonInfo::ValueDatas' has a wrong offset!");
static_assert(offsetof(FHCCollisionCommonInfo, HitTeam) == 0x000060, "Member 'FHCCollisionCommonInfo::HitTeam' has a wrong offset!");
static_assert(offsetof(FHCCollisionCommonInfo, GroupNo) == 0x000064, "Member 'FHCCollisionCommonInfo::GroupNo' has a wrong offset!");
static_assert(offsetof(FHCCollisionCommonInfo, GroupInfoKeepSec) == 0x000068, "Member 'FHCCollisionCommonInfo::GroupInfoKeepSec' has a wrong offset!");
static_assert(offsetof(FHCCollisionCommonInfo, RepeatHitSec) == 0x00006C, "Member 'FHCCollisionCommonInfo::RepeatHitSec' has a wrong offset!");

// ScriptStruct BattlePrototype.HCSkillCommonInfo
// 0x00E8 (0x00E8 - 0x0000)
struct FHCSkillCommonInfo final
{
public:
	float                                         Power;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Critical;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeTime;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectRange;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectTime;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Recast;                                            // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CaptureTime;                                       // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Wince;                                             // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockBack;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObjKnockBack;                                      // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Down;                                              // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Launch;                                            // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchHeight;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchTime;                                        // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Flame;                                             // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Electric;                                          // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Flooded;                                           // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Oil;                                               // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Confusion;                                         // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Crash;                                             // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObjCrash;                                          // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlameCrash;                                        // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElectricCrash;                                     // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCSkillAttackType                            AttackType;                                        // 0x0064(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCSkillMaterial                              SkillMaterial;                                     // 0x0065(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCSkillType                                  SkillType;                                         // 0x0066(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_67[0x1];                                       // 0x0067(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EHCSkillAttribute>                     Attribute;                                         // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCSkillEnemyHitEffect                        EnemyHitEffect;                                    // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCSkillEnemyHitEffect                        EnemyHitSound;                                     // 0x0079(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EHCSkillExtraType>                     ExtraType;                                         // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObjPower;                                          // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlamePower;                                        // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElectricPower;                                     // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopSec;                                        // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopActionSpeedRate;                            // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepeatHitSec;                                      // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PsychicBoost;                                      // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHitAttackerLocation;                             // 0x00AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HateTechRate;                                      // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCDamageReactionDirType                      DamageReactionDirType;                             // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageReactionFixDir;                              // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCHitCameraShakeType                         HitCameraShakeType;                                // 0x00BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitCameraShakeScale;                               // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCHitControllerVibrationType                 HitControllerVibrationType;                        // 0x00C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCHitStopCauseType                           HitStopCauseType;                                  // 0x00C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCRestictedHitStopType                       DamagedHitStopType;                                // 0x00C6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCRestictedHitStopType                       AttackedHitStopType;                               // 0x00C7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatingPower;                                     // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FloatingAngle;                                     // 0x00CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ToPlayerDamageRate;                                // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToEnemyDamageRate;                                 // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToOtherDamageRate;                                 // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHCSkillCommonInfo) == 0x000008, "Wrong alignment on FHCSkillCommonInfo");
static_assert(sizeof(FHCSkillCommonInfo) == 0x0000E8, "Wrong size on FHCSkillCommonInfo");
static_assert(offsetof(FHCSkillCommonInfo, Power) == 0x000000, "Member 'FHCSkillCommonInfo::Power' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, Critical) == 0x000004, "Member 'FHCSkillCommonInfo::Critical' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, ChargeTime) == 0x000008, "Member 'FHCSkillCommonInfo::ChargeTime' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, EffectRange) == 0x00000C, "Member 'FHCSkillCommonInfo::EffectRange' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, Range) == 0x000010, "Member 'FHCSkillCommonInfo::Range' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, EffectTime) == 0x000014, "Member 'FHCSkillCommonInfo::EffectTime' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, Strength) == 0x000018, "Member 'FHCSkillCommonInfo::Strength' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, Recast) == 0x00001C, "Member 'FHCSkillCommonInfo::Recast' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, CaptureTime) == 0x000020, "Member 'FHCSkillCommonInfo::CaptureTime' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, Wince) == 0x000024, "Member 'FHCSkillCommonInfo::Wince' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, KnockBack) == 0x000028, "Member 'FHCSkillCommonInfo::KnockBack' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, ObjKnockBack) == 0x00002C, "Member 'FHCSkillCommonInfo::ObjKnockBack' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, Down) == 0x000030, "Member 'FHCSkillCommonInfo::Down' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, Launch) == 0x000034, "Member 'FHCSkillCommonInfo::Launch' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, LaunchHeight) == 0x000038, "Member 'FHCSkillCommonInfo::LaunchHeight' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, LaunchTime) == 0x00003C, "Member 'FHCSkillCommonInfo::LaunchTime' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, Flame) == 0x000040, "Member 'FHCSkillCommonInfo::Flame' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, Electric) == 0x000044, "Member 'FHCSkillCommonInfo::Electric' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, Flooded) == 0x000048, "Member 'FHCSkillCommonInfo::Flooded' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, Oil) == 0x00004C, "Member 'FHCSkillCommonInfo::Oil' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, Confusion) == 0x000050, "Member 'FHCSkillCommonInfo::Confusion' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, Crash) == 0x000054, "Member 'FHCSkillCommonInfo::Crash' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, ObjCrash) == 0x000058, "Member 'FHCSkillCommonInfo::ObjCrash' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, FlameCrash) == 0x00005C, "Member 'FHCSkillCommonInfo::FlameCrash' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, ElectricCrash) == 0x000060, "Member 'FHCSkillCommonInfo::ElectricCrash' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, AttackType) == 0x000064, "Member 'FHCSkillCommonInfo::AttackType' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, SkillMaterial) == 0x000065, "Member 'FHCSkillCommonInfo::SkillMaterial' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, SkillType) == 0x000066, "Member 'FHCSkillCommonInfo::SkillType' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, Attribute) == 0x000068, "Member 'FHCSkillCommonInfo::Attribute' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, EnemyHitEffect) == 0x000078, "Member 'FHCSkillCommonInfo::EnemyHitEffect' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, EnemyHitSound) == 0x000079, "Member 'FHCSkillCommonInfo::EnemyHitSound' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, ExtraType) == 0x000080, "Member 'FHCSkillCommonInfo::ExtraType' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, ObjPower) == 0x000090, "Member 'FHCSkillCommonInfo::ObjPower' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, FlamePower) == 0x000094, "Member 'FHCSkillCommonInfo::FlamePower' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, ElectricPower) == 0x000098, "Member 'FHCSkillCommonInfo::ElectricPower' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, HitStopSec) == 0x00009C, "Member 'FHCSkillCommonInfo::HitStopSec' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, HitStopActionSpeedRate) == 0x0000A0, "Member 'FHCSkillCommonInfo::HitStopActionSpeedRate' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, RepeatHitSec) == 0x0000A4, "Member 'FHCSkillCommonInfo::RepeatHitSec' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, PsychicBoost) == 0x0000A8, "Member 'FHCSkillCommonInfo::PsychicBoost' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, IsHitAttackerLocation) == 0x0000AC, "Member 'FHCSkillCommonInfo::IsHitAttackerLocation' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, HateTechRate) == 0x0000B0, "Member 'FHCSkillCommonInfo::HateTechRate' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, DamageReactionDirType) == 0x0000B4, "Member 'FHCSkillCommonInfo::DamageReactionDirType' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, DamageReactionFixDir) == 0x0000B8, "Member 'FHCSkillCommonInfo::DamageReactionFixDir' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, HitCameraShakeType) == 0x0000BC, "Member 'FHCSkillCommonInfo::HitCameraShakeType' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, HitCameraShakeScale) == 0x0000C0, "Member 'FHCSkillCommonInfo::HitCameraShakeScale' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, HitControllerVibrationType) == 0x0000C4, "Member 'FHCSkillCommonInfo::HitControllerVibrationType' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, HitStopCauseType) == 0x0000C5, "Member 'FHCSkillCommonInfo::HitStopCauseType' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, DamagedHitStopType) == 0x0000C6, "Member 'FHCSkillCommonInfo::DamagedHitStopType' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, AttackedHitStopType) == 0x0000C7, "Member 'FHCSkillCommonInfo::AttackedHitStopType' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, FloatingPower) == 0x0000C8, "Member 'FHCSkillCommonInfo::FloatingPower' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, FloatingAngle) == 0x0000CC, "Member 'FHCSkillCommonInfo::FloatingAngle' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, ToPlayerDamageRate) == 0x0000D8, "Member 'FHCSkillCommonInfo::ToPlayerDamageRate' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, ToEnemyDamageRate) == 0x0000DC, "Member 'FHCSkillCommonInfo::ToEnemyDamageRate' has a wrong offset!");
static_assert(offsetof(FHCSkillCommonInfo, ToOtherDamageRate) == 0x0000E0, "Member 'FHCSkillCommonInfo::ToOtherDamageRate' has a wrong offset!");

// ScriptStruct BattlePrototype.HCHitResult
// 0x01B8 (0x01B8 - 0x0000)
struct FHCHitResult final
{
public:
	struct FHCCollisionCommonInfo                 Common;                                            // 0x0000(0x0070)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FHCRuntimeData                         RuntimeData;                                       // 0x0070(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Attacker;                                          // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPrimitiveComponent>     WpPrimitive;                                       // 0x0080(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitCount;                                          // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitPosition;                                       // 0x008C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  WpOpponentActor;                                   // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHCSkillCommonInfo                     Skill;                                             // 0x00A0(0x00E8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  AttackOwner;                                       // 0x0188(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCritical;                                        // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x3];                                      // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IsBadState;                                        // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitNormal;                                         // 0x0198(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttackDir;                                         // 0x01A4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHCHitEffectInfo                       EffectInfo;                                        // 0x01B0(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHCHitResult) == 0x000008, "Wrong alignment on FHCHitResult");
static_assert(sizeof(FHCHitResult) == 0x0001B8, "Wrong size on FHCHitResult");
static_assert(offsetof(FHCHitResult, Common) == 0x000000, "Member 'FHCHitResult::Common' has a wrong offset!");
static_assert(offsetof(FHCHitResult, RuntimeData) == 0x000070, "Member 'FHCHitResult::RuntimeData' has a wrong offset!");
static_assert(offsetof(FHCHitResult, Attacker) == 0x000078, "Member 'FHCHitResult::Attacker' has a wrong offset!");
static_assert(offsetof(FHCHitResult, WpPrimitive) == 0x000080, "Member 'FHCHitResult::WpPrimitive' has a wrong offset!");
static_assert(offsetof(FHCHitResult, HitCount) == 0x000088, "Member 'FHCHitResult::HitCount' has a wrong offset!");
static_assert(offsetof(FHCHitResult, HitPosition) == 0x00008C, "Member 'FHCHitResult::HitPosition' has a wrong offset!");
static_assert(offsetof(FHCHitResult, WpOpponentActor) == 0x000098, "Member 'FHCHitResult::WpOpponentActor' has a wrong offset!");
static_assert(offsetof(FHCHitResult, Skill) == 0x0000A0, "Member 'FHCHitResult::Skill' has a wrong offset!");
static_assert(offsetof(FHCHitResult, AttackOwner) == 0x000188, "Member 'FHCHitResult::AttackOwner' has a wrong offset!");
static_assert(offsetof(FHCHitResult, IsCritical) == 0x000190, "Member 'FHCHitResult::IsCritical' has a wrong offset!");
static_assert(offsetof(FHCHitResult, IsBadState) == 0x000194, "Member 'FHCHitResult::IsBadState' has a wrong offset!");
static_assert(offsetof(FHCHitResult, HitNormal) == 0x000198, "Member 'FHCHitResult::HitNormal' has a wrong offset!");
static_assert(offsetof(FHCHitResult, AttackDir) == 0x0001A4, "Member 'FHCHitResult::AttackDir' has a wrong offset!");
static_assert(offsetof(FHCHitResult, EffectInfo) == 0x0001B0, "Member 'FHCHitResult::EffectInfo' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_DeadInarow
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_DeadInarow final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWataruHaruka;                                    // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DeadNum;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_DeadInarow) == 0x000008, "Wrong alignment on FBrainTalkBt_DeadInarow");
static_assert(sizeof(FBrainTalkBt_DeadInarow) == 0x000020, "Wrong size on FBrainTalkBt_DeadInarow");
static_assert(offsetof(FBrainTalkBt_DeadInarow, Player) == 0x000008, "Member 'FBrainTalkBt_DeadInarow::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DeadInarow, IsWataruHaruka) == 0x000009, "Member 'FBrainTalkBt_DeadInarow::IsWataruHaruka' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DeadInarow, DeadNum) == 0x00000C, "Member 'FBrainTalkBt_DeadInarow::DeadNum' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DeadInarow, Category) == 0x000010, "Member 'FBrainTalkBt_DeadInarow::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DeadInarow, DatatableId) == 0x000014, "Member 'FBrainTalkBt_DeadInarow::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_DriveActive
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_DriveActive final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_DriveActive) == 0x000008, "Wrong alignment on FBrainTalkBt_DriveActive");
static_assert(sizeof(FBrainTalkBt_DriveActive) == 0x000018, "Wrong size on FBrainTalkBt_DriveActive");
static_assert(offsetof(FBrainTalkBt_DriveActive, TalkMember) == 0x000008, "Member 'FBrainTalkBt_DriveActive::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DriveActive, Category) == 0x000009, "Member 'FBrainTalkBt_DriveActive::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DriveActive, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_DriveActive::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.ActionIconSupportParam
// 0x0018 (0x0020 - 0x0008)
struct FActionIconSupportParam final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPositionOffset;                               // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionIconSupportParam) == 0x000008, "Wrong alignment on FActionIconSupportParam");
static_assert(sizeof(FActionIconSupportParam) == 0x000020, "Wrong size on FActionIconSupportParam");
static_assert(offsetof(FActionIconSupportParam, ID) == 0x000008, "Member 'FActionIconSupportParam::ID' has a wrong offset!");
static_assert(offsetof(FActionIconSupportParam, WorldPositionOffset) == 0x000010, "Member 'FActionIconSupportParam::WorldPositionOffset' has a wrong offset!");

// ScriptStruct BattlePrototype.RedMouseArgument
// 0x000C (0x000C - 0x0000)
struct FRedMouseArgument final
{
public:
	class FName                                   ArgumentName;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArgumentValue;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRedMouseArgument) == 0x000004, "Wrong alignment on FRedMouseArgument");
static_assert(sizeof(FRedMouseArgument) == 0x00000C, "Wrong size on FRedMouseArgument");
static_assert(offsetof(FRedMouseArgument, ArgumentName) == 0x000000, "Member 'FRedMouseArgument::ArgumentName' has a wrong offset!");
static_assert(offsetof(FRedMouseArgument, ArgumentValue) == 0x000008, "Member 'FRedMouseArgument::ArgumentValue' has a wrong offset!");

// ScriptStruct BattlePrototype.AnimeInterlockingNumRefDataCell
// 0x0020 (0x0028 - 0x0008)
struct FAnimeInterlockingNumRefDataCell final : public FTableRowBase
{
public:
	class FName                                   AnimeInterlockingNumName;                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TitleID;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClearedNum;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimeInterlockingNumRefDataCell) == 0x000008, "Wrong alignment on FAnimeInterlockingNumRefDataCell");
static_assert(sizeof(FAnimeInterlockingNumRefDataCell) == 0x000028, "Wrong size on FAnimeInterlockingNumRefDataCell");
static_assert(offsetof(FAnimeInterlockingNumRefDataCell, AnimeInterlockingNumName) == 0x000008, "Member 'FAnimeInterlockingNumRefDataCell::AnimeInterlockingNumName' has a wrong offset!");
static_assert(offsetof(FAnimeInterlockingNumRefDataCell, TitleID) == 0x000010, "Member 'FAnimeInterlockingNumRefDataCell::TitleID' has a wrong offset!");
static_assert(offsetof(FAnimeInterlockingNumRefDataCell, ClearedNum) == 0x000020, "Member 'FAnimeInterlockingNumRefDataCell::ClearedNum' has a wrong offset!");

// ScriptStruct BattlePrototype.CharacterHPEventInfo
// 0x0028 (0x0028 - 0x0000)
struct FCharacterHPEventInfo final
{
public:
	bool                                          IsAlreadyOccured;                                  // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HpRate;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterEventType                           EventType;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AMakeEventActor>            EventActor;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EventArg1;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EventArg2;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EventArg3;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EventArg4;                                         // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterHPEventInfo) == 0x000008, "Wrong alignment on FCharacterHPEventInfo");
static_assert(sizeof(FCharacterHPEventInfo) == 0x000028, "Wrong size on FCharacterHPEventInfo");
static_assert(offsetof(FCharacterHPEventInfo, IsAlreadyOccured) == 0x000000, "Member 'FCharacterHPEventInfo::IsAlreadyOccured' has a wrong offset!");
static_assert(offsetof(FCharacterHPEventInfo, HpRate) == 0x000004, "Member 'FCharacterHPEventInfo::HpRate' has a wrong offset!");
static_assert(offsetof(FCharacterHPEventInfo, EventType) == 0x000008, "Member 'FCharacterHPEventInfo::EventType' has a wrong offset!");
static_assert(offsetof(FCharacterHPEventInfo, EventActor) == 0x000010, "Member 'FCharacterHPEventInfo::EventActor' has a wrong offset!");
static_assert(offsetof(FCharacterHPEventInfo, EventArg1) == 0x000018, "Member 'FCharacterHPEventInfo::EventArg1' has a wrong offset!");
static_assert(offsetof(FCharacterHPEventInfo, EventArg2) == 0x00001C, "Member 'FCharacterHPEventInfo::EventArg2' has a wrong offset!");
static_assert(offsetof(FCharacterHPEventInfo, EventArg3) == 0x000020, "Member 'FCharacterHPEventInfo::EventArg3' has a wrong offset!");
static_assert(offsetof(FCharacterHPEventInfo, EventArg4) == 0x000024, "Member 'FCharacterHPEventInfo::EventArg4' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosSavedataUploadResponse
// 0x0004 (0x0004 - 0x0000)
struct FCosmosSavedataUploadResponse final
{
public:
	int32                                         Status;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosSavedataUploadResponse) == 0x000004, "Wrong alignment on FCosmosSavedataUploadResponse");
static_assert(sizeof(FCosmosSavedataUploadResponse) == 0x000004, "Wrong size on FCosmosSavedataUploadResponse");
static_assert(offsetof(FCosmosSavedataUploadResponse, Status) == 0x000000, "Member 'FCosmosSavedataUploadResponse::Status' has a wrong offset!");

// ScriptStruct BattlePrototype.AchievementSkillDBRaw
// 0x0010 (0x0018 - 0x0008)
struct FAchievementSkillDBRaw final : public FTableRowBase
{
public:
	EPlayerSkillCategory                          Category;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LearnPoint;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LearnPointCh0200;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAchievementSkillDBRaw) == 0x000008, "Wrong alignment on FAchievementSkillDBRaw");
static_assert(sizeof(FAchievementSkillDBRaw) == 0x000018, "Wrong size on FAchievementSkillDBRaw");
static_assert(offsetof(FAchievementSkillDBRaw, Category) == 0x000008, "Member 'FAchievementSkillDBRaw::Category' has a wrong offset!");
static_assert(offsetof(FAchievementSkillDBRaw, LearnPoint) == 0x00000C, "Member 'FAchievementSkillDBRaw::LearnPoint' has a wrong offset!");
static_assert(offsetof(FAchievementSkillDBRaw, LearnPointCh0200) == 0x000010, "Member 'FAchievementSkillDBRaw::LearnPointCh0200' has a wrong offset!");

// ScriptStruct BattlePrototype.AnimeInterlockingRewardToKins
// 0x0018 (0x0020 - 0x0008)
struct FAnimeInterlockingRewardToKins final : public FTableRowBase
{
public:
	class FString                                 ItemId;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KinsNum;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimeInterlockingRewardToKins) == 0x000008, "Wrong alignment on FAnimeInterlockingRewardToKins");
static_assert(sizeof(FAnimeInterlockingRewardToKins) == 0x000020, "Wrong size on FAnimeInterlockingRewardToKins");
static_assert(offsetof(FAnimeInterlockingRewardToKins, ItemId) == 0x000008, "Member 'FAnimeInterlockingRewardToKins::ItemId' has a wrong offset!");
static_assert(offsetof(FAnimeInterlockingRewardToKins, KinsNum) == 0x000018, "Member 'FAnimeInterlockingRewardToKins::KinsNum' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_WaitingVoice
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_WaitingVoice final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_WaitingVoice) == 0x000008, "Wrong alignment on FBrainTalkBt_WaitingVoice");
static_assert(sizeof(FBrainTalkBt_WaitingVoice) == 0x000018, "Wrong size on FBrainTalkBt_WaitingVoice");
static_assert(offsetof(FBrainTalkBt_WaitingVoice, TalkMember) == 0x000008, "Member 'FBrainTalkBt_WaitingVoice::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_WaitingVoice, Category) == 0x000009, "Member 'FBrainTalkBt_WaitingVoice::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_WaitingVoice, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_WaitingVoice::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoMotionNeedKizunaLevelInfo
// 0x0018 (0x0020 - 0x0008)
struct FAjitoMotionNeedKizunaLevelInfo final : public FTableRowBase
{
public:
	class FName                                   Description;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 MotionIdToNeedKizunaLevel;                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAjitoMotionNeedKizunaLevelInfo) == 0x000008, "Wrong alignment on FAjitoMotionNeedKizunaLevelInfo");
static_assert(sizeof(FAjitoMotionNeedKizunaLevelInfo) == 0x000020, "Wrong size on FAjitoMotionNeedKizunaLevelInfo");
static_assert(offsetof(FAjitoMotionNeedKizunaLevelInfo, Description) == 0x000008, "Member 'FAjitoMotionNeedKizunaLevelInfo::Description' has a wrong offset!");
static_assert(offsetof(FAjitoMotionNeedKizunaLevelInfo, MotionIdToNeedKizunaLevel) == 0x000010, "Member 'FAjitoMotionNeedKizunaLevelInfo::MotionIdToNeedKizunaLevel' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerAIThreatActorData
// 0x000C (0x000C - 0x0000)
struct FPlayerAIThreatActorData final
{
public:
	float                                         RemainTime;                                        // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  ThreatActor;                                       // 0x0004(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerAIThreatActorData) == 0x000004, "Wrong alignment on FPlayerAIThreatActorData");
static_assert(sizeof(FPlayerAIThreatActorData) == 0x00000C, "Wrong size on FPlayerAIThreatActorData");
static_assert(offsetof(FPlayerAIThreatActorData, RemainTime) == 0x000000, "Member 'FPlayerAIThreatActorData::RemainTime' has a wrong offset!");
static_assert(offsetof(FPlayerAIThreatActorData, ThreatActor) == 0x000004, "Member 'FPlayerAIThreatActorData::ThreatActor' has a wrong offset!");

// ScriptStruct BattlePrototype.KizunaEpisodeCheckInfo
// 0x0030 (0x0038 - 0x0008)
struct FKizunaEpisodeCheckInfo final : public FTableRowBase
{
public:
	EPlayerID                                     PlayerId;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TargetCharacterId;                                 // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ProgressId;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           NeedScenarioIds;                                   // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BondsProgressId;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKizunaEpisodeCheckInfo) == 0x000008, "Wrong alignment on FKizunaEpisodeCheckInfo");
static_assert(sizeof(FKizunaEpisodeCheckInfo) == 0x000038, "Wrong size on FKizunaEpisodeCheckInfo");
static_assert(offsetof(FKizunaEpisodeCheckInfo, PlayerId) == 0x000008, "Member 'FKizunaEpisodeCheckInfo::PlayerId' has a wrong offset!");
static_assert(offsetof(FKizunaEpisodeCheckInfo, TargetCharacterId) == 0x000009, "Member 'FKizunaEpisodeCheckInfo::TargetCharacterId' has a wrong offset!");
static_assert(offsetof(FKizunaEpisodeCheckInfo, ProgressId) == 0x000010, "Member 'FKizunaEpisodeCheckInfo::ProgressId' has a wrong offset!");
static_assert(offsetof(FKizunaEpisodeCheckInfo, NeedScenarioIds) == 0x000020, "Member 'FKizunaEpisodeCheckInfo::NeedScenarioIds' has a wrong offset!");
static_assert(offsetof(FKizunaEpisodeCheckInfo, BondsProgressId) == 0x000030, "Member 'FKizunaEpisodeCheckInfo::BondsProgressId' has a wrong offset!");

// ScriptStruct BattlePrototype.OptimizeMaterialCondition
// 0x0014 (0x0014 - 0x0000)
struct FOptimizeMaterialCondition final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOptimizeMaterialConditionBranch              Branch;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOptimizeMaterialConditionType                ConditionType;                                     // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NowSettingValue;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOptimizeMaterialCondition) == 0x000004, "Wrong alignment on FOptimizeMaterialCondition");
static_assert(sizeof(FOptimizeMaterialCondition) == 0x000014, "Wrong size on FOptimizeMaterialCondition");
static_assert(offsetof(FOptimizeMaterialCondition, ParameterName) == 0x000000, "Member 'FOptimizeMaterialCondition::ParameterName' has a wrong offset!");
static_assert(offsetof(FOptimizeMaterialCondition, Branch) == 0x000008, "Member 'FOptimizeMaterialCondition::Branch' has a wrong offset!");
static_assert(offsetof(FOptimizeMaterialCondition, ConditionType) == 0x000009, "Member 'FOptimizeMaterialCondition::ConditionType' has a wrong offset!");
static_assert(offsetof(FOptimizeMaterialCondition, ConditionValue) == 0x00000C, "Member 'FOptimizeMaterialCondition::ConditionValue' has a wrong offset!");
static_assert(offsetof(FOptimizeMaterialCondition, NowSettingValue) == 0x000010, "Member 'FOptimizeMaterialCondition::NowSettingValue' has a wrong offset!");

// ScriptStruct BattlePrototype.OptimizeMaterialMultiCondition
// 0x0010 (0x0010 - 0x0000)
struct FOptimizeMaterialMultiCondition final
{
public:
	TArray<struct FOptimizeMaterialCondition>     Conditions;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOptimizeMaterialMultiCondition) == 0x000008, "Wrong alignment on FOptimizeMaterialMultiCondition");
static_assert(sizeof(FOptimizeMaterialMultiCondition) == 0x000010, "Wrong size on FOptimizeMaterialMultiCondition");
static_assert(offsetof(FOptimizeMaterialMultiCondition, Conditions) == 0x000000, "Member 'FOptimizeMaterialMultiCondition::Conditions' has a wrong offset!");

// ScriptStruct BattlePrototype.MapGimmickStateLevelSequence
// 0x0010 (0x0010 - 0x0000)
struct FMapGimmickStateLevelSequence final
{
public:
	TArray<class ULevelSequence*>                 LevelSequences;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapGimmickStateLevelSequence) == 0x000008, "Wrong alignment on FMapGimmickStateLevelSequence");
static_assert(sizeof(FMapGimmickStateLevelSequence) == 0x000010, "Wrong size on FMapGimmickStateLevelSequence");
static_assert(offsetof(FMapGimmickStateLevelSequence, LevelSequences) == 0x000000, "Member 'FMapGimmickStateLevelSequence::LevelSequences' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoArrangementPatternInfoProgress
// 0x0020 (0x0028 - 0x0008)
struct FAjitoArrangementPatternInfoProgress final : public FTableRowBase
{
public:
	class FString                                 StartProgressID;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EndProgressID;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAjitoArrangementPatternInfoProgress) == 0x000008, "Wrong alignment on FAjitoArrangementPatternInfoProgress");
static_assert(sizeof(FAjitoArrangementPatternInfoProgress) == 0x000028, "Wrong size on FAjitoArrangementPatternInfoProgress");
static_assert(offsetof(FAjitoArrangementPatternInfoProgress, StartProgressID) == 0x000008, "Member 'FAjitoArrangementPatternInfoProgress::StartProgressID' has a wrong offset!");
static_assert(offsetof(FAjitoArrangementPatternInfoProgress, EndProgressID) == 0x000018, "Member 'FAjitoArrangementPatternInfoProgress::EndProgressID' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoArrangementPatternCondition
// 0x0040 (0x0048 - 0x0008)
struct FAjitoArrangementPatternCondition final : public FTableRowBase
{
public:
	class FString                                 Memo;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RequiredItem;                                      // 0x001C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPlayerID>                             RequiredMembers;                                   // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAjitoArrangementPatternInfoProgress> AvailableProgressIdPeriod;                         // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAjitoArrangementPatternCondition) == 0x000008, "Wrong alignment on FAjitoArrangementPatternCondition");
static_assert(sizeof(FAjitoArrangementPatternCondition) == 0x000048, "Wrong size on FAjitoArrangementPatternCondition");
static_assert(offsetof(FAjitoArrangementPatternCondition, Memo) == 0x000008, "Member 'FAjitoArrangementPatternCondition::Memo' has a wrong offset!");
static_assert(offsetof(FAjitoArrangementPatternCondition, Priority) == 0x000018, "Member 'FAjitoArrangementPatternCondition::Priority' has a wrong offset!");
static_assert(offsetof(FAjitoArrangementPatternCondition, RequiredItem) == 0x00001C, "Member 'FAjitoArrangementPatternCondition::RequiredItem' has a wrong offset!");
static_assert(offsetof(FAjitoArrangementPatternCondition, RequiredMembers) == 0x000028, "Member 'FAjitoArrangementPatternCondition::RequiredMembers' has a wrong offset!");
static_assert(offsetof(FAjitoArrangementPatternCondition, AvailableProgressIdPeriod) == 0x000038, "Member 'FAjitoArrangementPatternCondition::AvailableProgressIdPeriod' has a wrong offset!");

// ScriptStruct BattlePrototype.UIPkObjectTimerInfo
// 0x0020 (0x0020 - 0x0000)
struct FUIPkObjectTimerInfo final
{
public:
	class UUIPkObjectTimer*                       Widget;                                            // 0x0000(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARSCharacterBase*                       Target;                                            // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsUsing;                                           // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsClose;                                           // 0x0019(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIPkObjectTimerInfo) == 0x000008, "Wrong alignment on FUIPkObjectTimerInfo");
static_assert(sizeof(FUIPkObjectTimerInfo) == 0x000020, "Wrong size on FUIPkObjectTimerInfo");
static_assert(offsetof(FUIPkObjectTimerInfo, Widget) == 0x000000, "Member 'FUIPkObjectTimerInfo::Widget' has a wrong offset!");
static_assert(offsetof(FUIPkObjectTimerInfo, Target) == 0x000008, "Member 'FUIPkObjectTimerInfo::Target' has a wrong offset!");
static_assert(offsetof(FUIPkObjectTimerInfo, IsUsing) == 0x000018, "Member 'FUIPkObjectTimerInfo::IsUsing' has a wrong offset!");
static_assert(offsetof(FUIPkObjectTimerInfo, IsClose) == 0x000019, "Member 'FUIPkObjectTimerInfo::IsClose' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_BirthKizunaEp
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_BirthKizunaEp final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     EpMember;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_BirthKizunaEp) == 0x000008, "Wrong alignment on FBrainTalkBt_BirthKizunaEp");
static_assert(sizeof(FBrainTalkBt_BirthKizunaEp) == 0x000018, "Wrong size on FBrainTalkBt_BirthKizunaEp");
static_assert(offsetof(FBrainTalkBt_BirthKizunaEp, Player) == 0x000008, "Member 'FBrainTalkBt_BirthKizunaEp::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BirthKizunaEp, EpMember) == 0x000009, "Member 'FBrainTalkBt_BirthKizunaEp::EpMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BirthKizunaEp, Category) == 0x00000A, "Member 'FBrainTalkBt_BirthKizunaEp::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BirthKizunaEp, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_BirthKizunaEp::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.AchievementSkillItem
// 0x0010 (0x0010 - 0x0000)
struct FAchievementSkillItem final
{
public:
	TArray<EPlayerSkill>                          SkillArray;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAchievementSkillItem) == 0x000008, "Wrong alignment on FAchievementSkillItem");
static_assert(sizeof(FAchievementSkillItem) == 0x000010, "Wrong size on FAchievementSkillItem");
static_assert(offsetof(FAchievementSkillItem, SkillArray) == 0x000000, "Member 'FAchievementSkillItem::SkillArray' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_BadStateForEn
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_BadStateForEn final : public FTableRowBase
{
public:
	EPlayerID                                     BadStateFrom;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCSkillAttribute                             BadState;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     Player;                                            // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWataruHaruka;                                    // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_BadStateForEn) == 0x000008, "Wrong alignment on FBrainTalkBt_BadStateForEn");
static_assert(sizeof(FBrainTalkBt_BadStateForEn) == 0x000018, "Wrong size on FBrainTalkBt_BadStateForEn");
static_assert(offsetof(FBrainTalkBt_BadStateForEn, BadStateFrom) == 0x000008, "Member 'FBrainTalkBt_BadStateForEn::BadStateFrom' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BadStateForEn, BadState) == 0x000009, "Member 'FBrainTalkBt_BadStateForEn::BadState' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BadStateForEn, Player) == 0x00000A, "Member 'FBrainTalkBt_BadStateForEn::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BadStateForEn, IsWataruHaruka) == 0x00000B, "Member 'FBrainTalkBt_BadStateForEn::IsWataruHaruka' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BadStateForEn, Category) == 0x00000C, "Member 'FBrainTalkBt_BadStateForEn::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BadStateForEn, DatatableId) == 0x000010, "Member 'FBrainTalkBt_BadStateForEn::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.AchievementPresentItem
// 0x0018 (0x0018 - 0x0000)
struct FAchievementPresentItem final
{
public:
	TArray<class FName>                           IdArray;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartIdx;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAchievementPresentItem) == 0x000008, "Wrong alignment on FAchievementPresentItem");
static_assert(sizeof(FAchievementPresentItem) == 0x000018, "Wrong size on FAchievementPresentItem");
static_assert(offsetof(FAchievementPresentItem, IdArray) == 0x000000, "Member 'FAchievementPresentItem::IdArray' has a wrong offset!");
static_assert(offsetof(FAchievementPresentItem, StartIdx) == 0x000010, "Member 'FAchievementPresentItem::StartIdx' has a wrong offset!");

// ScriptStruct BattlePrototype.AchievementBondsProgressDBRaw
// 0x0008 (0x0010 - 0x0008)
struct FAchievementBondsProgressDBRaw final : public FTableRowBase
{
public:
	EPlayerID                                     PlayerId;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TargetID;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProgressNo;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAchievementBondsProgressDBRaw) == 0x000008, "Wrong alignment on FAchievementBondsProgressDBRaw");
static_assert(sizeof(FAchievementBondsProgressDBRaw) == 0x000010, "Wrong size on FAchievementBondsProgressDBRaw");
static_assert(offsetof(FAchievementBondsProgressDBRaw, PlayerId) == 0x000008, "Member 'FAchievementBondsProgressDBRaw::PlayerId' has a wrong offset!");
static_assert(offsetof(FAchievementBondsProgressDBRaw, TargetID) == 0x000009, "Member 'FAchievementBondsProgressDBRaw::TargetID' has a wrong offset!");
static_assert(offsetof(FAchievementBondsProgressDBRaw, ProgressNo) == 0x00000C, "Member 'FAchievementBondsProgressDBRaw::ProgressNo' has a wrong offset!");

// ScriptStruct BattlePrototype.AchievementStringDBRaw
// 0x0010 (0x0018 - 0x0008)
struct FAchievementStringDBRaw final : public FTableRowBase
{
public:
	class FString                                 StringData;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAchievementStringDBRaw) == 0x000008, "Wrong alignment on FAchievementStringDBRaw");
static_assert(sizeof(FAchievementStringDBRaw) == 0x000018, "Wrong size on FAchievementStringDBRaw");
static_assert(offsetof(FAchievementStringDBRaw, StringData) == 0x000008, "Member 'FAchievementStringDBRaw::StringData' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_Hp30p
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_Hp30p final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWataruHaruka;                                    // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_Hp30p) == 0x000008, "Wrong alignment on FBrainTalkBt_Hp30p");
static_assert(sizeof(FBrainTalkBt_Hp30p) == 0x000018, "Wrong size on FBrainTalkBt_Hp30p");
static_assert(offsetof(FBrainTalkBt_Hp30p, Player) == 0x000008, "Member 'FBrainTalkBt_Hp30p::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_Hp30p, IsWataruHaruka) == 0x000009, "Member 'FBrainTalkBt_Hp30p::IsWataruHaruka' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_Hp30p, Category) == 0x00000A, "Member 'FBrainTalkBt_Hp30p::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_Hp30p, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_Hp30p::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.AchievementNameDBRaw
// 0x0008 (0x0010 - 0x0008)
struct FAchievementNameDBRaw final : public FTableRowBase
{
public:
	class FName                                   NameData;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAchievementNameDBRaw) == 0x000008, "Wrong alignment on FAchievementNameDBRaw");
static_assert(sizeof(FAchievementNameDBRaw) == 0x000010, "Wrong size on FAchievementNameDBRaw");
static_assert(offsetof(FAchievementNameDBRaw, NameData) == 0x000008, "Member 'FAchievementNameDBRaw::NameData' has a wrong offset!");

// ScriptStruct BattlePrototype.AddContentRefDataCell
// 0x0070 (0x0078 - 0x0008)
struct FAddContentRefDataCell final : public FTableRowBase
{
public:
	class FName                                   AddContentName;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLossConfirmation;                                // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TitleID;                                           // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExplanationID;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EntitlementLabel;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ContentId;                                         // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StoreId;                                           // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AppId;                                             // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAddContentRefDataCell) == 0x000008, "Wrong alignment on FAddContentRefDataCell");
static_assert(sizeof(FAddContentRefDataCell) == 0x000078, "Wrong size on FAddContentRefDataCell");
static_assert(offsetof(FAddContentRefDataCell, AddContentName) == 0x000008, "Member 'FAddContentRefDataCell::AddContentName' has a wrong offset!");
static_assert(offsetof(FAddContentRefDataCell, IsValid) == 0x000010, "Member 'FAddContentRefDataCell::IsValid' has a wrong offset!");
static_assert(offsetof(FAddContentRefDataCell, IsLossConfirmation) == 0x000011, "Member 'FAddContentRefDataCell::IsLossConfirmation' has a wrong offset!");
static_assert(offsetof(FAddContentRefDataCell, TitleID) == 0x000018, "Member 'FAddContentRefDataCell::TitleID' has a wrong offset!");
static_assert(offsetof(FAddContentRefDataCell, ExplanationID) == 0x000028, "Member 'FAddContentRefDataCell::ExplanationID' has a wrong offset!");
static_assert(offsetof(FAddContentRefDataCell, EntitlementLabel) == 0x000038, "Member 'FAddContentRefDataCell::EntitlementLabel' has a wrong offset!");
static_assert(offsetof(FAddContentRefDataCell, ContentId) == 0x000048, "Member 'FAddContentRefDataCell::ContentId' has a wrong offset!");
static_assert(offsetof(FAddContentRefDataCell, StoreId) == 0x000058, "Member 'FAddContentRefDataCell::StoreId' has a wrong offset!");
static_assert(offsetof(FAddContentRefDataCell, AppId) == 0x000068, "Member 'FAddContentRefDataCell::AppId' has a wrong offset!");

// ScriptStruct BattlePrototype.AddContentsPresentInfo
// 0x0020 (0x0020 - 0x0000)
struct FAddContentsPresentInfo final
{
public:
	EAddContentsType                              DLCType;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ID;                                                // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num;                                               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAddContentsPresentInfo) == 0x000008, "Wrong alignment on FAddContentsPresentInfo");
static_assert(sizeof(FAddContentsPresentInfo) == 0x000020, "Wrong size on FAddContentsPresentInfo");
static_assert(offsetof(FAddContentsPresentInfo, DLCType) == 0x000000, "Member 'FAddContentsPresentInfo::DLCType' has a wrong offset!");
static_assert(offsetof(FAddContentsPresentInfo, ID) == 0x000008, "Member 'FAddContentsPresentInfo::ID' has a wrong offset!");
static_assert(offsetof(FAddContentsPresentInfo, Num) == 0x000018, "Member 'FAddContentsPresentInfo::Num' has a wrong offset!");

// ScriptStruct BattlePrototype.AddContentsPresentList
// 0x0018 (0x0020 - 0x0008)
struct FAddContentsPresentList final : public FTableRowBase
{
public:
	class FName                                   AddContentName;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAddContentsPresentInfo>        PresentInfos;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAddContentsPresentList) == 0x000008, "Wrong alignment on FAddContentsPresentList");
static_assert(sizeof(FAddContentsPresentList) == 0x000020, "Wrong size on FAddContentsPresentList");
static_assert(offsetof(FAddContentsPresentList, AddContentName) == 0x000008, "Member 'FAddContentsPresentList::AddContentName' has a wrong offset!");
static_assert(offsetof(FAddContentsPresentList, PresentInfos) == 0x000010, "Member 'FAddContentsPresentList::PresentInfos' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_InvalidProgressID
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_InvalidProgressID final : public FTableRowBase
{
public:
	int32                                         ProgressIdMin;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressIdMax;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkBtGroup                             Group;                                             // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_InvalidProgressID) == 0x000008, "Wrong alignment on FBrainTalkBt_InvalidProgressID");
static_assert(sizeof(FBrainTalkBt_InvalidProgressID) == 0x000018, "Wrong size on FBrainTalkBt_InvalidProgressID");
static_assert(offsetof(FBrainTalkBt_InvalidProgressID, ProgressIdMin) == 0x000008, "Member 'FBrainTalkBt_InvalidProgressID::ProgressIdMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_InvalidProgressID, ProgressIdMax) == 0x00000C, "Member 'FBrainTalkBt_InvalidProgressID::ProgressIdMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_InvalidProgressID, Group) == 0x000010, "Member 'FBrainTalkBt_InvalidProgressID::Group' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_PLChangeAttachment
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_PLChangeAttachment final : public FTableRowBase
{
public:
	EPlayerID                                     Member1;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     Member2;                                           // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KizunaLvMin;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KizunaLvMax;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_PLChangeAttachment) == 0x000008, "Wrong alignment on FBrainTalkBt_PLChangeAttachment");
static_assert(sizeof(FBrainTalkBt_PLChangeAttachment) == 0x000020, "Wrong size on FBrainTalkBt_PLChangeAttachment");
static_assert(offsetof(FBrainTalkBt_PLChangeAttachment, Member1) == 0x000008, "Member 'FBrainTalkBt_PLChangeAttachment::Member1' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_PLChangeAttachment, Member2) == 0x000009, "Member 'FBrainTalkBt_PLChangeAttachment::Member2' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_PLChangeAttachment, KizunaLvMin) == 0x00000C, "Member 'FBrainTalkBt_PLChangeAttachment::KizunaLvMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_PLChangeAttachment, KizunaLvMax) == 0x000010, "Member 'FBrainTalkBt_PLChangeAttachment::KizunaLvMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_PLChangeAttachment, Category) == 0x000014, "Member 'FBrainTalkBt_PLChangeAttachment::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_PLChangeAttachment, DatatableId) == 0x000018, "Member 'FBrainTalkBt_PLChangeAttachment::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoPlaceInfo
// 0x0018 (0x0020 - 0x0008)
struct FAjitoPlaceInfo final : public FTableRowBase
{
public:
	class FName                                   Description;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PlaceHolder;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     PlayerCharacterID;                                 // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MotionID;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAjitoPlaceInfo) == 0x000008, "Wrong alignment on FAjitoPlaceInfo");
static_assert(sizeof(FAjitoPlaceInfo) == 0x000020, "Wrong size on FAjitoPlaceInfo");
static_assert(offsetof(FAjitoPlaceInfo, Description) == 0x000008, "Member 'FAjitoPlaceInfo::Description' has a wrong offset!");
static_assert(offsetof(FAjitoPlaceInfo, PlaceHolder) == 0x000010, "Member 'FAjitoPlaceInfo::PlaceHolder' has a wrong offset!");
static_assert(offsetof(FAjitoPlaceInfo, PlayerCharacterID) == 0x000018, "Member 'FAjitoPlaceInfo::PlayerCharacterID' has a wrong offset!");
static_assert(offsetof(FAjitoPlaceInfo, MotionID) == 0x00001C, "Member 'FAjitoPlaceInfo::MotionID' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoAvailableMotionInPlace
// 0x0018 (0x0020 - 0x0008)
struct FAjitoAvailableMotionInPlace final : public FTableRowBase
{
public:
	class FName                                   Description;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAjitoAvailableMotion>          PlaceIds;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAjitoAvailableMotionInPlace) == 0x000008, "Wrong alignment on FAjitoAvailableMotionInPlace");
static_assert(sizeof(FAjitoAvailableMotionInPlace) == 0x000020, "Wrong size on FAjitoAvailableMotionInPlace");
static_assert(offsetof(FAjitoAvailableMotionInPlace, Description) == 0x000008, "Member 'FAjitoAvailableMotionInPlace::Description' has a wrong offset!");
static_assert(offsetof(FAjitoAvailableMotionInPlace, PlaceIds) == 0x000010, "Member 'FAjitoAvailableMotionInPlace::PlaceIds' has a wrong offset!");

// ScriptStruct BattlePrototype.DataTableRowTest2
// 0x0008 (0x0010 - 0x0008)
struct FDataTableRowTest2 final : public FTableRowBase
{
public:
	int32                                         _testIntVal;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDataTableRowTest2) == 0x000008, "Wrong alignment on FDataTableRowTest2");
static_assert(sizeof(FDataTableRowTest2) == 0x000010, "Wrong size on FDataTableRowTest2");
static_assert(offsetof(FDataTableRowTest2, _testIntVal) == 0x000008, "Member 'FDataTableRowTest2::_testIntVal' has a wrong offset!");

// ScriptStruct BattlePrototype.DebugCharacterPresetParam
// 0x0028 (0x0028 - 0x0000)
struct FDebugCharacterPresetParam final
{
public:
	EDebugCharacterPresetState                    State;                                             // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Weapon;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Accessory;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Bonds;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugCharacterPresetParam) == 0x000008, "Wrong alignment on FDebugCharacterPresetParam");
static_assert(sizeof(FDebugCharacterPresetParam) == 0x000028, "Wrong size on FDebugCharacterPresetParam");
static_assert(offsetof(FDebugCharacterPresetParam, State) == 0x000000, "Member 'FDebugCharacterPresetParam::State' has a wrong offset!");
static_assert(offsetof(FDebugCharacterPresetParam, Level) == 0x000004, "Member 'FDebugCharacterPresetParam::Level' has a wrong offset!");
static_assert(offsetof(FDebugCharacterPresetParam, Weapon) == 0x000008, "Member 'FDebugCharacterPresetParam::Weapon' has a wrong offset!");
static_assert(offsetof(FDebugCharacterPresetParam, Accessory) == 0x000010, "Member 'FDebugCharacterPresetParam::Accessory' has a wrong offset!");
static_assert(offsetof(FDebugCharacterPresetParam, Bonds) == 0x000020, "Member 'FDebugCharacterPresetParam::Bonds' has a wrong offset!");

// ScriptStruct BattlePrototype.DebugCharacterPresetDataCell
// 0x0198 (0x01A0 - 0x0008)
struct FDebugCharacterPresetDataCell final : public FTableRowBase
{
public:
	EPlayerID                                     BattleMain;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     BattleR;                                           // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     BattleL;                                           // 0x000A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDebugCharacterPresetParam             Ch0100;                                            // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDebugCharacterPresetParam             Ch0200;                                            // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDebugCharacterPresetParam             Ch0300;                                            // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDebugCharacterPresetParam             Ch0400;                                            // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDebugCharacterPresetParam             Ch0500;                                            // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDebugCharacterPresetParam             Ch0600;                                            // 0x00D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDebugCharacterPresetParam             Ch0700;                                            // 0x0100(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDebugCharacterPresetParam             Ch0800;                                            // 0x0128(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDebugCharacterPresetParam             Ch0900;                                            // 0x0150(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDebugCharacterPresetParam             Ch1000;                                            // 0x0178(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugCharacterPresetDataCell) == 0x000008, "Wrong alignment on FDebugCharacterPresetDataCell");
static_assert(sizeof(FDebugCharacterPresetDataCell) == 0x0001A0, "Wrong size on FDebugCharacterPresetDataCell");
static_assert(offsetof(FDebugCharacterPresetDataCell, BattleMain) == 0x000008, "Member 'FDebugCharacterPresetDataCell::BattleMain' has a wrong offset!");
static_assert(offsetof(FDebugCharacterPresetDataCell, BattleR) == 0x000009, "Member 'FDebugCharacterPresetDataCell::BattleR' has a wrong offset!");
static_assert(offsetof(FDebugCharacterPresetDataCell, BattleL) == 0x00000A, "Member 'FDebugCharacterPresetDataCell::BattleL' has a wrong offset!");
static_assert(offsetof(FDebugCharacterPresetDataCell, Ch0100) == 0x000010, "Member 'FDebugCharacterPresetDataCell::Ch0100' has a wrong offset!");
static_assert(offsetof(FDebugCharacterPresetDataCell, Ch0200) == 0x000038, "Member 'FDebugCharacterPresetDataCell::Ch0200' has a wrong offset!");
static_assert(offsetof(FDebugCharacterPresetDataCell, Ch0300) == 0x000060, "Member 'FDebugCharacterPresetDataCell::Ch0300' has a wrong offset!");
static_assert(offsetof(FDebugCharacterPresetDataCell, Ch0400) == 0x000088, "Member 'FDebugCharacterPresetDataCell::Ch0400' has a wrong offset!");
static_assert(offsetof(FDebugCharacterPresetDataCell, Ch0500) == 0x0000B0, "Member 'FDebugCharacterPresetDataCell::Ch0500' has a wrong offset!");
static_assert(offsetof(FDebugCharacterPresetDataCell, Ch0600) == 0x0000D8, "Member 'FDebugCharacterPresetDataCell::Ch0600' has a wrong offset!");
static_assert(offsetof(FDebugCharacterPresetDataCell, Ch0700) == 0x000100, "Member 'FDebugCharacterPresetDataCell::Ch0700' has a wrong offset!");
static_assert(offsetof(FDebugCharacterPresetDataCell, Ch0800) == 0x000128, "Member 'FDebugCharacterPresetDataCell::Ch0800' has a wrong offset!");
static_assert(offsetof(FDebugCharacterPresetDataCell, Ch0900) == 0x000150, "Member 'FDebugCharacterPresetDataCell::Ch0900' has a wrong offset!");
static_assert(offsetof(FDebugCharacterPresetDataCell, Ch1000) == 0x000178, "Member 'FDebugCharacterPresetDataCell::Ch1000' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoArrangementPatternInfoOne
// 0x0020 (0x0028 - 0x0008)
struct FAjitoArrangementPatternInfoOne final : public FTableRowBase
{
public:
	EPlayerID                                     PlayerId;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Action1;                                           // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Action2;                                           // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemForAction2;                                    // 0x001C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAjitoArrangementPatternInfoOne) == 0x000008, "Wrong alignment on FAjitoArrangementPatternInfoOne");
static_assert(sizeof(FAjitoArrangementPatternInfoOne) == 0x000028, "Wrong size on FAjitoArrangementPatternInfoOne");
static_assert(offsetof(FAjitoArrangementPatternInfoOne, PlayerId) == 0x000008, "Member 'FAjitoArrangementPatternInfoOne::PlayerId' has a wrong offset!");
static_assert(offsetof(FAjitoArrangementPatternInfoOne, Action1) == 0x00000C, "Member 'FAjitoArrangementPatternInfoOne::Action1' has a wrong offset!");
static_assert(offsetof(FAjitoArrangementPatternInfoOne, Action2) == 0x000014, "Member 'FAjitoArrangementPatternInfoOne::Action2' has a wrong offset!");
static_assert(offsetof(FAjitoArrangementPatternInfoOne, ItemForAction2) == 0x00001C, "Member 'FAjitoArrangementPatternInfoOne::ItemForAction2' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoArrangementPatternInfo
// 0x0020 (0x0028 - 0x0008)
struct FAjitoArrangementPatternInfo final : public FTableRowBase
{
public:
	class FString                                 Description;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAjitoArrangementPatternInfoOne> MemberAndAction;                                   // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAjitoArrangementPatternInfo) == 0x000008, "Wrong alignment on FAjitoArrangementPatternInfo");
static_assert(sizeof(FAjitoArrangementPatternInfo) == 0x000028, "Wrong size on FAjitoArrangementPatternInfo");
static_assert(offsetof(FAjitoArrangementPatternInfo, Description) == 0x000008, "Member 'FAjitoArrangementPatternInfo::Description' has a wrong offset!");
static_assert(offsetof(FAjitoArrangementPatternInfo, MemberAndAction) == 0x000018, "Member 'FAjitoArrangementPatternInfo::MemberAndAction' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_BattleEscape
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_BattleEscape final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KizunaLvMin;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KizunaLvMax;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_BattleEscape) == 0x000008, "Wrong alignment on FBrainTalkBt_BattleEscape");
static_assert(sizeof(FBrainTalkBt_BattleEscape) == 0x000020, "Wrong size on FBrainTalkBt_BattleEscape");
static_assert(offsetof(FBrainTalkBt_BattleEscape, TalkMember) == 0x000008, "Member 'FBrainTalkBt_BattleEscape::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BattleEscape, KizunaLvMin) == 0x00000C, "Member 'FBrainTalkBt_BattleEscape::KizunaLvMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BattleEscape, KizunaLvMax) == 0x000010, "Member 'FBrainTalkBt_BattleEscape::KizunaLvMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BattleEscape, Category) == 0x000014, "Member 'FBrainTalkBt_BattleEscape::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BattleEscape, DatatableId) == 0x000018, "Member 'FBrainTalkBt_BattleEscape::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoArrangementMasterInfoSub
// 0x0010 (0x0018 - 0x0008)
struct FAjitoArrangementMasterInfoSub final : public FTableRowBase
{
public:
	TArray<class FName>                           HideActorTags;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAjitoArrangementMasterInfoSub) == 0x000008, "Wrong alignment on FAjitoArrangementMasterInfoSub");
static_assert(sizeof(FAjitoArrangementMasterInfoSub) == 0x000018, "Wrong size on FAjitoArrangementMasterInfoSub");
static_assert(offsetof(FAjitoArrangementMasterInfoSub, HideActorTags) == 0x000008, "Member 'FAjitoArrangementMasterInfoSub::HideActorTags' has a wrong offset!");

// ScriptStruct BattlePrototype.MovingRoadActor
// 0x0010 (0x0010 - 0x0000)
struct FMovingRoadActor final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 RoadActor;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovingRoadActor) == 0x000008, "Wrong alignment on FMovingRoadActor");
static_assert(sizeof(FMovingRoadActor) == 0x000010, "Wrong size on FMovingRoadActor");
static_assert(offsetof(FMovingRoadActor, TargetActor) == 0x000000, "Member 'FMovingRoadActor::TargetActor' has a wrong offset!");
static_assert(offsetof(FMovingRoadActor, RoadActor) == 0x000008, "Member 'FMovingRoadActor::RoadActor' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoArrangementPatternMember
// 0x0010 (0x0018 - 0x0008)
struct FAjitoArrangementPatternMember final : public FTableRowBase
{
public:
	bool                                          Visible;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PlaceMasterKeyName;                                // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAjitoArrangementPatternMember) == 0x000008, "Wrong alignment on FAjitoArrangementPatternMember");
static_assert(sizeof(FAjitoArrangementPatternMember) == 0x000018, "Wrong size on FAjitoArrangementPatternMember");
static_assert(offsetof(FAjitoArrangementPatternMember, Visible) == 0x000008, "Member 'FAjitoArrangementPatternMember::Visible' has a wrong offset!");
static_assert(offsetof(FAjitoArrangementPatternMember, PlaceMasterKeyName) == 0x00000C, "Member 'FAjitoArrangementPatternMember::PlaceMasterKeyName' has a wrong offset!");

// ScriptStruct BattlePrototype.DetailedMapContentFloorDataCell
// 0x0040 (0x0048 - 0x0008)
struct FDetailedMapContentFloorDataCell final : public FTableRowBase
{
public:
	class FName                                   FloorName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapPath;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraLocation;                                    // 0x0020(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ViewLocation;                                      // 0x002C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewZoom;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionMinimap;                                  // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HightPer;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetailedMapContentFloorDataCell) == 0x000008, "Wrong alignment on FDetailedMapContentFloorDataCell");
static_assert(sizeof(FDetailedMapContentFloorDataCell) == 0x000048, "Wrong size on FDetailedMapContentFloorDataCell");
static_assert(offsetof(FDetailedMapContentFloorDataCell, FloorName) == 0x000008, "Member 'FDetailedMapContentFloorDataCell::FloorName' has a wrong offset!");
static_assert(offsetof(FDetailedMapContentFloorDataCell, MapPath) == 0x000010, "Member 'FDetailedMapContentFloorDataCell::MapPath' has a wrong offset!");
static_assert(offsetof(FDetailedMapContentFloorDataCell, CameraLocation) == 0x000020, "Member 'FDetailedMapContentFloorDataCell::CameraLocation' has a wrong offset!");
static_assert(offsetof(FDetailedMapContentFloorDataCell, ViewLocation) == 0x00002C, "Member 'FDetailedMapContentFloorDataCell::ViewLocation' has a wrong offset!");
static_assert(offsetof(FDetailedMapContentFloorDataCell, ViewZoom) == 0x000038, "Member 'FDetailedMapContentFloorDataCell::ViewZoom' has a wrong offset!");
static_assert(offsetof(FDetailedMapContentFloorDataCell, DirectionMinimap) == 0x00003C, "Member 'FDetailedMapContentFloorDataCell::DirectionMinimap' has a wrong offset!");
static_assert(offsetof(FDetailedMapContentFloorDataCell, HightPer) == 0x000040, "Member 'FDetailedMapContentFloorDataCell::HightPer' has a wrong offset!");
static_assert(offsetof(FDetailedMapContentFloorDataCell, Width) == 0x000044, "Member 'FDetailedMapContentFloorDataCell::Width' has a wrong offset!");

// ScriptStruct BattlePrototype.DetailedMapContentFloorDataArrayCell
// 0x0010 (0x0018 - 0x0008)
struct FDetailedMapContentFloorDataArrayCell final : public FTableRowBase
{
public:
	TArray<struct FDetailedMapContentFloorDataCell> FloorDatas;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetailedMapContentFloorDataArrayCell) == 0x000008, "Wrong alignment on FDetailedMapContentFloorDataArrayCell");
static_assert(sizeof(FDetailedMapContentFloorDataArrayCell) == 0x000018, "Wrong size on FDetailedMapContentFloorDataArrayCell");
static_assert(offsetof(FDetailedMapContentFloorDataArrayCell, FloorDatas) == 0x000008, "Member 'FDetailedMapContentFloorDataArrayCell::FloorDatas' has a wrong offset!");

// ScriptStruct BattlePrototype.DetailedMapDBDataCell
// 0x0050 (0x0058 - 0x0008)
struct FDetailedMapDBDataCell final : public FTableRowBase
{
public:
	TMap<class FName, struct FDetailedMapContentFloorDataArrayCell> AreaDatas;                                         // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetailedMapDBDataCell) == 0x000008, "Wrong alignment on FDetailedMapDBDataCell");
static_assert(sizeof(FDetailedMapDBDataCell) == 0x000058, "Wrong size on FDetailedMapDBDataCell");
static_assert(offsetof(FDetailedMapDBDataCell, AreaDatas) == 0x000008, "Member 'FDetailedMapDBDataCell::AreaDatas' has a wrong offset!");

// ScriptStruct BattlePrototype.SystemBrainTalkManageStruct
// 0x0040 (0x0048 - 0x0008)
struct FSystemBrainTalkManageStruct final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DataTablePath;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnableStartProgressIdYuito;                        // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnableStartProgressIdKasane;                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkBtGroup                             Group;                                             // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Interval;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NoBattle;                                          // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NoAjito;                                           // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NoPlBrainField;                                    // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NoEmBrainField;                                    // 0x0043(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSystemBrainTalkManageStruct) == 0x000008, "Wrong alignment on FSystemBrainTalkManageStruct");
static_assert(sizeof(FSystemBrainTalkManageStruct) == 0x000048, "Wrong size on FSystemBrainTalkManageStruct");
static_assert(offsetof(FSystemBrainTalkManageStruct, ID) == 0x000008, "Member 'FSystemBrainTalkManageStruct::ID' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStruct, DataTablePath) == 0x000010, "Member 'FSystemBrainTalkManageStruct::DataTablePath' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStruct, Comment) == 0x000020, "Member 'FSystemBrainTalkManageStruct::Comment' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStruct, EnableStartProgressIdYuito) == 0x000030, "Member 'FSystemBrainTalkManageStruct::EnableStartProgressIdYuito' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStruct, EnableStartProgressIdKasane) == 0x000034, "Member 'FSystemBrainTalkManageStruct::EnableStartProgressIdKasane' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStruct, Group) == 0x000038, "Member 'FSystemBrainTalkManageStruct::Group' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStruct, Interval) == 0x00003C, "Member 'FSystemBrainTalkManageStruct::Interval' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStruct, NoBattle) == 0x000040, "Member 'FSystemBrainTalkManageStruct::NoBattle' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStruct, NoAjito) == 0x000041, "Member 'FSystemBrainTalkManageStruct::NoAjito' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStruct, NoPlBrainField) == 0x000042, "Member 'FSystemBrainTalkManageStruct::NoPlBrainField' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStruct, NoEmBrainField) == 0x000043, "Member 'FSystemBrainTalkManageStruct::NoEmBrainField' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoObjMoveInfo
// 0x0038 (0x0040 - 0x0008)
struct FAjitoObjMoveInfo final : public FTableRowBase
{
public:
	class FName                                   ActorNameToMove;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             MoveToTransform;                                   // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAjitoObjMoveInfo) == 0x000010, "Wrong alignment on FAjitoObjMoveInfo");
static_assert(sizeof(FAjitoObjMoveInfo) == 0x000040, "Wrong size on FAjitoObjMoveInfo");
static_assert(offsetof(FAjitoObjMoveInfo, ActorNameToMove) == 0x000008, "Member 'FAjitoObjMoveInfo::ActorNameToMove' has a wrong offset!");
static_assert(offsetof(FAjitoObjMoveInfo, MoveToTransform) == 0x000010, "Member 'FAjitoObjMoveInfo::MoveToTransform' has a wrong offset!");

// ScriptStruct BattlePrototype.MACVariableBase
// 0x0020 (0x0020 - 0x0000)
struct FMACVariableBase
{
public:
	class FName                                   MaterialParameterName;                             // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 MaterialSlots;                                     // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollectDefaultValue;                              // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMACVariableBase) == 0x000008, "Wrong alignment on FMACVariableBase");
static_assert(sizeof(FMACVariableBase) == 0x000020, "Wrong size on FMACVariableBase");
static_assert(offsetof(FMACVariableBase, MaterialParameterName) == 0x000000, "Member 'FMACVariableBase::MaterialParameterName' has a wrong offset!");
static_assert(offsetof(FMACVariableBase, MaterialSlots) == 0x000008, "Member 'FMACVariableBase::MaterialSlots' has a wrong offset!");
static_assert(offsetof(FMACVariableBase, bCollectDefaultValue) == 0x000018, "Member 'FMACVariableBase::bCollectDefaultValue' has a wrong offset!");

// ScriptStruct BattlePrototype.MACVariableFloat
// 0x0008 (0x0028 - 0x0020)
struct FMACVariableFloat final : public FMACVariableBase
{
public:
	float                                         Value;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultValue;                                      // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMACVariableFloat) == 0x000008, "Wrong alignment on FMACVariableFloat");
static_assert(sizeof(FMACVariableFloat) == 0x000028, "Wrong size on FMACVariableFloat");
static_assert(offsetof(FMACVariableFloat, Value) == 0x000020, "Member 'FMACVariableFloat::Value' has a wrong offset!");
static_assert(offsetof(FMACVariableFloat, DefaultValue) == 0x000024, "Member 'FMACVariableFloat::DefaultValue' has a wrong offset!");

// ScriptStruct BattlePrototype.UIMain3DCharacterPlayerSetting
// 0x0040 (0x0040 - 0x0000)
struct FUIMain3DCharacterPlayerSetting final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UDataTable*                             EquipCameraTable;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIMain3DCharacterPlayerSetting) == 0x000010, "Wrong alignment on FUIMain3DCharacterPlayerSetting");
static_assert(sizeof(FUIMain3DCharacterPlayerSetting) == 0x000040, "Wrong size on FUIMain3DCharacterPlayerSetting");
static_assert(offsetof(FUIMain3DCharacterPlayerSetting, Transform) == 0x000000, "Member 'FUIMain3DCharacterPlayerSetting::Transform' has a wrong offset!");
static_assert(offsetof(FUIMain3DCharacterPlayerSetting, EquipCameraTable) == 0x000030, "Member 'FUIMain3DCharacterPlayerSetting::EquipCameraTable' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoArrangementMasterInfo
// 0x00B8 (0x00C0 - 0x0008)
struct FAjitoArrangementMasterInfo final : public FTableRowBase
{
public:
	EPlayerID                                     PlayerId;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CharaID;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharaName;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NpcMeshID;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0040(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 ActionID;                                          // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OtherNeedArrangementName;                          // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaceID;                                           // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimationAsset>         AnimToPlay;                                        // 0x0090(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAjitoArrangementMasterInfo) == 0x000010, "Wrong alignment on FAjitoArrangementMasterInfo");
static_assert(sizeof(FAjitoArrangementMasterInfo) == 0x0000C0, "Wrong size on FAjitoArrangementMasterInfo");
static_assert(offsetof(FAjitoArrangementMasterInfo, PlayerId) == 0x000008, "Member 'FAjitoArrangementMasterInfo::PlayerId' has a wrong offset!");
static_assert(offsetof(FAjitoArrangementMasterInfo, CharaID) == 0x000010, "Member 'FAjitoArrangementMasterInfo::CharaID' has a wrong offset!");
static_assert(offsetof(FAjitoArrangementMasterInfo, CharaName) == 0x000020, "Member 'FAjitoArrangementMasterInfo::CharaName' has a wrong offset!");
static_assert(offsetof(FAjitoArrangementMasterInfo, NpcMeshID) == 0x000030, "Member 'FAjitoArrangementMasterInfo::NpcMeshID' has a wrong offset!");
static_assert(offsetof(FAjitoArrangementMasterInfo, Transform) == 0x000040, "Member 'FAjitoArrangementMasterInfo::Transform' has a wrong offset!");
static_assert(offsetof(FAjitoArrangementMasterInfo, ActionID) == 0x000070, "Member 'FAjitoArrangementMasterInfo::ActionID' has a wrong offset!");
static_assert(offsetof(FAjitoArrangementMasterInfo, OtherNeedArrangementName) == 0x000080, "Member 'FAjitoArrangementMasterInfo::OtherNeedArrangementName' has a wrong offset!");
static_assert(offsetof(FAjitoArrangementMasterInfo, PlaceID) == 0x000088, "Member 'FAjitoArrangementMasterInfo::PlaceID' has a wrong offset!");
static_assert(offsetof(FAjitoArrangementMasterInfo, AnimToPlay) == 0x000090, "Member 'FAjitoArrangementMasterInfo::AnimToPlay' has a wrong offset!");

// ScriptStruct BattlePrototype.MapGimmickState
// 0x0040 (0x0048 - 0x0008)
struct FMapGimmickState final : public FTableRowBase
{
public:
	class FName                                   StateName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextStateName;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextStateNameInCancel;                             // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULevelSequence*>                 LevelSequences;                                    // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARSLevelSequenceActor*                  LevelSequenceActor;                                // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNeedTick;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickInterval;                                      // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsChangeNextStateOnAnimationEnd;                   // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapGimmickState) == 0x000008, "Wrong alignment on FMapGimmickState");
static_assert(sizeof(FMapGimmickState) == 0x000048, "Wrong size on FMapGimmickState");
static_assert(offsetof(FMapGimmickState, StateName) == 0x000008, "Member 'FMapGimmickState::StateName' has a wrong offset!");
static_assert(offsetof(FMapGimmickState, NextStateName) == 0x000010, "Member 'FMapGimmickState::NextStateName' has a wrong offset!");
static_assert(offsetof(FMapGimmickState, NextStateNameInCancel) == 0x000018, "Member 'FMapGimmickState::NextStateNameInCancel' has a wrong offset!");
static_assert(offsetof(FMapGimmickState, LevelSequences) == 0x000020, "Member 'FMapGimmickState::LevelSequences' has a wrong offset!");
static_assert(offsetof(FMapGimmickState, LevelSequenceActor) == 0x000030, "Member 'FMapGimmickState::LevelSequenceActor' has a wrong offset!");
static_assert(offsetof(FMapGimmickState, IsNeedTick) == 0x000038, "Member 'FMapGimmickState::IsNeedTick' has a wrong offset!");
static_assert(offsetof(FMapGimmickState, TickInterval) == 0x00003C, "Member 'FMapGimmickState::TickInterval' has a wrong offset!");
static_assert(offsetof(FMapGimmickState, IsChangeNextStateOnAnimationEnd) == 0x000040, "Member 'FMapGimmickState::IsChangeNextStateOnAnimationEnd' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoUniqueIconOffset
// 0x0010 (0x0018 - 0x0008)
struct FAjitoUniqueIconOffset final : public FTableRowBase
{
public:
	class FName                                   ActionKey;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OffsetRowName;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAjitoUniqueIconOffset) == 0x000008, "Wrong alignment on FAjitoUniqueIconOffset");
static_assert(sizeof(FAjitoUniqueIconOffset) == 0x000018, "Wrong size on FAjitoUniqueIconOffset");
static_assert(offsetof(FAjitoUniqueIconOffset, ActionKey) == 0x000008, "Member 'FAjitoUniqueIconOffset::ActionKey' has a wrong offset!");
static_assert(offsetof(FAjitoUniqueIconOffset, OffsetRowName) == 0x000010, "Member 'FAjitoUniqueIconOffset::OffsetRowName' has a wrong offset!");

// ScriptStruct BattlePrototype.DropItemRender
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FDropItemRender final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDropItemRender) == 0x000004, "Wrong alignment on FDropItemRender");
static_assert(sizeof(FDropItemRender) == 0x000004, "Wrong size on FDropItemRender");

// ScriptStruct BattlePrototype.BrainTalkBt_Revival
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_Revival final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     RevivalFrom;                                       // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     RevivalTo;                                         // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KizunaLvMin;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KizunaLvMax;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_Revival) == 0x000008, "Wrong alignment on FBrainTalkBt_Revival");
static_assert(sizeof(FBrainTalkBt_Revival) == 0x000020, "Wrong size on FBrainTalkBt_Revival");
static_assert(offsetof(FBrainTalkBt_Revival, Player) == 0x000008, "Member 'FBrainTalkBt_Revival::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_Revival, RevivalFrom) == 0x000009, "Member 'FBrainTalkBt_Revival::RevivalFrom' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_Revival, RevivalTo) == 0x00000A, "Member 'FBrainTalkBt_Revival::RevivalTo' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_Revival, KizunaLvMin) == 0x00000C, "Member 'FBrainTalkBt_Revival::KizunaLvMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_Revival, KizunaLvMax) == 0x000010, "Member 'FBrainTalkBt_Revival::KizunaLvMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_Revival, Category) == 0x000014, "Member 'FBrainTalkBt_Revival::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_Revival, DatatableId) == 0x000018, "Member 'FBrainTalkBt_Revival::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoMemberAttach
// 0x0060 (0x0060 - 0x0000)
struct FAjitoMemberAttach final
{
public:
	class FName                                   BoneNameToAttach;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachActorName;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RemoveBGActorName;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttachOffset;                                      // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AttachRot;                                         // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimForAttachedActor;                              // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          TalkAnimForAttachedActor;                          // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUserAnimationBP;                                 // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URSAjitoAnimInstance>       AnimClass;                                         // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UASStateMachine*                        StateMachine;                                      // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UASAnimationSet*                        AnimationSet;                                      // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAjitoMemberAttach) == 0x000008, "Wrong alignment on FAjitoMemberAttach");
static_assert(sizeof(FAjitoMemberAttach) == 0x000060, "Wrong size on FAjitoMemberAttach");
static_assert(offsetof(FAjitoMemberAttach, BoneNameToAttach) == 0x000000, "Member 'FAjitoMemberAttach::BoneNameToAttach' has a wrong offset!");
static_assert(offsetof(FAjitoMemberAttach, AttachActorName) == 0x000008, "Member 'FAjitoMemberAttach::AttachActorName' has a wrong offset!");
static_assert(offsetof(FAjitoMemberAttach, RemoveBGActorName) == 0x000010, "Member 'FAjitoMemberAttach::RemoveBGActorName' has a wrong offset!");
static_assert(offsetof(FAjitoMemberAttach, AttachOffset) == 0x000018, "Member 'FAjitoMemberAttach::AttachOffset' has a wrong offset!");
static_assert(offsetof(FAjitoMemberAttach, AttachRot) == 0x000024, "Member 'FAjitoMemberAttach::AttachRot' has a wrong offset!");
static_assert(offsetof(FAjitoMemberAttach, AnimForAttachedActor) == 0x000030, "Member 'FAjitoMemberAttach::AnimForAttachedActor' has a wrong offset!");
static_assert(offsetof(FAjitoMemberAttach, TalkAnimForAttachedActor) == 0x000038, "Member 'FAjitoMemberAttach::TalkAnimForAttachedActor' has a wrong offset!");
static_assert(offsetof(FAjitoMemberAttach, IsUserAnimationBP) == 0x000040, "Member 'FAjitoMemberAttach::IsUserAnimationBP' has a wrong offset!");
static_assert(offsetof(FAjitoMemberAttach, AnimClass) == 0x000048, "Member 'FAjitoMemberAttach::AnimClass' has a wrong offset!");
static_assert(offsetof(FAjitoMemberAttach, StateMachine) == 0x000050, "Member 'FAjitoMemberAttach::StateMachine' has a wrong offset!");
static_assert(offsetof(FAjitoMemberAttach, AnimationSet) == 0x000058, "Member 'FAjitoMemberAttach::AnimationSet' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoMemberAttachInfo
// 0x0018 (0x0020 - 0x0008)
struct FAjitoMemberAttachInfo final : public FTableRowBase
{
public:
	ENpcAnimationKind                             AnimKind;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAjitoMemberAttach>             Attaches;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAjitoMemberAttachInfo) == 0x000008, "Wrong alignment on FAjitoMemberAttachInfo");
static_assert(sizeof(FAjitoMemberAttachInfo) == 0x000020, "Wrong size on FAjitoMemberAttachInfo");
static_assert(offsetof(FAjitoMemberAttachInfo, AnimKind) == 0x000008, "Member 'FAjitoMemberAttachInfo::AnimKind' has a wrong offset!");
static_assert(offsetof(FAjitoMemberAttachInfo, Attaches) == 0x000010, "Member 'FAjitoMemberAttachInfo::Attaches' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoMemberAnimAttachInfo
// 0x0010 (0x0018 - 0x0008)
struct FAjitoMemberAnimAttachInfo final : public FTableRowBase
{
public:
	TArray<struct FAjitoMemberAttachInfo>         AttachInfo;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAjitoMemberAnimAttachInfo) == 0x000008, "Wrong alignment on FAjitoMemberAnimAttachInfo");
static_assert(sizeof(FAjitoMemberAnimAttachInfo) == 0x000018, "Wrong size on FAjitoMemberAnimAttachInfo");
static_assert(offsetof(FAjitoMemberAnimAttachInfo, AttachInfo) == 0x000008, "Member 'FAjitoMemberAnimAttachInfo::AttachInfo' has a wrong offset!");

// ScriptStruct BattlePrototype.CharacterEventInfo
// 0x0010 (0x0010 - 0x0000)
struct FCharacterEventInfo final
{
public:
	TSubclassOf<class AMakeEventActor>            Event;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EventAppendHpRate;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAlreadyEvent;                                    // 0x000C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterEventInfo) == 0x000008, "Wrong alignment on FCharacterEventInfo");
static_assert(sizeof(FCharacterEventInfo) == 0x000010, "Wrong size on FCharacterEventInfo");
static_assert(offsetof(FCharacterEventInfo, Event) == 0x000000, "Member 'FCharacterEventInfo::Event' has a wrong offset!");
static_assert(offsetof(FCharacterEventInfo, EventAppendHpRate) == 0x000008, "Member 'FCharacterEventInfo::EventAppendHpRate' has a wrong offset!");
static_assert(offsetof(FCharacterEventInfo, IsAlreadyEvent) == 0x00000C, "Member 'FCharacterEventInfo::IsAlreadyEvent' has a wrong offset!");

// ScriptStruct BattlePrototype.AmieInterlockingCheckAnswer
// 0x0020 (0x0020 - 0x0000)
struct FAmieInterlockingCheckAnswer final
{
public:
	class FString                                 QuestName;                                         // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Answer;                                            // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAmieInterlockingCheckAnswer) == 0x000008, "Wrong alignment on FAmieInterlockingCheckAnswer");
static_assert(sizeof(FAmieInterlockingCheckAnswer) == 0x000020, "Wrong size on FAmieInterlockingCheckAnswer");
static_assert(offsetof(FAmieInterlockingCheckAnswer, QuestName) == 0x000000, "Member 'FAmieInterlockingCheckAnswer::QuestName' has a wrong offset!");
static_assert(offsetof(FAmieInterlockingCheckAnswer, Answer) == 0x000010, "Member 'FAmieInterlockingCheckAnswer::Answer' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoPlacementInfo
// 0x0028 (0x0030 - 0x0008)
struct FAjitoPlacementInfo final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ActorToHide;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorTagToHide;                                    // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorTagToVisible;                                 // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAjitoPlacementInfo) == 0x000008, "Wrong alignment on FAjitoPlacementInfo");
static_assert(sizeof(FAjitoPlacementInfo) == 0x000030, "Wrong size on FAjitoPlacementInfo");
static_assert(offsetof(FAjitoPlacementInfo, Name) == 0x000008, "Member 'FAjitoPlacementInfo::Name' has a wrong offset!");
static_assert(offsetof(FAjitoPlacementInfo, Actor) == 0x000010, "Member 'FAjitoPlacementInfo::Actor' has a wrong offset!");
static_assert(offsetof(FAjitoPlacementInfo, ActorToHide) == 0x000018, "Member 'FAjitoPlacementInfo::ActorToHide' has a wrong offset!");
static_assert(offsetof(FAjitoPlacementInfo, ActorTagToHide) == 0x000020, "Member 'FAjitoPlacementInfo::ActorTagToHide' has a wrong offset!");
static_assert(offsetof(FAjitoPlacementInfo, ActorTagToVisible) == 0x000028, "Member 'FAjitoPlacementInfo::ActorTagToVisible' has a wrong offset!");

// ScriptStruct BattlePrototype.CharacterDefine
// 0x0001 (0x0001 - 0x0000)
struct FCharacterDefine final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterDefine) == 0x000001, "Wrong alignment on FCharacterDefine");
static_assert(sizeof(FCharacterDefine) == 0x000001, "Wrong size on FCharacterDefine");

// ScriptStruct BattlePrototype.AnimeInterlockingChallengeQuestInfo
// 0x0010 (0x0018 - 0x0008)
struct FAnimeInterlockingChallengeQuestInfo final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimeInterlockingChallengeQuestInfo) == 0x000008, "Wrong alignment on FAnimeInterlockingChallengeQuestInfo");
static_assert(sizeof(FAnimeInterlockingChallengeQuestInfo) == 0x000018, "Wrong size on FAnimeInterlockingChallengeQuestInfo");

// ScriptStruct BattlePrototype.AnimeInterlockingNumRewardSaveParams
// 0x0010 (0x0018 - 0x0008)
struct FAnimeInterlockingNumRewardSaveParams final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimeInterlockingNumRewardSaveParams) == 0x000008, "Wrong alignment on FAnimeInterlockingNumRewardSaveParams");
static_assert(sizeof(FAnimeInterlockingNumRewardSaveParams) == 0x000018, "Wrong size on FAnimeInterlockingNumRewardSaveParams");

// ScriptStruct BattlePrototype.AnimeInterlockingSaveParams
// 0x0010 (0x0018 - 0x0008)
struct FAnimeInterlockingSaveParams final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimeInterlockingSaveParams) == 0x000008, "Wrong alignment on FAnimeInterlockingSaveParams");
static_assert(sizeof(FAnimeInterlockingSaveParams) == 0x000018, "Wrong size on FAnimeInterlockingSaveParams");

// ScriptStruct BattlePrototype.CosmosHugeTSSData
// 0x0018 (0x0018 - 0x0000)
struct FCosmosHugeTSSData final
{
public:
	int32                                         SlotNo;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 URL;                                               // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosHugeTSSData) == 0x000008, "Wrong alignment on FCosmosHugeTSSData");
static_assert(sizeof(FCosmosHugeTSSData) == 0x000018, "Wrong size on FCosmosHugeTSSData");
static_assert(offsetof(FCosmosHugeTSSData, SlotNo) == 0x000000, "Member 'FCosmosHugeTSSData::SlotNo' has a wrong offset!");
static_assert(offsetof(FCosmosHugeTSSData, URL) == 0x000008, "Member 'FCosmosHugeTSSData::URL' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_PTChangeAttachment
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_PTChangeAttachment final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_PTChangeAttachment) == 0x000008, "Wrong alignment on FBrainTalkBt_PTChangeAttachment");
static_assert(sizeof(FBrainTalkBt_PTChangeAttachment) == 0x000018, "Wrong size on FBrainTalkBt_PTChangeAttachment");
static_assert(offsetof(FBrainTalkBt_PTChangeAttachment, TalkMember) == 0x000008, "Member 'FBrainTalkBt_PTChangeAttachment::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_PTChangeAttachment, Category) == 0x000009, "Member 'FBrainTalkBt_PTChangeAttachment::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_PTChangeAttachment, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_PTChangeAttachment::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.AnimeInterlockingRefDataCell
// 0x0020 (0x0028 - 0x0008)
struct FAnimeInterlockingRefDataCell final : public FTableRowBase
{
public:
	class FName                                   AnimeInterlockingName;                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TitleID;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnableProgressID_M;                                // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnableProgressID_F;                                // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimeInterlockingRefDataCell) == 0x000008, "Wrong alignment on FAnimeInterlockingRefDataCell");
static_assert(sizeof(FAnimeInterlockingRefDataCell) == 0x000028, "Wrong size on FAnimeInterlockingRefDataCell");
static_assert(offsetof(FAnimeInterlockingRefDataCell, AnimeInterlockingName) == 0x000008, "Member 'FAnimeInterlockingRefDataCell::AnimeInterlockingName' has a wrong offset!");
static_assert(offsetof(FAnimeInterlockingRefDataCell, TitleID) == 0x000010, "Member 'FAnimeInterlockingRefDataCell::TitleID' has a wrong offset!");
static_assert(offsetof(FAnimeInterlockingRefDataCell, EnableProgressID_M) == 0x000020, "Member 'FAnimeInterlockingRefDataCell::EnableProgressID_M' has a wrong offset!");
static_assert(offsetof(FAnimeInterlockingRefDataCell, EnableProgressID_F) == 0x000024, "Member 'FAnimeInterlockingRefDataCell::EnableProgressID_F' has a wrong offset!");

// ScriptStruct BattlePrototype.AnimeInterlockingsPresentInfo
// 0x0020 (0x0020 - 0x0000)
struct FAnimeInterlockingsPresentInfo final
{
public:
	EAnimeInterlockingsType                       Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ID;                                                // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num;                                               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimeInterlockingsPresentInfo) == 0x000008, "Wrong alignment on FAnimeInterlockingsPresentInfo");
static_assert(sizeof(FAnimeInterlockingsPresentInfo) == 0x000020, "Wrong size on FAnimeInterlockingsPresentInfo");
static_assert(offsetof(FAnimeInterlockingsPresentInfo, Type) == 0x000000, "Member 'FAnimeInterlockingsPresentInfo::Type' has a wrong offset!");
static_assert(offsetof(FAnimeInterlockingsPresentInfo, ID) == 0x000008, "Member 'FAnimeInterlockingsPresentInfo::ID' has a wrong offset!");
static_assert(offsetof(FAnimeInterlockingsPresentInfo, Num) == 0x000018, "Member 'FAnimeInterlockingsPresentInfo::Num' has a wrong offset!");

// ScriptStruct BattlePrototype.AnimeInterlockingsPresentList
// 0x0018 (0x0020 - 0x0008)
struct FAnimeInterlockingsPresentList final : public FTableRowBase
{
public:
	class FName                                   AnimeInterlockingName;                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAnimeInterlockingsPresentInfo> PresentInfos;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimeInterlockingsPresentList) == 0x000008, "Wrong alignment on FAnimeInterlockingsPresentList");
static_assert(sizeof(FAnimeInterlockingsPresentList) == 0x000020, "Wrong size on FAnimeInterlockingsPresentList");
static_assert(offsetof(FAnimeInterlockingsPresentList, AnimeInterlockingName) == 0x000008, "Member 'FAnimeInterlockingsPresentList::AnimeInterlockingName' has a wrong offset!");
static_assert(offsetof(FAnimeInterlockingsPresentList, PresentInfos) == 0x000010, "Member 'FAnimeInterlockingsPresentList::PresentInfos' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosSavedataDownloadResponse
// 0x0018 (0x0018 - 0x0000)
struct FCosmosSavedataDownloadResponse final
{
public:
	int32                                         Status;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SaveData;                                          // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosSavedataDownloadResponse) == 0x000008, "Wrong alignment on FCosmosSavedataDownloadResponse");
static_assert(sizeof(FCosmosSavedataDownloadResponse) == 0x000018, "Wrong size on FCosmosSavedataDownloadResponse");
static_assert(offsetof(FCosmosSavedataDownloadResponse, Status) == 0x000000, "Member 'FCosmosSavedataDownloadResponse::Status' has a wrong offset!");
static_assert(offsetof(FCosmosSavedataDownloadResponse, SaveData) == 0x000008, "Member 'FCosmosSavedataDownloadResponse::SaveData' has a wrong offset!");

// ScriptStruct BattlePrototype.CharactersParameterBasic
// 0x0068 (0x0068 - 0x0000)
struct FCharactersParameterBasic final
{
public:
	TArray<int32>                                 HP;                                                // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHpDownLimitType                              HpDownLimitType;                                   // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HpDownLimitValue;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BrainHackGauge;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WinceAccumulation;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockBackAccumulation;                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownAccumulation;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchAccumulation;                                // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrashAccumulation;                                 // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrashAccumulationOldFrame;                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlameAccumulation;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElectricAccumulation;                              // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloodedAccumulation;                               // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OilAccumulation;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionAccumulation;                             // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Exp;                                               // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFlame;                                           // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsElectric;                                        // 0x004D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFlooded;                                         // 0x004E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOil;                                             // 0x004F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsConfusion;                                       // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlameTimer;                                        // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElectricTimer;                                     // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloodedTimer;                                      // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OilTimer;                                          // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionTimer;                                    // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharactersParameterBasic) == 0x000008, "Wrong alignment on FCharactersParameterBasic");
static_assert(sizeof(FCharactersParameterBasic) == 0x000068, "Wrong size on FCharactersParameterBasic");
static_assert(offsetof(FCharactersParameterBasic, HP) == 0x000000, "Member 'FCharactersParameterBasic::HP' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, HpDownLimitType) == 0x000010, "Member 'FCharactersParameterBasic::HpDownLimitType' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, HpDownLimitValue) == 0x000014, "Member 'FCharactersParameterBasic::HpDownLimitValue' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, BrainHackGauge) == 0x000018, "Member 'FCharactersParameterBasic::BrainHackGauge' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, WinceAccumulation) == 0x00001C, "Member 'FCharactersParameterBasic::WinceAccumulation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, KnockBackAccumulation) == 0x000020, "Member 'FCharactersParameterBasic::KnockBackAccumulation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, DownAccumulation) == 0x000024, "Member 'FCharactersParameterBasic::DownAccumulation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, LaunchAccumulation) == 0x000028, "Member 'FCharactersParameterBasic::LaunchAccumulation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, CrashAccumulation) == 0x00002C, "Member 'FCharactersParameterBasic::CrashAccumulation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, CrashAccumulationOldFrame) == 0x000030, "Member 'FCharactersParameterBasic::CrashAccumulationOldFrame' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, FlameAccumulation) == 0x000034, "Member 'FCharactersParameterBasic::FlameAccumulation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, ElectricAccumulation) == 0x000038, "Member 'FCharactersParameterBasic::ElectricAccumulation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, FloodedAccumulation) == 0x00003C, "Member 'FCharactersParameterBasic::FloodedAccumulation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, OilAccumulation) == 0x000040, "Member 'FCharactersParameterBasic::OilAccumulation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, ConfusionAccumulation) == 0x000044, "Member 'FCharactersParameterBasic::ConfusionAccumulation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, Exp) == 0x000048, "Member 'FCharactersParameterBasic::Exp' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, IsFlame) == 0x00004C, "Member 'FCharactersParameterBasic::IsFlame' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, IsElectric) == 0x00004D, "Member 'FCharactersParameterBasic::IsElectric' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, IsFlooded) == 0x00004E, "Member 'FCharactersParameterBasic::IsFlooded' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, IsOil) == 0x00004F, "Member 'FCharactersParameterBasic::IsOil' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, IsConfusion) == 0x000050, "Member 'FCharactersParameterBasic::IsConfusion' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, FlameTimer) == 0x000054, "Member 'FCharactersParameterBasic::FlameTimer' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, ElectricTimer) == 0x000058, "Member 'FCharactersParameterBasic::ElectricTimer' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, FloodedTimer) == 0x00005C, "Member 'FCharactersParameterBasic::FloodedTimer' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, OilTimer) == 0x000060, "Member 'FCharactersParameterBasic::OilTimer' has a wrong offset!");
static_assert(offsetof(FCharactersParameterBasic, ConfusionTimer) == 0x000064, "Member 'FCharactersParameterBasic::ConfusionTimer' has a wrong offset!");

// ScriptStruct BattlePrototype.CharacterInfo
// 0x0080 (0x0080 - 0x0000)
struct FCharacterInfo final
{
public:
	int32                                         CharacterId;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharactersParameterBasic              Param;                                             // 0x0010(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         StrategyID;                                        // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KizunaValue;                                       // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterInfo) == 0x000008, "Wrong alignment on FCharacterInfo");
static_assert(sizeof(FCharacterInfo) == 0x000080, "Wrong size on FCharacterInfo");
static_assert(offsetof(FCharacterInfo, CharacterId) == 0x000000, "Member 'FCharacterInfo::CharacterId' has a wrong offset!");
static_assert(offsetof(FCharacterInfo, Actor) == 0x000008, "Member 'FCharacterInfo::Actor' has a wrong offset!");
static_assert(offsetof(FCharacterInfo, Param) == 0x000010, "Member 'FCharacterInfo::Param' has a wrong offset!");
static_assert(offsetof(FCharacterInfo, StrategyID) == 0x000078, "Member 'FCharacterInfo::StrategyID' has a wrong offset!");
static_assert(offsetof(FCharacterInfo, KizunaValue) == 0x00007C, "Member 'FCharacterInfo::KizunaValue' has a wrong offset!");

// ScriptStruct BattlePrototype.AnimNotifyRadialBlurColorModulate
// 0x0010 (0x0018 - 0x0008)
struct FAnimNotifyRadialBlurColorModulate final : public FTableRowBase
{
public:
	struct FLinearColor                           ColorModluate;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNotifyRadialBlurColorModulate) == 0x000008, "Wrong alignment on FAnimNotifyRadialBlurColorModulate");
static_assert(sizeof(FAnimNotifyRadialBlurColorModulate) == 0x000018, "Wrong size on FAnimNotifyRadialBlurColorModulate");
static_assert(offsetof(FAnimNotifyRadialBlurColorModulate, ColorModluate) == 0x000008, "Member 'FAnimNotifyRadialBlurColorModulate::ColorModluate' has a wrong offset!");

// ScriptStruct BattlePrototype.ArrangeItemList
// 0x0008 (0x0010 - 0x0008)
struct FArrangeItemList final : public FTableRowBase
{
public:
	class FName                                   ArrangePointId;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArrangeItemList) == 0x000008, "Wrong alignment on FArrangeItemList");
static_assert(sizeof(FArrangeItemList) == 0x000010, "Wrong size on FArrangeItemList");
static_assert(offsetof(FArrangeItemList, ArrangePointId) == 0x000008, "Member 'FArrangeItemList::ArrangePointId' has a wrong offset!");

// ScriptStruct BattlePrototype.MapArrangeItemNode
// 0x0034 (0x0034 - 0x0000)
struct FMapArrangeItemNode final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ArrangePointId;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocationName                                 LocationId;                                        // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAreaName                                     AreaId;                                            // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Translation;                                       // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapIconType                                  Map_Icon_Type;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RandomArrangeItemID;                               // 0x002C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapArrangeItemNode) == 0x000004, "Wrong alignment on FMapArrangeItemNode");
static_assert(sizeof(FMapArrangeItemNode) == 0x000034, "Wrong size on FMapArrangeItemNode");
static_assert(offsetof(FMapArrangeItemNode, Name) == 0x000000, "Member 'FMapArrangeItemNode::Name' has a wrong offset!");
static_assert(offsetof(FMapArrangeItemNode, ActorName) == 0x000008, "Member 'FMapArrangeItemNode::ActorName' has a wrong offset!");
static_assert(offsetof(FMapArrangeItemNode, ArrangePointId) == 0x000010, "Member 'FMapArrangeItemNode::ArrangePointId' has a wrong offset!");
static_assert(offsetof(FMapArrangeItemNode, LocationId) == 0x000018, "Member 'FMapArrangeItemNode::LocationId' has a wrong offset!");
static_assert(offsetof(FMapArrangeItemNode, AreaId) == 0x000019, "Member 'FMapArrangeItemNode::AreaId' has a wrong offset!");
static_assert(offsetof(FMapArrangeItemNode, Translation) == 0x00001C, "Member 'FMapArrangeItemNode::Translation' has a wrong offset!");
static_assert(offsetof(FMapArrangeItemNode, Map_Icon_Type) == 0x000028, "Member 'FMapArrangeItemNode::Map_Icon_Type' has a wrong offset!");
static_assert(offsetof(FMapArrangeItemNode, RandomArrangeItemID) == 0x00002C, "Member 'FMapArrangeItemNode::RandomArrangeItemID' has a wrong offset!");

// ScriptStruct BattlePrototype.MapArrangeItemInfo
// 0x0028 (0x0030 - 0x0008)
struct FMapArrangeItemInfo final : public FTableRowBase
{
public:
	class FName                                   LocationName;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaName;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LocationNo;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaNo;                                            // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMapArrangeItemNode>            NodeList;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapArrangeItemInfo) == 0x000008, "Wrong alignment on FMapArrangeItemInfo");
static_assert(sizeof(FMapArrangeItemInfo) == 0x000030, "Wrong size on FMapArrangeItemInfo");
static_assert(offsetof(FMapArrangeItemInfo, LocationName) == 0x000008, "Member 'FMapArrangeItemInfo::LocationName' has a wrong offset!");
static_assert(offsetof(FMapArrangeItemInfo, AreaName) == 0x000010, "Member 'FMapArrangeItemInfo::AreaName' has a wrong offset!");
static_assert(offsetof(FMapArrangeItemInfo, LocationNo) == 0x000018, "Member 'FMapArrangeItemInfo::LocationNo' has a wrong offset!");
static_assert(offsetof(FMapArrangeItemInfo, AreaNo) == 0x00001C, "Member 'FMapArrangeItemInfo::AreaNo' has a wrong offset!");
static_assert(offsetof(FMapArrangeItemInfo, NodeList) == 0x000020, "Member 'FMapArrangeItemInfo::NodeList' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosSealInfo
// 0x0018 (0x0018 - 0x0000)
struct FCosmosSealInfo final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        Decal;                                             // 0x0010(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosSealInfo) == 0x000008, "Wrong alignment on FCosmosSealInfo");
static_assert(sizeof(FCosmosSealInfo) == 0x000018, "Wrong size on FCosmosSealInfo");
static_assert(offsetof(FCosmosSealInfo, UserId) == 0x000000, "Member 'FCosmosSealInfo::UserId' has a wrong offset!");
static_assert(offsetof(FCosmosSealInfo, Decal) == 0x000010, "Member 'FCosmosSealInfo::Decal' has a wrong offset!");

// ScriptStruct BattlePrototype.UIEnemyInfo
// 0x0028 (0x0028 - 0x0000)
struct FUIEnemyInfo final
{
public:
	class UUIVitalityEN02*                        HpGauge;                                           // 0x0000(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARSCharacterBase*                       Enemy;                                             // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentHp;                                         // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseHp;                                            // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timer;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Position;                                          // 0x001C(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIEnemyInfo) == 0x000008, "Wrong alignment on FUIEnemyInfo");
static_assert(sizeof(FUIEnemyInfo) == 0x000028, "Wrong size on FUIEnemyInfo");
static_assert(offsetof(FUIEnemyInfo, HpGauge) == 0x000000, "Member 'FUIEnemyInfo::HpGauge' has a wrong offset!");
static_assert(offsetof(FUIEnemyInfo, Enemy) == 0x000008, "Member 'FUIEnemyInfo::Enemy' has a wrong offset!");
static_assert(offsetof(FUIEnemyInfo, CurrentHp) == 0x000010, "Member 'FUIEnemyInfo::CurrentHp' has a wrong offset!");
static_assert(offsetof(FUIEnemyInfo, BaseHp) == 0x000014, "Member 'FUIEnemyInfo::BaseHp' has a wrong offset!");
static_assert(offsetof(FUIEnemyInfo, Timer) == 0x000018, "Member 'FUIEnemyInfo::Timer' has a wrong offset!");
static_assert(offsetof(FUIEnemyInfo, Position) == 0x00001C, "Member 'FUIEnemyInfo::Position' has a wrong offset!");

// ScriptStruct BattlePrototype.UIBrainTargetInfo
// 0x0018 (0x0018 - 0x0000)
struct FUIBrainTargetInfo final
{
public:
	class UUITargetBrain*                         Widget;                                            // 0x0000(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARSCharacterBase*                       Target;                                            // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDraw;                                            // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsClose;                                           // 0x0011(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIBrainTargetInfo) == 0x000008, "Wrong alignment on FUIBrainTargetInfo");
static_assert(sizeof(FUIBrainTargetInfo) == 0x000018, "Wrong size on FUIBrainTargetInfo");
static_assert(offsetof(FUIBrainTargetInfo, Widget) == 0x000000, "Member 'FUIBrainTargetInfo::Widget' has a wrong offset!");
static_assert(offsetof(FUIBrainTargetInfo, Target) == 0x000008, "Member 'FUIBrainTargetInfo::Target' has a wrong offset!");
static_assert(offsetof(FUIBrainTargetInfo, IsDraw) == 0x000010, "Member 'FUIBrainTargetInfo::IsDraw' has a wrong offset!");
static_assert(offsetof(FUIBrainTargetInfo, IsClose) == 0x000011, "Member 'FUIBrainTargetInfo::IsClose' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalk_CategoryDatatable
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalk_CategoryDatatable final : public FTableRowBase
{
public:
	EBrainTalkCategory                            Category;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalk_CategoryDatatable) == 0x000008, "Wrong alignment on FBrainTalk_CategoryDatatable");
static_assert(sizeof(FBrainTalk_CategoryDatatable) == 0x000018, "Wrong size on FBrainTalk_CategoryDatatable");
static_assert(offsetof(FBrainTalk_CategoryDatatable, Category) == 0x000008, "Member 'FBrainTalk_CategoryDatatable::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalk_CategoryDatatable, DatatableId) == 0x00000C, "Member 'FBrainTalk_CategoryDatatable::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.HitActorInfo
// 0x0010 (0x0010 - 0x0000)
struct FHitActorInfo final
{
public:
	class AActor*                                 HitOtherActor;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitTime;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitActorInfo) == 0x000008, "Wrong alignment on FHitActorInfo");
static_assert(sizeof(FHitActorInfo) == 0x000010, "Wrong size on FHitActorInfo");
static_assert(offsetof(FHitActorInfo, HitOtherActor) == 0x000000, "Member 'FHitActorInfo::HitOtherActor' has a wrong offset!");
static_assert(offsetof(FHitActorInfo, HitTime) == 0x000008, "Member 'FHitActorInfo::HitTime' has a wrong offset!");

// ScriptStruct BattlePrototype.ArrayOfMID
// 0x0010 (0x0010 - 0x0000)
struct FArrayOfMID final
{
public:
	TArray<class UMaterialInstanceDynamic*>       Value;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArrayOfMID) == 0x000008, "Wrong alignment on FArrayOfMID");
static_assert(sizeof(FArrayOfMID) == 0x000010, "Wrong size on FArrayOfMID");
static_assert(offsetof(FArrayOfMID, Value) == 0x000000, "Member 'FArrayOfMID::Value' has a wrong offset!");

// ScriptStruct BattlePrototype.BoolVector
// 0x0003 (0x0003 - 0x0000)
struct FBoolVector final
{
public:
	bool                                          X;                                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Y;                                                 // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Z;                                                 // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoolVector) == 0x000001, "Wrong alignment on FBoolVector");
static_assert(sizeof(FBoolVector) == 0x000003, "Wrong size on FBoolVector");
static_assert(offsetof(FBoolVector, X) == 0x000000, "Member 'FBoolVector::X' has a wrong offset!");
static_assert(offsetof(FBoolVector, Y) == 0x000001, "Member 'FBoolVector::Y' has a wrong offset!");
static_assert(offsetof(FBoolVector, Z) == 0x000002, "Member 'FBoolVector::Z' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_KillEnRest
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_KillEnRest final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_KillEnRest) == 0x000008, "Wrong alignment on FBrainTalkBt_KillEnRest");
static_assert(sizeof(FBrainTalkBt_KillEnRest) == 0x000018, "Wrong size on FBrainTalkBt_KillEnRest");
static_assert(offsetof(FBrainTalkBt_KillEnRest, TalkMember) == 0x000008, "Member 'FBrainTalkBt_KillEnRest::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillEnRest, Category) == 0x000009, "Member 'FBrainTalkBt_KillEnRest::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillEnRest, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_KillEnRest::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BoolVector2
// 0x0002 (0x0002 - 0x0000)
struct FBoolVector2 final
{
public:
	bool                                          X;                                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Y;                                                 // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoolVector2) == 0x000001, "Wrong alignment on FBoolVector2");
static_assert(sizeof(FBoolVector2) == 0x000002, "Wrong size on FBoolVector2");
static_assert(offsetof(FBoolVector2, X) == 0x000000, "Member 'FBoolVector2::X' has a wrong offset!");
static_assert(offsetof(FBoolVector2, Y) == 0x000001, "Member 'FBoolVector2::Y' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosSavedataDeleteResponse
// 0x0004 (0x0004 - 0x0000)
struct FCosmosSavedataDeleteResponse final
{
public:
	int32                                         Status;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosSavedataDeleteResponse) == 0x000004, "Wrong alignment on FCosmosSavedataDeleteResponse");
static_assert(sizeof(FCosmosSavedataDeleteResponse) == 0x000004, "Wrong size on FCosmosSavedataDeleteResponse");
static_assert(offsetof(FCosmosSavedataDeleteResponse, Status) == 0x000000, "Member 'FCosmosSavedataDeleteResponse::Status' has a wrong offset!");

// ScriptStruct BattlePrototype.ArrayOfLinearColor
// 0x0010 (0x0010 - 0x0000)
struct FArrayOfLinearColor final
{
public:
	TArray<struct FLinearColor>                   Value;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArrayOfLinearColor) == 0x000008, "Wrong alignment on FArrayOfLinearColor");
static_assert(sizeof(FArrayOfLinearColor) == 0x000010, "Wrong size on FArrayOfLinearColor");
static_assert(offsetof(FArrayOfLinearColor, Value) == 0x000000, "Member 'FArrayOfLinearColor::Value' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryInfo
// 0x0030 (0x0030 - 0x0000)
struct FLibraryInfo final
{
public:
	TArray<uint8>                                 EpisodeList;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 TerminologyList;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 EnemyList;                                         // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryInfo) == 0x000008, "Wrong alignment on FLibraryInfo");
static_assert(sizeof(FLibraryInfo) == 0x000030, "Wrong size on FLibraryInfo");
static_assert(offsetof(FLibraryInfo, EpisodeList) == 0x000000, "Member 'FLibraryInfo::EpisodeList' has a wrong offset!");
static_assert(offsetof(FLibraryInfo, TerminologyList) == 0x000010, "Member 'FLibraryInfo::TerminologyList' has a wrong offset!");
static_assert(offsetof(FLibraryInfo, EnemyList) == 0x000020, "Member 'FLibraryInfo::EnemyList' has a wrong offset!");

// ScriptStruct BattlePrototype.ArrayOfVector
// 0x0010 (0x0010 - 0x0000)
struct FArrayOfVector final
{
public:
	TArray<struct FVector>                        Value;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArrayOfVector) == 0x000008, "Wrong alignment on FArrayOfVector");
static_assert(sizeof(FArrayOfVector) == 0x000010, "Wrong size on FArrayOfVector");
static_assert(offsetof(FArrayOfVector, Value) == 0x000000, "Member 'FArrayOfVector::Value' has a wrong offset!");

// ScriptStruct BattlePrototype.ArrayOfBool
// 0x0010 (0x0010 - 0x0000)
struct FArrayOfBool final
{
public:
	TArray<bool>                                  Value;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArrayOfBool) == 0x000008, "Wrong alignment on FArrayOfBool");
static_assert(sizeof(FArrayOfBool) == 0x000010, "Wrong size on FArrayOfBool");
static_assert(offsetof(FArrayOfBool, Value) == 0x000000, "Member 'FArrayOfBool::Value' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_NoSallyTimes
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_NoSallyTimes final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NoSallyMinutes;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_NoSallyTimes) == 0x000008, "Wrong alignment on FBrainTalkBt_NoSallyTimes");
static_assert(sizeof(FBrainTalkBt_NoSallyTimes) == 0x000020, "Wrong size on FBrainTalkBt_NoSallyTimes");
static_assert(offsetof(FBrainTalkBt_NoSallyTimes, TalkMember) == 0x000008, "Member 'FBrainTalkBt_NoSallyTimes::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_NoSallyTimes, NoSallyMinutes) == 0x00000C, "Member 'FBrainTalkBt_NoSallyTimes::NoSallyMinutes' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_NoSallyTimes, Category) == 0x000010, "Member 'FBrainTalkBt_NoSallyTimes::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_NoSallyTimes, DatatableId) == 0x000014, "Member 'FBrainTalkBt_NoSallyTimes::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.ArrayOfInt
// 0x0010 (0x0010 - 0x0000)
struct FArrayOfInt final
{
public:
	TArray<int32>                                 Value;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArrayOfInt) == 0x000008, "Wrong alignment on FArrayOfInt");
static_assert(sizeof(FArrayOfInt) == 0x000010, "Wrong size on FArrayOfInt");
static_assert(offsetof(FArrayOfInt, Value) == 0x000000, "Member 'FArrayOfInt::Value' has a wrong offset!");

// ScriptStruct BattlePrototype.CharacterMaterialLightSettingVectorData
// 0x0018 (0x0018 - 0x0000)
struct FCharacterMaterialLightSettingVectorData final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Parameter;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterMaterialLightSettingVectorData) == 0x000004, "Wrong alignment on FCharacterMaterialLightSettingVectorData");
static_assert(sizeof(FCharacterMaterialLightSettingVectorData) == 0x000018, "Wrong size on FCharacterMaterialLightSettingVectorData");
static_assert(offsetof(FCharacterMaterialLightSettingVectorData, ParameterName) == 0x000000, "Member 'FCharacterMaterialLightSettingVectorData::ParameterName' has a wrong offset!");
static_assert(offsetof(FCharacterMaterialLightSettingVectorData, Parameter) == 0x000008, "Member 'FCharacterMaterialLightSettingVectorData::Parameter' has a wrong offset!");

// ScriptStruct BattlePrototype.ArrayOfFloat
// 0x0010 (0x0010 - 0x0000)
struct FArrayOfFloat final
{
public:
	TArray<float>                                 Value;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArrayOfFloat) == 0x000008, "Wrong alignment on FArrayOfFloat");
static_assert(sizeof(FArrayOfFloat) == 0x000010, "Wrong size on FArrayOfFloat");
static_assert(offsetof(FArrayOfFloat, Value) == 0x000000, "Member 'FArrayOfFloat::Value' has a wrong offset!");

// ScriptStruct BattlePrototype.BattlefieldTutorialInfo
// 0x0010 (0x0010 - 0x0000)
struct FBattlefieldTutorialInfo final
{
public:
	TSubclassOf<class AMakeEventActor>            MakeEventActorClass;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupID;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubGroupID;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattlefieldTutorialInfo) == 0x000008, "Wrong alignment on FBattlefieldTutorialInfo");
static_assert(sizeof(FBattlefieldTutorialInfo) == 0x000010, "Wrong size on FBattlefieldTutorialInfo");
static_assert(offsetof(FBattlefieldTutorialInfo, MakeEventActorClass) == 0x000000, "Member 'FBattlefieldTutorialInfo::MakeEventActorClass' has a wrong offset!");
static_assert(offsetof(FBattlefieldTutorialInfo, GroupID) == 0x000008, "Member 'FBattlefieldTutorialInfo::GroupID' has a wrong offset!");
static_assert(offsetof(FBattlefieldTutorialInfo, SubGroupID) == 0x00000C, "Member 'FBattlefieldTutorialInfo::SubGroupID' has a wrong offset!");

// ScriptStruct BattlePrototype.BattlefieldInfo
// 0x0088 (0x0088 - 0x0000)
struct FBattlefieldInfo final
{
public:
	EBattlefieldEventType                         EventType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BFGroupID;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurSubGroupID;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KeepEnemyNumAll;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KeepEnemyNum;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattlefieldStat                              Status;                                            // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         FenceActors;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AMakeEventActor>            MakeEventActorClass;                               // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MakeEventActorClassPath;                           // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TutorialGroupID;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TutorialSubGroupID;                                // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBattlefieldTutorialInfo>       AdditonalTutorialInfo;                             // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseFence;                                        // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TriggerActorName;                                  // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LocationId;                                        // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaId;                                            // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HaveDestroyed;                                     // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RepopRate;                                         // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattlefieldInfo) == 0x000008, "Wrong alignment on FBattlefieldInfo");
static_assert(sizeof(FBattlefieldInfo) == 0x000088, "Wrong size on FBattlefieldInfo");
static_assert(offsetof(FBattlefieldInfo, EventType) == 0x000000, "Member 'FBattlefieldInfo::EventType' has a wrong offset!");
static_assert(offsetof(FBattlefieldInfo, BFGroupID) == 0x000004, "Member 'FBattlefieldInfo::BFGroupID' has a wrong offset!");
static_assert(offsetof(FBattlefieldInfo, CurSubGroupID) == 0x000008, "Member 'FBattlefieldInfo::CurSubGroupID' has a wrong offset!");
static_assert(offsetof(FBattlefieldInfo, KeepEnemyNumAll) == 0x00000C, "Member 'FBattlefieldInfo::KeepEnemyNumAll' has a wrong offset!");
static_assert(offsetof(FBattlefieldInfo, KeepEnemyNum) == 0x000010, "Member 'FBattlefieldInfo::KeepEnemyNum' has a wrong offset!");
static_assert(offsetof(FBattlefieldInfo, Status) == 0x000014, "Member 'FBattlefieldInfo::Status' has a wrong offset!");
static_assert(offsetof(FBattlefieldInfo, FenceActors) == 0x000018, "Member 'FBattlefieldInfo::FenceActors' has a wrong offset!");
static_assert(offsetof(FBattlefieldInfo, MakeEventActorClass) == 0x000030, "Member 'FBattlefieldInfo::MakeEventActorClass' has a wrong offset!");
static_assert(offsetof(FBattlefieldInfo, MakeEventActorClassPath) == 0x000038, "Member 'FBattlefieldInfo::MakeEventActorClassPath' has a wrong offset!");
static_assert(offsetof(FBattlefieldInfo, TutorialGroupID) == 0x000048, "Member 'FBattlefieldInfo::TutorialGroupID' has a wrong offset!");
static_assert(offsetof(FBattlefieldInfo, TutorialSubGroupID) == 0x00004C, "Member 'FBattlefieldInfo::TutorialSubGroupID' has a wrong offset!");
static_assert(offsetof(FBattlefieldInfo, AdditonalTutorialInfo) == 0x000050, "Member 'FBattlefieldInfo::AdditonalTutorialInfo' has a wrong offset!");
static_assert(offsetof(FBattlefieldInfo, IsUseFence) == 0x000060, "Member 'FBattlefieldInfo::IsUseFence' has a wrong offset!");
static_assert(offsetof(FBattlefieldInfo, TriggerActorName) == 0x000068, "Member 'FBattlefieldInfo::TriggerActorName' has a wrong offset!");
static_assert(offsetof(FBattlefieldInfo, LocationId) == 0x000078, "Member 'FBattlefieldInfo::LocationId' has a wrong offset!");
static_assert(offsetof(FBattlefieldInfo, AreaId) == 0x00007C, "Member 'FBattlefieldInfo::AreaId' has a wrong offset!");
static_assert(offsetof(FBattlefieldInfo, HaveDestroyed) == 0x000080, "Member 'FBattlefieldInfo::HaveDestroyed' has a wrong offset!");
static_assert(offsetof(FBattlefieldInfo, RepopRate) == 0x000084, "Member 'FBattlefieldInfo::RepopRate' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_DamageTakeOver
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_DamageTakeOver final : public FTableRowBase
{
public:
	EPlayerID                                     Member1;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     Member2;                                           // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_DamageTakeOver) == 0x000008, "Wrong alignment on FBrainTalkBt_DamageTakeOver");
static_assert(sizeof(FBrainTalkBt_DamageTakeOver) == 0x000018, "Wrong size on FBrainTalkBt_DamageTakeOver");
static_assert(offsetof(FBrainTalkBt_DamageTakeOver, Member1) == 0x000008, "Member 'FBrainTalkBt_DamageTakeOver::Member1' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DamageTakeOver, Member2) == 0x000009, "Member 'FBrainTalkBt_DamageTakeOver::Member2' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DamageTakeOver, Category) == 0x00000A, "Member 'FBrainTalkBt_DamageTakeOver::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DamageTakeOver, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_DamageTakeOver::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.EnemyHpDownEventInfo
// 0x0018 (0x0018 - 0x0000)
struct FEnemyHpDownEventInfo final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HP;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleEventType                              EventType;                                         // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GroupID;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubGroupID;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyHpDownEventInfo) == 0x000004, "Wrong alignment on FEnemyHpDownEventInfo");
static_assert(sizeof(FEnemyHpDownEventInfo) == 0x000018, "Wrong size on FEnemyHpDownEventInfo");
static_assert(offsetof(FEnemyHpDownEventInfo, Tag) == 0x000000, "Member 'FEnemyHpDownEventInfo::Tag' has a wrong offset!");
static_assert(offsetof(FEnemyHpDownEventInfo, HP) == 0x000008, "Member 'FEnemyHpDownEventInfo::HP' has a wrong offset!");
static_assert(offsetof(FEnemyHpDownEventInfo, EventType) == 0x00000C, "Member 'FEnemyHpDownEventInfo::EventType' has a wrong offset!");
static_assert(offsetof(FEnemyHpDownEventInfo, GroupID) == 0x000010, "Member 'FEnemyHpDownEventInfo::GroupID' has a wrong offset!");
static_assert(offsetof(FEnemyHpDownEventInfo, SubGroupID) == 0x000014, "Member 'FEnemyHpDownEventInfo::SubGroupID' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosRankingUserData
// 0x0018 (0x0018 - 0x0000)
struct FCosmosRankingUserData final
{
public:
	struct FVector                                Pos;                                               // 0x0000(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotate;                                            // 0x000C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosRankingUserData) == 0x000004, "Wrong alignment on FCosmosRankingUserData");
static_assert(sizeof(FCosmosRankingUserData) == 0x000018, "Wrong size on FCosmosRankingUserData");
static_assert(offsetof(FCosmosRankingUserData, Pos) == 0x000000, "Member 'FCosmosRankingUserData::Pos' has a wrong offset!");
static_assert(offsetof(FCosmosRankingUserData, Rotate) == 0x00000C, "Member 'FCosmosRankingUserData::Rotate' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosRankingList
// 0x0048 (0x0048 - 0x0000)
struct FCosmosRankingList final
{
public:
	int32                                         UniqueRank;                                        // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SameRank;                                          // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserId;                                            // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Score;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UserData;                                          // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCosmosRankingUserData                 UserDataValue;                                     // 0x0030(0x0018)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosRankingList) == 0x000008, "Wrong alignment on FCosmosRankingList");
static_assert(sizeof(FCosmosRankingList) == 0x000048, "Wrong size on FCosmosRankingList");
static_assert(offsetof(FCosmosRankingList, UniqueRank) == 0x000000, "Member 'FCosmosRankingList::UniqueRank' has a wrong offset!");
static_assert(offsetof(FCosmosRankingList, SameRank) == 0x000004, "Member 'FCosmosRankingList::SameRank' has a wrong offset!");
static_assert(offsetof(FCosmosRankingList, UserId) == 0x000008, "Member 'FCosmosRankingList::UserId' has a wrong offset!");
static_assert(offsetof(FCosmosRankingList, Score) == 0x000018, "Member 'FCosmosRankingList::Score' has a wrong offset!");
static_assert(offsetof(FCosmosRankingList, UserData) == 0x000020, "Member 'FCosmosRankingList::UserData' has a wrong offset!");
static_assert(offsetof(FCosmosRankingList, UserDataValue) == 0x000030, "Member 'FCosmosRankingList::UserDataValue' has a wrong offset!");

// ScriptStruct BattlePrototype.BattleLogParam
// 0x0028 (0x0028 - 0x0000)
struct FBattleLogParam final
{
public:
	int32                                         AddExpValue;                                       // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddMoneyValue;                                     // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DropItemId;                                        // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemNum;                                       // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0014(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CharacterId;                                       // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterLV;                                       // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDispKillName;                                    // 0x0024(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleLogParam) == 0x000004, "Wrong alignment on FBattleLogParam");
static_assert(sizeof(FBattleLogParam) == 0x000028, "Wrong size on FBattleLogParam");
static_assert(offsetof(FBattleLogParam, AddExpValue) == 0x000000, "Member 'FBattleLogParam::AddExpValue' has a wrong offset!");
static_assert(offsetof(FBattleLogParam, AddMoneyValue) == 0x000004, "Member 'FBattleLogParam::AddMoneyValue' has a wrong offset!");
static_assert(offsetof(FBattleLogParam, DropItemId) == 0x000008, "Member 'FBattleLogParam::DropItemId' has a wrong offset!");
static_assert(offsetof(FBattleLogParam, DropItemNum) == 0x000010, "Member 'FBattleLogParam::DropItemNum' has a wrong offset!");
static_assert(offsetof(FBattleLogParam, Rarity) == 0x000014, "Member 'FBattleLogParam::Rarity' has a wrong offset!");
static_assert(offsetof(FBattleLogParam, CharacterId) == 0x000018, "Member 'FBattleLogParam::CharacterId' has a wrong offset!");
static_assert(offsetof(FBattleLogParam, CharacterLV) == 0x000020, "Member 'FBattleLogParam::CharacterLV' has a wrong offset!");
static_assert(offsetof(FBattleLogParam, IsDispKillName) == 0x000024, "Member 'FBattleLogParam::IsDispKillName' has a wrong offset!");

// ScriptStruct BattlePrototype.ActorBattleEndLogData
// 0x0002 (0x0002 - 0x0000)
struct FActorBattleEndLogData final
{
public:
	EReasonBattleEnd                              Reason;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStrongCharacter;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorBattleEndLogData) == 0x000001, "Wrong alignment on FActorBattleEndLogData");
static_assert(sizeof(FActorBattleEndLogData) == 0x000002, "Wrong size on FActorBattleEndLogData");
static_assert(offsetof(FActorBattleEndLogData, Reason) == 0x000000, "Member 'FActorBattleEndLogData::Reason' has a wrong offset!");
static_assert(offsetof(FActorBattleEndLogData, bStrongCharacter) == 0x000001, "Member 'FActorBattleEndLogData::bStrongCharacter' has a wrong offset!");

// ScriptStruct BattlePrototype.ActionParameter
// 0x0001 (0x0001 - 0x0000)
struct FActionParameter final
{
public:
	EBattleSituationActionType                    ActionType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActionParameter) == 0x000001, "Wrong alignment on FActionParameter");
static_assert(sizeof(FActionParameter) == 0x000001, "Wrong size on FActionParameter");
static_assert(offsetof(FActionParameter, ActionType) == 0x000000, "Member 'FActionParameter::ActionType' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_TouchBFWall
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_TouchBFWall final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWataruHaruka;                                    // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_TouchBFWall) == 0x000008, "Wrong alignment on FBrainTalkBt_TouchBFWall");
static_assert(sizeof(FBrainTalkBt_TouchBFWall) == 0x000018, "Wrong size on FBrainTalkBt_TouchBFWall");
static_assert(offsetof(FBrainTalkBt_TouchBFWall, Player) == 0x000008, "Member 'FBrainTalkBt_TouchBFWall::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_TouchBFWall, IsWataruHaruka) == 0x000009, "Member 'FBrainTalkBt_TouchBFWall::IsWataruHaruka' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_TouchBFWall, Category) == 0x00000A, "Member 'FBrainTalkBt_TouchBFWall::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_TouchBFWall, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_TouchBFWall::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainCrashSequenceSettingsData
// 0x0048 (0x0048 - 0x0000)
struct FBrainCrashSequenceSettingsData final
{
public:
	int32                                         EnemyRotationIndex;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterLocation;                                    // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxSize;                                           // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlayerStartLocation;                               // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlayerEndLocation;                                 // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EnemyStartLocation;                                // 0x003C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainCrashSequenceSettingsData) == 0x000004, "Wrong alignment on FBrainCrashSequenceSettingsData");
static_assert(sizeof(FBrainCrashSequenceSettingsData) == 0x000048, "Wrong size on FBrainCrashSequenceSettingsData");
static_assert(offsetof(FBrainCrashSequenceSettingsData, EnemyRotationIndex) == 0x000000, "Member 'FBrainCrashSequenceSettingsData::EnemyRotationIndex' has a wrong offset!");
static_assert(offsetof(FBrainCrashSequenceSettingsData, CenterLocation) == 0x000004, "Member 'FBrainCrashSequenceSettingsData::CenterLocation' has a wrong offset!");
static_assert(offsetof(FBrainCrashSequenceSettingsData, Radius) == 0x000010, "Member 'FBrainCrashSequenceSettingsData::Radius' has a wrong offset!");
static_assert(offsetof(FBrainCrashSequenceSettingsData, Height) == 0x000014, "Member 'FBrainCrashSequenceSettingsData::Height' has a wrong offset!");
static_assert(offsetof(FBrainCrashSequenceSettingsData, BoxSize) == 0x000018, "Member 'FBrainCrashSequenceSettingsData::BoxSize' has a wrong offset!");
static_assert(offsetof(FBrainCrashSequenceSettingsData, PlayerStartLocation) == 0x000024, "Member 'FBrainCrashSequenceSettingsData::PlayerStartLocation' has a wrong offset!");
static_assert(offsetof(FBrainCrashSequenceSettingsData, PlayerEndLocation) == 0x000030, "Member 'FBrainCrashSequenceSettingsData::PlayerEndLocation' has a wrong offset!");
static_assert(offsetof(FBrainCrashSequenceSettingsData, EnemyStartLocation) == 0x00003C, "Member 'FBrainCrashSequenceSettingsData::EnemyStartLocation' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainCrashSequenceSettings
// 0x0048 (0x0050 - 0x0008)
struct FBrainCrashSequenceSettings final : public FTableRowBase
{
public:
	struct FBrainCrashSequenceSettingsData        Data;                                              // 0x0008(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainCrashSequenceSettings) == 0x000008, "Wrong alignment on FBrainCrashSequenceSettings");
static_assert(sizeof(FBrainCrashSequenceSettings) == 0x000050, "Wrong size on FBrainCrashSequenceSettings");
static_assert(offsetof(FBrainCrashSequenceSettings, Data) == 0x000008, "Member 'FBrainCrashSequenceSettings::Data' has a wrong offset!");

// ScriptStruct BattlePrototype.AnimeInterlockingAnswer
// 0x0020 (0x0020 - 0x0000)
struct FAnimeInterlockingAnswer final
{
public:
	class FString                                 QuestName;                                         // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Answers;                                           // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimeInterlockingAnswer) == 0x000008, "Wrong alignment on FAnimeInterlockingAnswer");
static_assert(sizeof(FAnimeInterlockingAnswer) == 0x000020, "Wrong size on FAnimeInterlockingAnswer");
static_assert(offsetof(FAnimeInterlockingAnswer, QuestName) == 0x000000, "Member 'FAnimeInterlockingAnswer::QuestName' has a wrong offset!");
static_assert(offsetof(FAnimeInterlockingAnswer, Answers) == 0x000010, "Member 'FAnimeInterlockingAnswer::Answers' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainCrashLocationAlias
// 0x0008 (0x0010 - 0x0008)
struct FBrainCrashLocationAlias final : public FTableRowBase
{
public:
	int32                                         LocationId;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaId;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainCrashLocationAlias) == 0x000008, "Wrong alignment on FBrainCrashLocationAlias");
static_assert(sizeof(FBrainCrashLocationAlias) == 0x000010, "Wrong size on FBrainCrashLocationAlias");
static_assert(offsetof(FBrainCrashLocationAlias, LocationId) == 0x000008, "Member 'FBrainCrashLocationAlias::LocationId' has a wrong offset!");
static_assert(offsetof(FBrainCrashLocationAlias, AreaId) == 0x00000C, "Member 'FBrainCrashLocationAlias::AreaId' has a wrong offset!");

// ScriptStruct BattlePrototype.SubquestRequestData
// 0x001C (0x001C - 0x0000)
struct FSubquestRequestData final
{
public:
	ESubQuestRequestType                          RequestType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RequestID;                                         // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequestNum;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeansOfKillType                              MeansOfKill;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpecifiedLocation;                                 // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubquestRequestData) == 0x000004, "Wrong alignment on FSubquestRequestData");
static_assert(sizeof(FSubquestRequestData) == 0x00001C, "Wrong size on FSubquestRequestData");
static_assert(offsetof(FSubquestRequestData, RequestType) == 0x000000, "Member 'FSubquestRequestData::RequestType' has a wrong offset!");
static_assert(offsetof(FSubquestRequestData, RequestID) == 0x000004, "Member 'FSubquestRequestData::RequestID' has a wrong offset!");
static_assert(offsetof(FSubquestRequestData, RequestNum) == 0x00000C, "Member 'FSubquestRequestData::RequestNum' has a wrong offset!");
static_assert(offsetof(FSubquestRequestData, MeansOfKill) == 0x000010, "Member 'FSubquestRequestData::MeansOfKill' has a wrong offset!");
static_assert(offsetof(FSubquestRequestData, SpecifiedLocation) == 0x000014, "Member 'FSubquestRequestData::SpecifiedLocation' has a wrong offset!");

// ScriptStruct BattlePrototype.SubquestRewardData
// 0x0010 (0x0010 - 0x0000)
struct FSubquestRewardData final
{
public:
	ESubQuestRewardType                           RewardType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RewardId;                                          // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardNum;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubquestRewardData) == 0x000004, "Wrong alignment on FSubquestRewardData");
static_assert(sizeof(FSubquestRewardData) == 0x000010, "Wrong size on FSubquestRewardData");
static_assert(offsetof(FSubquestRewardData, RewardType) == 0x000000, "Member 'FSubquestRewardData::RewardType' has a wrong offset!");
static_assert(offsetof(FSubquestRewardData, RewardId) == 0x000004, "Member 'FSubquestRewardData::RewardId' has a wrong offset!");
static_assert(offsetof(FSubquestRewardData, RewardNum) == 0x00000C, "Member 'FSubquestRewardData::RewardNum' has a wrong offset!");

// ScriptStruct BattlePrototype.SubQuestDBDataCell
// 0x0088 (0x0090 - 0x0008)
struct FSubQuestDBDataCell final : public FTableRowBase
{
public:
	class FName                                   ScenarioName;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScenarioType                                 ScenarioType;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MsgListTitle;                                      // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgDetailTitle;                                    // 0x001C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgClientName;                                     // 0x0024(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgPlace;                                          // 0x002C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSubquestRequestData>           RequestData;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSubquestRewardData>            RewardData;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ImagePath;                                         // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgContent1;                                       // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgContent2;                                       // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAreaInfoTweakCondition>        Conditions;                                        // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OnFlagAfterClear;                                  // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubQuestDBDataCell) == 0x000008, "Wrong alignment on FSubQuestDBDataCell");
static_assert(sizeof(FSubQuestDBDataCell) == 0x000090, "Wrong size on FSubQuestDBDataCell");
static_assert(offsetof(FSubQuestDBDataCell, ScenarioName) == 0x000008, "Member 'FSubQuestDBDataCell::ScenarioName' has a wrong offset!");
static_assert(offsetof(FSubQuestDBDataCell, ScenarioType) == 0x000010, "Member 'FSubQuestDBDataCell::ScenarioType' has a wrong offset!");
static_assert(offsetof(FSubQuestDBDataCell, MsgListTitle) == 0x000014, "Member 'FSubQuestDBDataCell::MsgListTitle' has a wrong offset!");
static_assert(offsetof(FSubQuestDBDataCell, MsgDetailTitle) == 0x00001C, "Member 'FSubQuestDBDataCell::MsgDetailTitle' has a wrong offset!");
static_assert(offsetof(FSubQuestDBDataCell, MsgClientName) == 0x000024, "Member 'FSubQuestDBDataCell::MsgClientName' has a wrong offset!");
static_assert(offsetof(FSubQuestDBDataCell, MsgPlace) == 0x00002C, "Member 'FSubQuestDBDataCell::MsgPlace' has a wrong offset!");
static_assert(offsetof(FSubQuestDBDataCell, RequestData) == 0x000038, "Member 'FSubQuestDBDataCell::RequestData' has a wrong offset!");
static_assert(offsetof(FSubQuestDBDataCell, RewardData) == 0x000048, "Member 'FSubQuestDBDataCell::RewardData' has a wrong offset!");
static_assert(offsetof(FSubQuestDBDataCell, ImagePath) == 0x000058, "Member 'FSubQuestDBDataCell::ImagePath' has a wrong offset!");
static_assert(offsetof(FSubQuestDBDataCell, MsgContent1) == 0x000068, "Member 'FSubQuestDBDataCell::MsgContent1' has a wrong offset!");
static_assert(offsetof(FSubQuestDBDataCell, MsgContent2) == 0x000070, "Member 'FSubQuestDBDataCell::MsgContent2' has a wrong offset!");
static_assert(offsetof(FSubQuestDBDataCell, Conditions) == 0x000078, "Member 'FSubQuestDBDataCell::Conditions' has a wrong offset!");
static_assert(offsetof(FSubQuestDBDataCell, OnFlagAfterClear) == 0x000088, "Member 'FSubQuestDBDataCell::OnFlagAfterClear' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainCrashSafePoint
// 0x0020 (0x0020 - 0x0000)
struct FBrainCrashSafePoint final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint16>                                AllowRotationBits;                                 // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainCrashSafePoint) == 0x000008, "Wrong alignment on FBrainCrashSafePoint");
static_assert(sizeof(FBrainCrashSafePoint) == 0x000020, "Wrong size on FBrainCrashSafePoint");
static_assert(offsetof(FBrainCrashSafePoint, Location) == 0x000000, "Member 'FBrainCrashSafePoint::Location' has a wrong offset!");
static_assert(offsetof(FBrainCrashSafePoint, AllowRotationBits) == 0x000010, "Member 'FBrainCrashSafePoint::AllowRotationBits' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainFieldNormalLevelActorListInput
// 0x0048 (0x0048 - 0x0000)
struct FBrainFieldNormalLevelActorListInput final
{
public:
	TArray<class UClass*>                         IgnoreClasses;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class IInterface>                 BrainFieldActiveInterfaceClass;                    // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     CharacterClass;                                    // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     WeaponClass;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     PsychicObjectClass;                                // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     PsychicGrabClass;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     EffectBackgroundClass;                             // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     EffectBackgroundMotherClass;                       // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainFieldNormalLevelActorListInput) == 0x000008, "Wrong alignment on FBrainFieldNormalLevelActorListInput");
static_assert(sizeof(FBrainFieldNormalLevelActorListInput) == 0x000048, "Wrong size on FBrainFieldNormalLevelActorListInput");
static_assert(offsetof(FBrainFieldNormalLevelActorListInput, IgnoreClasses) == 0x000000, "Member 'FBrainFieldNormalLevelActorListInput::IgnoreClasses' has a wrong offset!");
static_assert(offsetof(FBrainFieldNormalLevelActorListInput, BrainFieldActiveInterfaceClass) == 0x000010, "Member 'FBrainFieldNormalLevelActorListInput::BrainFieldActiveInterfaceClass' has a wrong offset!");
static_assert(offsetof(FBrainFieldNormalLevelActorListInput, CharacterClass) == 0x000018, "Member 'FBrainFieldNormalLevelActorListInput::CharacterClass' has a wrong offset!");
static_assert(offsetof(FBrainFieldNormalLevelActorListInput, WeaponClass) == 0x000020, "Member 'FBrainFieldNormalLevelActorListInput::WeaponClass' has a wrong offset!");
static_assert(offsetof(FBrainFieldNormalLevelActorListInput, PsychicObjectClass) == 0x000028, "Member 'FBrainFieldNormalLevelActorListInput::PsychicObjectClass' has a wrong offset!");
static_assert(offsetof(FBrainFieldNormalLevelActorListInput, PsychicGrabClass) == 0x000030, "Member 'FBrainFieldNormalLevelActorListInput::PsychicGrabClass' has a wrong offset!");
static_assert(offsetof(FBrainFieldNormalLevelActorListInput, EffectBackgroundClass) == 0x000038, "Member 'FBrainFieldNormalLevelActorListInput::EffectBackgroundClass' has a wrong offset!");
static_assert(offsetof(FBrainFieldNormalLevelActorListInput, EffectBackgroundMotherClass) == 0x000040, "Member 'FBrainFieldNormalLevelActorListInput::EffectBackgroundMotherClass' has a wrong offset!");

// ScriptStruct BattlePrototype.HitActorInfoAtPsychic
// 0x0010 (0x0010 - 0x0000)
struct FHitActorInfoAtPsychic final
{
public:
	class AActor*                                 HitOtherActor;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitTime;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitActorInfoAtPsychic) == 0x000008, "Wrong alignment on FHitActorInfoAtPsychic");
static_assert(sizeof(FHitActorInfoAtPsychic) == 0x000010, "Wrong size on FHitActorInfoAtPsychic");
static_assert(offsetof(FHitActorInfoAtPsychic, HitOtherActor) == 0x000000, "Member 'FHitActorInfoAtPsychic::HitOtherActor' has a wrong offset!");
static_assert(offsetof(FHitActorInfoAtPsychic, HitTime) == 0x000008, "Member 'FHitActorInfoAtPsychic::HitTime' has a wrong offset!");

// ScriptStruct BattlePrototype.MemberSlotInfo
// 0x0004 (0x0004 - 0x0000)
struct FMemberSlotInfo final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMemberSlotInfo) == 0x000004, "Wrong alignment on FMemberSlotInfo");
static_assert(sizeof(FMemberSlotInfo) == 0x000004, "Wrong size on FMemberSlotInfo");
static_assert(offsetof(FMemberSlotInfo, ID) == 0x000000, "Member 'FMemberSlotInfo::ID' has a wrong offset!");

// ScriptStruct BattlePrototype.BondsEpisodeProgressInfo
// 0x0002 (0x0002 - 0x0000)
struct FBondsEpisodeProgressInfo final
{
public:
	EPlayerID                                     PlayerId;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TargetID;                                          // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBondsEpisodeProgressInfo) == 0x000001, "Wrong alignment on FBondsEpisodeProgressInfo");
static_assert(sizeof(FBondsEpisodeProgressInfo) == 0x000002, "Wrong size on FBondsEpisodeProgressInfo");
static_assert(offsetof(FBondsEpisodeProgressInfo, PlayerId) == 0x000000, "Member 'FBondsEpisodeProgressInfo::PlayerId' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeProgressInfo, TargetID) == 0x000001, "Member 'FBondsEpisodeProgressInfo::TargetID' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkOnceCheck_DataTableID
// 0x0010 (0x0010 - 0x0000)
struct FBrainTalkOnceCheck_DataTableID final
{
public:
	TArray<class FName>                           DataTableIDList;                                   // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkOnceCheck_DataTableID) == 0x000008, "Wrong alignment on FBrainTalkOnceCheck_DataTableID");
static_assert(sizeof(FBrainTalkOnceCheck_DataTableID) == 0x000010, "Wrong size on FBrainTalkOnceCheck_DataTableID");
static_assert(offsetof(FBrainTalkOnceCheck_DataTableID, DataTableIDList) == 0x000000, "Member 'FBrainTalkOnceCheck_DataTableID::DataTableIDList' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkOnceCheck_Category
// 0x0010 (0x0010 - 0x0000)
struct FBrainTalkOnceCheck_Category final
{
public:
	TArray<struct FBrainTalkOnceCheck_DataTableID> CategoryList;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkOnceCheck_Category) == 0x000008, "Wrong alignment on FBrainTalkOnceCheck_Category");
static_assert(sizeof(FBrainTalkOnceCheck_Category) == 0x000010, "Wrong size on FBrainTalkOnceCheck_Category");
static_assert(offsetof(FBrainTalkOnceCheck_Category, CategoryList) == 0x000000, "Member 'FBrainTalkOnceCheck_Category::CategoryList' has a wrong offset!");

// ScriptStruct BattlePrototype.TeamBondsParam
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FTeamBondsParam final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTeamBondsParam) == 0x000004, "Wrong alignment on FTeamBondsParam");
static_assert(sizeof(FTeamBondsParam) == 0x000014, "Wrong size on FTeamBondsParam");

// ScriptStruct BattlePrototype.UserParam
// 0x03E8 (0x03E8 - 0x0000)
struct FUserParam final
{
public:
	TArray<struct FMemberSlotInfo>                MemberSlotInfoList;                                // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedScenario;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsExNewGameFlow;                                   // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsExNewGame_TakeOverCharacterLevel;                // 0x0015(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsExNewGame_TakeOverBrainMap;                      // 0x0016(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Money;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUserItemInfo>                  ItemList;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SelectBattleItem;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLibraryInfo                           LibraryInfo;                                       // 0x0038(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         TotalPlayTime;                                     // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClearLapNum;                                       // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReceiveOrderQuestID;                               // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastShopID;                                        // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastTradeShopID;                                   // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCGameDifficulty                             GameDifficulty;                                    // 0x007C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameClearState                               GameClearState;                                    // 0x007D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPlayerID, int32>                        bondsProgressM;                                    // 0x0080(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EPlayerID, int32>                        bondsProgressF;                                    // 0x00D0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EPlayerID, int32>                        bondsLevelM;                                       // 0x0120(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EPlayerID, int32>                        bondsLevelF;                                       // 0x0170(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EPlayerID, float>                        bondsValueM;                                       // 0x01C0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EPlayerID, float>                        bondsValueF;                                       // 0x0210(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBondsEpisodeProgressInfo              bondsProgressInfo;                                 // 0x0260(0x0002)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bExtendEquipSAS;                                   // 0x0262(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_263[0x5];                                      // 0x0263(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<E_SASKindNative>                       SasEquipInfo;                                      // 0x0268(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ESASEquipStatus>                       SasEquipStatus;                                    // 0x0278(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<E_SASButton>                           SasEquipMemory;                                    // 0x0288(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillPoint;                                        // 0x0298(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillPointCh0200;                                  // 0x029C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  Ch0100LearnedSkillList;                            // 0x02A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  Ch0200LearnedSkillList;                            // 0x02B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         battlefieldRandomSeed;                             // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FBattlefieldInfo>  battlefieldInfos;                                  // 0x02C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EMapGimmickType, int32>                  MapGimmickUseTimes;                                // 0x0318(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBrainTalkOnceCheck_Category           M_BrainTalkOnceCheck_InSaveData;                   // 0x0368(0x0010)(NativeAccessSpecifierPublic)
	TArray<bool>                                  NpcAccessoryExtend1;                               // 0x0378(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  NpcAccessoryExtend2;                               // 0x0388(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTeamBondsParam                        TeamBondsParam;                                    // 0x0398(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUserItemInfo>                  PresentItemOthers;                                 // 0x03B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FUserItemInfo>                  KeyItemForBackupM;                                 // 0x03C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FUserItemInfo>                  KeyItemForBackupF;                                 // 0x03D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUserParam) == 0x000008, "Wrong alignment on FUserParam");
static_assert(sizeof(FUserParam) == 0x0003E8, "Wrong size on FUserParam");
static_assert(offsetof(FUserParam, MemberSlotInfoList) == 0x000000, "Member 'FUserParam::MemberSlotInfoList' has a wrong offset!");
static_assert(offsetof(FUserParam, SelectedScenario) == 0x000010, "Member 'FUserParam::SelectedScenario' has a wrong offset!");
static_assert(offsetof(FUserParam, IsExNewGameFlow) == 0x000014, "Member 'FUserParam::IsExNewGameFlow' has a wrong offset!");
static_assert(offsetof(FUserParam, IsExNewGame_TakeOverCharacterLevel) == 0x000015, "Member 'FUserParam::IsExNewGame_TakeOverCharacterLevel' has a wrong offset!");
static_assert(offsetof(FUserParam, IsExNewGame_TakeOverBrainMap) == 0x000016, "Member 'FUserParam::IsExNewGame_TakeOverBrainMap' has a wrong offset!");
static_assert(offsetof(FUserParam, Money) == 0x000018, "Member 'FUserParam::Money' has a wrong offset!");
static_assert(offsetof(FUserParam, ItemList) == 0x000020, "Member 'FUserParam::ItemList' has a wrong offset!");
static_assert(offsetof(FUserParam, SelectBattleItem) == 0x000030, "Member 'FUserParam::SelectBattleItem' has a wrong offset!");
static_assert(offsetof(FUserParam, LibraryInfo) == 0x000038, "Member 'FUserParam::LibraryInfo' has a wrong offset!");
static_assert(offsetof(FUserParam, TotalPlayTime) == 0x000068, "Member 'FUserParam::TotalPlayTime' has a wrong offset!");
static_assert(offsetof(FUserParam, ClearLapNum) == 0x00006C, "Member 'FUserParam::ClearLapNum' has a wrong offset!");
static_assert(offsetof(FUserParam, ReceiveOrderQuestID) == 0x000070, "Member 'FUserParam::ReceiveOrderQuestID' has a wrong offset!");
static_assert(offsetof(FUserParam, LastShopID) == 0x000074, "Member 'FUserParam::LastShopID' has a wrong offset!");
static_assert(offsetof(FUserParam, LastTradeShopID) == 0x000078, "Member 'FUserParam::LastTradeShopID' has a wrong offset!");
static_assert(offsetof(FUserParam, GameDifficulty) == 0x00007C, "Member 'FUserParam::GameDifficulty' has a wrong offset!");
static_assert(offsetof(FUserParam, GameClearState) == 0x00007D, "Member 'FUserParam::GameClearState' has a wrong offset!");
static_assert(offsetof(FUserParam, bondsProgressM) == 0x000080, "Member 'FUserParam::bondsProgressM' has a wrong offset!");
static_assert(offsetof(FUserParam, bondsProgressF) == 0x0000D0, "Member 'FUserParam::bondsProgressF' has a wrong offset!");
static_assert(offsetof(FUserParam, bondsLevelM) == 0x000120, "Member 'FUserParam::bondsLevelM' has a wrong offset!");
static_assert(offsetof(FUserParam, bondsLevelF) == 0x000170, "Member 'FUserParam::bondsLevelF' has a wrong offset!");
static_assert(offsetof(FUserParam, bondsValueM) == 0x0001C0, "Member 'FUserParam::bondsValueM' has a wrong offset!");
static_assert(offsetof(FUserParam, bondsValueF) == 0x000210, "Member 'FUserParam::bondsValueF' has a wrong offset!");
static_assert(offsetof(FUserParam, bondsProgressInfo) == 0x000260, "Member 'FUserParam::bondsProgressInfo' has a wrong offset!");
static_assert(offsetof(FUserParam, bExtendEquipSAS) == 0x000262, "Member 'FUserParam::bExtendEquipSAS' has a wrong offset!");
static_assert(offsetof(FUserParam, SasEquipInfo) == 0x000268, "Member 'FUserParam::SasEquipInfo' has a wrong offset!");
static_assert(offsetof(FUserParam, SasEquipStatus) == 0x000278, "Member 'FUserParam::SasEquipStatus' has a wrong offset!");
static_assert(offsetof(FUserParam, SasEquipMemory) == 0x000288, "Member 'FUserParam::SasEquipMemory' has a wrong offset!");
static_assert(offsetof(FUserParam, SkillPoint) == 0x000298, "Member 'FUserParam::SkillPoint' has a wrong offset!");
static_assert(offsetof(FUserParam, SkillPointCh0200) == 0x00029C, "Member 'FUserParam::SkillPointCh0200' has a wrong offset!");
static_assert(offsetof(FUserParam, Ch0100LearnedSkillList) == 0x0002A0, "Member 'FUserParam::Ch0100LearnedSkillList' has a wrong offset!");
static_assert(offsetof(FUserParam, Ch0200LearnedSkillList) == 0x0002B0, "Member 'FUserParam::Ch0200LearnedSkillList' has a wrong offset!");
static_assert(offsetof(FUserParam, battlefieldRandomSeed) == 0x0002C0, "Member 'FUserParam::battlefieldRandomSeed' has a wrong offset!");
static_assert(offsetof(FUserParam, battlefieldInfos) == 0x0002C8, "Member 'FUserParam::battlefieldInfos' has a wrong offset!");
static_assert(offsetof(FUserParam, MapGimmickUseTimes) == 0x000318, "Member 'FUserParam::MapGimmickUseTimes' has a wrong offset!");
static_assert(offsetof(FUserParam, M_BrainTalkOnceCheck_InSaveData) == 0x000368, "Member 'FUserParam::M_BrainTalkOnceCheck_InSaveData' has a wrong offset!");
static_assert(offsetof(FUserParam, NpcAccessoryExtend1) == 0x000378, "Member 'FUserParam::NpcAccessoryExtend1' has a wrong offset!");
static_assert(offsetof(FUserParam, NpcAccessoryExtend2) == 0x000388, "Member 'FUserParam::NpcAccessoryExtend2' has a wrong offset!");
static_assert(offsetof(FUserParam, TeamBondsParam) == 0x000398, "Member 'FUserParam::TeamBondsParam' has a wrong offset!");
static_assert(offsetof(FUserParam, PresentItemOthers) == 0x0003B0, "Member 'FUserParam::PresentItemOthers' has a wrong offset!");
static_assert(offsetof(FUserParam, KeyItemForBackupM) == 0x0003C0, "Member 'FUserParam::KeyItemForBackupM' has a wrong offset!");
static_assert(offsetof(FUserParam, KeyItemForBackupF) == 0x0003D0, "Member 'FUserParam::KeyItemForBackupF' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainFieldWaveEnemyFlag
// 0x0008 (0x0008 - 0x0000)
struct FBrainFieldWaveEnemyFlag final
{
public:
	int32                                         LocatioNo;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LongAway;                                          // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainFieldWaveEnemyFlag) == 0x000004, "Wrong alignment on FBrainFieldWaveEnemyFlag");
static_assert(sizeof(FBrainFieldWaveEnemyFlag) == 0x000008, "Wrong size on FBrainFieldWaveEnemyFlag");
static_assert(offsetof(FBrainFieldWaveEnemyFlag, LocatioNo) == 0x000000, "Member 'FBrainFieldWaveEnemyFlag::LocatioNo' has a wrong offset!");
static_assert(offsetof(FBrainFieldWaveEnemyFlag, LongAway) == 0x000004, "Member 'FBrainFieldWaveEnemyFlag::LongAway' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainFieldRestoreFlag
// 0x0028 (0x0028 - 0x0000)
struct FBrainFieldRestoreFlag final
{
public:
	int32                                         Flags;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 LightComponentsFlag;                               // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 PrimitiveComponentsFlag;                           // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainFieldRestoreFlag) == 0x000008, "Wrong alignment on FBrainFieldRestoreFlag");
static_assert(sizeof(FBrainFieldRestoreFlag) == 0x000028, "Wrong size on FBrainFieldRestoreFlag");
static_assert(offsetof(FBrainFieldRestoreFlag, Flags) == 0x000000, "Member 'FBrainFieldRestoreFlag::Flags' has a wrong offset!");
static_assert(offsetof(FBrainFieldRestoreFlag, LightComponentsFlag) == 0x000008, "Member 'FBrainFieldRestoreFlag::LightComponentsFlag' has a wrong offset!");
static_assert(offsetof(FBrainFieldRestoreFlag, PrimitiveComponentsFlag) == 0x000018, "Member 'FBrainFieldRestoreFlag::PrimitiveComponentsFlag' has a wrong offset!");

// ScriptStruct BattlePrototype.PsychicDroneGuageDataCell
// 0x0008 (0x0010 - 0x0008)
struct FPsychicDroneGuageDataCell final : public FTableRowBase
{
public:
	struct FColor                                 SideColor;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 CenterColor;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPsychicDroneGuageDataCell) == 0x000008, "Wrong alignment on FPsychicDroneGuageDataCell");
static_assert(sizeof(FPsychicDroneGuageDataCell) == 0x000010, "Wrong size on FPsychicDroneGuageDataCell");
static_assert(offsetof(FPsychicDroneGuageDataCell, SideColor) == 0x000008, "Member 'FPsychicDroneGuageDataCell::SideColor' has a wrong offset!");
static_assert(offsetof(FPsychicDroneGuageDataCell, CenterColor) == 0x00000C, "Member 'FPsychicDroneGuageDataCell::CenterColor' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainFieldMonitorData
// 0x0028 (0x0030 - 0x0008)
struct FBrainFieldMonitorData final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UManaTexture>            Movie;                                             // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainFieldMonitorData) == 0x000008, "Wrong alignment on FBrainFieldMonitorData");
static_assert(sizeof(FBrainFieldMonitorData) == 0x000030, "Wrong size on FBrainFieldMonitorData");
static_assert(offsetof(FBrainFieldMonitorData, Movie) == 0x000008, "Member 'FBrainFieldMonitorData::Movie' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainFieldSequencerData
// 0x0040 (0x0048 - 0x0008)
struct FBrainFieldSequencerData final : public FTableRowBase
{
public:
	TArray<TSoftObjectPtr<class ULevelSequence>>  Open;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ULevelSequence>>  Close;                                             // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ULevelSequence>>  ReceiveBrainCrash;                                 // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ULevelSequence>>  Override;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainFieldSequencerData) == 0x000008, "Wrong alignment on FBrainFieldSequencerData");
static_assert(sizeof(FBrainFieldSequencerData) == 0x000048, "Wrong size on FBrainFieldSequencerData");
static_assert(offsetof(FBrainFieldSequencerData, Open) == 0x000008, "Member 'FBrainFieldSequencerData::Open' has a wrong offset!");
static_assert(offsetof(FBrainFieldSequencerData, Close) == 0x000018, "Member 'FBrainFieldSequencerData::Close' has a wrong offset!");
static_assert(offsetof(FBrainFieldSequencerData, ReceiveBrainCrash) == 0x000028, "Member 'FBrainFieldSequencerData::ReceiveBrainCrash' has a wrong offset!");
static_assert(offsetof(FBrainFieldSequencerData, Override) == 0x000038, "Member 'FBrainFieldSequencerData::Override' has a wrong offset!");

// ScriptStruct BattlePrototype.SystemData
// 0x0004 (0x0004 - 0x0000)
struct FSystemData final
{
public:
	int32                                         Gold;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSystemData) == 0x000004, "Wrong alignment on FSystemData");
static_assert(sizeof(FSystemData) == 0x000004, "Wrong size on FSystemData");
static_assert(offsetof(FSystemData, Gold) == 0x000000, "Member 'FSystemData::Gold' has a wrong offset!");

// ScriptStruct BattlePrototype.CharacterData
// 0x0004 (0x0004 - 0x0000)
struct FCharacterData final
{
public:
	int32                                         Hoge;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterData) == 0x000004, "Wrong alignment on FCharacterData");
static_assert(sizeof(FCharacterData) == 0x000004, "Wrong size on FCharacterData");
static_assert(offsetof(FCharacterData, Hoge) == 0x000000, "Member 'FCharacterData::Hoge' has a wrong offset!");

// ScriptStruct BattlePrototype.ScenarioData
// 0x0004 (0x0004 - 0x0000)
struct FScenarioData final
{
public:
	int32                                         Hoge;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScenarioData) == 0x000004, "Wrong alignment on FScenarioData");
static_assert(sizeof(FScenarioData) == 0x000004, "Wrong size on FScenarioData");
static_assert(offsetof(FScenarioData, Hoge) == 0x000000, "Member 'FScenarioData::Hoge' has a wrong offset!");

// ScriptStruct BattlePrototype.UserData
// 0x0020 (0x0020 - 0x0000)
struct FUserData final
{
public:
	struct FSystemData                            SystemData;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharacterData>                 CharacterDatas;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScenarioData                          ScenarioData;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUserData) == 0x000008, "Wrong alignment on FUserData");
static_assert(sizeof(FUserData) == 0x000020, "Wrong size on FUserData");
static_assert(offsetof(FUserData, SystemData) == 0x000000, "Member 'FUserData::SystemData' has a wrong offset!");
static_assert(offsetof(FUserData, CharacterDatas) == 0x000008, "Member 'FUserData::CharacterDatas' has a wrong offset!");
static_assert(offsetof(FUserData, ScenarioData) == 0x000018, "Member 'FUserData::ScenarioData' has a wrong offset!");

// ScriptStruct BattlePrototype.BondsEpisodeDLCContent
// 0x000C (0x000C - 0x0000)
struct FBondsEpisodeDLCContent final
{
public:
	EPlayerID                                     PresentCheckPlayer;                                // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PresentID;                                         // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBondsEpisodeDLCContent) == 0x000004, "Wrong alignment on FBondsEpisodeDLCContent");
static_assert(sizeof(FBondsEpisodeDLCContent) == 0x00000C, "Wrong size on FBondsEpisodeDLCContent");
static_assert(offsetof(FBondsEpisodeDLCContent, PresentCheckPlayer) == 0x000000, "Member 'FBondsEpisodeDLCContent::PresentCheckPlayer' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeDLCContent, PresentID) == 0x000004, "Member 'FBondsEpisodeDLCContent::PresentID' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainFieldSettings
// 0x0028 (0x0028 - 0x0000)
struct FBrainFieldSettings final
{
public:
	TArray<class ARSCharacterBase*>               TargetActor;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Unbound;                                           // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollisionLevelPath;                                // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NavimeshLevelPath;                                 // 0x001C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainFieldSettings) == 0x000008, "Wrong alignment on FBrainFieldSettings");
static_assert(sizeof(FBrainFieldSettings) == 0x000028, "Wrong size on FBrainFieldSettings");
static_assert(offsetof(FBrainFieldSettings, TargetActor) == 0x000000, "Member 'FBrainFieldSettings::TargetActor' has a wrong offset!");
static_assert(offsetof(FBrainFieldSettings, Unbound) == 0x000010, "Member 'FBrainFieldSettings::Unbound' has a wrong offset!");
static_assert(offsetof(FBrainFieldSettings, CollisionLevelPath) == 0x000014, "Member 'FBrainFieldSettings::CollisionLevelPath' has a wrong offset!");
static_assert(offsetof(FBrainFieldSettings, NavimeshLevelPath) == 0x00001C, "Member 'FBrainFieldSettings::NavimeshLevelPath' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainFieldSettingsLocation
// 0x0220 (0x0220 - 0x0000)
struct FBrainFieldSettingsLocation final
{
public:
	class FName                                   CollisionLevelPath;                                // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NavimeshLevelPath;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCollisionLocationOrigin;                       // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultPlayerStartLeftRight;                   // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0xE];                                       // 0x0012(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PlayerStartMain;                                   // 0x0020(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             PlayerStartLeft;                                   // 0x0050(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             PlayerStartRight;                                  // 0x0080(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnemyRelativeJump;                                // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0xF];                                       // 0x00B1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             EnemyStart01;                                      // 0x00C0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             EnemyStart02;                                      // 0x00F0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             EnemyStart03;                                      // 0x0120(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             EnemyStart04;                                      // 0x0150(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseRestoreTransform;                              // 0x0180(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0xF];                                      // 0x0181(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PlayerRestoreMain;                                 // 0x0190(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             PlayerRestoreLeft;                                 // 0x01C0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             PlayerRestoreRight;                                // 0x01F0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainFieldSettingsLocation) == 0x000010, "Wrong alignment on FBrainFieldSettingsLocation");
static_assert(sizeof(FBrainFieldSettingsLocation) == 0x000220, "Wrong size on FBrainFieldSettingsLocation");
static_assert(offsetof(FBrainFieldSettingsLocation, CollisionLevelPath) == 0x000000, "Member 'FBrainFieldSettingsLocation::CollisionLevelPath' has a wrong offset!");
static_assert(offsetof(FBrainFieldSettingsLocation, NavimeshLevelPath) == 0x000008, "Member 'FBrainFieldSettingsLocation::NavimeshLevelPath' has a wrong offset!");
static_assert(offsetof(FBrainFieldSettingsLocation, bUseCollisionLocationOrigin) == 0x000010, "Member 'FBrainFieldSettingsLocation::bUseCollisionLocationOrigin' has a wrong offset!");
static_assert(offsetof(FBrainFieldSettingsLocation, bUseDefaultPlayerStartLeftRight) == 0x000011, "Member 'FBrainFieldSettingsLocation::bUseDefaultPlayerStartLeftRight' has a wrong offset!");
static_assert(offsetof(FBrainFieldSettingsLocation, PlayerStartMain) == 0x000020, "Member 'FBrainFieldSettingsLocation::PlayerStartMain' has a wrong offset!");
static_assert(offsetof(FBrainFieldSettingsLocation, PlayerStartLeft) == 0x000050, "Member 'FBrainFieldSettingsLocation::PlayerStartLeft' has a wrong offset!");
static_assert(offsetof(FBrainFieldSettingsLocation, PlayerStartRight) == 0x000080, "Member 'FBrainFieldSettingsLocation::PlayerStartRight' has a wrong offset!");
static_assert(offsetof(FBrainFieldSettingsLocation, bEnemyRelativeJump) == 0x0000B0, "Member 'FBrainFieldSettingsLocation::bEnemyRelativeJump' has a wrong offset!");
static_assert(offsetof(FBrainFieldSettingsLocation, EnemyStart01) == 0x0000C0, "Member 'FBrainFieldSettingsLocation::EnemyStart01' has a wrong offset!");
static_assert(offsetof(FBrainFieldSettingsLocation, EnemyStart02) == 0x0000F0, "Member 'FBrainFieldSettingsLocation::EnemyStart02' has a wrong offset!");
static_assert(offsetof(FBrainFieldSettingsLocation, EnemyStart03) == 0x000120, "Member 'FBrainFieldSettingsLocation::EnemyStart03' has a wrong offset!");
static_assert(offsetof(FBrainFieldSettingsLocation, EnemyStart04) == 0x000150, "Member 'FBrainFieldSettingsLocation::EnemyStart04' has a wrong offset!");
static_assert(offsetof(FBrainFieldSettingsLocation, bUseRestoreTransform) == 0x000180, "Member 'FBrainFieldSettingsLocation::bUseRestoreTransform' has a wrong offset!");
static_assert(offsetof(FBrainFieldSettingsLocation, PlayerRestoreMain) == 0x000190, "Member 'FBrainFieldSettingsLocation::PlayerRestoreMain' has a wrong offset!");
static_assert(offsetof(FBrainFieldSettingsLocation, PlayerRestoreLeft) == 0x0001C0, "Member 'FBrainFieldSettingsLocation::PlayerRestoreLeft' has a wrong offset!");
static_assert(offsetof(FBrainFieldSettingsLocation, PlayerRestoreRight) == 0x0001F0, "Member 'FBrainFieldSettingsLocation::PlayerRestoreRight' has a wrong offset!");

// ScriptStruct BattlePrototype.PurposeMessageData
// 0x0008 (0x0010 - 0x0008)
struct FPurposeMessageData final : public FTableRowBase
{
public:
	class FName                                   MsgID;                                             // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPurposeMessageData) == 0x000008, "Wrong alignment on FPurposeMessageData");
static_assert(sizeof(FPurposeMessageData) == 0x000010, "Wrong size on FPurposeMessageData");
static_assert(offsetof(FPurposeMessageData, MsgID) == 0x000008, "Member 'FPurposeMessageData::MsgID' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainMessageRowDataCell
// 0x00A8 (0x00B0 - 0x0008)
struct FBrainMessageRowDataCell final : public FTableRowBase
{
public:
	class FName                                   ThreadID;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TitleID;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharID;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageID;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAreaInfoTweakCondition>        OpenConditions;                                    // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReplyMessageFlg;                                   // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 bondsBPReference;                                  // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyAfterClearing;                                 // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAreaInfoTweakCondition>        ReplyConditions;                                   // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAreaInfoTweakCondition>        banReplyConditions;                                // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBrainMessageJumpMessage>       JumpMessage;                                       // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReplyDelayTime;                                    // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IconCharID_0;                                      // 0x008C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IconCharID_1;                                      // 0x0094(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IconCharID_2;                                      // 0x009C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IconCharID_3;                                      // 0x00A4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBothThread;                                       // 0x00AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimThread;                                       // 0x00AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE[0x2];                                       // 0x00AE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainMessageRowDataCell) == 0x000008, "Wrong alignment on FBrainMessageRowDataCell");
static_assert(sizeof(FBrainMessageRowDataCell) == 0x0000B0, "Wrong size on FBrainMessageRowDataCell");
static_assert(offsetof(FBrainMessageRowDataCell, ThreadID) == 0x000008, "Member 'FBrainMessageRowDataCell::ThreadID' has a wrong offset!");
static_assert(offsetof(FBrainMessageRowDataCell, TitleID) == 0x000010, "Member 'FBrainMessageRowDataCell::TitleID' has a wrong offset!");
static_assert(offsetof(FBrainMessageRowDataCell, CharID) == 0x000018, "Member 'FBrainMessageRowDataCell::CharID' has a wrong offset!");
static_assert(offsetof(FBrainMessageRowDataCell, MessageID) == 0x000020, "Member 'FBrainMessageRowDataCell::MessageID' has a wrong offset!");
static_assert(offsetof(FBrainMessageRowDataCell, OpenConditions) == 0x000028, "Member 'FBrainMessageRowDataCell::OpenConditions' has a wrong offset!");
static_assert(offsetof(FBrainMessageRowDataCell, ReplyMessageFlg) == 0x000038, "Member 'FBrainMessageRowDataCell::ReplyMessageFlg' has a wrong offset!");
static_assert(offsetof(FBrainMessageRowDataCell, bondsBPReference) == 0x000040, "Member 'FBrainMessageRowDataCell::bondsBPReference' has a wrong offset!");
static_assert(offsetof(FBrainMessageRowDataCell, OnlyAfterClearing) == 0x000050, "Member 'FBrainMessageRowDataCell::OnlyAfterClearing' has a wrong offset!");
static_assert(offsetof(FBrainMessageRowDataCell, ReplyConditions) == 0x000058, "Member 'FBrainMessageRowDataCell::ReplyConditions' has a wrong offset!");
static_assert(offsetof(FBrainMessageRowDataCell, banReplyConditions) == 0x000068, "Member 'FBrainMessageRowDataCell::banReplyConditions' has a wrong offset!");
static_assert(offsetof(FBrainMessageRowDataCell, JumpMessage) == 0x000078, "Member 'FBrainMessageRowDataCell::JumpMessage' has a wrong offset!");
static_assert(offsetof(FBrainMessageRowDataCell, ReplyDelayTime) == 0x000088, "Member 'FBrainMessageRowDataCell::ReplyDelayTime' has a wrong offset!");
static_assert(offsetof(FBrainMessageRowDataCell, IconCharID_0) == 0x00008C, "Member 'FBrainMessageRowDataCell::IconCharID_0' has a wrong offset!");
static_assert(offsetof(FBrainMessageRowDataCell, IconCharID_1) == 0x000094, "Member 'FBrainMessageRowDataCell::IconCharID_1' has a wrong offset!");
static_assert(offsetof(FBrainMessageRowDataCell, IconCharID_2) == 0x00009C, "Member 'FBrainMessageRowDataCell::IconCharID_2' has a wrong offset!");
static_assert(offsetof(FBrainMessageRowDataCell, IconCharID_3) == 0x0000A4, "Member 'FBrainMessageRowDataCell::IconCharID_3' has a wrong offset!");
static_assert(offsetof(FBrainMessageRowDataCell, bBothThread) == 0x0000AC, "Member 'FBrainMessageRowDataCell::bBothThread' has a wrong offset!");
static_assert(offsetof(FBrainMessageRowDataCell, bAnimThread) == 0x0000AD, "Member 'FBrainMessageRowDataCell::bAnimThread' has a wrong offset!");

// ScriptStruct BattlePrototype.ThreadData
// 0x0028 (0x0028 - 0x0000)
struct FThreadData final
{
public:
	int32                                         AlreadyLookNum;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AlreadyEmergenceNum;                               // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int32>                                 PublishedMessageNum;                               // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FThreadData) == 0x000008, "Wrong alignment on FThreadData");
static_assert(sizeof(FThreadData) == 0x000028, "Wrong size on FThreadData");
static_assert(offsetof(FThreadData, AlreadyLookNum) == 0x000000, "Member 'FThreadData::AlreadyLookNum' has a wrong offset!");
static_assert(offsetof(FThreadData, AlreadyEmergenceNum) == 0x000004, "Member 'FThreadData::AlreadyEmergenceNum' has a wrong offset!");
static_assert(offsetof(FThreadData, PublishedMessageNum) == 0x000008, "Member 'FThreadData::PublishedMessageNum' has a wrong offset!");

// ScriptStruct BattlePrototype.ClearConditions
// 0x0014 (0x0014 - 0x0000)
struct FClearConditions final
{
public:
	class FName                                   Id_;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NeedNum_;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NowNum_;                                           // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeansOfKillType                              MeansOfKill_;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClearConditions) == 0x000004, "Wrong alignment on FClearConditions");
static_assert(sizeof(FClearConditions) == 0x000014, "Wrong size on FClearConditions");
static_assert(offsetof(FClearConditions, Id_) == 0x000000, "Member 'FClearConditions::Id_' has a wrong offset!");
static_assert(offsetof(FClearConditions, NeedNum_) == 0x000008, "Member 'FClearConditions::NeedNum_' has a wrong offset!");
static_assert(offsetof(FClearConditions, NowNum_) == 0x00000C, "Member 'FClearConditions::NowNum_' has a wrong offset!");
static_assert(offsetof(FClearConditions, MeansOfKill_) == 0x000010, "Member 'FClearConditions::MeansOfKill_' has a wrong offset!");

// ScriptStruct BattlePrototype.QuestParams
// 0x0002 (0x0002 - 0x0000)
struct FQuestParams
{
public:
	EQuestProgressState                           QuestProgressState_;                               // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsNew_;                                            // 0x0001(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FQuestParams) == 0x000001, "Wrong alignment on FQuestParams");
static_assert(sizeof(FQuestParams) == 0x000002, "Wrong size on FQuestParams");
static_assert(offsetof(FQuestParams, QuestProgressState_) == 0x000000, "Member 'FQuestParams::QuestProgressState_' has a wrong offset!");
static_assert(offsetof(FQuestParams, IsNew_) == 0x000001, "Member 'FQuestParams::IsNew_' has a wrong offset!");

// ScriptStruct BattlePrototype.ConditionQuestParams
// 0x001E (0x0020 - 0x0002)
struct FConditionQuestParams final : public FQuestParams
{
public:
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FClearConditions>               Conditions_;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConditionQuestParams) == 0x000008, "Wrong alignment on FConditionQuestParams");
static_assert(sizeof(FConditionQuestParams) == 0x000020, "Wrong size on FConditionQuestParams");
static_assert(offsetof(FConditionQuestParams, Conditions_) == 0x000008, "Member 'FConditionQuestParams::Conditions_' has a wrong offset!");

// ScriptStruct BattlePrototype.UIDetaileMapFloorData
// 0x0030 (0x0030 - 0x0000)
struct FUIDetaileMapFloorData final
{
public:
	float                                         HeightData;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WidthData;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitCameraViewPos;                                 // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitCameraViewTargetOffsetPos;                     // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitCameraViewTargetPos;                           // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitViewZoom;                                      // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIDetaileMapFloorData) == 0x000004, "Wrong alignment on FUIDetaileMapFloorData");
static_assert(sizeof(FUIDetaileMapFloorData) == 0x000030, "Wrong size on FUIDetaileMapFloorData");
static_assert(offsetof(FUIDetaileMapFloorData, HeightData) == 0x000000, "Member 'FUIDetaileMapFloorData::HeightData' has a wrong offset!");
static_assert(offsetof(FUIDetaileMapFloorData, WidthData) == 0x000004, "Member 'FUIDetaileMapFloorData::WidthData' has a wrong offset!");
static_assert(offsetof(FUIDetaileMapFloorData, InitCameraViewPos) == 0x000008, "Member 'FUIDetaileMapFloorData::InitCameraViewPos' has a wrong offset!");
static_assert(offsetof(FUIDetaileMapFloorData, InitCameraViewTargetOffsetPos) == 0x000014, "Member 'FUIDetaileMapFloorData::InitCameraViewTargetOffsetPos' has a wrong offset!");
static_assert(offsetof(FUIDetaileMapFloorData, InitCameraViewTargetPos) == 0x000020, "Member 'FUIDetaileMapFloorData::InitCameraViewTargetPos' has a wrong offset!");
static_assert(offsetof(FUIDetaileMapFloorData, InitViewZoom) == 0x00002C, "Member 'FUIDetaileMapFloorData::InitViewZoom' has a wrong offset!");

// ScriptStruct BattlePrototype.SubquestRewardRawData
// 0x0020 (0x0020 - 0x0000)
struct FSubquestRewardRawData final
{
public:
	ESubQuestRewardType                           RewardType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RewardId;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardNum;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubquestRewardRawData) == 0x000008, "Wrong alignment on FSubquestRewardRawData");
static_assert(sizeof(FSubquestRewardRawData) == 0x000020, "Wrong size on FSubquestRewardRawData");
static_assert(offsetof(FSubquestRewardRawData, RewardType) == 0x000000, "Member 'FSubquestRewardRawData::RewardType' has a wrong offset!");
static_assert(offsetof(FSubquestRewardRawData, RewardId) == 0x000008, "Member 'FSubquestRewardRawData::RewardId' has a wrong offset!");
static_assert(offsetof(FSubquestRewardRawData, RewardNum) == 0x000018, "Member 'FSubquestRewardRawData::RewardNum' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkTutorial
// 0x0020 (0x0028 - 0x0008)
struct FBrainTalkTutorial final : public FTableRowBase
{
public:
	class FString                                 Label;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember1;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x001C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkTutorial) == 0x000008, "Wrong alignment on FBrainTalkTutorial");
static_assert(sizeof(FBrainTalkTutorial) == 0x000028, "Wrong size on FBrainTalkTutorial");
static_assert(offsetof(FBrainTalkTutorial, Label) == 0x000008, "Member 'FBrainTalkTutorial::Label' has a wrong offset!");
static_assert(offsetof(FBrainTalkTutorial, TalkMember1) == 0x000018, "Member 'FBrainTalkTutorial::TalkMember1' has a wrong offset!");
static_assert(offsetof(FBrainTalkTutorial, Category) == 0x000019, "Member 'FBrainTalkTutorial::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkTutorial, DatatableId) == 0x00001C, "Member 'FBrainTalkTutorial::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkTutorial_ConditionParam
// 0x0020 (0x0028 - 0x0008)
struct FBrainTalkTutorial_ConditionParam final : public FTableRowBase
{
public:
	TArray<struct FBrainTalkTutorial>             M_DataList;                                        // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBrainTalkBattle_ConditionsParam       M_DataList_Param;                                  // 0x0018(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkTutorial_ConditionParam) == 0x000008, "Wrong alignment on FBrainTalkTutorial_ConditionParam");
static_assert(sizeof(FBrainTalkTutorial_ConditionParam) == 0x000028, "Wrong size on FBrainTalkTutorial_ConditionParam");
static_assert(offsetof(FBrainTalkTutorial_ConditionParam, M_DataList) == 0x000008, "Member 'FBrainTalkTutorial_ConditionParam::M_DataList' has a wrong offset!");
static_assert(offsetof(FBrainTalkTutorial_ConditionParam, M_DataList_Param) == 0x000018, "Member 'FBrainTalkTutorial_ConditionParam::M_DataList_Param' has a wrong offset!");

// ScriptStruct BattlePrototype.UIDetaileMapCheckCoreData
// 0x0010 (0x0010 - 0x0000)
struct FUIDetaileMapCheckCoreData final
{
public:
	EAreaInfoDetaileCheckType                     CheckType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAreaInfoDetaileConditionType                 ConditionType;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProgressNum;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Flag;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIDetaileMapCheckCoreData) == 0x000004, "Wrong alignment on FUIDetaileMapCheckCoreData");
static_assert(sizeof(FUIDetaileMapCheckCoreData) == 0x000010, "Wrong size on FUIDetaileMapCheckCoreData");
static_assert(offsetof(FUIDetaileMapCheckCoreData, CheckType) == 0x000000, "Member 'FUIDetaileMapCheckCoreData::CheckType' has a wrong offset!");
static_assert(offsetof(FUIDetaileMapCheckCoreData, ConditionType) == 0x000001, "Member 'FUIDetaileMapCheckCoreData::ConditionType' has a wrong offset!");
static_assert(offsetof(FUIDetaileMapCheckCoreData, ProgressNum) == 0x000004, "Member 'FUIDetaileMapCheckCoreData::ProgressNum' has a wrong offset!");
static_assert(offsetof(FUIDetaileMapCheckCoreData, Flag) == 0x000008, "Member 'FUIDetaileMapCheckCoreData::Flag' has a wrong offset!");

// ScriptStruct BattlePrototype.UIDetaileMapCheckConditionList
// 0x0010 (0x0010 - 0x0000)
struct FUIDetaileMapCheckConditionList final
{
public:
	TArray<struct FUIDetaileMapCheckCoreData>     ConditionList;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIDetaileMapCheckConditionList) == 0x000008, "Wrong alignment on FUIDetaileMapCheckConditionList");
static_assert(sizeof(FUIDetaileMapCheckConditionList) == 0x000010, "Wrong size on FUIDetaileMapCheckConditionList");
static_assert(offsetof(FUIDetaileMapCheckConditionList, ConditionList) == 0x000000, "Member 'FUIDetaileMapCheckConditionList::ConditionList' has a wrong offset!");

// ScriptStruct BattlePrototype.MainQuestConditionData
// 0x0024 (0x0024 - 0x0000)
struct FMainQuestConditionData final
{
public:
	EShowDestinationCheckType                     CheckType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProgressId;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpperLimitProgressID;                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMainQuestFlagConditionData            FlagData;                                          // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FMainQuestFlagConditionData            InValidFlagData;                                   // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMainQuestConditionData) == 0x000004, "Wrong alignment on FMainQuestConditionData");
static_assert(sizeof(FMainQuestConditionData) == 0x000024, "Wrong size on FMainQuestConditionData");
static_assert(offsetof(FMainQuestConditionData, CheckType) == 0x000000, "Member 'FMainQuestConditionData::CheckType' has a wrong offset!");
static_assert(offsetof(FMainQuestConditionData, ProgressId) == 0x000004, "Member 'FMainQuestConditionData::ProgressId' has a wrong offset!");
static_assert(offsetof(FMainQuestConditionData, UpperLimitProgressID) == 0x000008, "Member 'FMainQuestConditionData::UpperLimitProgressID' has a wrong offset!");
static_assert(offsetof(FMainQuestConditionData, FlagData) == 0x00000C, "Member 'FMainQuestConditionData::FlagData' has a wrong offset!");
static_assert(offsetof(FMainQuestConditionData, InValidFlagData) == 0x000018, "Member 'FMainQuestConditionData::InValidFlagData' has a wrong offset!");

// ScriptStruct BattlePrototype.MainQuestContentData
// 0x0028 (0x0028 - 0x0000)
struct FMainQuestContentData final
{
public:
	class FName                                   MsgContent;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ImagePath;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMainQuestConditionData>        Conditions;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMainQuestContentData) == 0x000008, "Wrong alignment on FMainQuestContentData");
static_assert(sizeof(FMainQuestContentData) == 0x000028, "Wrong size on FMainQuestContentData");
static_assert(offsetof(FMainQuestContentData, MsgContent) == 0x000000, "Member 'FMainQuestContentData::MsgContent' has a wrong offset!");
static_assert(offsetof(FMainQuestContentData, ImagePath) == 0x000008, "Member 'FMainQuestContentData::ImagePath' has a wrong offset!");
static_assert(offsetof(FMainQuestContentData, Conditions) == 0x000018, "Member 'FMainQuestContentData::Conditions' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkEm_Capture
// 0x0020 (0x0028 - 0x0008)
struct FBrainTalkEm_Capture final : public FTableRowBase
{
public:
	class FString                                 Label;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     Player;                                            // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWataruHaruka;                                    // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember1;                                       // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember2;                                       // 0x001B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember3;                                       // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     PartyMember1;                                      // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x001E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkEm_Capture) == 0x000008, "Wrong alignment on FBrainTalkEm_Capture");
static_assert(sizeof(FBrainTalkEm_Capture) == 0x000028, "Wrong size on FBrainTalkEm_Capture");
static_assert(offsetof(FBrainTalkEm_Capture, Label) == 0x000008, "Member 'FBrainTalkEm_Capture::Label' has a wrong offset!");
static_assert(offsetof(FBrainTalkEm_Capture, Player) == 0x000018, "Member 'FBrainTalkEm_Capture::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkEm_Capture, IsWataruHaruka) == 0x000019, "Member 'FBrainTalkEm_Capture::IsWataruHaruka' has a wrong offset!");
static_assert(offsetof(FBrainTalkEm_Capture, TalkMember1) == 0x00001A, "Member 'FBrainTalkEm_Capture::TalkMember1' has a wrong offset!");
static_assert(offsetof(FBrainTalkEm_Capture, TalkMember2) == 0x00001B, "Member 'FBrainTalkEm_Capture::TalkMember2' has a wrong offset!");
static_assert(offsetof(FBrainTalkEm_Capture, TalkMember3) == 0x00001C, "Member 'FBrainTalkEm_Capture::TalkMember3' has a wrong offset!");
static_assert(offsetof(FBrainTalkEm_Capture, PartyMember1) == 0x00001D, "Member 'FBrainTalkEm_Capture::PartyMember1' has a wrong offset!");
static_assert(offsetof(FBrainTalkEm_Capture, Category) == 0x00001E, "Member 'FBrainTalkEm_Capture::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkEm_Capture, DatatableId) == 0x000020, "Member 'FBrainTalkEm_Capture::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkEm_ConditionParam
// 0x0020 (0x0028 - 0x0008)
struct FBrainTalkEm_ConditionParam final : public FTableRowBase
{
public:
	TArray<struct FBrainTalkEm_Capture>           M_DataList;                                        // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBrainTalkBattle_ConditionsParam       M_DataList_Param;                                  // 0x0018(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkEm_ConditionParam) == 0x000008, "Wrong alignment on FBrainTalkEm_ConditionParam");
static_assert(sizeof(FBrainTalkEm_ConditionParam) == 0x000028, "Wrong size on FBrainTalkEm_ConditionParam");
static_assert(offsetof(FBrainTalkEm_ConditionParam, M_DataList) == 0x000008, "Member 'FBrainTalkEm_ConditionParam::M_DataList' has a wrong offset!");
static_assert(offsetof(FBrainTalkEm_ConditionParam, M_DataList_Param) == 0x000018, "Member 'FBrainTalkEm_ConditionParam::M_DataList_Param' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_RecoveryAbToPL
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_RecoveryAbToPL final : public FTableRowBase
{
public:
	EPlayerID                                     RecoveryFrom;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     RecoveryTo;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KizunaLvMin;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KizunaLvMax;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_RecoveryAbToPL) == 0x000008, "Wrong alignment on FBrainTalkBt_RecoveryAbToPL");
static_assert(sizeof(FBrainTalkBt_RecoveryAbToPL) == 0x000020, "Wrong size on FBrainTalkBt_RecoveryAbToPL");
static_assert(offsetof(FBrainTalkBt_RecoveryAbToPL, RecoveryFrom) == 0x000008, "Member 'FBrainTalkBt_RecoveryAbToPL::RecoveryFrom' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_RecoveryAbToPL, RecoveryTo) == 0x000009, "Member 'FBrainTalkBt_RecoveryAbToPL::RecoveryTo' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_RecoveryAbToPL, KizunaLvMin) == 0x00000C, "Member 'FBrainTalkBt_RecoveryAbToPL::KizunaLvMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_RecoveryAbToPL, KizunaLvMax) == 0x000010, "Member 'FBrainTalkBt_RecoveryAbToPL::KizunaLvMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_RecoveryAbToPL, Category) == 0x000014, "Member 'FBrainTalkBt_RecoveryAbToPL::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_RecoveryAbToPL, DatatableId) == 0x000018, "Member 'FBrainTalkBt_RecoveryAbToPL::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_EquipStrongestWeapon
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_EquipStrongestWeapon final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_EquipStrongestWeapon) == 0x000008, "Wrong alignment on FBrainTalkBt_EquipStrongestWeapon");
static_assert(sizeof(FBrainTalkBt_EquipStrongestWeapon) == 0x000018, "Wrong size on FBrainTalkBt_EquipStrongestWeapon");
static_assert(offsetof(FBrainTalkBt_EquipStrongestWeapon, Player) == 0x000008, "Member 'FBrainTalkBt_EquipStrongestWeapon::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_EquipStrongestWeapon, TalkMember) == 0x000009, "Member 'FBrainTalkBt_EquipStrongestWeapon::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_EquipStrongestWeapon, Category) == 0x00000A, "Member 'FBrainTalkBt_EquipStrongestWeapon::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_EquipStrongestWeapon, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_EquipStrongestWeapon::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_DriveGaugeMax
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_DriveGaugeMax final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWataruHaruka;                                    // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_DriveGaugeMax) == 0x000008, "Wrong alignment on FBrainTalkBt_DriveGaugeMax");
static_assert(sizeof(FBrainTalkBt_DriveGaugeMax) == 0x000018, "Wrong size on FBrainTalkBt_DriveGaugeMax");
static_assert(offsetof(FBrainTalkBt_DriveGaugeMax, Player) == 0x000008, "Member 'FBrainTalkBt_DriveGaugeMax::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DriveGaugeMax, IsWataruHaruka) == 0x000009, "Member 'FBrainTalkBt_DriveGaugeMax::IsWataruHaruka' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DriveGaugeMax, Category) == 0x00000A, "Member 'FBrainTalkBt_DriveGaugeMax::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DriveGaugeMax, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_DriveGaugeMax::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.MainQuestRawDataCell
// 0x0060 (0x0068 - 0x0008)
struct FMainQuestRawDataCell final : public FTableRowBase
{
public:
	class FName                                   MainQuestID;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScenarioType                                 ScenarioType;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MsgListTitle;                                      // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgDetailTitle;                                    // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ContentDataText;                                   // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ContentDataImage;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShowDestinationCheckType                     CheckType;                                         // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProgressId;                                        // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpperLimitProgressID;                              // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConditionFlag;                                     // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCheck;                                           // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InValidConditionFlag;                              // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InValidIsCheck;                                    // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMainQuestRawDataCell) == 0x000008, "Wrong alignment on FMainQuestRawDataCell");
static_assert(sizeof(FMainQuestRawDataCell) == 0x000068, "Wrong size on FMainQuestRawDataCell");
static_assert(offsetof(FMainQuestRawDataCell, MainQuestID) == 0x000008, "Member 'FMainQuestRawDataCell::MainQuestID' has a wrong offset!");
static_assert(offsetof(FMainQuestRawDataCell, ScenarioType) == 0x000010, "Member 'FMainQuestRawDataCell::ScenarioType' has a wrong offset!");
static_assert(offsetof(FMainQuestRawDataCell, MsgListTitle) == 0x000014, "Member 'FMainQuestRawDataCell::MsgListTitle' has a wrong offset!");
static_assert(offsetof(FMainQuestRawDataCell, MsgDetailTitle) == 0x00001C, "Member 'FMainQuestRawDataCell::MsgDetailTitle' has a wrong offset!");
static_assert(offsetof(FMainQuestRawDataCell, ContentDataText) == 0x000024, "Member 'FMainQuestRawDataCell::ContentDataText' has a wrong offset!");
static_assert(offsetof(FMainQuestRawDataCell, ContentDataImage) == 0x000030, "Member 'FMainQuestRawDataCell::ContentDataImage' has a wrong offset!");
static_assert(offsetof(FMainQuestRawDataCell, CheckType) == 0x000040, "Member 'FMainQuestRawDataCell::CheckType' has a wrong offset!");
static_assert(offsetof(FMainQuestRawDataCell, ProgressId) == 0x000044, "Member 'FMainQuestRawDataCell::ProgressId' has a wrong offset!");
static_assert(offsetof(FMainQuestRawDataCell, UpperLimitProgressID) == 0x000048, "Member 'FMainQuestRawDataCell::UpperLimitProgressID' has a wrong offset!");
static_assert(offsetof(FMainQuestRawDataCell, ConditionFlag) == 0x00004C, "Member 'FMainQuestRawDataCell::ConditionFlag' has a wrong offset!");
static_assert(offsetof(FMainQuestRawDataCell, IsCheck) == 0x000054, "Member 'FMainQuestRawDataCell::IsCheck' has a wrong offset!");
static_assert(offsetof(FMainQuestRawDataCell, InValidConditionFlag) == 0x000058, "Member 'FMainQuestRawDataCell::InValidConditionFlag' has a wrong offset!");
static_assert(offsetof(FMainQuestRawDataCell, InValidIsCheck) == 0x000060, "Member 'FMainQuestRawDataCell::InValidIsCheck' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_GetQuestTgtItem
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_GetQuestTgtItem final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KizunaLvMin;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KizunaLvMax;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_GetQuestTgtItem) == 0x000008, "Wrong alignment on FBrainTalkBt_GetQuestTgtItem");
static_assert(sizeof(FBrainTalkBt_GetQuestTgtItem) == 0x000020, "Wrong size on FBrainTalkBt_GetQuestTgtItem");
static_assert(offsetof(FBrainTalkBt_GetQuestTgtItem, TalkMember) == 0x000008, "Member 'FBrainTalkBt_GetQuestTgtItem::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_GetQuestTgtItem, KizunaLvMin) == 0x00000C, "Member 'FBrainTalkBt_GetQuestTgtItem::KizunaLvMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_GetQuestTgtItem, KizunaLvMax) == 0x000010, "Member 'FBrainTalkBt_GetQuestTgtItem::KizunaLvMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_GetQuestTgtItem, Category) == 0x000014, "Member 'FBrainTalkBt_GetQuestTgtItem::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_GetQuestTgtItem, DatatableId) == 0x000018, "Member 'FBrainTalkBt_GetQuestTgtItem::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_KillQuestTgtEn
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_KillQuestTgtEn final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KizunaLvMin;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KizunaLvMax;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_KillQuestTgtEn) == 0x000008, "Wrong alignment on FBrainTalkBt_KillQuestTgtEn");
static_assert(sizeof(FBrainTalkBt_KillQuestTgtEn) == 0x000020, "Wrong size on FBrainTalkBt_KillQuestTgtEn");
static_assert(offsetof(FBrainTalkBt_KillQuestTgtEn, TalkMember) == 0x000008, "Member 'FBrainTalkBt_KillQuestTgtEn::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillQuestTgtEn, KizunaLvMin) == 0x00000C, "Member 'FBrainTalkBt_KillQuestTgtEn::KizunaLvMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillQuestTgtEn, KizunaLvMax) == 0x000010, "Member 'FBrainTalkBt_KillQuestTgtEn::KizunaLvMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillQuestTgtEn, Category) == 0x000014, "Member 'FBrainTalkBt_KillQuestTgtEn::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillQuestTgtEn, DatatableId) == 0x000018, "Member 'FBrainTalkBt_KillQuestTgtEn::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_ClearQuest
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_ClearQuest final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KizunaLvMin;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KizunaLvMax;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_ClearQuest) == 0x000008, "Wrong alignment on FBrainTalkBt_ClearQuest");
static_assert(sizeof(FBrainTalkBt_ClearQuest) == 0x000020, "Wrong size on FBrainTalkBt_ClearQuest");
static_assert(offsetof(FBrainTalkBt_ClearQuest, TalkMember) == 0x000008, "Member 'FBrainTalkBt_ClearQuest::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_ClearQuest, KizunaLvMin) == 0x00000C, "Member 'FBrainTalkBt_ClearQuest::KizunaLvMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_ClearQuest, KizunaLvMax) == 0x000010, "Member 'FBrainTalkBt_ClearQuest::KizunaLvMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_ClearQuest, Category) == 0x000014, "Member 'FBrainTalkBt_ClearQuest::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_ClearQuest, DatatableId) == 0x000018, "Member 'FBrainTalkBt_ClearQuest::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoMemberInfo
// 0x0038 (0x0040 - 0x0008)
struct FAjitoMemberInfo final : public FTableRowBase
{
public:
	TSubclassOf<class URSAjitoAnimInstance>       AnimClass;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UASStateMachine>            StateMachine;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UASAnimationSet>            AnimationSet;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLookAtPlayerInTalking;                           // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAjitoMemberAttach>             AttachInfo;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAjitoMemberIdleStateType                     IdleStateType;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAjitoMemberTalkStateType                     TalkStateType;                                     // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsIdleOnlyAction;                                  // 0x003A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAjitoMemberInfo) == 0x000008, "Wrong alignment on FAjitoMemberInfo");
static_assert(sizeof(FAjitoMemberInfo) == 0x000040, "Wrong size on FAjitoMemberInfo");
static_assert(offsetof(FAjitoMemberInfo, AnimClass) == 0x000008, "Member 'FAjitoMemberInfo::AnimClass' has a wrong offset!");
static_assert(offsetof(FAjitoMemberInfo, StateMachine) == 0x000010, "Member 'FAjitoMemberInfo::StateMachine' has a wrong offset!");
static_assert(offsetof(FAjitoMemberInfo, AnimationSet) == 0x000018, "Member 'FAjitoMemberInfo::AnimationSet' has a wrong offset!");
static_assert(offsetof(FAjitoMemberInfo, IsLookAtPlayerInTalking) == 0x000020, "Member 'FAjitoMemberInfo::IsLookAtPlayerInTalking' has a wrong offset!");
static_assert(offsetof(FAjitoMemberInfo, AttachInfo) == 0x000028, "Member 'FAjitoMemberInfo::AttachInfo' has a wrong offset!");
static_assert(offsetof(FAjitoMemberInfo, IdleStateType) == 0x000038, "Member 'FAjitoMemberInfo::IdleStateType' has a wrong offset!");
static_assert(offsetof(FAjitoMemberInfo, TalkStateType) == 0x000039, "Member 'FAjitoMemberInfo::TalkStateType' has a wrong offset!");
static_assert(offsetof(FAjitoMemberInfo, IsIdleOnlyAction) == 0x00003A, "Member 'FAjitoMemberInfo::IsIdleOnlyAction' has a wrong offset!");

// ScriptStruct BattlePrototype.UIMapIconPGAdjust
// 0x0024 (0x0024 - 0x0000)
struct FUIMapIconPGAdjust final
{
public:
	struct FVector                                IconPGWideArea;                                    // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IconPGNarrowArea;                                  // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IconPGDetailMap;                                   // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIMapIconPGAdjust) == 0x000004, "Wrong alignment on FUIMapIconPGAdjust");
static_assert(sizeof(FUIMapIconPGAdjust) == 0x000024, "Wrong size on FUIMapIconPGAdjust");
static_assert(offsetof(FUIMapIconPGAdjust, IconPGWideArea) == 0x000000, "Member 'FUIMapIconPGAdjust::IconPGWideArea' has a wrong offset!");
static_assert(offsetof(FUIMapIconPGAdjust, IconPGNarrowArea) == 0x00000C, "Member 'FUIMapIconPGAdjust::IconPGNarrowArea' has a wrong offset!");
static_assert(offsetof(FUIMapIconPGAdjust, IconPGDetailMap) == 0x000018, "Member 'FUIMapIconPGAdjust::IconPGDetailMap' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_DiscQuestEnemy
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_DiscQuestEnemy final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KizunaLvMin;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KizunaLvMax;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_DiscQuestEnemy) == 0x000008, "Wrong alignment on FBrainTalkBt_DiscQuestEnemy");
static_assert(sizeof(FBrainTalkBt_DiscQuestEnemy) == 0x000020, "Wrong size on FBrainTalkBt_DiscQuestEnemy");
static_assert(offsetof(FBrainTalkBt_DiscQuestEnemy, TalkMember) == 0x000008, "Member 'FBrainTalkBt_DiscQuestEnemy::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscQuestEnemy, KizunaLvMin) == 0x00000C, "Member 'FBrainTalkBt_DiscQuestEnemy::KizunaLvMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscQuestEnemy, KizunaLvMax) == 0x000010, "Member 'FBrainTalkBt_DiscQuestEnemy::KizunaLvMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscQuestEnemy, Category) == 0x000014, "Member 'FBrainTalkBt_DiscQuestEnemy::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscQuestEnemy, DatatableId) == 0x000018, "Member 'FBrainTalkBt_DiscQuestEnemy::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_RecoveryItemZero
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_RecoveryItemZero final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_RecoveryItemZero) == 0x000008, "Wrong alignment on FBrainTalkBt_RecoveryItemZero");
static_assert(sizeof(FBrainTalkBt_RecoveryItemZero) == 0x000018, "Wrong size on FBrainTalkBt_RecoveryItemZero");
static_assert(offsetof(FBrainTalkBt_RecoveryItemZero, Player) == 0x000008, "Member 'FBrainTalkBt_RecoveryItemZero::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_RecoveryItemZero, Category) == 0x000009, "Member 'FBrainTalkBt_RecoveryItemZero::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_RecoveryItemZero, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_RecoveryItemZero::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.RenderingSettingsFloat
// 0x0038 (0x0038 - 0x0000)
struct FRenderingSettingsFloat final
{
public:
	bool                                          bUsePlatformValue;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ValueALL;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueWin64;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueWin64_4k;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValuePS4;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValuePS4Pro;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValuePS4Pro_4k;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueXB1;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueXB1X;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueXB1X_4k;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValuePS5;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValuePS5_4k;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueXSX;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueXSX_4k;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRenderingSettingsFloat) == 0x000004, "Wrong alignment on FRenderingSettingsFloat");
static_assert(sizeof(FRenderingSettingsFloat) == 0x000038, "Wrong size on FRenderingSettingsFloat");
static_assert(offsetof(FRenderingSettingsFloat, bUsePlatformValue) == 0x000000, "Member 'FRenderingSettingsFloat::bUsePlatformValue' has a wrong offset!");
static_assert(offsetof(FRenderingSettingsFloat, ValueALL) == 0x000004, "Member 'FRenderingSettingsFloat::ValueALL' has a wrong offset!");
static_assert(offsetof(FRenderingSettingsFloat, ValueWin64) == 0x000008, "Member 'FRenderingSettingsFloat::ValueWin64' has a wrong offset!");
static_assert(offsetof(FRenderingSettingsFloat, ValueWin64_4k) == 0x00000C, "Member 'FRenderingSettingsFloat::ValueWin64_4k' has a wrong offset!");
static_assert(offsetof(FRenderingSettingsFloat, ValuePS4) == 0x000010, "Member 'FRenderingSettingsFloat::ValuePS4' has a wrong offset!");
static_assert(offsetof(FRenderingSettingsFloat, ValuePS4Pro) == 0x000014, "Member 'FRenderingSettingsFloat::ValuePS4Pro' has a wrong offset!");
static_assert(offsetof(FRenderingSettingsFloat, ValuePS4Pro_4k) == 0x000018, "Member 'FRenderingSettingsFloat::ValuePS4Pro_4k' has a wrong offset!");
static_assert(offsetof(FRenderingSettingsFloat, ValueXB1) == 0x00001C, "Member 'FRenderingSettingsFloat::ValueXB1' has a wrong offset!");
static_assert(offsetof(FRenderingSettingsFloat, ValueXB1X) == 0x000020, "Member 'FRenderingSettingsFloat::ValueXB1X' has a wrong offset!");
static_assert(offsetof(FRenderingSettingsFloat, ValueXB1X_4k) == 0x000024, "Member 'FRenderingSettingsFloat::ValueXB1X_4k' has a wrong offset!");
static_assert(offsetof(FRenderingSettingsFloat, ValuePS5) == 0x000028, "Member 'FRenderingSettingsFloat::ValuePS5' has a wrong offset!");
static_assert(offsetof(FRenderingSettingsFloat, ValuePS5_4k) == 0x00002C, "Member 'FRenderingSettingsFloat::ValuePS5_4k' has a wrong offset!");
static_assert(offsetof(FRenderingSettingsFloat, ValueXSX) == 0x000030, "Member 'FRenderingSettingsFloat::ValueXSX' has a wrong offset!");
static_assert(offsetof(FRenderingSettingsFloat, ValueXSX_4k) == 0x000034, "Member 'FRenderingSettingsFloat::ValueXSX_4k' has a wrong offset!");

// ScriptStruct BattlePrototype.RenderingSettings
// 0x0078 (0x0078 - 0x0000)
struct FRenderingSettings final
{
public:
	bool                                          bOverrideTranslucencyResolution;                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRenderingSettingsFloat                TranslucencyResolution;                            // 0x0004(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideSSRResolution;                            // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRenderingSettingsFloat                SSRResolution;                                     // 0x0040(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRenderingSettings) == 0x000004, "Wrong alignment on FRenderingSettings");
static_assert(sizeof(FRenderingSettings) == 0x000078, "Wrong size on FRenderingSettings");
static_assert(offsetof(FRenderingSettings, bOverrideTranslucencyResolution) == 0x000000, "Member 'FRenderingSettings::bOverrideTranslucencyResolution' has a wrong offset!");
static_assert(offsetof(FRenderingSettings, TranslucencyResolution) == 0x000004, "Member 'FRenderingSettings::TranslucencyResolution' has a wrong offset!");
static_assert(offsetof(FRenderingSettings, bOverrideSSRResolution) == 0x00003C, "Member 'FRenderingSettings::bOverrideSSRResolution' has a wrong offset!");
static_assert(offsetof(FRenderingSettings, SSRResolution) == 0x000040, "Member 'FRenderingSettings::SSRResolution' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_GatherPoint
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_GatherPoint final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_GatherPoint) == 0x000008, "Wrong alignment on FBrainTalkBt_GatherPoint");
static_assert(sizeof(FBrainTalkBt_GatherPoint) == 0x000018, "Wrong size on FBrainTalkBt_GatherPoint");
static_assert(offsetof(FBrainTalkBt_GatherPoint, Player) == 0x000008, "Member 'FBrainTalkBt_GatherPoint::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_GatherPoint, Category) == 0x000009, "Member 'FBrainTalkBt_GatherPoint::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_GatherPoint, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_GatherPoint::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_UnopenedTreasure
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_UnopenedTreasure final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KizunaLvMin;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KizunaLvMax;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_UnopenedTreasure) == 0x000008, "Wrong alignment on FBrainTalkBt_UnopenedTreasure");
static_assert(sizeof(FBrainTalkBt_UnopenedTreasure) == 0x000020, "Wrong size on FBrainTalkBt_UnopenedTreasure");
static_assert(offsetof(FBrainTalkBt_UnopenedTreasure, TalkMember) == 0x000008, "Member 'FBrainTalkBt_UnopenedTreasure::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_UnopenedTreasure, KizunaLvMin) == 0x00000C, "Member 'FBrainTalkBt_UnopenedTreasure::KizunaLvMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_UnopenedTreasure, KizunaLvMax) == 0x000010, "Member 'FBrainTalkBt_UnopenedTreasure::KizunaLvMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_UnopenedTreasure, Category) == 0x000014, "Member 'FBrainTalkBt_UnopenedTreasure::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_UnopenedTreasure, DatatableId) == 0x000018, "Member 'FBrainTalkBt_UnopenedTreasure::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.CreditPartsUtility
// 0x0001 (0x0001 - 0x0000)
struct FCreditPartsUtility final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCreditPartsUtility) == 0x000001, "Wrong alignment on FCreditPartsUtility");
static_assert(sizeof(FCreditPartsUtility) == 0x000001, "Wrong size on FCreditPartsUtility");

// ScriptStruct BattlePrototype.BrainTalkBt_EnemyDrop
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_EnemyDrop final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_EnemyDrop) == 0x000008, "Wrong alignment on FBrainTalkBt_EnemyDrop");
static_assert(sizeof(FBrainTalkBt_EnemyDrop) == 0x000018, "Wrong size on FBrainTalkBt_EnemyDrop");
static_assert(offsetof(FBrainTalkBt_EnemyDrop, Player) == 0x000008, "Member 'FBrainTalkBt_EnemyDrop::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_EnemyDrop, Rarity) == 0x000009, "Member 'FBrainTalkBt_EnemyDrop::Rarity' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_EnemyDrop, Category) == 0x00000A, "Member 'FBrainTalkBt_EnemyDrop::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_EnemyDrop, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_EnemyDrop::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_GetItem
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_GetItem final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_GetItem) == 0x000008, "Wrong alignment on FBrainTalkBt_GetItem");
static_assert(sizeof(FBrainTalkBt_GetItem) == 0x000018, "Wrong size on FBrainTalkBt_GetItem");
static_assert(offsetof(FBrainTalkBt_GetItem, Player) == 0x000008, "Member 'FBrainTalkBt_GetItem::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_GetItem, Rarity) == 0x000009, "Member 'FBrainTalkBt_GetItem::Rarity' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_GetItem, Category) == 0x00000A, "Member 'FBrainTalkBt_GetItem::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_GetItem, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_GetItem::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.ResourceMipPrestreamMesh
// 0x0018 (0x0018 - 0x0000)
struct FResourceMipPrestreamMesh final
{
public:
	EPlayerID                                     PlayerId;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UTexture2D>>      TargetTextures;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FResourceMipPrestreamMesh) == 0x000008, "Wrong alignment on FResourceMipPrestreamMesh");
static_assert(sizeof(FResourceMipPrestreamMesh) == 0x000018, "Wrong size on FResourceMipPrestreamMesh");
static_assert(offsetof(FResourceMipPrestreamMesh, PlayerId) == 0x000000, "Member 'FResourceMipPrestreamMesh::PlayerId' has a wrong offset!");
static_assert(offsetof(FResourceMipPrestreamMesh, TargetTextures) == 0x000008, "Member 'FResourceMipPrestreamMesh::TargetTextures' has a wrong offset!");

// ScriptStruct BattlePrototype.ResourceMipPrestreamMeshTable
// 0x0018 (0x0020 - 0x0008)
struct FResourceMipPrestreamMeshTable final : public FTableRowBase
{
public:
	struct FResourceMipPrestreamMesh              Setting;                                           // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FResourceMipPrestreamMeshTable) == 0x000008, "Wrong alignment on FResourceMipPrestreamMeshTable");
static_assert(sizeof(FResourceMipPrestreamMeshTable) == 0x000020, "Wrong size on FResourceMipPrestreamMeshTable");
static_assert(offsetof(FResourceMipPrestreamMeshTable, Setting) == 0x000008, "Member 'FResourceMipPrestreamMeshTable::Setting' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_SasHoloPursuit
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_SasHoloPursuit final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_SasHoloPursuit) == 0x000008, "Wrong alignment on FBrainTalkBt_SasHoloPursuit");
static_assert(sizeof(FBrainTalkBt_SasHoloPursuit) == 0x000018, "Wrong size on FBrainTalkBt_SasHoloPursuit");
static_assert(offsetof(FBrainTalkBt_SasHoloPursuit, Player) == 0x000008, "Member 'FBrainTalkBt_SasHoloPursuit::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasHoloPursuit, TalkMember) == 0x000009, "Member 'FBrainTalkBt_SasHoloPursuit::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasHoloPursuit, Category) == 0x00000A, "Member 'FBrainTalkBt_SasHoloPursuit::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasHoloPursuit, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_SasHoloPursuit::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_SasHoloPossible
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_SasHoloPossible final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_SasHoloPossible) == 0x000008, "Wrong alignment on FBrainTalkBt_SasHoloPossible");
static_assert(sizeof(FBrainTalkBt_SasHoloPossible) == 0x000018, "Wrong size on FBrainTalkBt_SasHoloPossible");
static_assert(offsetof(FBrainTalkBt_SasHoloPossible, Player) == 0x000008, "Member 'FBrainTalkBt_SasHoloPossible::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasHoloPossible, TalkMember) == 0x000009, "Member 'FBrainTalkBt_SasHoloPossible::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasHoloPossible, Category) == 0x00000A, "Member 'FBrainTalkBt_SasHoloPossible::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasHoloPossible, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_SasHoloPossible::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.PoolHitEffectData
// 0x01C0 (0x01C0 - 0x0000)
struct FPoolHitEffectData final
{
public:
	TWeakObjectPtr<class AActor>                  HitActor;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHCHitResult                           HitResult;                                         // 0x0008(0x01B8)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPoolHitEffectData) == 0x000008, "Wrong alignment on FPoolHitEffectData");
static_assert(sizeof(FPoolHitEffectData) == 0x0001C0, "Wrong size on FPoolHitEffectData");
static_assert(offsetof(FPoolHitEffectData, HitActor) == 0x000000, "Member 'FPoolHitEffectData::HitActor' has a wrong offset!");
static_assert(offsetof(FPoolHitEffectData, HitResult) == 0x000008, "Member 'FPoolHitEffectData::HitResult' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_SasContinuity
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_SasContinuity final : public FTableRowBase
{
public:
	E_SASKindNative                               SasEffect;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     Player;                                            // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember;                                        // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Num;                                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_SasContinuity) == 0x000008, "Wrong alignment on FBrainTalkBt_SasContinuity");
static_assert(sizeof(FBrainTalkBt_SasContinuity) == 0x000020, "Wrong size on FBrainTalkBt_SasContinuity");
static_assert(offsetof(FBrainTalkBt_SasContinuity, SasEffect) == 0x000008, "Member 'FBrainTalkBt_SasContinuity::SasEffect' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasContinuity, Player) == 0x000009, "Member 'FBrainTalkBt_SasContinuity::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasContinuity, TalkMember) == 0x00000A, "Member 'FBrainTalkBt_SasContinuity::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasContinuity, Num) == 0x00000C, "Member 'FBrainTalkBt_SasContinuity::Num' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasContinuity, Category) == 0x000010, "Member 'FBrainTalkBt_SasContinuity::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasContinuity, DatatableId) == 0x000014, "Member 'FBrainTalkBt_SasContinuity::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_SasNoUse
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_SasNoUse final : public FTableRowBase
{
public:
	E_SASKindNative                               SasEffect;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProgressMinutes;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_SasNoUse) == 0x000008, "Wrong alignment on FBrainTalkBt_SasNoUse");
static_assert(sizeof(FBrainTalkBt_SasNoUse) == 0x000020, "Wrong size on FBrainTalkBt_SasNoUse");
static_assert(offsetof(FBrainTalkBt_SasNoUse, SasEffect) == 0x000008, "Member 'FBrainTalkBt_SasNoUse::SasEffect' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasNoUse, TalkMember) == 0x000009, "Member 'FBrainTalkBt_SasNoUse::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasNoUse, ProgressMinutes) == 0x00000C, "Member 'FBrainTalkBt_SasNoUse::ProgressMinutes' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasNoUse, Category) == 0x000010, "Member 'FBrainTalkBt_SasNoUse::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasNoUse, DatatableId) == 0x000014, "Member 'FBrainTalkBt_SasNoUse::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.UIMain3DCharacterEquipSetting
// 0x0070 (0x0070 - 0x0000)
struct FUIMain3DCharacterEquipSetting final
{
public:
	bool                                          bOverride;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CameraTransform;                                   // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               DirectionalLightRotation;                          // 0x0040(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CharaPositionOffset;                               // 0x004C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CharaRotationOffset;                               // 0x0058(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIMain3DCharacterEquipSetting) == 0x000010, "Wrong alignment on FUIMain3DCharacterEquipSetting");
static_assert(sizeof(FUIMain3DCharacterEquipSetting) == 0x000070, "Wrong size on FUIMain3DCharacterEquipSetting");
static_assert(offsetof(FUIMain3DCharacterEquipSetting, bOverride) == 0x000000, "Member 'FUIMain3DCharacterEquipSetting::bOverride' has a wrong offset!");
static_assert(offsetof(FUIMain3DCharacterEquipSetting, CameraTransform) == 0x000010, "Member 'FUIMain3DCharacterEquipSetting::CameraTransform' has a wrong offset!");
static_assert(offsetof(FUIMain3DCharacterEquipSetting, DirectionalLightRotation) == 0x000040, "Member 'FUIMain3DCharacterEquipSetting::DirectionalLightRotation' has a wrong offset!");
static_assert(offsetof(FUIMain3DCharacterEquipSetting, CharaPositionOffset) == 0x00004C, "Member 'FUIMain3DCharacterEquipSetting::CharaPositionOffset' has a wrong offset!");
static_assert(offsetof(FUIMain3DCharacterEquipSetting, CharaRotationOffset) == 0x000058, "Member 'FUIMain3DCharacterEquipSetting::CharaRotationOffset' has a wrong offset!");

// ScriptStruct BattlePrototype.CableAdditiveBoneParam
// 0x0020 (0x0028 - 0x0008)
struct FCableAdditiveBoneParam final : public FTableRowBase
{
public:
	TArray<float>                                 AngleRoll;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 AnglePitch;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCableAdditiveBoneParam) == 0x000008, "Wrong alignment on FCableAdditiveBoneParam");
static_assert(sizeof(FCableAdditiveBoneParam) == 0x000028, "Wrong size on FCableAdditiveBoneParam");
static_assert(offsetof(FCableAdditiveBoneParam, AngleRoll) == 0x000008, "Member 'FCableAdditiveBoneParam::AngleRoll' has a wrong offset!");
static_assert(offsetof(FCableAdditiveBoneParam, AnglePitch) == 0x000018, "Member 'FCableAdditiveBoneParam::AnglePitch' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_StealthLosePL
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_StealthLosePL final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_StealthLosePL) == 0x000008, "Wrong alignment on FBrainTalkBt_StealthLosePL");
static_assert(sizeof(FBrainTalkBt_StealthLosePL) == 0x000018, "Wrong size on FBrainTalkBt_StealthLosePL");
static_assert(offsetof(FBrainTalkBt_StealthLosePL, TalkMember) == 0x000008, "Member 'FBrainTalkBt_StealthLosePL::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_StealthLosePL, Category) == 0x000009, "Member 'FBrainTalkBt_StealthLosePL::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_StealthLosePL, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_StealthLosePL::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_DiscSasValidEn
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_DiscSasValidEn final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_SASKindNative                               SasEffect;                                         // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KizunaLvMin;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KizunaLvMax;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_DiscSasValidEn) == 0x000008, "Wrong alignment on FBrainTalkBt_DiscSasValidEn");
static_assert(sizeof(FBrainTalkBt_DiscSasValidEn) == 0x000020, "Wrong size on FBrainTalkBt_DiscSasValidEn");
static_assert(offsetof(FBrainTalkBt_DiscSasValidEn, Player) == 0x000008, "Member 'FBrainTalkBt_DiscSasValidEn::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscSasValidEn, TalkMember) == 0x000009, "Member 'FBrainTalkBt_DiscSasValidEn::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscSasValidEn, SasEffect) == 0x00000A, "Member 'FBrainTalkBt_DiscSasValidEn::SasEffect' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscSasValidEn, KizunaLvMin) == 0x00000C, "Member 'FBrainTalkBt_DiscSasValidEn::KizunaLvMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscSasValidEn, KizunaLvMax) == 0x000010, "Member 'FBrainTalkBt_DiscSasValidEn::KizunaLvMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscSasValidEn, Category) == 0x000014, "Member 'FBrainTalkBt_DiscSasValidEn::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscSasValidEn, DatatableId) == 0x000018, "Member 'FBrainTalkBt_DiscSasValidEn::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.UIMain3DBGCameraSetting
// 0x0020 (0x0020 - 0x0000)
struct FUIMain3DBGCameraSetting final
{
public:
	struct FVector                                LookAtLocation;                                    // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchAngle;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldOfView;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartAngle;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIMain3DBGCameraSetting) == 0x000004, "Wrong alignment on FUIMain3DBGCameraSetting");
static_assert(sizeof(FUIMain3DBGCameraSetting) == 0x000020, "Wrong size on FUIMain3DBGCameraSetting");
static_assert(offsetof(FUIMain3DBGCameraSetting, LookAtLocation) == 0x000000, "Member 'FUIMain3DBGCameraSetting::LookAtLocation' has a wrong offset!");
static_assert(offsetof(FUIMain3DBGCameraSetting, Length) == 0x00000C, "Member 'FUIMain3DBGCameraSetting::Length' has a wrong offset!");
static_assert(offsetof(FUIMain3DBGCameraSetting, PitchAngle) == 0x000010, "Member 'FUIMain3DBGCameraSetting::PitchAngle' has a wrong offset!");
static_assert(offsetof(FUIMain3DBGCameraSetting, FieldOfView) == 0x000014, "Member 'FUIMain3DBGCameraSetting::FieldOfView' has a wrong offset!");
static_assert(offsetof(FUIMain3DBGCameraSetting, Speed) == 0x000018, "Member 'FUIMain3DBGCameraSetting::Speed' has a wrong offset!");
static_assert(offsetof(FUIMain3DBGCameraSetting, StartAngle) == 0x00001C, "Member 'FUIMain3DBGCameraSetting::StartAngle' has a wrong offset!");

// ScriptStruct BattlePrototype.NpcMergeMeshResource
// 0x0010 (0x0010 - 0x0000)
struct FNpcMergeMeshResource final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcMergeMeshResource) == 0x000008, "Wrong alignment on FNpcMergeMeshResource");
static_assert(sizeof(FNpcMergeMeshResource) == 0x000010, "Wrong size on FNpcMergeMeshResource");
static_assert(offsetof(FNpcMergeMeshResource, SkeletalMesh) == 0x000008, "Member 'FNpcMergeMeshResource::SkeletalMesh' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_DiscStealth
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_DiscStealth final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWataruHaruka;                                    // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_DiscStealth) == 0x000008, "Wrong alignment on FBrainTalkBt_DiscStealth");
static_assert(sizeof(FBrainTalkBt_DiscStealth) == 0x000018, "Wrong size on FBrainTalkBt_DiscStealth");
static_assert(offsetof(FBrainTalkBt_DiscStealth, Player) == 0x000008, "Member 'FBrainTalkBt_DiscStealth::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscStealth, IsWataruHaruka) == 0x000009, "Member 'FBrainTalkBt_DiscStealth::IsWataruHaruka' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscStealth, Category) == 0x00000A, "Member 'FBrainTalkBt_DiscStealth::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscStealth, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_DiscStealth::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_WaterEnAtkElectric
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_WaterEnAtkElectric final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_WaterEnAtkElectric) == 0x000008, "Wrong alignment on FBrainTalkBt_WaterEnAtkElectric");
static_assert(sizeof(FBrainTalkBt_WaterEnAtkElectric) == 0x000018, "Wrong size on FBrainTalkBt_WaterEnAtkElectric");
static_assert(offsetof(FBrainTalkBt_WaterEnAtkElectric, TalkMember) == 0x000008, "Member 'FBrainTalkBt_WaterEnAtkElectric::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_WaterEnAtkElectric, Category) == 0x000009, "Member 'FBrainTalkBt_WaterEnAtkElectric::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_WaterEnAtkElectric, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_WaterEnAtkElectric::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.SoftObjPtrSoundCueSheet
// 0x0028 (0x0030 - 0x0008)
struct FSoftObjPtrSoundCueSheet final : public FTableRowBase
{
public:
	TSoftObjectPtr<class USoundAtomCueSheet>      CueSheet;                                          // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoftObjPtrSoundCueSheet) == 0x000008, "Wrong alignment on FSoftObjPtrSoundCueSheet");
static_assert(sizeof(FSoftObjPtrSoundCueSheet) == 0x000030, "Wrong size on FSoftObjPtrSoundCueSheet");
static_assert(offsetof(FSoftObjPtrSoundCueSheet, CueSheet) == 0x000008, "Member 'FSoftObjPtrSoundCueSheet::CueSheet' has a wrong offset!");

// ScriptStruct BattlePrototype.SoundCvCueSheets
// 0x0020 (0x0028 - 0x0008)
struct FSoundCvCueSheets final : public FTableRowBase
{
public:
	TArray<struct FSoftObjPtrSoundCueSheet>       CueSheetsJa;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjPtrSoundCueSheet>       CueSheetsEn;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundCvCueSheets) == 0x000008, "Wrong alignment on FSoundCvCueSheets");
static_assert(sizeof(FSoundCvCueSheets) == 0x000028, "Wrong size on FSoundCvCueSheets");
static_assert(offsetof(FSoundCvCueSheets, CueSheetsJa) == 0x000008, "Member 'FSoundCvCueSheets::CueSheetsJa' has a wrong offset!");
static_assert(offsetof(FSoundCvCueSheets, CueSheetsEn) == 0x000018, "Member 'FSoundCvCueSheets::CueSheetsEn' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_OilEnAtkFire
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_OilEnAtkFire final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_OilEnAtkFire) == 0x000008, "Wrong alignment on FBrainTalkBt_OilEnAtkFire");
static_assert(sizeof(FBrainTalkBt_OilEnAtkFire) == 0x000018, "Wrong size on FBrainTalkBt_OilEnAtkFire");
static_assert(offsetof(FBrainTalkBt_OilEnAtkFire, TalkMember) == 0x000008, "Member 'FBrainTalkBt_OilEnAtkFire::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_OilEnAtkFire, Category) == 0x000009, "Member 'FBrainTalkBt_OilEnAtkFire::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_OilEnAtkFire, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_OilEnAtkFire::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_FirstStrike
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_FirstStrike final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_FirstStrike) == 0x000008, "Wrong alignment on FBrainTalkBt_FirstStrike");
static_assert(sizeof(FBrainTalkBt_FirstStrike) == 0x000018, "Wrong size on FBrainTalkBt_FirstStrike");
static_assert(offsetof(FBrainTalkBt_FirstStrike, TalkMember) == 0x000008, "Member 'FBrainTalkBt_FirstStrike::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_FirstStrike, Category) == 0x000009, "Member 'FBrainTalkBt_FirstStrike::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_FirstStrike, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_FirstStrike::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_AttackEnWeak
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_AttackEnWeak final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWataruHaruka;                                    // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_AttackEnWeak) == 0x000008, "Wrong alignment on FBrainTalkBt_AttackEnWeak");
static_assert(sizeof(FBrainTalkBt_AttackEnWeak) == 0x000018, "Wrong size on FBrainTalkBt_AttackEnWeak");
static_assert(offsetof(FBrainTalkBt_AttackEnWeak, Player) == 0x000008, "Member 'FBrainTalkBt_AttackEnWeak::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_AttackEnWeak, IsWataruHaruka) == 0x000009, "Member 'FBrainTalkBt_AttackEnWeak::IsWataruHaruka' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_AttackEnWeak, Category) == 0x00000A, "Member 'FBrainTalkBt_AttackEnWeak::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_AttackEnWeak, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_AttackEnWeak::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_AttackEnShell
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_AttackEnShell final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWataruHaruka;                                    // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_AttackEnShell) == 0x000008, "Wrong alignment on FBrainTalkBt_AttackEnShell");
static_assert(sizeof(FBrainTalkBt_AttackEnShell) == 0x000018, "Wrong size on FBrainTalkBt_AttackEnShell");
static_assert(offsetof(FBrainTalkBt_AttackEnShell, Player) == 0x000008, "Member 'FBrainTalkBt_AttackEnShell::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_AttackEnShell, IsWataruHaruka) == 0x000009, "Member 'FBrainTalkBt_AttackEnShell::IsWataruHaruka' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_AttackEnShell, Category) == 0x00000A, "Member 'FBrainTalkBt_AttackEnShell::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_AttackEnShell, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_AttackEnShell::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_EnBerserk
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_EnBerserk final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWataruHaruka;                                    // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_EnBerserk) == 0x000008, "Wrong alignment on FBrainTalkBt_EnBerserk");
static_assert(sizeof(FBrainTalkBt_EnBerserk) == 0x000018, "Wrong size on FBrainTalkBt_EnBerserk");
static_assert(offsetof(FBrainTalkBt_EnBerserk, Player) == 0x000008, "Member 'FBrainTalkBt_EnBerserk::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_EnBerserk, IsWataruHaruka) == 0x000009, "Member 'FBrainTalkBt_EnBerserk::IsWataruHaruka' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_EnBerserk, Category) == 0x00000A, "Member 'FBrainTalkBt_EnBerserk::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_EnBerserk, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_EnBerserk::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_EnBerserkSign
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_EnBerserkSign final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWataruHaruka;                                    // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_EnBerserkSign) == 0x000008, "Wrong alignment on FBrainTalkBt_EnBerserkSign");
static_assert(sizeof(FBrainTalkBt_EnBerserkSign) == 0x000018, "Wrong size on FBrainTalkBt_EnBerserkSign");
static_assert(offsetof(FBrainTalkBt_EnBerserkSign, Player) == 0x000008, "Member 'FBrainTalkBt_EnBerserkSign::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_EnBerserkSign, IsWataruHaruka) == 0x000009, "Member 'FBrainTalkBt_EnBerserkSign::IsWataruHaruka' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_EnBerserkSign, Category) == 0x00000A, "Member 'FBrainTalkBt_EnBerserkSign::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_EnBerserkSign, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_EnBerserkSign::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.CurveMoveData
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FCurveMoveData final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCurveMoveData) == 0x000008, "Wrong alignment on FCurveMoveData");
static_assert(sizeof(FCurveMoveData) == 0x000048, "Wrong size on FCurveMoveData");

// ScriptStruct BattlePrototype.BrainTalkBt_KillEnemyBC
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_KillEnemyBC final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_KillEnemyBC) == 0x000008, "Wrong alignment on FBrainTalkBt_KillEnemyBC");
static_assert(sizeof(FBrainTalkBt_KillEnemyBC) == 0x000018, "Wrong size on FBrainTalkBt_KillEnemyBC");
static_assert(offsetof(FBrainTalkBt_KillEnemyBC, TalkMember) == 0x000008, "Member 'FBrainTalkBt_KillEnemyBC::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillEnemyBC, Category) == 0x000009, "Member 'FBrainTalkBt_KillEnemyBC::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillEnemyBC, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_KillEnemyBC::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_DispCrashTrg
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_DispCrashTrg final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_DispCrashTrg) == 0x000008, "Wrong alignment on FBrainTalkBt_DispCrashTrg");
static_assert(sizeof(FBrainTalkBt_DispCrashTrg) == 0x000018, "Wrong size on FBrainTalkBt_DispCrashTrg");
static_assert(offsetof(FBrainTalkBt_DispCrashTrg, Player) == 0x000008, "Member 'FBrainTalkBt_DispCrashTrg::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DispCrashTrg, TalkMember) == 0x000009, "Member 'FBrainTalkBt_DispCrashTrg::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DispCrashTrg, Category) == 0x00000A, "Member 'FBrainTalkBt_DispCrashTrg::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DispCrashTrg, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_DispCrashTrg::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.OneArrowLR
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FOneArrowLR final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOneArrowLR) == 0x000008, "Wrong alignment on FOneArrowLR");
static_assert(sizeof(FOneArrowLR) == 0x000038, "Wrong size on FOneArrowLR");

// ScriptStruct BattlePrototype.BrainTalkBt_DiscEn
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_DiscEn final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KizunaLvMin;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KizunaLvMax;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_DiscEn) == 0x000008, "Wrong alignment on FBrainTalkBt_DiscEn");
static_assert(sizeof(FBrainTalkBt_DiscEn) == 0x000020, "Wrong size on FBrainTalkBt_DiscEn");
static_assert(offsetof(FBrainTalkBt_DiscEn, TalkMember) == 0x000008, "Member 'FBrainTalkBt_DiscEn::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscEn, KizunaLvMin) == 0x00000C, "Member 'FBrainTalkBt_DiscEn::KizunaLvMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscEn, KizunaLvMax) == 0x000010, "Member 'FBrainTalkBt_DiscEn::KizunaLvMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscEn, Category) == 0x000014, "Member 'FBrainTalkBt_DiscEn::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscEn, DatatableId) == 0x000018, "Member 'FBrainTalkBt_DiscEn::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_EnemyDown
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_EnemyDown final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_EnemyDown) == 0x000008, "Wrong alignment on FBrainTalkBt_EnemyDown");
static_assert(sizeof(FBrainTalkBt_EnemyDown) == 0x000018, "Wrong size on FBrainTalkBt_EnemyDown");
static_assert(offsetof(FBrainTalkBt_EnemyDown, TalkMember) == 0x000008, "Member 'FBrainTalkBt_EnemyDown::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_EnemyDown, Category) == 0x000009, "Member 'FBrainTalkBt_EnemyDown::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_EnemyDown, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_EnemyDown::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.OneGameOverIndex
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FOneGameOverIndex final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOneGameOverIndex) == 0x000008, "Wrong alignment on FOneGameOverIndex");
static_assert(sizeof(FOneGameOverIndex) == 0x000028, "Wrong size on FOneGameOverIndex");

// ScriptStruct BattlePrototype.PsychicObjectAreaChangeData
// 0x0018 (0x0018 - 0x0000)
struct FPsychicObjectAreaChangeData final
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ThrowTypeIndex;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SwingCnt;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SAS_Kind;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPsychicObjectAreaChangeData) == 0x000008, "Wrong alignment on FPsychicObjectAreaChangeData");
static_assert(sizeof(FPsychicObjectAreaChangeData) == 0x000018, "Wrong size on FPsychicObjectAreaChangeData");
static_assert(offsetof(FPsychicObjectAreaChangeData, ActorClass) == 0x000000, "Member 'FPsychicObjectAreaChangeData::ActorClass' has a wrong offset!");
static_assert(offsetof(FPsychicObjectAreaChangeData, ThrowTypeIndex) == 0x000008, "Member 'FPsychicObjectAreaChangeData::ThrowTypeIndex' has a wrong offset!");
static_assert(offsetof(FPsychicObjectAreaChangeData, SwingCnt) == 0x00000C, "Member 'FPsychicObjectAreaChangeData::SwingCnt' has a wrong offset!");
static_assert(offsetof(FPsychicObjectAreaChangeData, SAS_Kind) == 0x000010, "Member 'FPsychicObjectAreaChangeData::SAS_Kind' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_DestroyShell
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_DestroyShell final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWataruHaruka;                                    // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_DestroyShell) == 0x000008, "Wrong alignment on FBrainTalkBt_DestroyShell");
static_assert(sizeof(FBrainTalkBt_DestroyShell) == 0x000018, "Wrong size on FBrainTalkBt_DestroyShell");
static_assert(offsetof(FBrainTalkBt_DestroyShell, Player) == 0x000008, "Member 'FBrainTalkBt_DestroyShell::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DestroyShell, IsWataruHaruka) == 0x000009, "Member 'FBrainTalkBt_DestroyShell::IsWataruHaruka' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DestroyShell, Category) == 0x00000A, "Member 'FBrainTalkBt_DestroyShell::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DestroyShell, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_DestroyShell::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_DiscStrEn
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_DiscStrEn final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KizunaLvMin;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KizunaLvMax;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_DiscStrEn) == 0x000008, "Wrong alignment on FBrainTalkBt_DiscStrEn");
static_assert(sizeof(FBrainTalkBt_DiscStrEn) == 0x000020, "Wrong size on FBrainTalkBt_DiscStrEn");
static_assert(offsetof(FBrainTalkBt_DiscStrEn, Player) == 0x000008, "Member 'FBrainTalkBt_DiscStrEn::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscStrEn, TalkMember) == 0x000009, "Member 'FBrainTalkBt_DiscStrEn::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscStrEn, KizunaLvMin) == 0x00000C, "Member 'FBrainTalkBt_DiscStrEn::KizunaLvMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscStrEn, KizunaLvMax) == 0x000010, "Member 'FBrainTalkBt_DiscStrEn::KizunaLvMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscStrEn, Category) == 0x000014, "Member 'FBrainTalkBt_DiscStrEn::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_DiscStrEn, DatatableId) == 0x000018, "Member 'FBrainTalkBt_DiscStrEn::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.PsychicBattleSequenceData
// 0x0048 (0x0048 - 0x0000)
struct FPsychicBattleSequenceData final
{
public:
	TSoftObjectPtr<class ULevelSequence>          SequenceAsset;                                     // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WinShotName;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LoseShotName;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPsychicBattleSequenceData) == 0x000008, "Wrong alignment on FPsychicBattleSequenceData");
static_assert(sizeof(FPsychicBattleSequenceData) == 0x000048, "Wrong size on FPsychicBattleSequenceData");
static_assert(offsetof(FPsychicBattleSequenceData, SequenceAsset) == 0x000000, "Member 'FPsychicBattleSequenceData::SequenceAsset' has a wrong offset!");
static_assert(offsetof(FPsychicBattleSequenceData, WinShotName) == 0x000028, "Member 'FPsychicBattleSequenceData::WinShotName' has a wrong offset!");
static_assert(offsetof(FPsychicBattleSequenceData, LoseShotName) == 0x000038, "Member 'FPsychicBattleSequenceData::LoseShotName' has a wrong offset!");

// ScriptStruct BattlePrototype.PsychicBattleParameter
// 0x0090 (0x0098 - 0x0008)
struct FPsychicBattleParameter final : public FTableRowBase
{
public:
	struct FPsychicBattleSequenceData             Sequence_Ch0100;                                   // 0x0008(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPsychicBattleSequenceData             Sequence_Ch0200;                                   // 0x0050(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPsychicBattleParameter) == 0x000008, "Wrong alignment on FPsychicBattleParameter");
static_assert(sizeof(FPsychicBattleParameter) == 0x000098, "Wrong size on FPsychicBattleParameter");
static_assert(offsetof(FPsychicBattleParameter, Sequence_Ch0100) == 0x000008, "Member 'FPsychicBattleParameter::Sequence_Ch0100' has a wrong offset!");
static_assert(offsetof(FPsychicBattleParameter, Sequence_Ch0200) == 0x000050, "Member 'FPsychicBattleParameter::Sequence_Ch0200' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_KillEnStrategy
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_KillEnStrategy final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_KillEnStrategy) == 0x000008, "Wrong alignment on FBrainTalkBt_KillEnStrategy");
static_assert(sizeof(FBrainTalkBt_KillEnStrategy) == 0x000018, "Wrong size on FBrainTalkBt_KillEnStrategy");
static_assert(offsetof(FBrainTalkBt_KillEnStrategy, TalkMember) == 0x000008, "Member 'FBrainTalkBt_KillEnStrategy::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillEnStrategy, Category) == 0x000009, "Member 'FBrainTalkBt_KillEnStrategy::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillEnStrategy, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_KillEnStrategy::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.OneTab
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FOneTab final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOneTab) == 0x000008, "Wrong alignment on FOneTab");
static_assert(sizeof(FOneTab) == 0x000050, "Wrong size on FOneTab");

// ScriptStruct BattlePrototype.BrainTalkBt_KillAllEnManyWeakEn
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_KillAllEnManyWeakEn final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_KillAllEnManyWeakEn) == 0x000008, "Wrong alignment on FBrainTalkBt_KillAllEnManyWeakEn");
static_assert(sizeof(FBrainTalkBt_KillAllEnManyWeakEn) == 0x000018, "Wrong size on FBrainTalkBt_KillAllEnManyWeakEn");
static_assert(offsetof(FBrainTalkBt_KillAllEnManyWeakEn, TalkMember) == 0x000008, "Member 'FBrainTalkBt_KillAllEnManyWeakEn::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillAllEnManyWeakEn, Category) == 0x000009, "Member 'FBrainTalkBt_KillAllEnManyWeakEn::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillAllEnManyWeakEn, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_KillAllEnManyWeakEn::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.CreditPartsBase
// 0x0020 (0x0020 - 0x0000)
struct FCreditPartsBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlay*                               Overlay;                                           // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlaySlot*                           OverlaySlot;                                       // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCreditPartsBase) == 0x000008, "Wrong alignment on FCreditPartsBase");
static_assert(sizeof(FCreditPartsBase) == 0x000020, "Wrong size on FCreditPartsBase");
static_assert(offsetof(FCreditPartsBase, Overlay) == 0x000008, "Member 'FCreditPartsBase::Overlay' has a wrong offset!");
static_assert(offsetof(FCreditPartsBase, OverlaySlot) == 0x000010, "Member 'FCreditPartsBase::OverlaySlot' has a wrong offset!");

// ScriptStruct BattlePrototype.CreditOfficial_StaffName
// 0x0018 (0x0038 - 0x0020)
struct FCreditOfficial_StaffName final : public FCreditPartsBase
{
public:
	class USpacer*                                Spacer;                                            // 0x0020(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextPosition;                                      // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextStaff;                                         // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreditOfficial_StaffName) == 0x000008, "Wrong alignment on FCreditOfficial_StaffName");
static_assert(sizeof(FCreditOfficial_StaffName) == 0x000038, "Wrong size on FCreditOfficial_StaffName");
static_assert(offsetof(FCreditOfficial_StaffName, Spacer) == 0x000020, "Member 'FCreditOfficial_StaffName::Spacer' has a wrong offset!");
static_assert(offsetof(FCreditOfficial_StaffName, TextPosition) == 0x000028, "Member 'FCreditOfficial_StaffName::TextPosition' has a wrong offset!");
static_assert(offsetof(FCreditOfficial_StaffName, TextStaff) == 0x000030, "Member 'FCreditOfficial_StaffName::TextStaff' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_KillAllEnManyEn
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_KillAllEnManyEn final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_KillAllEnManyEn) == 0x000008, "Wrong alignment on FBrainTalkBt_KillAllEnManyEn");
static_assert(sizeof(FBrainTalkBt_KillAllEnManyEn) == 0x000018, "Wrong size on FBrainTalkBt_KillAllEnManyEn");
static_assert(offsetof(FBrainTalkBt_KillAllEnManyEn, TalkMember) == 0x000008, "Member 'FBrainTalkBt_KillAllEnManyEn::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillAllEnManyEn, Category) == 0x000009, "Member 'FBrainTalkBt_KillAllEnManyEn::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillAllEnManyEn, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_KillAllEnManyEn::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.UIMain3DCharacterPlayerSettingTableRow
// 0x0048 (0x0050 - 0x0008)
struct FUIMain3DCharacterPlayerSettingTableRow final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUIMain3DCharacterPlayerSetting        Setting;                                           // 0x0010(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIMain3DCharacterPlayerSettingTableRow) == 0x000010, "Wrong alignment on FUIMain3DCharacterPlayerSettingTableRow");
static_assert(sizeof(FUIMain3DCharacterPlayerSettingTableRow) == 0x000050, "Wrong size on FUIMain3DCharacterPlayerSettingTableRow");
static_assert(offsetof(FUIMain3DCharacterPlayerSettingTableRow, Setting) == 0x000010, "Member 'FUIMain3DCharacterPlayerSettingTableRow::Setting' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_KillAllEnStrEn
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_KillAllEnStrEn final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_KillAllEnStrEn) == 0x000008, "Wrong alignment on FBrainTalkBt_KillAllEnStrEn");
static_assert(sizeof(FBrainTalkBt_KillAllEnStrEn) == 0x000018, "Wrong size on FBrainTalkBt_KillAllEnStrEn");
static_assert(offsetof(FBrainTalkBt_KillAllEnStrEn, TalkMember) == 0x000008, "Member 'FBrainTalkBt_KillAllEnStrEn::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillAllEnStrEn, Category) == 0x000009, "Member 'FBrainTalkBt_KillAllEnStrEn::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillAllEnStrEn, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_KillAllEnStrEn::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.PsychicObjectListInfo
// 0x0010 (0x0010 - 0x0000)
struct FPsychicObjectListInfo final
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPsychicObjectListInfo) == 0x000008, "Wrong alignment on FPsychicObjectListInfo");
static_assert(sizeof(FPsychicObjectListInfo) == 0x000010, "Wrong size on FPsychicObjectListInfo");
static_assert(offsetof(FPsychicObjectListInfo, Actors) == 0x000000, "Member 'FPsychicObjectListInfo::Actors' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_KillAllEnShortTime
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_KillAllEnShortTime final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_KillAllEnShortTime) == 0x000008, "Wrong alignment on FBrainTalkBt_KillAllEnShortTime");
static_assert(sizeof(FBrainTalkBt_KillAllEnShortTime) == 0x000018, "Wrong size on FBrainTalkBt_KillAllEnShortTime");
static_assert(offsetof(FBrainTalkBt_KillAllEnShortTime, TalkMember) == 0x000008, "Member 'FBrainTalkBt_KillAllEnShortTime::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillAllEnShortTime, Category) == 0x000009, "Member 'FBrainTalkBt_KillAllEnShortTime::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillAllEnShortTime, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_KillAllEnShortTime::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_KillAllEnForPL
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_KillAllEnForPL final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KizunaLvMin;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KizunaLvMax;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_KillAllEnForPL) == 0x000008, "Wrong alignment on FBrainTalkBt_KillAllEnForPL");
static_assert(sizeof(FBrainTalkBt_KillAllEnForPL) == 0x000020, "Wrong size on FBrainTalkBt_KillAllEnForPL");
static_assert(offsetof(FBrainTalkBt_KillAllEnForPL, Player) == 0x000008, "Member 'FBrainTalkBt_KillAllEnForPL::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillAllEnForPL, TalkMember) == 0x000009, "Member 'FBrainTalkBt_KillAllEnForPL::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillAllEnForPL, KizunaLvMin) == 0x00000C, "Member 'FBrainTalkBt_KillAllEnForPL::KizunaLvMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillAllEnForPL, KizunaLvMax) == 0x000010, "Member 'FBrainTalkBt_KillAllEnForPL::KizunaLvMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillAllEnForPL, Category) == 0x000014, "Member 'FBrainTalkBt_KillAllEnForPL::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillAllEnForPL, DatatableId) == 0x000018, "Member 'FBrainTalkBt_KillAllEnForPL::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_KillAllEnForPT
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_KillAllEnForPT final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_KillAllEnForPT) == 0x000008, "Wrong alignment on FBrainTalkBt_KillAllEnForPT");
static_assert(sizeof(FBrainTalkBt_KillAllEnForPT) == 0x000018, "Wrong size on FBrainTalkBt_KillAllEnForPT");
static_assert(offsetof(FBrainTalkBt_KillAllEnForPT, TalkMember) == 0x000008, "Member 'FBrainTalkBt_KillAllEnForPT::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillAllEnForPT, Category) == 0x000009, "Member 'FBrainTalkBt_KillAllEnForPT::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillAllEnForPT, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_KillAllEnForPT::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_PLDead
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_PLDead final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_PLDead) == 0x000008, "Wrong alignment on FBrainTalkBt_PLDead");
static_assert(sizeof(FBrainTalkBt_PLDead) == 0x000018, "Wrong size on FBrainTalkBt_PLDead");
static_assert(offsetof(FBrainTalkBt_PLDead, Player) == 0x000008, "Member 'FBrainTalkBt_PLDead::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_PLDead, TalkMember) == 0x000009, "Member 'FBrainTalkBt_PLDead::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_PLDead, Category) == 0x00000A, "Member 'FBrainTalkBt_PLDead::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_PLDead, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_PLDead::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_JumpOff
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_JumpOff final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_JumpOff) == 0x000008, "Wrong alignment on FBrainTalkBt_JumpOff");
static_assert(sizeof(FBrainTalkBt_JumpOff) == 0x000018, "Wrong size on FBrainTalkBt_JumpOff");
static_assert(offsetof(FBrainTalkBt_JumpOff, TalkMember) == 0x000008, "Member 'FBrainTalkBt_JumpOff::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_JumpOff, Category) == 0x000009, "Member 'FBrainTalkBt_JumpOff::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_JumpOff, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_JumpOff::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_SallyTimes
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_SallyTimes final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SallyMinutes;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_SallyTimes) == 0x000008, "Wrong alignment on FBrainTalkBt_SallyTimes");
static_assert(sizeof(FBrainTalkBt_SallyTimes) == 0x000020, "Wrong size on FBrainTalkBt_SallyTimes");
static_assert(offsetof(FBrainTalkBt_SallyTimes, TalkMember) == 0x000008, "Member 'FBrainTalkBt_SallyTimes::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SallyTimes, SallyMinutes) == 0x00000C, "Member 'FBrainTalkBt_SallyTimes::SallyMinutes' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SallyTimes, Category) == 0x000010, "Member 'FBrainTalkBt_SallyTimes::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SallyTimes, DatatableId) == 0x000014, "Member 'FBrainTalkBt_SallyTimes::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_LvUp
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_LvUp final : public FTableRowBase
{
public:
	EPlayerID                                     Member;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_LvUp) == 0x000008, "Wrong alignment on FBrainTalkBt_LvUp");
static_assert(sizeof(FBrainTalkBt_LvUp) == 0x000018, "Wrong size on FBrainTalkBt_LvUp");
static_assert(offsetof(FBrainTalkBt_LvUp, Member) == 0x000008, "Member 'FBrainTalkBt_LvUp::Member' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_LvUp, Category) == 0x000009, "Member 'FBrainTalkBt_LvUp::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_LvUp, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_LvUp::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_KizunaLvUp
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_KizunaLvUp final : public FTableRowBase
{
public:
	EPlayerID                                     Member1;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     Member2;                                           // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KizunaLv;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_KizunaLvUp) == 0x000008, "Wrong alignment on FBrainTalkBt_KizunaLvUp");
static_assert(sizeof(FBrainTalkBt_KizunaLvUp) == 0x000020, "Wrong size on FBrainTalkBt_KizunaLvUp");
static_assert(offsetof(FBrainTalkBt_KizunaLvUp, Member1) == 0x000008, "Member 'FBrainTalkBt_KizunaLvUp::Member1' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KizunaLvUp, Member2) == 0x000009, "Member 'FBrainTalkBt_KizunaLvUp::Member2' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KizunaLvUp, KizunaLv) == 0x00000C, "Member 'FBrainTalkBt_KizunaLvUp::KizunaLv' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KizunaLvUp, Category) == 0x000010, "Member 'FBrainTalkBt_KizunaLvUp::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KizunaLvUp, DatatableId) == 0x000014, "Member 'FBrainTalkBt_KizunaLvUp::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_NearCC
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_NearCC final : public FTableRowBase
{
public:
	EPlayerID                                     TalkMember;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KizunaLvMin;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KizunaLvMax;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_NearCC) == 0x000008, "Wrong alignment on FBrainTalkBt_NearCC");
static_assert(sizeof(FBrainTalkBt_NearCC) == 0x000020, "Wrong size on FBrainTalkBt_NearCC");
static_assert(offsetof(FBrainTalkBt_NearCC, TalkMember) == 0x000008, "Member 'FBrainTalkBt_NearCC::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_NearCC, KizunaLvMin) == 0x00000C, "Member 'FBrainTalkBt_NearCC::KizunaLvMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_NearCC, KizunaLvMax) == 0x000010, "Member 'FBrainTalkBt_NearCC::KizunaLvMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_NearCC, Category) == 0x000014, "Member 'FBrainTalkBt_NearCC::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_NearCC, DatatableId) == 0x000018, "Member 'FBrainTalkBt_NearCC::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_HiKizunaEffect
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_HiKizunaEffect final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_HiKizunaEffect) == 0x000008, "Wrong alignment on FBrainTalkBt_HiKizunaEffect");
static_assert(sizeof(FBrainTalkBt_HiKizunaEffect) == 0x000018, "Wrong size on FBrainTalkBt_HiKizunaEffect");
static_assert(offsetof(FBrainTalkBt_HiKizunaEffect, Player) == 0x000008, "Member 'FBrainTalkBt_HiKizunaEffect::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_HiKizunaEffect, TalkMember) == 0x000009, "Member 'FBrainTalkBt_HiKizunaEffect::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_HiKizunaEffect, Category) == 0x00000A, "Member 'FBrainTalkBt_HiKizunaEffect::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_HiKizunaEffect, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_HiKizunaEffect::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_PsychicCombo
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_PsychicCombo final : public FTableRowBase
{
public:
	EPlayerID                                     ComboPlayer;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ComboNumMin;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ComboNumMax;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_PsychicCombo) == 0x000008, "Wrong alignment on FBrainTalkBt_PsychicCombo");
static_assert(sizeof(FBrainTalkBt_PsychicCombo) == 0x000020, "Wrong size on FBrainTalkBt_PsychicCombo");
static_assert(offsetof(FBrainTalkBt_PsychicCombo, ComboPlayer) == 0x000008, "Member 'FBrainTalkBt_PsychicCombo::ComboPlayer' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_PsychicCombo, TalkMember) == 0x000009, "Member 'FBrainTalkBt_PsychicCombo::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_PsychicCombo, ComboNumMin) == 0x00000C, "Member 'FBrainTalkBt_PsychicCombo::ComboNumMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_PsychicCombo, ComboNumMax) == 0x000010, "Member 'FBrainTalkBt_PsychicCombo::ComboNumMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_PsychicCombo, Category) == 0x000014, "Member 'FBrainTalkBt_PsychicCombo::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_PsychicCombo, DatatableId) == 0x000018, "Member 'FBrainTalkBt_PsychicCombo::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_SasCombo
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_SasCombo final : public FTableRowBase
{
public:
	EPlayerID                                     ComboPlayer;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ComboNumMin;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ComboNumMax;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_SasCombo) == 0x000008, "Wrong alignment on FBrainTalkBt_SasCombo");
static_assert(sizeof(FBrainTalkBt_SasCombo) == 0x000020, "Wrong size on FBrainTalkBt_SasCombo");
static_assert(offsetof(FBrainTalkBt_SasCombo, ComboPlayer) == 0x000008, "Member 'FBrainTalkBt_SasCombo::ComboPlayer' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasCombo, TalkMember) == 0x000009, "Member 'FBrainTalkBt_SasCombo::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasCombo, ComboNumMin) == 0x00000C, "Member 'FBrainTalkBt_SasCombo::ComboNumMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasCombo, ComboNumMax) == 0x000010, "Member 'FBrainTalkBt_SasCombo::ComboNumMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasCombo, Category) == 0x000014, "Member 'FBrainTalkBt_SasCombo::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_SasCombo, DatatableId) == 0x000018, "Member 'FBrainTalkBt_SasCombo::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_BFActivate
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_BFActivate final : public FTableRowBase
{
public:
	EPlayerID                                     ActivatePlayer;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TalkMember;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KizunaLvMin;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KizunaLvMax;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_BFActivate) == 0x000008, "Wrong alignment on FBrainTalkBt_BFActivate");
static_assert(sizeof(FBrainTalkBt_BFActivate) == 0x000020, "Wrong size on FBrainTalkBt_BFActivate");
static_assert(offsetof(FBrainTalkBt_BFActivate, ActivatePlayer) == 0x000008, "Member 'FBrainTalkBt_BFActivate::ActivatePlayer' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BFActivate, TalkMember) == 0x000009, "Member 'FBrainTalkBt_BFActivate::TalkMember' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BFActivate, KizunaLvMin) == 0x00000C, "Member 'FBrainTalkBt_BFActivate::KizunaLvMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BFActivate, KizunaLvMax) == 0x000010, "Member 'FBrainTalkBt_BFActivate::KizunaLvMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BFActivate, Category) == 0x000014, "Member 'FBrainTalkBt_BFActivate::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BFActivate, DatatableId) == 0x000018, "Member 'FBrainTalkBt_BFActivate::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_Recovery
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_Recovery final : public FTableRowBase
{
public:
	EPlayerID                                     RecoveryFrom;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     RecoveryTo;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KizunaLvMin;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KizunaLvMax;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_Recovery) == 0x000008, "Wrong alignment on FBrainTalkBt_Recovery");
static_assert(sizeof(FBrainTalkBt_Recovery) == 0x000020, "Wrong size on FBrainTalkBt_Recovery");
static_assert(offsetof(FBrainTalkBt_Recovery, RecoveryFrom) == 0x000008, "Member 'FBrainTalkBt_Recovery::RecoveryFrom' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_Recovery, RecoveryTo) == 0x000009, "Member 'FBrainTalkBt_Recovery::RecoveryTo' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_Recovery, KizunaLvMin) == 0x00000C, "Member 'FBrainTalkBt_Recovery::KizunaLvMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_Recovery, KizunaLvMax) == 0x000010, "Member 'FBrainTalkBt_Recovery::KizunaLvMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_Recovery, Category) == 0x000014, "Member 'FBrainTalkBt_Recovery::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_Recovery, DatatableId) == 0x000018, "Member 'FBrainTalkBt_Recovery::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_BadStateByEn
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_BadStateByEn final : public FTableRowBase
{
public:
	EPlayerID                                     BadStateFor;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCSkillAttribute                             BadState;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     Player;                                            // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWataruHaruka;                                    // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_BadStateByEn) == 0x000008, "Wrong alignment on FBrainTalkBt_BadStateByEn");
static_assert(sizeof(FBrainTalkBt_BadStateByEn) == 0x000018, "Wrong size on FBrainTalkBt_BadStateByEn");
static_assert(offsetof(FBrainTalkBt_BadStateByEn, BadStateFor) == 0x000008, "Member 'FBrainTalkBt_BadStateByEn::BadStateFor' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BadStateByEn, BadState) == 0x000009, "Member 'FBrainTalkBt_BadStateByEn::BadState' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BadStateByEn, Player) == 0x00000A, "Member 'FBrainTalkBt_BadStateByEn::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BadStateByEn, IsWataruHaruka) == 0x00000B, "Member 'FBrainTalkBt_BadStateByEn::IsWataruHaruka' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BadStateByEn, Category) == 0x00000C, "Member 'FBrainTalkBt_BadStateByEn::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_BadStateByEn, DatatableId) == 0x000010, "Member 'FBrainTalkBt_BadStateByEn::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_KillByEn
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkBt_KillByEn final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWataruHaruka;                                    // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_KillByEn) == 0x000008, "Wrong alignment on FBrainTalkBt_KillByEn");
static_assert(sizeof(FBrainTalkBt_KillByEn) == 0x000018, "Wrong size on FBrainTalkBt_KillByEn");
static_assert(offsetof(FBrainTalkBt_KillByEn, Player) == 0x000008, "Member 'FBrainTalkBt_KillByEn::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillByEn, IsWataruHaruka) == 0x000009, "Member 'FBrainTalkBt_KillByEn::IsWataruHaruka' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillByEn, Category) == 0x00000A, "Member 'FBrainTalkBt_KillByEn::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_KillByEn, DatatableId) == 0x00000C, "Member 'FBrainTalkBt_KillByEn::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_PlayInfo
// 0x0018 (0x0020 - 0x0008)
struct FBrainTalkBt_PlayInfo final : public FTableRowBase
{
public:
	EBrainTalkBtTag                               Tag;                                               // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     Member;                                            // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IntParam;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DatatableId;                                       // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkBt_PlayInfo) == 0x000008, "Wrong alignment on FBrainTalkBt_PlayInfo");
static_assert(sizeof(FBrainTalkBt_PlayInfo) == 0x000020, "Wrong size on FBrainTalkBt_PlayInfo");
static_assert(offsetof(FBrainTalkBt_PlayInfo, Tag) == 0x000008, "Member 'FBrainTalkBt_PlayInfo::Tag' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_PlayInfo, Member) == 0x000009, "Member 'FBrainTalkBt_PlayInfo::Member' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_PlayInfo, IntParam) == 0x00000C, "Member 'FBrainTalkBt_PlayInfo::IntParam' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_PlayInfo, Category) == 0x000010, "Member 'FBrainTalkBt_PlayInfo::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_PlayInfo, DatatableId) == 0x000014, "Member 'FBrainTalkBt_PlayInfo::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkBt_WataruHarukaExistenceProgressID
// 0x0008 (0x0010 - 0x0008)
struct FBrainTalkBt_WataruHarukaExistenceProgressID final : public FTableRowBase
{
public:
	int32                                         ProgressIdMin;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressIdMax;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkBt_WataruHarukaExistenceProgressID) == 0x000008, "Wrong alignment on FBrainTalkBt_WataruHarukaExistenceProgressID");
static_assert(sizeof(FBrainTalkBt_WataruHarukaExistenceProgressID) == 0x000010, "Wrong size on FBrainTalkBt_WataruHarukaExistenceProgressID");
static_assert(offsetof(FBrainTalkBt_WataruHarukaExistenceProgressID, ProgressIdMin) == 0x000008, "Member 'FBrainTalkBt_WataruHarukaExistenceProgressID::ProgressIdMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkBt_WataruHarukaExistenceProgressID, ProgressIdMax) == 0x00000C, "Member 'FBrainTalkBt_WataruHarukaExistenceProgressID::ProgressIdMax' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkCh_InvalidProgressID
// 0x0010 (0x0018 - 0x0008)
struct FBrainTalkCh_InvalidProgressID final : public FTableRowBase
{
public:
	int32                                         ProgressIdMin;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressIdMax;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkChGroup                             Group;                                             // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkCh_InvalidProgressID) == 0x000008, "Wrong alignment on FBrainTalkCh_InvalidProgressID");
static_assert(sizeof(FBrainTalkCh_InvalidProgressID) == 0x000018, "Wrong size on FBrainTalkCh_InvalidProgressID");
static_assert(offsetof(FBrainTalkCh_InvalidProgressID, ProgressIdMin) == 0x000008, "Member 'FBrainTalkCh_InvalidProgressID::ProgressIdMin' has a wrong offset!");
static_assert(offsetof(FBrainTalkCh_InvalidProgressID, ProgressIdMax) == 0x00000C, "Member 'FBrainTalkCh_InvalidProgressID::ProgressIdMax' has a wrong offset!");
static_assert(offsetof(FBrainTalkCh_InvalidProgressID, Group) == 0x000010, "Member 'FBrainTalkCh_InvalidProgressID::Group' has a wrong offset!");

// ScriptStruct BattlePrototype.SystemBrainTalkManageStructParam
// 0x0024 (0x0024 - 0x0000)
struct FSystemBrainTalkManageStructParam final
{
public:
	int32                                         EnableStartProgressIdYuito;                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnableStartProgressIdKasane;                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkBtGroup                             Group;                                             // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Interval;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NoBattle;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NoAjito;                                           // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NoPlBrainField;                                    // 0x0012(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NoEmBrainField;                                    // 0x0013(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BeforePlayTime;                                  // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_BattleTimeFromBeforePlay;                        // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_BeforePlayDataTableID;                           // 0x001C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSystemBrainTalkManageStructParam) == 0x000004, "Wrong alignment on FSystemBrainTalkManageStructParam");
static_assert(sizeof(FSystemBrainTalkManageStructParam) == 0x000024, "Wrong size on FSystemBrainTalkManageStructParam");
static_assert(offsetof(FSystemBrainTalkManageStructParam, EnableStartProgressIdYuito) == 0x000000, "Member 'FSystemBrainTalkManageStructParam::EnableStartProgressIdYuito' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStructParam, EnableStartProgressIdKasane) == 0x000004, "Member 'FSystemBrainTalkManageStructParam::EnableStartProgressIdKasane' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStructParam, Group) == 0x000008, "Member 'FSystemBrainTalkManageStructParam::Group' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStructParam, Interval) == 0x00000C, "Member 'FSystemBrainTalkManageStructParam::Interval' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStructParam, NoBattle) == 0x000010, "Member 'FSystemBrainTalkManageStructParam::NoBattle' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStructParam, NoAjito) == 0x000011, "Member 'FSystemBrainTalkManageStructParam::NoAjito' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStructParam, NoPlBrainField) == 0x000012, "Member 'FSystemBrainTalkManageStructParam::NoPlBrainField' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStructParam, NoEmBrainField) == 0x000013, "Member 'FSystemBrainTalkManageStructParam::NoEmBrainField' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStructParam, M_BeforePlayTime) == 0x000014, "Member 'FSystemBrainTalkManageStructParam::M_BeforePlayTime' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStructParam, M_BattleTimeFromBeforePlay) == 0x000018, "Member 'FSystemBrainTalkManageStructParam::M_BattleTimeFromBeforePlay' has a wrong offset!");
static_assert(offsetof(FSystemBrainTalkManageStructParam, M_BeforePlayDataTableID) == 0x00001C, "Member 'FSystemBrainTalkManageStructParam::M_BeforePlayDataTableID' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkCharaManageStruct
// 0x0008 (0x0010 - 0x0008)
struct FBrainTalkCharaManageStruct final : public FTableRowBase
{
public:
	EPlayerID                                     Player;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkChGroup                             Group;                                             // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkCharaManageStruct) == 0x000008, "Wrong alignment on FBrainTalkCharaManageStruct");
static_assert(sizeof(FBrainTalkCharaManageStruct) == 0x000010, "Wrong size on FBrainTalkCharaManageStruct");
static_assert(offsetof(FBrainTalkCharaManageStruct, Player) == 0x000008, "Member 'FBrainTalkCharaManageStruct::Player' has a wrong offset!");
static_assert(offsetof(FBrainTalkCharaManageStruct, Group) == 0x000009, "Member 'FBrainTalkCharaManageStruct::Group' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalk_Bt_Revival
// 0x0020 (0x0028 - 0x0008)
struct FBrainTalk_Bt_Revival final : public FTableRowBase
{
public:
	EPlayerID                                     RevivalFrom;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     RevivalTo;                                         // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Coefficient;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkCategory                            Category;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DatatableId;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalk_Bt_Revival) == 0x000008, "Wrong alignment on FBrainTalk_Bt_Revival");
static_assert(sizeof(FBrainTalk_Bt_Revival) == 0x000028, "Wrong size on FBrainTalk_Bt_Revival");
static_assert(offsetof(FBrainTalk_Bt_Revival, RevivalFrom) == 0x000008, "Member 'FBrainTalk_Bt_Revival::RevivalFrom' has a wrong offset!");
static_assert(offsetof(FBrainTalk_Bt_Revival, RevivalTo) == 0x000009, "Member 'FBrainTalk_Bt_Revival::RevivalTo' has a wrong offset!");
static_assert(offsetof(FBrainTalk_Bt_Revival, Coefficient) == 0x00000C, "Member 'FBrainTalk_Bt_Revival::Coefficient' has a wrong offset!");
static_assert(offsetof(FBrainTalk_Bt_Revival, Category) == 0x000010, "Member 'FBrainTalk_Bt_Revival::Category' has a wrong offset!");
static_assert(offsetof(FBrainTalk_Bt_Revival, DatatableId) == 0x000018, "Member 'FBrainTalk_Bt_Revival::DatatableId' has a wrong offset!");

// ScriptStruct BattlePrototype.UIMapFloorAdjustDataCore
// 0x0014 (0x0014 - 0x0000)
struct FUIMapFloorAdjustDataCore final
{
public:
	float                                         TopHeightData;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnderHeightData;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ScenarioFlag;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NotFloor;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIMapFloorAdjustDataCore) == 0x000004, "Wrong alignment on FUIMapFloorAdjustDataCore");
static_assert(sizeof(FUIMapFloorAdjustDataCore) == 0x000014, "Wrong size on FUIMapFloorAdjustDataCore");
static_assert(offsetof(FUIMapFloorAdjustDataCore, TopHeightData) == 0x000000, "Member 'FUIMapFloorAdjustDataCore::TopHeightData' has a wrong offset!");
static_assert(offsetof(FUIMapFloorAdjustDataCore, UnderHeightData) == 0x000004, "Member 'FUIMapFloorAdjustDataCore::UnderHeightData' has a wrong offset!");
static_assert(offsetof(FUIMapFloorAdjustDataCore, ScenarioFlag) == 0x000008, "Member 'FUIMapFloorAdjustDataCore::ScenarioFlag' has a wrong offset!");
static_assert(offsetof(FUIMapFloorAdjustDataCore, NotFloor) == 0x000010, "Member 'FUIMapFloorAdjustDataCore::NotFloor' has a wrong offset!");

// ScriptStruct BattlePrototype.UIMapFloorAdjustData
// 0x0020 (0x0020 - 0x0000)
struct FUIMapFloorAdjustData final
{
public:
	int32                                         ChapterNo;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScenarioNo;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinProgress;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxProgress;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FUIMapFloorAdjustDataCore>      PgAsjuster;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIMapFloorAdjustData) == 0x000008, "Wrong alignment on FUIMapFloorAdjustData");
static_assert(sizeof(FUIMapFloorAdjustData) == 0x000020, "Wrong size on FUIMapFloorAdjustData");
static_assert(offsetof(FUIMapFloorAdjustData, ChapterNo) == 0x000000, "Member 'FUIMapFloorAdjustData::ChapterNo' has a wrong offset!");
static_assert(offsetof(FUIMapFloorAdjustData, ScenarioNo) == 0x000004, "Member 'FUIMapFloorAdjustData::ScenarioNo' has a wrong offset!");
static_assert(offsetof(FUIMapFloorAdjustData, MinProgress) == 0x000008, "Member 'FUIMapFloorAdjustData::MinProgress' has a wrong offset!");
static_assert(offsetof(FUIMapFloorAdjustData, MaxProgress) == 0x00000C, "Member 'FUIMapFloorAdjustData::MaxProgress' has a wrong offset!");
static_assert(offsetof(FUIMapFloorAdjustData, PgAsjuster) == 0x000010, "Member 'FUIMapFloorAdjustData::PgAsjuster' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkMasterData
// 0x0028 (0x0030 - 0x0008)
struct FBrainTalkMasterData final : public FTableRowBase
{
public:
	class FString                                 DataFilePath;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MessageFilePath;                                   // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkPriority                            Priority;                                          // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnce;                                            // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OccurRate;                                         // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainTalkMasterData) == 0x000008, "Wrong alignment on FBrainTalkMasterData");
static_assert(sizeof(FBrainTalkMasterData) == 0x000030, "Wrong size on FBrainTalkMasterData");
static_assert(offsetof(FBrainTalkMasterData, DataFilePath) == 0x000008, "Member 'FBrainTalkMasterData::DataFilePath' has a wrong offset!");
static_assert(offsetof(FBrainTalkMasterData, MessageFilePath) == 0x000018, "Member 'FBrainTalkMasterData::MessageFilePath' has a wrong offset!");
static_assert(offsetof(FBrainTalkMasterData, Priority) == 0x000028, "Member 'FBrainTalkMasterData::Priority' has a wrong offset!");
static_assert(offsetof(FBrainTalkMasterData, IsOnce) == 0x000029, "Member 'FBrainTalkMasterData::IsOnce' has a wrong offset!");
static_assert(offsetof(FBrainTalkMasterData, OccurRate) == 0x00002C, "Member 'FBrainTalkMasterData::OccurRate' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkData
// 0x0020 (0x0028 - 0x0008)
struct FBrainTalkData final : public FTableRowBase
{
public:
	int32                                         CharacterId;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpressionID;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawSecond;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkData) == 0x000008, "Wrong alignment on FBrainTalkData");
static_assert(sizeof(FBrainTalkData) == 0x000028, "Wrong size on FBrainTalkData");
static_assert(offsetof(FBrainTalkData, CharacterId) == 0x000008, "Member 'FBrainTalkData::CharacterId' has a wrong offset!");
static_assert(offsetof(FBrainTalkData, ExpressionID) == 0x00000C, "Member 'FBrainTalkData::ExpressionID' has a wrong offset!");
static_assert(offsetof(FBrainTalkData, Message) == 0x000010, "Member 'FBrainTalkData::Message' has a wrong offset!");
static_assert(offsetof(FBrainTalkData, DrawSecond) == 0x000020, "Member 'FBrainTalkData::DrawSecond' has a wrong offset!");

// ScriptStruct BattlePrototype.CharacterDither
// 0x0018 (0x0020 - 0x0008)
struct FCharacterDither final : public FTableRowBase
{
public:
	float                                         DitherDistance;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         UseCapsuleComponentNames;                          // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterDither) == 0x000008, "Wrong alignment on FCharacterDither");
static_assert(sizeof(FCharacterDither) == 0x000020, "Wrong size on FCharacterDither");
static_assert(offsetof(FCharacterDither, DitherDistance) == 0x000008, "Member 'FCharacterDither::DitherDistance' has a wrong offset!");
static_assert(offsetof(FCharacterDither, UseCapsuleComponentNames) == 0x000010, "Member 'FCharacterDither::UseCapsuleComponentNames' has a wrong offset!");

// ScriptStruct BattlePrototype.CharacterMaterialLightSettingScalarData
// 0x000C (0x000C - 0x0000)
struct FCharacterMaterialLightSettingScalarData final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Parameter;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterMaterialLightSettingScalarData) == 0x000004, "Wrong alignment on FCharacterMaterialLightSettingScalarData");
static_assert(sizeof(FCharacterMaterialLightSettingScalarData) == 0x00000C, "Wrong size on FCharacterMaterialLightSettingScalarData");
static_assert(offsetof(FCharacterMaterialLightSettingScalarData, ParameterName) == 0x000000, "Member 'FCharacterMaterialLightSettingScalarData::ParameterName' has a wrong offset!");
static_assert(offsetof(FCharacterMaterialLightSettingScalarData, Parameter) == 0x000008, "Member 'FCharacterMaterialLightSettingScalarData::Parameter' has a wrong offset!");

// ScriptStruct BattlePrototype.CharacterMaterialLightSetting
// 0x0058 (0x0058 - 0x0000)
struct FCharacterMaterialLightSetting final
{
public:
	class UCurveFloat*                            TimelineCurve;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EndCurve;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAmbientLightGradation_Upper;                    // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           AmbientLightGradation_Upper;                       // 0x0014(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAmbientLightGradation_Lower;                    // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           AmbientLightGradation_Lower;                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCharacterMaterialLightSettingScalarData> MaterialScalar;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCharacterMaterialLightSettingVectorData> MaterialVector;                                    // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterMaterialLightSetting) == 0x000008, "Wrong alignment on FCharacterMaterialLightSetting");
static_assert(sizeof(FCharacterMaterialLightSetting) == 0x000058, "Wrong size on FCharacterMaterialLightSetting");
static_assert(offsetof(FCharacterMaterialLightSetting, TimelineCurve) == 0x000000, "Member 'FCharacterMaterialLightSetting::TimelineCurve' has a wrong offset!");
static_assert(offsetof(FCharacterMaterialLightSetting, EndCurve) == 0x000008, "Member 'FCharacterMaterialLightSetting::EndCurve' has a wrong offset!");
static_assert(offsetof(FCharacterMaterialLightSetting, UseAmbientLightGradation_Upper) == 0x000010, "Member 'FCharacterMaterialLightSetting::UseAmbientLightGradation_Upper' has a wrong offset!");
static_assert(offsetof(FCharacterMaterialLightSetting, AmbientLightGradation_Upper) == 0x000014, "Member 'FCharacterMaterialLightSetting::AmbientLightGradation_Upper' has a wrong offset!");
static_assert(offsetof(FCharacterMaterialLightSetting, UseAmbientLightGradation_Lower) == 0x000024, "Member 'FCharacterMaterialLightSetting::UseAmbientLightGradation_Lower' has a wrong offset!");
static_assert(offsetof(FCharacterMaterialLightSetting, AmbientLightGradation_Lower) == 0x000028, "Member 'FCharacterMaterialLightSetting::AmbientLightGradation_Lower' has a wrong offset!");
static_assert(offsetof(FCharacterMaterialLightSetting, MaterialScalar) == 0x000038, "Member 'FCharacterMaterialLightSetting::MaterialScalar' has a wrong offset!");
static_assert(offsetof(FCharacterMaterialLightSetting, MaterialVector) == 0x000048, "Member 'FCharacterMaterialLightSetting::MaterialVector' has a wrong offset!");

// ScriptStruct BattlePrototype.CharacterMaterialLight
// 0x0058 (0x0060 - 0x0008)
struct FCharacterMaterialLight final : public FTableRowBase
{
public:
	struct FCharacterMaterialLightSetting         Setting;                                           // 0x0008(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterMaterialLight) == 0x000008, "Wrong alignment on FCharacterMaterialLight");
static_assert(sizeof(FCharacterMaterialLight) == 0x000060, "Wrong size on FCharacterMaterialLight");
static_assert(offsetof(FCharacterMaterialLight, Setting) == 0x000008, "Member 'FCharacterMaterialLight::Setting' has a wrong offset!");

// ScriptStruct BattlePrototype.CharactersParameterTable
// 0x01F8 (0x01F8 - 0x0000)
struct FCharactersParameterTable final
{
public:
	TArray<int32>                                 MaxHp;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBrainHackGauge;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack;                                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BrainAttack;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 PhysicsDefense;                                    // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ObjDefense;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 FlameDefense;                                      // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ElectricDefense;                                   // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 WinceScale;                                        // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 KnockBackScale;                                    // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 DownScale;                                         // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 LaunchScale;                                       // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 FlameScale;                                        // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 ElectricScale;                                     // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 FloodedScale;                                      // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 OilScale;                                          // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 ConfusionScale;                                    // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 CrashScale;                                        // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 ObjCrashScale;                                     // 0x0100(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 FlameCrashScale;                                   // 0x0110(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 ElectricCrashScale;                                // 0x0120(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  PartEnable;                                        // 0x0130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  PartDestroy;                                       // 0x0140(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  CrashConfirm;                                      // 0x0150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchRange;                                       // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchAngle;                                       // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SensingArea;                                       // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CaptureArea;                                       // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveArea;                                          // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlowDisable;                                       // 0x0174(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SpecialDownEnable;                                 // 0x0175(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_176[0x2];                                      // 0x0176(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WinceResistance;                                   // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockBackResistance;                               // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownResistance;                                    // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchResistance;                                  // 0x0184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 CrashResistance;                                   // 0x0188(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlameResistance;                                   // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElectricResistance;                                // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloodedResistance;                                 // 0x01A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OilResistance;                                     // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionResistance;                               // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 AttributeResistance;                               // 0x01B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObjKnockBackRate;                                  // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WinceAttenuation;                                  // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockBackAttenuation;                              // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownAttenuation;                                   // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchAttenuation;                                 // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrashAttenuation;                                  // 0x01D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlameAttenuation;                                  // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElectricAttenuation;                               // 0x01DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloodedAttenuation;                                // 0x01E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OilAttenuation;                                    // 0x01E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionAttenuation;                              // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextExp;                                           // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropExp;                                           // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4[0x4];                                      // 0x01F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharactersParameterTable) == 0x000008, "Wrong alignment on FCharactersParameterTable");
static_assert(sizeof(FCharactersParameterTable) == 0x0001F8, "Wrong size on FCharactersParameterTable");
static_assert(offsetof(FCharactersParameterTable, MaxHp) == 0x000000, "Member 'FCharactersParameterTable::MaxHp' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, MaxBrainHackGauge) == 0x000010, "Member 'FCharactersParameterTable::MaxBrainHackGauge' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, Attack) == 0x000014, "Member 'FCharactersParameterTable::Attack' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, BrainAttack) == 0x000018, "Member 'FCharactersParameterTable::BrainAttack' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, PhysicsDefense) == 0x000020, "Member 'FCharactersParameterTable::PhysicsDefense' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, ObjDefense) == 0x000030, "Member 'FCharactersParameterTable::ObjDefense' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, FlameDefense) == 0x000040, "Member 'FCharactersParameterTable::FlameDefense' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, ElectricDefense) == 0x000050, "Member 'FCharactersParameterTable::ElectricDefense' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, WinceScale) == 0x000060, "Member 'FCharactersParameterTable::WinceScale' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, KnockBackScale) == 0x000070, "Member 'FCharactersParameterTable::KnockBackScale' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, DownScale) == 0x000080, "Member 'FCharactersParameterTable::DownScale' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, LaunchScale) == 0x000090, "Member 'FCharactersParameterTable::LaunchScale' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, FlameScale) == 0x0000A0, "Member 'FCharactersParameterTable::FlameScale' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, ElectricScale) == 0x0000B0, "Member 'FCharactersParameterTable::ElectricScale' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, FloodedScale) == 0x0000C0, "Member 'FCharactersParameterTable::FloodedScale' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, OilScale) == 0x0000D0, "Member 'FCharactersParameterTable::OilScale' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, ConfusionScale) == 0x0000E0, "Member 'FCharactersParameterTable::ConfusionScale' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, CrashScale) == 0x0000F0, "Member 'FCharactersParameterTable::CrashScale' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, ObjCrashScale) == 0x000100, "Member 'FCharactersParameterTable::ObjCrashScale' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, FlameCrashScale) == 0x000110, "Member 'FCharactersParameterTable::FlameCrashScale' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, ElectricCrashScale) == 0x000120, "Member 'FCharactersParameterTable::ElectricCrashScale' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, PartEnable) == 0x000130, "Member 'FCharactersParameterTable::PartEnable' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, PartDestroy) == 0x000140, "Member 'FCharactersParameterTable::PartDestroy' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, CrashConfirm) == 0x000150, "Member 'FCharactersParameterTable::CrashConfirm' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, SearchRange) == 0x000160, "Member 'FCharactersParameterTable::SearchRange' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, SearchAngle) == 0x000164, "Member 'FCharactersParameterTable::SearchAngle' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, SensingArea) == 0x000168, "Member 'FCharactersParameterTable::SensingArea' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, CaptureArea) == 0x00016C, "Member 'FCharactersParameterTable::CaptureArea' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, MoveArea) == 0x000170, "Member 'FCharactersParameterTable::MoveArea' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, BlowDisable) == 0x000174, "Member 'FCharactersParameterTable::BlowDisable' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, SpecialDownEnable) == 0x000175, "Member 'FCharactersParameterTable::SpecialDownEnable' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, WinceResistance) == 0x000178, "Member 'FCharactersParameterTable::WinceResistance' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, KnockBackResistance) == 0x00017C, "Member 'FCharactersParameterTable::KnockBackResistance' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, DownResistance) == 0x000180, "Member 'FCharactersParameterTable::DownResistance' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, LaunchResistance) == 0x000184, "Member 'FCharactersParameterTable::LaunchResistance' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, CrashResistance) == 0x000188, "Member 'FCharactersParameterTable::CrashResistance' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, FlameResistance) == 0x000198, "Member 'FCharactersParameterTable::FlameResistance' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, ElectricResistance) == 0x00019C, "Member 'FCharactersParameterTable::ElectricResistance' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, FloodedResistance) == 0x0001A0, "Member 'FCharactersParameterTable::FloodedResistance' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, OilResistance) == 0x0001A4, "Member 'FCharactersParameterTable::OilResistance' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, ConfusionResistance) == 0x0001A8, "Member 'FCharactersParameterTable::ConfusionResistance' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, AttributeResistance) == 0x0001B0, "Member 'FCharactersParameterTable::AttributeResistance' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, ObjKnockBackRate) == 0x0001C0, "Member 'FCharactersParameterTable::ObjKnockBackRate' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, WinceAttenuation) == 0x0001C4, "Member 'FCharactersParameterTable::WinceAttenuation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, KnockBackAttenuation) == 0x0001C8, "Member 'FCharactersParameterTable::KnockBackAttenuation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, DownAttenuation) == 0x0001CC, "Member 'FCharactersParameterTable::DownAttenuation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, LaunchAttenuation) == 0x0001D0, "Member 'FCharactersParameterTable::LaunchAttenuation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, CrashAttenuation) == 0x0001D4, "Member 'FCharactersParameterTable::CrashAttenuation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, FlameAttenuation) == 0x0001D8, "Member 'FCharactersParameterTable::FlameAttenuation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, ElectricAttenuation) == 0x0001DC, "Member 'FCharactersParameterTable::ElectricAttenuation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, FloodedAttenuation) == 0x0001E0, "Member 'FCharactersParameterTable::FloodedAttenuation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, OilAttenuation) == 0x0001E4, "Member 'FCharactersParameterTable::OilAttenuation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, ConfusionAttenuation) == 0x0001E8, "Member 'FCharactersParameterTable::ConfusionAttenuation' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, NextExp) == 0x0001EC, "Member 'FCharactersParameterTable::NextExp' has a wrong offset!");
static_assert(offsetof(FCharactersParameterTable, DropExp) == 0x0001F0, "Member 'FCharactersParameterTable::DropExp' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosSaveImageBuf
// 0x0010 (0x0010 - 0x0000)
struct FCosmosSaveImageBuf final
{
public:
	TArray<uint8>                                 Buff;                                              // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosSaveImageBuf) == 0x000008, "Wrong alignment on FCosmosSaveImageBuf");
static_assert(sizeof(FCosmosSaveImageBuf) == 0x000010, "Wrong size on FCosmosSaveImageBuf");
static_assert(offsetof(FCosmosSaveImageBuf, Buff) == 0x000000, "Member 'FCosmosSaveImageBuf::Buff' has a wrong offset!");

// ScriptStruct BattlePrototype.AnimeInterlockingURL
// 0x0020 (0x0020 - 0x0000)
struct FAnimeInterlockingURL final
{
public:
	class FString                                 QuestName;                                         // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 URL;                                               // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimeInterlockingURL) == 0x000008, "Wrong alignment on FAnimeInterlockingURL");
static_assert(sizeof(FAnimeInterlockingURL) == 0x000020, "Wrong size on FAnimeInterlockingURL");
static_assert(offsetof(FAnimeInterlockingURL, QuestName) == 0x000000, "Member 'FAnimeInterlockingURL::QuestName' has a wrong offset!");
static_assert(offsetof(FAnimeInterlockingURL, URL) == 0x000010, "Member 'FAnimeInterlockingURL::URL' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosHugeTssReadListResponse
// 0x0018 (0x0018 - 0x0000)
struct FCosmosHugeTssReadListResponse final
{
public:
	int32                                         Status;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCosmosHugeTSSData>             TssDataList;                                       // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosHugeTssReadListResponse) == 0x000008, "Wrong alignment on FCosmosHugeTssReadListResponse");
static_assert(sizeof(FCosmosHugeTssReadListResponse) == 0x000018, "Wrong size on FCosmosHugeTssReadListResponse");
static_assert(offsetof(FCosmosHugeTssReadListResponse, Status) == 0x000000, "Member 'FCosmosHugeTssReadListResponse::Status' has a wrong offset!");
static_assert(offsetof(FCosmosHugeTssReadListResponse, TssDataList) == 0x000008, "Member 'FCosmosHugeTssReadListResponse::TssDataList' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosHugeTssReadListParam
// 0x000C (0x000C - 0x0000)
struct FCosmosHugeTssReadListParam final
{
public:
	int32                                         Region;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Use;                                               // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Language;                                          // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosHugeTssReadListParam) == 0x000004, "Wrong alignment on FCosmosHugeTssReadListParam");
static_assert(sizeof(FCosmosHugeTssReadListParam) == 0x00000C, "Wrong size on FCosmosHugeTssReadListParam");
static_assert(offsetof(FCosmosHugeTssReadListParam, Region) == 0x000000, "Member 'FCosmosHugeTssReadListParam::Region' has a wrong offset!");
static_assert(offsetof(FCosmosHugeTssReadListParam, Use) == 0x000004, "Member 'FCosmosHugeTssReadListParam::Use' has a wrong offset!");
static_assert(offsetof(FCosmosHugeTssReadListParam, Language) == 0x000008, "Member 'FCosmosHugeTssReadListParam::Language' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosSavedataDeleteParam
// 0x0018 (0x0018 - 0x0000)
struct FCosmosSavedataDeleteParam final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotNo;                                            // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCosmosSavedataDeleteParam) == 0x000008, "Wrong alignment on FCosmosSavedataDeleteParam");
static_assert(sizeof(FCosmosSavedataDeleteParam) == 0x000018, "Wrong size on FCosmosSavedataDeleteParam");
static_assert(offsetof(FCosmosSavedataDeleteParam, UserId) == 0x000000, "Member 'FCosmosSavedataDeleteParam::UserId' has a wrong offset!");
static_assert(offsetof(FCosmosSavedataDeleteParam, SlotNo) == 0x000010, "Member 'FCosmosSavedataDeleteParam::SlotNo' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosSavedataDownloadParam
// 0x0018 (0x0018 - 0x0000)
struct FCosmosSavedataDownloadParam final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotNo;                                            // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCosmosSavedataDownloadParam) == 0x000008, "Wrong alignment on FCosmosSavedataDownloadParam");
static_assert(sizeof(FCosmosSavedataDownloadParam) == 0x000018, "Wrong size on FCosmosSavedataDownloadParam");
static_assert(offsetof(FCosmosSavedataDownloadParam, UserId) == 0x000000, "Member 'FCosmosSavedataDownloadParam::UserId' has a wrong offset!");
static_assert(offsetof(FCosmosSavedataDownloadParam, SlotNo) == 0x000010, "Member 'FCosmosSavedataDownloadParam::SlotNo' has a wrong offset!");

// ScriptStruct BattlePrototype.UserSystemParam
// 0x0006 (0x0006 - 0x0000)
struct FUserSystemParam final
{
public:
	bool                                          IsZeroEpClear;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGameClear;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCEBANK;                                          // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPrivacyPolicy;                                   // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEULA;                                            // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTitleProductFlag;                                // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUserSystemParam) == 0x000001, "Wrong alignment on FUserSystemParam");
static_assert(sizeof(FUserSystemParam) == 0x000006, "Wrong size on FUserSystemParam");
static_assert(offsetof(FUserSystemParam, IsZeroEpClear) == 0x000000, "Member 'FUserSystemParam::IsZeroEpClear' has a wrong offset!");
static_assert(offsetof(FUserSystemParam, IsGameClear) == 0x000001, "Member 'FUserSystemParam::IsGameClear' has a wrong offset!");
static_assert(offsetof(FUserSystemParam, IsCEBANK) == 0x000002, "Member 'FUserSystemParam::IsCEBANK' has a wrong offset!");
static_assert(offsetof(FUserSystemParam, IsPrivacyPolicy) == 0x000003, "Member 'FUserSystemParam::IsPrivacyPolicy' has a wrong offset!");
static_assert(offsetof(FUserSystemParam, IsEULA) == 0x000004, "Member 'FUserSystemParam::IsEULA' has a wrong offset!");
static_assert(offsetof(FUserSystemParam, IsTitleProductFlag) == 0x000005, "Member 'FUserSystemParam::IsTitleProductFlag' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosSavedataUploadParam
// 0x0048 (0x0048 - 0x0000)
struct FCosmosSavedataUploadParam final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotNo;                                            // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SlotLabel;                                         // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SaveData;                                          // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HashKey;                                           // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosSavedataUploadParam) == 0x000008, "Wrong alignment on FCosmosSavedataUploadParam");
static_assert(sizeof(FCosmosSavedataUploadParam) == 0x000048, "Wrong size on FCosmosSavedataUploadParam");
static_assert(offsetof(FCosmosSavedataUploadParam, UserId) == 0x000000, "Member 'FCosmosSavedataUploadParam::UserId' has a wrong offset!");
static_assert(offsetof(FCosmosSavedataUploadParam, SlotNo) == 0x000010, "Member 'FCosmosSavedataUploadParam::SlotNo' has a wrong offset!");
static_assert(offsetof(FCosmosSavedataUploadParam, SlotLabel) == 0x000018, "Member 'FCosmosSavedataUploadParam::SlotLabel' has a wrong offset!");
static_assert(offsetof(FCosmosSavedataUploadParam, SaveData) == 0x000028, "Member 'FCosmosSavedataUploadParam::SaveData' has a wrong offset!");
static_assert(offsetof(FCosmosSavedataUploadParam, HashKey) == 0x000038, "Member 'FCosmosSavedataUploadParam::HashKey' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosRankingGetByRangeResponse
// 0x0030 (0x0030 - 0x0000)
struct FCosmosRankingGetByRangeResponse final
{
public:
	int32                                         Status;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AreaName;                                          // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SumNum;                                            // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ListNum;                                           // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCosmosRankingList>             RankingList;                                       // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosRankingGetByRangeResponse) == 0x000008, "Wrong alignment on FCosmosRankingGetByRangeResponse");
static_assert(sizeof(FCosmosRankingGetByRangeResponse) == 0x000030, "Wrong size on FCosmosRankingGetByRangeResponse");
static_assert(offsetof(FCosmosRankingGetByRangeResponse, Status) == 0x000000, "Member 'FCosmosRankingGetByRangeResponse::Status' has a wrong offset!");
static_assert(offsetof(FCosmosRankingGetByRangeResponse, AreaName) == 0x000008, "Member 'FCosmosRankingGetByRangeResponse::AreaName' has a wrong offset!");
static_assert(offsetof(FCosmosRankingGetByRangeResponse, SumNum) == 0x000018, "Member 'FCosmosRankingGetByRangeResponse::SumNum' has a wrong offset!");
static_assert(offsetof(FCosmosRankingGetByRangeResponse, ListNum) == 0x00001C, "Member 'FCosmosRankingGetByRangeResponse::ListNum' has a wrong offset!");
static_assert(offsetof(FCosmosRankingGetByRangeResponse, RankingList) == 0x000020, "Member 'FCosmosRankingGetByRangeResponse::RankingList' has a wrong offset!");

// ScriptStruct BattlePrototype.CreditStaffNameDouble
// 0x0018 (0x0038 - 0x0020)
struct FCreditStaffNameDouble final : public FCreditPartsBase
{
public:
	class USpacer*                                Spacer;                                            // 0x0020(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextStaff1;                                        // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextStaff2;                                        // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreditStaffNameDouble) == 0x000008, "Wrong alignment on FCreditStaffNameDouble");
static_assert(sizeof(FCreditStaffNameDouble) == 0x000038, "Wrong size on FCreditStaffNameDouble");
static_assert(offsetof(FCreditStaffNameDouble, Spacer) == 0x000020, "Member 'FCreditStaffNameDouble::Spacer' has a wrong offset!");
static_assert(offsetof(FCreditStaffNameDouble, TextStaff1) == 0x000028, "Member 'FCreditStaffNameDouble::TextStaff1' has a wrong offset!");
static_assert(offsetof(FCreditStaffNameDouble, TextStaff2) == 0x000030, "Member 'FCreditStaffNameDouble::TextStaff2' has a wrong offset!");

// ScriptStruct BattlePrototype.ActorReferenceInfo
// 0x0030 (0x0030 - 0x0000)
struct FActorReferenceInfo final
{
public:
	class FString                                 ReferenceName;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PackageName;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetName;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorReferenceInfo) == 0x000008, "Wrong alignment on FActorReferenceInfo");
static_assert(sizeof(FActorReferenceInfo) == 0x000030, "Wrong size on FActorReferenceInfo");
static_assert(offsetof(FActorReferenceInfo, ReferenceName) == 0x000000, "Member 'FActorReferenceInfo::ReferenceName' has a wrong offset!");
static_assert(offsetof(FActorReferenceInfo, PackageName) == 0x000010, "Member 'FActorReferenceInfo::PackageName' has a wrong offset!");
static_assert(offsetof(FActorReferenceInfo, AssetName) == 0x000020, "Member 'FActorReferenceInfo::AssetName' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosRankingGetByRangeParam
// 0x0020 (0x0020 - 0x0000)
struct FCosmosRankingGetByRangeParam final
{
public:
	class FString                                 AreaName;                                          // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RankingType;                                       // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartRank;                                         // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GetNum;                                            // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCosmosRankingGetByRangeParam) == 0x000008, "Wrong alignment on FCosmosRankingGetByRangeParam");
static_assert(sizeof(FCosmosRankingGetByRangeParam) == 0x000020, "Wrong size on FCosmosRankingGetByRangeParam");
static_assert(offsetof(FCosmosRankingGetByRangeParam, AreaName) == 0x000000, "Member 'FCosmosRankingGetByRangeParam::AreaName' has a wrong offset!");
static_assert(offsetof(FCosmosRankingGetByRangeParam, RankingType) == 0x000010, "Member 'FCosmosRankingGetByRangeParam::RankingType' has a wrong offset!");
static_assert(offsetof(FCosmosRankingGetByRangeParam, StartRank) == 0x000014, "Member 'FCosmosRankingGetByRangeParam::StartRank' has a wrong offset!");
static_assert(offsetof(FCosmosRankingGetByRangeParam, GetNum) == 0x000018, "Member 'FCosmosRankingGetByRangeParam::GetNum' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosRankingSetScoreResponse
// 0x0004 (0x0004 - 0x0000)
struct FCosmosRankingSetScoreResponse final
{
public:
	int32                                         Status;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosRankingSetScoreResponse) == 0x000004, "Wrong alignment on FCosmosRankingSetScoreResponse");
static_assert(sizeof(FCosmosRankingSetScoreResponse) == 0x000004, "Wrong size on FCosmosRankingSetScoreResponse");
static_assert(offsetof(FCosmosRankingSetScoreResponse, Status) == 0x000000, "Member 'FCosmosRankingSetScoreResponse::Status' has a wrong offset!");

// ScriptStruct BattlePrototype.BondsLevelupExpData
// 0x0010 (0x0010 - 0x0000)
struct FBondsLevelupExpData final
{
public:
	TArray<int32>                                 ExpList;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBondsLevelupExpData) == 0x000008, "Wrong alignment on FBondsLevelupExpData");
static_assert(sizeof(FBondsLevelupExpData) == 0x000010, "Wrong size on FBondsLevelupExpData");
static_assert(offsetof(FBondsLevelupExpData, ExpList) == 0x000000, "Member 'FBondsLevelupExpData::ExpList' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosRankingSetScoreParam
// 0x0028 (0x0028 - 0x0000)
struct FCosmosRankingSetScoreParam final
{
public:
	class FString                                 AreaName;                                          // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Score;                                             // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UserData;                                          // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosRankingSetScoreParam) == 0x000008, "Wrong alignment on FCosmosRankingSetScoreParam");
static_assert(sizeof(FCosmosRankingSetScoreParam) == 0x000028, "Wrong size on FCosmosRankingSetScoreParam");
static_assert(offsetof(FCosmosRankingSetScoreParam, AreaName) == 0x000000, "Member 'FCosmosRankingSetScoreParam::AreaName' has a wrong offset!");
static_assert(offsetof(FCosmosRankingSetScoreParam, Score) == 0x000010, "Member 'FCosmosRankingSetScoreParam::Score' has a wrong offset!");
static_assert(offsetof(FCosmosRankingSetScoreParam, UserData) == 0x000018, "Member 'FCosmosRankingSetScoreParam::UserData' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosRankingGetMasterList
// 0x0030 (0x0030 - 0x0000)
struct FCosmosRankingGetMasterList final
{
public:
	class FString                                 RankingId;                                         // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortType;                                          // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScoreType;                                         // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SetType;                                           // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RankingInfo;                                       // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosRankingGetMasterList) == 0x000008, "Wrong alignment on FCosmosRankingGetMasterList");
static_assert(sizeof(FCosmosRankingGetMasterList) == 0x000030, "Wrong size on FCosmosRankingGetMasterList");
static_assert(offsetof(FCosmosRankingGetMasterList, RankingId) == 0x000000, "Member 'FCosmosRankingGetMasterList::RankingId' has a wrong offset!");
static_assert(offsetof(FCosmosRankingGetMasterList, SortType) == 0x000010, "Member 'FCosmosRankingGetMasterList::SortType' has a wrong offset!");
static_assert(offsetof(FCosmosRankingGetMasterList, ScoreType) == 0x000014, "Member 'FCosmosRankingGetMasterList::ScoreType' has a wrong offset!");
static_assert(offsetof(FCosmosRankingGetMasterList, SetType) == 0x000018, "Member 'FCosmosRankingGetMasterList::SetType' has a wrong offset!");
static_assert(offsetof(FCosmosRankingGetMasterList, RankingInfo) == 0x000020, "Member 'FCosmosRankingGetMasterList::RankingInfo' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosRankingGetMasterResponse
// 0x0018 (0x0018 - 0x0000)
struct FCosmosRankingGetMasterResponse final
{
public:
	int32                                         Status;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCosmosRankingGetMasterList>    MasterList;                                        // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosRankingGetMasterResponse) == 0x000008, "Wrong alignment on FCosmosRankingGetMasterResponse");
static_assert(sizeof(FCosmosRankingGetMasterResponse) == 0x000018, "Wrong size on FCosmosRankingGetMasterResponse");
static_assert(offsetof(FCosmosRankingGetMasterResponse, Status) == 0x000000, "Member 'FCosmosRankingGetMasterResponse::Status' has a wrong offset!");
static_assert(offsetof(FCosmosRankingGetMasterResponse, MasterList) == 0x000008, "Member 'FCosmosRankingGetMasterResponse::MasterList' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoNpcAttach
// 0x0020 (0x0020 - 0x0000)
struct FAjitoNpcAttach final
{
public:
	class FName                                   AttachBoneName;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AttachActor;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttachOffset;                                      // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAjitoNpcAttach) == 0x000008, "Wrong alignment on FAjitoNpcAttach");
static_assert(sizeof(FAjitoNpcAttach) == 0x000020, "Wrong size on FAjitoNpcAttach");
static_assert(offsetof(FAjitoNpcAttach, AttachBoneName) == 0x000000, "Member 'FAjitoNpcAttach::AttachBoneName' has a wrong offset!");
static_assert(offsetof(FAjitoNpcAttach, AttachActor) == 0x000008, "Member 'FAjitoNpcAttach::AttachActor' has a wrong offset!");
static_assert(offsetof(FAjitoNpcAttach, AttachOffset) == 0x000010, "Member 'FAjitoNpcAttach::AttachOffset' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosTusWriteResponse
// 0x0004 (0x0004 - 0x0000)
struct FCosmosTusWriteResponse final
{
public:
	int32                                         Status;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosTusWriteResponse) == 0x000004, "Wrong alignment on FCosmosTusWriteResponse");
static_assert(sizeof(FCosmosTusWriteResponse) == 0x000004, "Wrong size on FCosmosTusWriteResponse");
static_assert(offsetof(FCosmosTusWriteResponse, Status) == 0x000000, "Member 'FCosmosTusWriteResponse::Status' has a wrong offset!");

// ScriptStruct BattlePrototype.MsgViewerDispNameAndPath
// 0x0020 (0x0020 - 0x0000)
struct FMsgViewerDispNameAndPath final
{
public:
	class FString                                 DispName;                                          // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DataPath;                                          // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgViewerDispNameAndPath) == 0x000008, "Wrong alignment on FMsgViewerDispNameAndPath");
static_assert(sizeof(FMsgViewerDispNameAndPath) == 0x000020, "Wrong size on FMsgViewerDispNameAndPath");
static_assert(offsetof(FMsgViewerDispNameAndPath, DispName) == 0x000000, "Member 'FMsgViewerDispNameAndPath::DispName' has a wrong offset!");
static_assert(offsetof(FMsgViewerDispNameAndPath, DataPath) == 0x000010, "Member 'FMsgViewerDispNameAndPath::DataPath' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosTusWriteParam
// 0x0018 (0x0018 - 0x0000)
struct FCosmosTusWriteParam final
{
public:
	int32                                         SlotNo;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TusData;                                           // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosTusWriteParam) == 0x000008, "Wrong alignment on FCosmosTusWriteParam");
static_assert(sizeof(FCosmosTusWriteParam) == 0x000018, "Wrong size on FCosmosTusWriteParam");
static_assert(offsetof(FCosmosTusWriteParam, SlotNo) == 0x000000, "Member 'FCosmosTusWriteParam::SlotNo' has a wrong offset!");
static_assert(offsetof(FCosmosTusWriteParam, TusData) == 0x000008, "Member 'FCosmosTusWriteParam::TusData' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosTusReadResponse
// 0x0018 (0x0018 - 0x0000)
struct FCosmosTusReadResponse final
{
public:
	int32                                         Status;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TusData;                                           // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosTusReadResponse) == 0x000008, "Wrong alignment on FCosmosTusReadResponse");
static_assert(sizeof(FCosmosTusReadResponse) == 0x000018, "Wrong size on FCosmosTusReadResponse");
static_assert(offsetof(FCosmosTusReadResponse, Status) == 0x000000, "Member 'FCosmosTusReadResponse::Status' has a wrong offset!");
static_assert(offsetof(FCosmosTusReadResponse, TusData) == 0x000008, "Member 'FCosmosTusReadResponse::TusData' has a wrong offset!");

// ScriptStruct BattlePrototype.TeamBondsLevelupCharData
// 0x0020 (0x0020 - 0x0000)
struct FTeamBondsLevelupCharData final
{
public:
	EPlayerID                                     CharaID;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BondsLv;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BondsEp;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Present;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamBondsLevelupCharData) == 0x000008, "Wrong alignment on FTeamBondsLevelupCharData");
static_assert(sizeof(FTeamBondsLevelupCharData) == 0x000020, "Wrong size on FTeamBondsLevelupCharData");
static_assert(offsetof(FTeamBondsLevelupCharData, CharaID) == 0x000000, "Member 'FTeamBondsLevelupCharData::CharaID' has a wrong offset!");
static_assert(offsetof(FTeamBondsLevelupCharData, BondsLv) == 0x000004, "Member 'FTeamBondsLevelupCharData::BondsLv' has a wrong offset!");
static_assert(offsetof(FTeamBondsLevelupCharData, BondsEp) == 0x000008, "Member 'FTeamBondsLevelupCharData::BondsEp' has a wrong offset!");
static_assert(offsetof(FTeamBondsLevelupCharData, Present) == 0x000010, "Member 'FTeamBondsLevelupCharData::Present' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosTusReadParam
// 0x0018 (0x0018 - 0x0000)
struct FCosmosTusReadParam final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotNo;                                            // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCosmosTusReadParam) == 0x000008, "Wrong alignment on FCosmosTusReadParam");
static_assert(sizeof(FCosmosTusReadParam) == 0x000018, "Wrong size on FCosmosTusReadParam");
static_assert(offsetof(FCosmosTusReadParam, UserId) == 0x000000, "Member 'FCosmosTusReadParam::UserId' has a wrong offset!");
static_assert(offsetof(FCosmosTusReadParam, SlotNo) == 0x000010, "Member 'FCosmosTusReadParam::SlotNo' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosTusData
// 0x0028 (0x0028 - 0x0000)
struct FCosmosTusData final
{
public:
	struct FVector                                Pos;                                               // 0x0000(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotate;                                            // 0x000C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 Image;                                             // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosTusData) == 0x000008, "Wrong alignment on FCosmosTusData");
static_assert(sizeof(FCosmosTusData) == 0x000028, "Wrong size on FCosmosTusData");
static_assert(offsetof(FCosmosTusData, Pos) == 0x000000, "Member 'FCosmosTusData::Pos' has a wrong offset!");
static_assert(offsetof(FCosmosTusData, Rotate) == 0x00000C, "Member 'FCosmosTusData::Rotate' has a wrong offset!");
static_assert(offsetof(FCosmosTusData, Image) == 0x000018, "Member 'FCosmosTusData::Image' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryMessageParam
// 0x000C (0x000C - 0x0000)
struct FLibraryMessageParam final
{
public:
	ELibraryFlagType                              ChkFlag;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MsgID;                                             // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryMessageParam) == 0x000004, "Wrong alignment on FLibraryMessageParam");
static_assert(sizeof(FLibraryMessageParam) == 0x00000C, "Wrong size on FLibraryMessageParam");
static_assert(offsetof(FLibraryMessageParam, ChkFlag) == 0x000000, "Member 'FLibraryMessageParam::ChkFlag' has a wrong offset!");
static_assert(offsetof(FLibraryMessageParam, MsgID) == 0x000004, "Member 'FLibraryMessageParam::MsgID' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosUserConvertInfo
// 0x0020 (0x0020 - 0x0000)
struct FCosmosUserConvertInfo final
{
public:
	class FString                                 PlatformUserID;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CosmosUserID;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosUserConvertInfo) == 0x000008, "Wrong alignment on FCosmosUserConvertInfo");
static_assert(sizeof(FCosmosUserConvertInfo) == 0x000020, "Wrong size on FCosmosUserConvertInfo");
static_assert(offsetof(FCosmosUserConvertInfo, PlatformUserID) == 0x000000, "Member 'FCosmosUserConvertInfo::PlatformUserID' has a wrong offset!");
static_assert(offsetof(FCosmosUserConvertInfo, CosmosUserID) == 0x000010, "Member 'FCosmosUserConvertInfo::CosmosUserID' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosUserConvertUserIdResponseParam
// 0x0018 (0x0018 - 0x0000)
struct FCosmosUserConvertUserIdResponseParam final
{
public:
	int32                                         Status;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCosmosUserConvertInfo>         UserConvertInfo;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosUserConvertUserIdResponseParam) == 0x000008, "Wrong alignment on FCosmosUserConvertUserIdResponseParam");
static_assert(sizeof(FCosmosUserConvertUserIdResponseParam) == 0x000018, "Wrong size on FCosmosUserConvertUserIdResponseParam");
static_assert(offsetof(FCosmosUserConvertUserIdResponseParam, Status) == 0x000000, "Member 'FCosmosUserConvertUserIdResponseParam::Status' has a wrong offset!");
static_assert(offsetof(FCosmosUserConvertUserIdResponseParam, UserConvertInfo) == 0x000008, "Member 'FCosmosUserConvertUserIdResponseParam::UserConvertInfo' has a wrong offset!");

// ScriptStruct BattlePrototype.OneShopDescPayment
// 0x0008 (0x0008 - 0x0000)
struct FOneShopDescPayment final
{
public:
	class UUserWidget*                            Widget;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOneShopDescPayment) == 0x000008, "Wrong alignment on FOneShopDescPayment");
static_assert(sizeof(FOneShopDescPayment) == 0x000008, "Wrong size on FOneShopDescPayment");
static_assert(offsetof(FOneShopDescPayment, Widget) == 0x000000, "Member 'FOneShopDescPayment::Widget' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryEnemyDataCell
// 0x0040 (0x0040 - 0x0000)
struct FLibraryEnemyDataCell final
{
public:
	class FName                                   EnemyID;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           DetailMsg;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ImageNum;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DropItems;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Habitat;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryEnemyDataCell) == 0x000008, "Wrong alignment on FLibraryEnemyDataCell");
static_assert(sizeof(FLibraryEnemyDataCell) == 0x000040, "Wrong size on FLibraryEnemyDataCell");
static_assert(offsetof(FLibraryEnemyDataCell, EnemyID) == 0x000000, "Member 'FLibraryEnemyDataCell::EnemyID' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyDataCell, DetailMsg) == 0x000008, "Member 'FLibraryEnemyDataCell::DetailMsg' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyDataCell, ImageNum) == 0x000018, "Member 'FLibraryEnemyDataCell::ImageNum' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyDataCell, DropItems) == 0x000020, "Member 'FLibraryEnemyDataCell::DropItems' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyDataCell, Habitat) == 0x000030, "Member 'FLibraryEnemyDataCell::Habitat' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosUserResponseV2
// 0x0020 (0x0020 - 0x0000)
struct FCosmosUserResponseV2 final
{
public:
	int32                                         Status;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UserId;                                            // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECosmosRegistType                             RegisterStatus;                                    // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCosmosUserResponseV2) == 0x000008, "Wrong alignment on FCosmosUserResponseV2");
static_assert(sizeof(FCosmosUserResponseV2) == 0x000020, "Wrong size on FCosmosUserResponseV2");
static_assert(offsetof(FCosmosUserResponseV2, Status) == 0x000000, "Member 'FCosmosUserResponseV2::Status' has a wrong offset!");
static_assert(offsetof(FCosmosUserResponseV2, UserId) == 0x000008, "Member 'FCosmosUserResponseV2::UserId' has a wrong offset!");
static_assert(offsetof(FCosmosUserResponseV2, RegisterStatus) == 0x000018, "Member 'FCosmosUserResponseV2::RegisterStatus' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosUserResponse
// 0x0018 (0x0018 - 0x0000)
struct FCosmosUserResponse final
{
public:
	int32                                         Status;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UserId;                                            // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosUserResponse) == 0x000008, "Wrong alignment on FCosmosUserResponse");
static_assert(sizeof(FCosmosUserResponse) == 0x000018, "Wrong size on FCosmosUserResponse");
static_assert(offsetof(FCosmosUserResponse, Status) == 0x000000, "Member 'FCosmosUserResponse::Status' has a wrong offset!");
static_assert(offsetof(FCosmosUserResponse, UserId) == 0x000008, "Member 'FCosmosUserResponse::UserId' has a wrong offset!");

// ScriptStruct BattlePrototype.RSStreamingSettings
// 0x0020 (0x0028 - 0x0008)
struct FRSStreamingSettings final : public FTableRowBase
{
public:
	int32                                         UseBackgroundLevelStreaming;                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AsyncLoadingTimeLimit;                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ASyncLoadingUseFullTimeLimit;                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PriorityAsyncLoadingExtraTime;                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelStreamingActorsUpdateTimeLimit;               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelStreamingComponentsRegistrationGranularity;   // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelStreamingComponentsUnregistrationGranularity; // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelStreamingUnregisterComponentsTimeLimit;       // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRSStreamingSettings) == 0x000008, "Wrong alignment on FRSStreamingSettings");
static_assert(sizeof(FRSStreamingSettings) == 0x000028, "Wrong size on FRSStreamingSettings");
static_assert(offsetof(FRSStreamingSettings, UseBackgroundLevelStreaming) == 0x000008, "Member 'FRSStreamingSettings::UseBackgroundLevelStreaming' has a wrong offset!");
static_assert(offsetof(FRSStreamingSettings, AsyncLoadingTimeLimit) == 0x00000C, "Member 'FRSStreamingSettings::AsyncLoadingTimeLimit' has a wrong offset!");
static_assert(offsetof(FRSStreamingSettings, ASyncLoadingUseFullTimeLimit) == 0x000010, "Member 'FRSStreamingSettings::ASyncLoadingUseFullTimeLimit' has a wrong offset!");
static_assert(offsetof(FRSStreamingSettings, PriorityAsyncLoadingExtraTime) == 0x000014, "Member 'FRSStreamingSettings::PriorityAsyncLoadingExtraTime' has a wrong offset!");
static_assert(offsetof(FRSStreamingSettings, LevelStreamingActorsUpdateTimeLimit) == 0x000018, "Member 'FRSStreamingSettings::LevelStreamingActorsUpdateTimeLimit' has a wrong offset!");
static_assert(offsetof(FRSStreamingSettings, LevelStreamingComponentsRegistrationGranularity) == 0x00001C, "Member 'FRSStreamingSettings::LevelStreamingComponentsRegistrationGranularity' has a wrong offset!");
static_assert(offsetof(FRSStreamingSettings, LevelStreamingComponentsUnregistrationGranularity) == 0x000020, "Member 'FRSStreamingSettings::LevelStreamingComponentsUnregistrationGranularity' has a wrong offset!");
static_assert(offsetof(FRSStreamingSettings, LevelStreamingUnregisterComponentsTimeLimit) == 0x000024, "Member 'FRSStreamingSettings::LevelStreamingUnregisterComponentsTimeLimit' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosUserParam
// 0x0028 (0x0028 - 0x0000)
struct FCosmosUserParam final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Talken;                                            // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkuType;                                           // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCosmosUserParam) == 0x000008, "Wrong alignment on FCosmosUserParam");
static_assert(sizeof(FCosmosUserParam) == 0x000028, "Wrong size on FCosmosUserParam");
static_assert(offsetof(FCosmosUserParam, UserId) == 0x000000, "Member 'FCosmosUserParam::UserId' has a wrong offset!");
static_assert(offsetof(FCosmosUserParam, Talken) == 0x000010, "Member 'FCosmosUserParam::Talken' has a wrong offset!");
static_assert(offsetof(FCosmosUserParam, SkuType) == 0x000020, "Member 'FCosmosUserParam::SkuType' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosSysAgreeKpiResponse
// 0x0004 (0x0004 - 0x0000)
struct FCosmosSysAgreeKpiResponse final
{
public:
	int32                                         Status;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosSysAgreeKpiResponse) == 0x000004, "Wrong alignment on FCosmosSysAgreeKpiResponse");
static_assert(sizeof(FCosmosSysAgreeKpiResponse) == 0x000004, "Wrong size on FCosmosSysAgreeKpiResponse");
static_assert(offsetof(FCosmosSysAgreeKpiResponse, Status) == 0x000000, "Member 'FCosmosSysAgreeKpiResponse::Status' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryHabitatParam
// 0x0020 (0x0020 - 0x0000)
struct FLibraryHabitatParam final
{
public:
	int32                                         BeginProgressNo;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndProgressNo;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELibraryFlagType                              ChkFlag;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Habitat;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryHabitatParam) == 0x000008, "Wrong alignment on FLibraryHabitatParam");
static_assert(sizeof(FLibraryHabitatParam) == 0x000020, "Wrong size on FLibraryHabitatParam");
static_assert(offsetof(FLibraryHabitatParam, BeginProgressNo) == 0x000000, "Member 'FLibraryHabitatParam::BeginProgressNo' has a wrong offset!");
static_assert(offsetof(FLibraryHabitatParam, EndProgressNo) == 0x000004, "Member 'FLibraryHabitatParam::EndProgressNo' has a wrong offset!");
static_assert(offsetof(FLibraryHabitatParam, ChkFlag) == 0x000008, "Member 'FLibraryHabitatParam::ChkFlag' has a wrong offset!");
static_assert(offsetof(FLibraryHabitatParam, Habitat) == 0x000010, "Member 'FLibraryHabitatParam::Habitat' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosSysAgreeKpiParam
// 0x0004 (0x0004 - 0x0000)
struct FCosmosSysAgreeKpiParam final
{
public:
	int32                                         AgreeFlag;                                         // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosSysAgreeKpiParam) == 0x000004, "Wrong alignment on FCosmosSysAgreeKpiParam");
static_assert(sizeof(FCosmosSysAgreeKpiParam) == 0x000004, "Wrong size on FCosmosSysAgreeKpiParam");
static_assert(offsetof(FCosmosSysAgreeKpiParam, AgreeFlag) == 0x000000, "Member 'FCosmosSysAgreeKpiParam::AgreeFlag' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmsoSysKpiResponse
// 0x0004 (0x0004 - 0x0000)
struct FCosmsoSysKpiResponse final
{
public:
	int32                                         Status;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmsoSysKpiResponse) == 0x000004, "Wrong alignment on FCosmsoSysKpiResponse");
static_assert(sizeof(FCosmsoSysKpiResponse) == 0x000004, "Wrong size on FCosmsoSysKpiResponse");
static_assert(offsetof(FCosmsoSysKpiResponse, Status) == 0x000000, "Member 'FCosmsoSysKpiResponse::Status' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryVoiceParamRaw
// 0x0010 (0x0010 - 0x0000)
struct FLibraryVoiceParamRaw final
{
public:
	ELibraryFlagType                              ChkFlag;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          VoiceData;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryVoiceParamRaw) == 0x000008, "Wrong alignment on FLibraryVoiceParamRaw");
static_assert(sizeof(FLibraryVoiceParamRaw) == 0x000010, "Wrong size on FLibraryVoiceParamRaw");
static_assert(offsetof(FLibraryVoiceParamRaw, ChkFlag) == 0x000000, "Member 'FLibraryVoiceParamRaw::ChkFlag' has a wrong offset!");
static_assert(offsetof(FLibraryVoiceParamRaw, VoiceData) == 0x000008, "Member 'FLibraryVoiceParamRaw::VoiceData' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryStringParamRaw
// 0x000C (0x000C - 0x0000)
struct FLibraryStringParamRaw final
{
public:
	ELibraryFlagType                              ChkFlag;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StrData;                                           // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryStringParamRaw) == 0x000004, "Wrong alignment on FLibraryStringParamRaw");
static_assert(sizeof(FLibraryStringParamRaw) == 0x00000C, "Wrong size on FLibraryStringParamRaw");
static_assert(offsetof(FLibraryStringParamRaw, ChkFlag) == 0x000000, "Member 'FLibraryStringParamRaw::ChkFlag' has a wrong offset!");
static_assert(offsetof(FLibraryStringParamRaw, StrData) == 0x000004, "Member 'FLibraryStringParamRaw::StrData' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryBoolParamRaw
// 0x0002 (0x0002 - 0x0000)
struct FLibraryBoolParamRaw final
{
public:
	ELibraryFlagType                              ChkFlag;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoolData;                                          // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryBoolParamRaw) == 0x000001, "Wrong alignment on FLibraryBoolParamRaw");
static_assert(sizeof(FLibraryBoolParamRaw) == 0x000002, "Wrong size on FLibraryBoolParamRaw");
static_assert(offsetof(FLibraryBoolParamRaw, ChkFlag) == 0x000000, "Member 'FLibraryBoolParamRaw::ChkFlag' has a wrong offset!");
static_assert(offsetof(FLibraryBoolParamRaw, BoolData) == 0x000001, "Member 'FLibraryBoolParamRaw::BoolData' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryCharaDBRaw
// 0x0108 (0x0110 - 0x0008)
struct FLibraryCharaDBRaw final : public FTableRowBase
{
public:
	class FName                                   CharaID;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     PlayerId;                                          // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SortID;                                            // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLibraryStringParamRaw                 Gender;                                            // 0x0028(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FLibraryStringParamRaw                 Birthday;                                          // 0x0034(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FLibraryStringParamRaw                 Height;                                            // 0x0040(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FLibraryStringParamRaw                 Psychic;                                           // 0x004C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FLibraryStringParamRaw                 Weapon;                                            // 0x0058(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FLibraryStringParamRaw                 MilitaryID;                                        // 0x0064(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FLibraryStringParamRaw                 MilitaryYear;                                      // 0x0070(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FLibraryStringParamRaw                 FavoriteFood;                                      // 0x007C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FLibraryStringParamRaw                 Character;                                         // 0x0088(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FLibraryBoolParamRaw                   Hood;                                              // 0x0094(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_96[0x2];                                       // 0x0096(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLibraryStringParamRaw                 Details;                                           // 0x0098(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           VoiceCast;                                         // 0x00A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLibraryVoiceParamRaw                  Voice;                                             // 0x00B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLibraryStringParamRaw                 FavoriteCollect;                                   // 0x00C8(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FLibraryStringParamRaw                 NotgoodCollect;                                    // 0x00D4(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FLibraryStringParamRaw                 Hobby;                                             // 0x00E0(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FLibraryStringParamRaw                 SpecialSkill;                                      // 0x00EC(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FLibraryStringParamRaw                 DetailsMini;                                       // 0x00F8(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FLibraryStringParamRaw                 DetailsPage4;                                      // 0x0104(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryCharaDBRaw) == 0x000008, "Wrong alignment on FLibraryCharaDBRaw");
static_assert(sizeof(FLibraryCharaDBRaw) == 0x000110, "Wrong size on FLibraryCharaDBRaw");
static_assert(offsetof(FLibraryCharaDBRaw, CharaID) == 0x000008, "Member 'FLibraryCharaDBRaw::CharaID' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, PlayerId) == 0x000010, "Member 'FLibraryCharaDBRaw::PlayerId' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, SortID) == 0x000018, "Member 'FLibraryCharaDBRaw::SortID' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, Gender) == 0x000028, "Member 'FLibraryCharaDBRaw::Gender' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, Birthday) == 0x000034, "Member 'FLibraryCharaDBRaw::Birthday' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, Height) == 0x000040, "Member 'FLibraryCharaDBRaw::Height' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, Psychic) == 0x00004C, "Member 'FLibraryCharaDBRaw::Psychic' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, Weapon) == 0x000058, "Member 'FLibraryCharaDBRaw::Weapon' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, MilitaryID) == 0x000064, "Member 'FLibraryCharaDBRaw::MilitaryID' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, MilitaryYear) == 0x000070, "Member 'FLibraryCharaDBRaw::MilitaryYear' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, FavoriteFood) == 0x00007C, "Member 'FLibraryCharaDBRaw::FavoriteFood' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, Character) == 0x000088, "Member 'FLibraryCharaDBRaw::Character' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, Hood) == 0x000094, "Member 'FLibraryCharaDBRaw::Hood' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, Details) == 0x000098, "Member 'FLibraryCharaDBRaw::Details' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, VoiceCast) == 0x0000A8, "Member 'FLibraryCharaDBRaw::VoiceCast' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, Voice) == 0x0000B8, "Member 'FLibraryCharaDBRaw::Voice' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, FavoriteCollect) == 0x0000C8, "Member 'FLibraryCharaDBRaw::FavoriteCollect' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, NotgoodCollect) == 0x0000D4, "Member 'FLibraryCharaDBRaw::NotgoodCollect' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, Hobby) == 0x0000E0, "Member 'FLibraryCharaDBRaw::Hobby' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, SpecialSkill) == 0x0000EC, "Member 'FLibraryCharaDBRaw::SpecialSkill' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, DetailsMini) == 0x0000F8, "Member 'FLibraryCharaDBRaw::DetailsMini' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBRaw, DetailsPage4) == 0x000104, "Member 'FLibraryCharaDBRaw::DetailsPage4' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosSysKpiColumn
// 0x0018 (0x0018 - 0x0000)
struct FCosmosSysKpiColumn final
{
public:
	class FString                                 Columun;                                           // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCosmosSysKpiColumn) == 0x000008, "Wrong alignment on FCosmosSysKpiColumn");
static_assert(sizeof(FCosmosSysKpiColumn) == 0x000018, "Wrong size on FCosmosSysKpiColumn");
static_assert(offsetof(FCosmosSysKpiColumn, Columun) == 0x000000, "Member 'FCosmosSysKpiColumn::Columun' has a wrong offset!");
static_assert(offsetof(FCosmosSysKpiColumn, Type) == 0x000010, "Member 'FCosmosSysKpiColumn::Type' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosSysKpiData
// 0x0010 (0x0010 - 0x0000)
struct FCosmosSysKpiData final
{
public:
	TArray<class FString>                         Data;                                              // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosSysKpiData) == 0x000008, "Wrong alignment on FCosmosSysKpiData");
static_assert(sizeof(FCosmosSysKpiData) == 0x000010, "Wrong size on FCosmosSysKpiData");
static_assert(offsetof(FCosmosSysKpiData, Data) == 0x000000, "Member 'FCosmosSysKpiData::Data' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosSysKpiNo
// 0x0028 (0x0028 - 0x0000)
struct FCosmosSysKpiNo final
{
public:
	int32                                         No;                                                // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCosmosSysKpiColumn>            ColumnList;                                        // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCosmosSysKpiData>              DataList;                                          // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosSysKpiNo) == 0x000008, "Wrong alignment on FCosmosSysKpiNo");
static_assert(sizeof(FCosmosSysKpiNo) == 0x000028, "Wrong size on FCosmosSysKpiNo");
static_assert(offsetof(FCosmosSysKpiNo, No) == 0x000000, "Member 'FCosmosSysKpiNo::No' has a wrong offset!");
static_assert(offsetof(FCosmosSysKpiNo, ColumnList) == 0x000008, "Member 'FCosmosSysKpiNo::ColumnList' has a wrong offset!");
static_assert(offsetof(FCosmosSysKpiNo, DataList) == 0x000018, "Member 'FCosmosSysKpiNo::DataList' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosSysKpiParam
// 0x0010 (0x0010 - 0x0000)
struct FCosmosSysKpiParam final
{
public:
	TArray<struct FCosmosSysKpiNo>                KpiNoList;                                         // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosSysKpiParam) == 0x000008, "Wrong alignment on FCosmosSysKpiParam");
static_assert(sizeof(FCosmosSysKpiParam) == 0x000010, "Wrong size on FCosmosSysKpiParam");
static_assert(offsetof(FCosmosSysKpiParam, KpiNoList) == 0x000000, "Member 'FCosmosSysKpiParam::KpiNoList' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryVoiceParam
// 0x0010 (0x0010 - 0x0000)
struct FLibraryVoiceParam final
{
public:
	ELibraryFlagType                              ChkFlag;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          Voice;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryVoiceParam) == 0x000008, "Wrong alignment on FLibraryVoiceParam");
static_assert(sizeof(FLibraryVoiceParam) == 0x000010, "Wrong size on FLibraryVoiceParam");
static_assert(offsetof(FLibraryVoiceParam, ChkFlag) == 0x000000, "Member 'FLibraryVoiceParam::ChkFlag' has a wrong offset!");
static_assert(offsetof(FLibraryVoiceParam, Voice) == 0x000008, "Member 'FLibraryVoiceParam::Voice' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryCharaDataCell
// 0x0088 (0x0088 - 0x0000)
struct FLibraryCharaDataCell final
{
public:
	EPlayerID                                     PlayerId;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SortID;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Gender;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Birthday;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Height;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Psychic;                                           // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Weapon;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MilitaryID;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MilitaryYear;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FavoriteFood;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Character;                                         // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Hood;                                              // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Details;                                           // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           VoiceCast;                                         // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USoundAtomCue*>                  Voices;                                            // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryCharaDataCell) == 0x000008, "Wrong alignment on FLibraryCharaDataCell");
static_assert(sizeof(FLibraryCharaDataCell) == 0x000088, "Wrong size on FLibraryCharaDataCell");
static_assert(offsetof(FLibraryCharaDataCell, PlayerId) == 0x000000, "Member 'FLibraryCharaDataCell::PlayerId' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDataCell, SortID) == 0x000004, "Member 'FLibraryCharaDataCell::SortID' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDataCell, Gender) == 0x000008, "Member 'FLibraryCharaDataCell::Gender' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDataCell, Birthday) == 0x000010, "Member 'FLibraryCharaDataCell::Birthday' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDataCell, Height) == 0x000018, "Member 'FLibraryCharaDataCell::Height' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDataCell, Psychic) == 0x000020, "Member 'FLibraryCharaDataCell::Psychic' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDataCell, Weapon) == 0x000028, "Member 'FLibraryCharaDataCell::Weapon' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDataCell, MilitaryID) == 0x000030, "Member 'FLibraryCharaDataCell::MilitaryID' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDataCell, MilitaryYear) == 0x000038, "Member 'FLibraryCharaDataCell::MilitaryYear' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDataCell, FavoriteFood) == 0x000040, "Member 'FLibraryCharaDataCell::FavoriteFood' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDataCell, Character) == 0x000048, "Member 'FLibraryCharaDataCell::Character' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDataCell, Hood) == 0x000050, "Member 'FLibraryCharaDataCell::Hood' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDataCell, Details) == 0x000058, "Member 'FLibraryCharaDataCell::Details' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDataCell, VoiceCast) == 0x000068, "Member 'FLibraryCharaDataCell::VoiceCast' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDataCell, Voices) == 0x000078, "Member 'FLibraryCharaDataCell::Voices' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosSysGetEnvResponse
// 0x0018 (0x0018 - 0x0000)
struct FCosmosSysGetEnvResponse final
{
public:
	int32                                         Status;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 URL;                                               // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosSysGetEnvResponse) == 0x000008, "Wrong alignment on FCosmosSysGetEnvResponse");
static_assert(sizeof(FCosmosSysGetEnvResponse) == 0x000018, "Wrong size on FCosmosSysGetEnvResponse");
static_assert(offsetof(FCosmosSysGetEnvResponse, Status) == 0x000000, "Member 'FCosmosSysGetEnvResponse::Status' has a wrong offset!");
static_assert(offsetof(FCosmosSysGetEnvResponse, URL) == 0x000008, "Member 'FCosmosSysGetEnvResponse::URL' has a wrong offset!");

// ScriptStruct BattlePrototype.UIDetaileMapSubAreaCenterPosition
// 0x0020 (0x0020 - 0x0000)
struct FUIDetaileMapSubAreaCenterPosition final
{
public:
	class FString                                 SubAreaName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterSunAreaPos;                                  // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIDetaileMapSubAreaCenterPosition) == 0x000008, "Wrong alignment on FUIDetaileMapSubAreaCenterPosition");
static_assert(sizeof(FUIDetaileMapSubAreaCenterPosition) == 0x000020, "Wrong size on FUIDetaileMapSubAreaCenterPosition");
static_assert(offsetof(FUIDetaileMapSubAreaCenterPosition, SubAreaName) == 0x000000, "Member 'FUIDetaileMapSubAreaCenterPosition::SubAreaName' has a wrong offset!");
static_assert(offsetof(FUIDetaileMapSubAreaCenterPosition, CenterSunAreaPos) == 0x000010, "Member 'FUIDetaileMapSubAreaCenterPosition::CenterSunAreaPos' has a wrong offset!");

// ScriptStruct BattlePrototype.CosmosResultParam
// 0x0028 (0x0028 - 0x0000)
struct FCosmosResultParam final
{
public:
	class FString                                 SessionID;                                         // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Result;                                            // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Date;                                              // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmosResultParam) == 0x000008, "Wrong alignment on FCosmosResultParam");
static_assert(sizeof(FCosmosResultParam) == 0x000028, "Wrong size on FCosmosResultParam");
static_assert(offsetof(FCosmosResultParam, SessionID) == 0x000000, "Member 'FCosmosResultParam::SessionID' has a wrong offset!");
static_assert(offsetof(FCosmosResultParam, Result) == 0x000010, "Member 'FCosmosResultParam::Result' has a wrong offset!");
static_assert(offsetof(FCosmosResultParam, Date) == 0x000018, "Member 'FCosmosResultParam::Date' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryIntegerParamRaw
// 0x0008 (0x0008 - 0x0000)
struct FLibraryIntegerParamRaw final
{
public:
	ELibraryFlagType                              ChkFlag;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IntData;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryIntegerParamRaw) == 0x000004, "Wrong alignment on FLibraryIntegerParamRaw");
static_assert(sizeof(FLibraryIntegerParamRaw) == 0x000008, "Wrong size on FLibraryIntegerParamRaw");
static_assert(offsetof(FLibraryIntegerParamRaw, ChkFlag) == 0x000000, "Member 'FLibraryIntegerParamRaw::ChkFlag' has a wrong offset!");
static_assert(offsetof(FLibraryIntegerParamRaw, IntData) == 0x000004, "Member 'FLibraryIntegerParamRaw::IntData' has a wrong offset!");

// ScriptStruct BattlePrototype.CutCameraPresetData
// 0x0040 (0x0048 - 0x0008)
struct FCutCameraPresetData final : public FTableRowBase
{
public:
	struct FVector                                Location;                                          // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotate;                                            // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAttachSocket;                                     // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0024(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _BeginBlendTime;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      _BeginBlendFunc;                                   // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _BeginBlendExp;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _EndBlendTime;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      _EndBlendFunc;                                     // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _EndBlendExp;                                      // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCutCameraPresetData) == 0x000008, "Wrong alignment on FCutCameraPresetData");
static_assert(sizeof(FCutCameraPresetData) == 0x000048, "Wrong size on FCutCameraPresetData");
static_assert(offsetof(FCutCameraPresetData, Location) == 0x000008, "Member 'FCutCameraPresetData::Location' has a wrong offset!");
static_assert(offsetof(FCutCameraPresetData, Rotate) == 0x000014, "Member 'FCutCameraPresetData::Rotate' has a wrong offset!");
static_assert(offsetof(FCutCameraPresetData, bAttachSocket) == 0x000020, "Member 'FCutCameraPresetData::bAttachSocket' has a wrong offset!");
static_assert(offsetof(FCutCameraPresetData, SocketName) == 0x000024, "Member 'FCutCameraPresetData::SocketName' has a wrong offset!");
static_assert(offsetof(FCutCameraPresetData, FOV) == 0x00002C, "Member 'FCutCameraPresetData::FOV' has a wrong offset!");
static_assert(offsetof(FCutCameraPresetData, _BeginBlendTime) == 0x000030, "Member 'FCutCameraPresetData::_BeginBlendTime' has a wrong offset!");
static_assert(offsetof(FCutCameraPresetData, _BeginBlendFunc) == 0x000034, "Member 'FCutCameraPresetData::_BeginBlendFunc' has a wrong offset!");
static_assert(offsetof(FCutCameraPresetData, _BeginBlendExp) == 0x000038, "Member 'FCutCameraPresetData::_BeginBlendExp' has a wrong offset!");
static_assert(offsetof(FCutCameraPresetData, _EndBlendTime) == 0x00003C, "Member 'FCutCameraPresetData::_EndBlendTime' has a wrong offset!");
static_assert(offsetof(FCutCameraPresetData, _EndBlendFunc) == 0x000040, "Member 'FCutCameraPresetData::_EndBlendFunc' has a wrong offset!");
static_assert(offsetof(FCutCameraPresetData, _EndBlendExp) == 0x000044, "Member 'FCutCameraPresetData::_EndBlendExp' has a wrong offset!");

// ScriptStruct BattlePrototype.CutCameraTransitionParams
// 0x0010 (0x0010 - 0x0000)
struct FCutCameraTransitionParams final
{
public:
	int32                                         _changeCameraIndex;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _blendTime;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      _blendFunc;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _blendExp;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCutCameraTransitionParams) == 0x000004, "Wrong alignment on FCutCameraTransitionParams");
static_assert(sizeof(FCutCameraTransitionParams) == 0x000010, "Wrong size on FCutCameraTransitionParams");
static_assert(offsetof(FCutCameraTransitionParams, _changeCameraIndex) == 0x000000, "Member 'FCutCameraTransitionParams::_changeCameraIndex' has a wrong offset!");
static_assert(offsetof(FCutCameraTransitionParams, _blendTime) == 0x000004, "Member 'FCutCameraTransitionParams::_blendTime' has a wrong offset!");
static_assert(offsetof(FCutCameraTransitionParams, _blendFunc) == 0x000008, "Member 'FCutCameraTransitionParams::_blendFunc' has a wrong offset!");
static_assert(offsetof(FCutCameraTransitionParams, _blendExp) == 0x00000C, "Member 'FCutCameraTransitionParams::_blendExp' has a wrong offset!");

// ScriptStruct BattlePrototype.LoadingTipsParam
// 0x001C (0x001C - 0x0000)
struct FLoadingTipsParam final
{
public:
	int32                                         ProgressBeginNo;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressEndNo;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnemyID;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerSkill                                  SkillID;                                           // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     BondsTargetID;                                     // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         bondsLevel;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LocationNo;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingTipsParam) == 0x000004, "Wrong alignment on FLoadingTipsParam");
static_assert(sizeof(FLoadingTipsParam) == 0x00001C, "Wrong size on FLoadingTipsParam");
static_assert(offsetof(FLoadingTipsParam, ProgressBeginNo) == 0x000000, "Member 'FLoadingTipsParam::ProgressBeginNo' has a wrong offset!");
static_assert(offsetof(FLoadingTipsParam, ProgressEndNo) == 0x000004, "Member 'FLoadingTipsParam::ProgressEndNo' has a wrong offset!");
static_assert(offsetof(FLoadingTipsParam, EnemyID) == 0x000008, "Member 'FLoadingTipsParam::EnemyID' has a wrong offset!");
static_assert(offsetof(FLoadingTipsParam, SkillID) == 0x000010, "Member 'FLoadingTipsParam::SkillID' has a wrong offset!");
static_assert(offsetof(FLoadingTipsParam, BondsTargetID) == 0x000011, "Member 'FLoadingTipsParam::BondsTargetID' has a wrong offset!");
static_assert(offsetof(FLoadingTipsParam, bondsLevel) == 0x000014, "Member 'FLoadingTipsParam::bondsLevel' has a wrong offset!");
static_assert(offsetof(FLoadingTipsParam, LocationNo) == 0x000018, "Member 'FLoadingTipsParam::LocationNo' has a wrong offset!");

// ScriptStruct BattlePrototype.DamageAnimParam
// 0x01C0 (0x01C0 - 0x0000)
struct FDamageAnimParam final
{
public:
	struct FHCHitResult                           HitResult;                                         // 0x0000(0x01B8)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         Damage;                                            // 0x01B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDown;                                            // 0x01BC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayAnim;                                         // 0x01BD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BE[0x2];                                      // 0x01BE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageAnimParam) == 0x000008, "Wrong alignment on FDamageAnimParam");
static_assert(sizeof(FDamageAnimParam) == 0x0001C0, "Wrong size on FDamageAnimParam");
static_assert(offsetof(FDamageAnimParam, HitResult) == 0x000000, "Member 'FDamageAnimParam::HitResult' has a wrong offset!");
static_assert(offsetof(FDamageAnimParam, Damage) == 0x0001B8, "Member 'FDamageAnimParam::Damage' has a wrong offset!");
static_assert(offsetof(FDamageAnimParam, IsDown) == 0x0001BC, "Member 'FDamageAnimParam::IsDown' has a wrong offset!");
static_assert(offsetof(FDamageAnimParam, bPlayAnim) == 0x0001BD, "Member 'FDamageAnimParam::bPlayAnim' has a wrong offset!");

// ScriptStruct BattlePrototype.DifficultyDamageRate
// 0x0008 (0x0010 - 0x0008)
struct FDifficultyDamageRate final : public FTableRowBase
{
public:
	float                                         AttackDamageRate;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefenceDamageRate;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDifficultyDamageRate) == 0x000008, "Wrong alignment on FDifficultyDamageRate");
static_assert(sizeof(FDifficultyDamageRate) == 0x000010, "Wrong size on FDifficultyDamageRate");
static_assert(offsetof(FDifficultyDamageRate, AttackDamageRate) == 0x000008, "Member 'FDifficultyDamageRate::AttackDamageRate' has a wrong offset!");
static_assert(offsetof(FDifficultyDamageRate, DefenceDamageRate) == 0x00000C, "Member 'FDifficultyDamageRate::DefenceDamageRate' has a wrong offset!");

// ScriptStruct BattlePrototype.OneTutoKeyData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FOneTutoKeyData final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOneTutoKeyData) == 0x000004, "Wrong alignment on FOneTutoKeyData");
static_assert(sizeof(FOneTutoKeyData) == 0x00000C, "Wrong size on FOneTutoKeyData");

// ScriptStruct BattlePrototype.DamageCalcInfo
// 0x0020 (0x0020 - 0x0000)
struct FDamageCalcInfo final
{
public:
	float                                         _collectedDefense;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _damageRate;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _elementCollectonFire;                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _elementCollectonWater;                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _elementCollectonWind;                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _elementCollectonEarth;                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _elementCollectonLight;                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _elementCollectonDark;                             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageCalcInfo) == 0x000004, "Wrong alignment on FDamageCalcInfo");
static_assert(sizeof(FDamageCalcInfo) == 0x000020, "Wrong size on FDamageCalcInfo");
static_assert(offsetof(FDamageCalcInfo, _collectedDefense) == 0x000000, "Member 'FDamageCalcInfo::_collectedDefense' has a wrong offset!");
static_assert(offsetof(FDamageCalcInfo, _damageRate) == 0x000004, "Member 'FDamageCalcInfo::_damageRate' has a wrong offset!");
static_assert(offsetof(FDamageCalcInfo, _elementCollectonFire) == 0x000008, "Member 'FDamageCalcInfo::_elementCollectonFire' has a wrong offset!");
static_assert(offsetof(FDamageCalcInfo, _elementCollectonWater) == 0x00000C, "Member 'FDamageCalcInfo::_elementCollectonWater' has a wrong offset!");
static_assert(offsetof(FDamageCalcInfo, _elementCollectonWind) == 0x000010, "Member 'FDamageCalcInfo::_elementCollectonWind' has a wrong offset!");
static_assert(offsetof(FDamageCalcInfo, _elementCollectonEarth) == 0x000014, "Member 'FDamageCalcInfo::_elementCollectonEarth' has a wrong offset!");
static_assert(offsetof(FDamageCalcInfo, _elementCollectonLight) == 0x000018, "Member 'FDamageCalcInfo::_elementCollectonLight' has a wrong offset!");
static_assert(offsetof(FDamageCalcInfo, _elementCollectonDark) == 0x00001C, "Member 'FDamageCalcInfo::_elementCollectonDark' has a wrong offset!");

// ScriptStruct BattlePrototype.AttackCalcInfo
// 0x0010 (0x0010 - 0x0000)
struct FAttackCalcInfo final
{
public:
	float                                         _collectedAttack;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitRearDecideType                            _rearDecideType;                                   // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _collectedPower;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _collectedBrainPower;                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttackCalcInfo) == 0x000004, "Wrong alignment on FAttackCalcInfo");
static_assert(sizeof(FAttackCalcInfo) == 0x000010, "Wrong size on FAttackCalcInfo");
static_assert(offsetof(FAttackCalcInfo, _collectedAttack) == 0x000000, "Member 'FAttackCalcInfo::_collectedAttack' has a wrong offset!");
static_assert(offsetof(FAttackCalcInfo, _rearDecideType) == 0x000004, "Member 'FAttackCalcInfo::_rearDecideType' has a wrong offset!");
static_assert(offsetof(FAttackCalcInfo, _collectedPower) == 0x000008, "Member 'FAttackCalcInfo::_collectedPower' has a wrong offset!");
static_assert(offsetof(FAttackCalcInfo, _collectedBrainPower) == 0x00000C, "Member 'FAttackCalcInfo::_collectedBrainPower' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryHabiatParamRaw
// 0x0018 (0x0018 - 0x0000)
struct FLibraryHabiatParamRaw final
{
public:
	int32                                         ProgressNo;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELibraryFlagType                              ChkFlag;                                           // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Habitat;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryHabiatParamRaw) == 0x000008, "Wrong alignment on FLibraryHabiatParamRaw");
static_assert(sizeof(FLibraryHabiatParamRaw) == 0x000018, "Wrong size on FLibraryHabiatParamRaw");
static_assert(offsetof(FLibraryHabiatParamRaw, ProgressNo) == 0x000000, "Member 'FLibraryHabiatParamRaw::ProgressNo' has a wrong offset!");
static_assert(offsetof(FLibraryHabiatParamRaw, ChkFlag) == 0x000004, "Member 'FLibraryHabiatParamRaw::ChkFlag' has a wrong offset!");
static_assert(offsetof(FLibraryHabiatParamRaw, Habitat) == 0x000008, "Member 'FLibraryHabiatParamRaw::Habitat' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryEnemyDBRaw
// 0x0068 (0x0070 - 0x0008)
struct FLibraryEnemyDBRaw final : public FTableRowBase
{
public:
	class FName                                   ELibID;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnemyID;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLibraryStringParamRaw                 DetailMsg;                                         // 0x0018(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FLibraryIntegerParamRaw                ImageNum;                                          // 0x0024(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DropItems;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLibraryHabiatParamRaw                 Habitat_m;                                         // 0x0040(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FLibraryHabiatParamRaw                 Habitat_f;                                         // 0x0058(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryEnemyDBRaw) == 0x000008, "Wrong alignment on FLibraryEnemyDBRaw");
static_assert(sizeof(FLibraryEnemyDBRaw) == 0x000070, "Wrong size on FLibraryEnemyDBRaw");
static_assert(offsetof(FLibraryEnemyDBRaw, ELibID) == 0x000008, "Member 'FLibraryEnemyDBRaw::ELibID' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyDBRaw, EnemyID) == 0x000010, "Member 'FLibraryEnemyDBRaw::EnemyID' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyDBRaw, DetailMsg) == 0x000018, "Member 'FLibraryEnemyDBRaw::DetailMsg' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyDBRaw, ImageNum) == 0x000024, "Member 'FLibraryEnemyDBRaw::ImageNum' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyDBRaw, DropItems) == 0x000030, "Member 'FLibraryEnemyDBRaw::DropItems' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyDBRaw, Habitat_m) == 0x000040, "Member 'FLibraryEnemyDBRaw::Habitat_m' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyDBRaw, Habitat_f) == 0x000058, "Member 'FLibraryEnemyDBRaw::Habitat_f' has a wrong offset!");

// ScriptStruct BattlePrototype.HitZeroEffectAndSE
// 0x0018 (0x0018 - 0x0000)
struct FHitZeroEffectAndSE final
{
public:
	class UParticleSystem*                        _Effect;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitZeroEffectSpawnType                       _effectSpawnType;                                  // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             _SE;                                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitZeroEffectAndSE) == 0x000008, "Wrong alignment on FHitZeroEffectAndSE");
static_assert(sizeof(FHitZeroEffectAndSE) == 0x000018, "Wrong size on FHitZeroEffectAndSE");
static_assert(offsetof(FHitZeroEffectAndSE, _Effect) == 0x000000, "Member 'FHitZeroEffectAndSE::_Effect' has a wrong offset!");
static_assert(offsetof(FHitZeroEffectAndSE, _effectSpawnType) == 0x000008, "Member 'FHitZeroEffectAndSE::_effectSpawnType' has a wrong offset!");
static_assert(offsetof(FHitZeroEffectAndSE, _SE) == 0x000010, "Member 'FHitZeroEffectAndSE::_SE' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainTalkDataBase
// 0x0120 (0x0120 - 0x0000)
struct alignas(0x10) FBrainTalkDataBase final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDataTable*>                     CategoryDataTableList;                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class UDataTable*>        BrainTalkDataDTList;                               // 0x0020(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, class UDataTable*>        MessageDataDTList;                                 // 0x0070(0x0050)(NativeAccessSpecifierPublic)
	bool                                          IsAsyncLoadRequest;                                // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBTLoadAsyncFlow                              AsyncLoadFlow;                                     // 0x00C1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x5E];                                      // 0x00C2(0x005E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrainTalkDataBase) == 0x000010, "Wrong alignment on FBrainTalkDataBase");
static_assert(sizeof(FBrainTalkDataBase) == 0x000120, "Wrong size on FBrainTalkDataBase");
static_assert(offsetof(FBrainTalkDataBase, CategoryDataTableList) == 0x000010, "Member 'FBrainTalkDataBase::CategoryDataTableList' has a wrong offset!");
static_assert(offsetof(FBrainTalkDataBase, BrainTalkDataDTList) == 0x000020, "Member 'FBrainTalkDataBase::BrainTalkDataDTList' has a wrong offset!");
static_assert(offsetof(FBrainTalkDataBase, MessageDataDTList) == 0x000070, "Member 'FBrainTalkDataBase::MessageDataDTList' has a wrong offset!");
static_assert(offsetof(FBrainTalkDataBase, IsAsyncLoadRequest) == 0x0000C0, "Member 'FBrainTalkDataBase::IsAsyncLoadRequest' has a wrong offset!");
static_assert(offsetof(FBrainTalkDataBase, AsyncLoadFlow) == 0x0000C1, "Member 'FBrainTalkDataBase::AsyncLoadFlow' has a wrong offset!");

// ScriptStruct BattlePrototype.DataTableRowTest
// 0x0010 (0x0018 - 0x0008)
struct FDataTableRowTest final : public FTableRowBase
{
public:
	int32                                         _testIntVal;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _testFloatVal;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _testNameVal;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDataTableRowTest) == 0x000008, "Wrong alignment on FDataTableRowTest");
static_assert(sizeof(FDataTableRowTest) == 0x000018, "Wrong size on FDataTableRowTest");
static_assert(offsetof(FDataTableRowTest, _testIntVal) == 0x000008, "Member 'FDataTableRowTest::_testIntVal' has a wrong offset!");
static_assert(offsetof(FDataTableRowTest, _testFloatVal) == 0x00000C, "Member 'FDataTableRowTest::_testFloatVal' has a wrong offset!");
static_assert(offsetof(FDataTableRowTest, _testNameVal) == 0x000010, "Member 'FDataTableRowTest::_testNameVal' has a wrong offset!");

// ScriptStruct BattlePrototype.MapGimmickPlayerAnimations
// 0x0060 (0x0068 - 0x0008)
struct FMapGimmickPlayerAnimations final : public FTableRowBase
{
public:
	class UAnimMontage*                           StartL_CaptureL_EndR;                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StartL_CaptureL_EndL;                              // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StartL_CaptureA_EndL;                              // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StartL_CaptureA_EndR;                              // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StartL_CaptureR_EndR;                              // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StartL_CaptureR_EndL;                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StartR_CaptureL_EndL;                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StartR_CaptureL_EndR;                              // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StartR_CaptureA_EndL;                              // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StartR_CaptureA_EndR;                              // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StartR_CaptureR_EndL;                              // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StartR_CaptureR_EndR;                              // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapGimmickPlayerAnimations) == 0x000008, "Wrong alignment on FMapGimmickPlayerAnimations");
static_assert(sizeof(FMapGimmickPlayerAnimations) == 0x000068, "Wrong size on FMapGimmickPlayerAnimations");
static_assert(offsetof(FMapGimmickPlayerAnimations, StartL_CaptureL_EndR) == 0x000008, "Member 'FMapGimmickPlayerAnimations::StartL_CaptureL_EndR' has a wrong offset!");
static_assert(offsetof(FMapGimmickPlayerAnimations, StartL_CaptureL_EndL) == 0x000010, "Member 'FMapGimmickPlayerAnimations::StartL_CaptureL_EndL' has a wrong offset!");
static_assert(offsetof(FMapGimmickPlayerAnimations, StartL_CaptureA_EndL) == 0x000018, "Member 'FMapGimmickPlayerAnimations::StartL_CaptureA_EndL' has a wrong offset!");
static_assert(offsetof(FMapGimmickPlayerAnimations, StartL_CaptureA_EndR) == 0x000020, "Member 'FMapGimmickPlayerAnimations::StartL_CaptureA_EndR' has a wrong offset!");
static_assert(offsetof(FMapGimmickPlayerAnimations, StartL_CaptureR_EndR) == 0x000028, "Member 'FMapGimmickPlayerAnimations::StartL_CaptureR_EndR' has a wrong offset!");
static_assert(offsetof(FMapGimmickPlayerAnimations, StartL_CaptureR_EndL) == 0x000030, "Member 'FMapGimmickPlayerAnimations::StartL_CaptureR_EndL' has a wrong offset!");
static_assert(offsetof(FMapGimmickPlayerAnimations, StartR_CaptureL_EndL) == 0x000038, "Member 'FMapGimmickPlayerAnimations::StartR_CaptureL_EndL' has a wrong offset!");
static_assert(offsetof(FMapGimmickPlayerAnimations, StartR_CaptureL_EndR) == 0x000040, "Member 'FMapGimmickPlayerAnimations::StartR_CaptureL_EndR' has a wrong offset!");
static_assert(offsetof(FMapGimmickPlayerAnimations, StartR_CaptureA_EndL) == 0x000048, "Member 'FMapGimmickPlayerAnimations::StartR_CaptureA_EndL' has a wrong offset!");
static_assert(offsetof(FMapGimmickPlayerAnimations, StartR_CaptureA_EndR) == 0x000050, "Member 'FMapGimmickPlayerAnimations::StartR_CaptureA_EndR' has a wrong offset!");
static_assert(offsetof(FMapGimmickPlayerAnimations, StartR_CaptureR_EndL) == 0x000058, "Member 'FMapGimmickPlayerAnimations::StartR_CaptureR_EndL' has a wrong offset!");
static_assert(offsetof(FMapGimmickPlayerAnimations, StartR_CaptureR_EndR) == 0x000060, "Member 'FMapGimmickPlayerAnimations::StartR_CaptureR_EndR' has a wrong offset!");

// ScriptStruct BattlePrototype.DebugItemPresetParam
// 0x000C (0x000C - 0x0000)
struct FDebugItemPresetParam final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugItemPresetParam) == 0x000004, "Wrong alignment on FDebugItemPresetParam");
static_assert(sizeof(FDebugItemPresetParam) == 0x00000C, "Wrong size on FDebugItemPresetParam");
static_assert(offsetof(FDebugItemPresetParam, ItemId) == 0x000000, "Member 'FDebugItemPresetParam::ItemId' has a wrong offset!");
static_assert(offsetof(FDebugItemPresetParam, Num) == 0x000008, "Member 'FDebugItemPresetParam::Num' has a wrong offset!");

// ScriptStruct BattlePrototype.DebugItemPresetDataCell
// 0x0018 (0x0020 - 0x0008)
struct FDebugItemPresetDataCell final : public FTableRowBase
{
public:
	int32                                         Money;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDebugItemPresetParam>          Items;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugItemPresetDataCell) == 0x000008, "Wrong alignment on FDebugItemPresetDataCell");
static_assert(sizeof(FDebugItemPresetDataCell) == 0x000020, "Wrong size on FDebugItemPresetDataCell");
static_assert(offsetof(FDebugItemPresetDataCell, Money) == 0x000008, "Member 'FDebugItemPresetDataCell::Money' has a wrong offset!");
static_assert(offsetof(FDebugItemPresetDataCell, Items) == 0x000010, "Member 'FDebugItemPresetDataCell::Items' has a wrong offset!");

// ScriptStruct BattlePrototype.UIMain3DCharacterSceneSetting
// 0x0800 (0x0800 - 0x0000)
struct FUIMain3DCharacterSceneSetting final
{
public:
	float                                         ViewCutout;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SpotLightColor;                                    // 0x0004(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpotLightIntensity;                                // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpotLightAttenuationRadius;                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpotLightLocation;                                 // 0x001C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RimLightColor;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OutlineColor;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CameraTransform;                                   // 0x0050(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0080(0x0780)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIMain3DCharacterSceneSetting) == 0x000010, "Wrong alignment on FUIMain3DCharacterSceneSetting");
static_assert(sizeof(FUIMain3DCharacterSceneSetting) == 0x000800, "Wrong size on FUIMain3DCharacterSceneSetting");
static_assert(offsetof(FUIMain3DCharacterSceneSetting, ViewCutout) == 0x000000, "Member 'FUIMain3DCharacterSceneSetting::ViewCutout' has a wrong offset!");
static_assert(offsetof(FUIMain3DCharacterSceneSetting, SpotLightColor) == 0x000004, "Member 'FUIMain3DCharacterSceneSetting::SpotLightColor' has a wrong offset!");
static_assert(offsetof(FUIMain3DCharacterSceneSetting, SpotLightIntensity) == 0x000014, "Member 'FUIMain3DCharacterSceneSetting::SpotLightIntensity' has a wrong offset!");
static_assert(offsetof(FUIMain3DCharacterSceneSetting, SpotLightAttenuationRadius) == 0x000018, "Member 'FUIMain3DCharacterSceneSetting::SpotLightAttenuationRadius' has a wrong offset!");
static_assert(offsetof(FUIMain3DCharacterSceneSetting, SpotLightLocation) == 0x00001C, "Member 'FUIMain3DCharacterSceneSetting::SpotLightLocation' has a wrong offset!");
static_assert(offsetof(FUIMain3DCharacterSceneSetting, RimLightColor) == 0x000028, "Member 'FUIMain3DCharacterSceneSetting::RimLightColor' has a wrong offset!");
static_assert(offsetof(FUIMain3DCharacterSceneSetting, OutlineColor) == 0x000038, "Member 'FUIMain3DCharacterSceneSetting::OutlineColor' has a wrong offset!");
static_assert(offsetof(FUIMain3DCharacterSceneSetting, CameraTransform) == 0x000050, "Member 'FUIMain3DCharacterSceneSetting::CameraTransform' has a wrong offset!");
static_assert(offsetof(FUIMain3DCharacterSceneSetting, PostProcessSettings) == 0x000080, "Member 'FUIMain3DCharacterSceneSetting::PostProcessSettings' has a wrong offset!");

// ScriptStruct BattlePrototype.DebugPresetDataCell
// 0x0018 (0x0020 - 0x0008)
struct FDebugPresetDataCell final : public FTableRowBase
{
public:
	int32                                         ProgressId;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharacterPreset;                                   // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemPreset;                                        // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugPresetDataCell) == 0x000008, "Wrong alignment on FDebugPresetDataCell");
static_assert(sizeof(FDebugPresetDataCell) == 0x000020, "Wrong size on FDebugPresetDataCell");
static_assert(offsetof(FDebugPresetDataCell, ProgressId) == 0x000008, "Member 'FDebugPresetDataCell::ProgressId' has a wrong offset!");
static_assert(offsetof(FDebugPresetDataCell, CharacterPreset) == 0x00000C, "Member 'FDebugPresetDataCell::CharacterPreset' has a wrong offset!");
static_assert(offsetof(FDebugPresetDataCell, ItemPreset) == 0x000014, "Member 'FDebugPresetDataCell::ItemPreset' has a wrong offset!");

// ScriptStruct BattlePrototype.DebugInfoScreenData
// 0x0028 (0x0028 - 0x0000)
struct FDebugInfoScreenData final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 String;                                            // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugInfoScreenData) == 0x000008, "Wrong alignment on FDebugInfoScreenData");
static_assert(sizeof(FDebugInfoScreenData) == 0x000028, "Wrong size on FDebugInfoScreenData");
static_assert(offsetof(FDebugInfoScreenData, Location) == 0x000000, "Member 'FDebugInfoScreenData::Location' has a wrong offset!");
static_assert(offsetof(FDebugInfoScreenData, String) == 0x000010, "Member 'FDebugInfoScreenData::String' has a wrong offset!");
static_assert(offsetof(FDebugInfoScreenData, Color) == 0x000020, "Member 'FDebugInfoScreenData::Color' has a wrong offset!");

// ScriptStruct BattlePrototype.MACVariableVector
// 0x0018 (0x0038 - 0x0020)
struct FMACVariableVector final : public FMACVariableBase
{
public:
	struct FVector                                Value;                                             // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DefaultValue;                                      // 0x002C(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMACVariableVector) == 0x000008, "Wrong alignment on FMACVariableVector");
static_assert(sizeof(FMACVariableVector) == 0x000038, "Wrong size on FMACVariableVector");
static_assert(offsetof(FMACVariableVector, Value) == 0x000020, "Member 'FMACVariableVector::Value' has a wrong offset!");
static_assert(offsetof(FMACVariableVector, DefaultValue) == 0x00002C, "Member 'FMACVariableVector::DefaultValue' has a wrong offset!");

// ScriptStruct BattlePrototype.DetailedMapRowDataCell
// 0x0050 (0x0058 - 0x0008)
struct FDetailedMapRowDataCell final : public FTableRowBase
{
public:
	class FName                                   LocationName;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaName;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FloorName;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapPath;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraLocation;                                    // 0x0030(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ViewLocation;                                      // 0x003C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewZoom;                                          // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionMinimap;                                  // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HightPer;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetailedMapRowDataCell) == 0x000008, "Wrong alignment on FDetailedMapRowDataCell");
static_assert(sizeof(FDetailedMapRowDataCell) == 0x000058, "Wrong size on FDetailedMapRowDataCell");
static_assert(offsetof(FDetailedMapRowDataCell, LocationName) == 0x000008, "Member 'FDetailedMapRowDataCell::LocationName' has a wrong offset!");
static_assert(offsetof(FDetailedMapRowDataCell, AreaName) == 0x000010, "Member 'FDetailedMapRowDataCell::AreaName' has a wrong offset!");
static_assert(offsetof(FDetailedMapRowDataCell, FloorName) == 0x000018, "Member 'FDetailedMapRowDataCell::FloorName' has a wrong offset!");
static_assert(offsetof(FDetailedMapRowDataCell, MapPath) == 0x000020, "Member 'FDetailedMapRowDataCell::MapPath' has a wrong offset!");
static_assert(offsetof(FDetailedMapRowDataCell, CameraLocation) == 0x000030, "Member 'FDetailedMapRowDataCell::CameraLocation' has a wrong offset!");
static_assert(offsetof(FDetailedMapRowDataCell, ViewLocation) == 0x00003C, "Member 'FDetailedMapRowDataCell::ViewLocation' has a wrong offset!");
static_assert(offsetof(FDetailedMapRowDataCell, ViewZoom) == 0x000048, "Member 'FDetailedMapRowDataCell::ViewZoom' has a wrong offset!");
static_assert(offsetof(FDetailedMapRowDataCell, DirectionMinimap) == 0x00004C, "Member 'FDetailedMapRowDataCell::DirectionMinimap' has a wrong offset!");
static_assert(offsetof(FDetailedMapRowDataCell, HightPer) == 0x000050, "Member 'FDetailedMapRowDataCell::HightPer' has a wrong offset!");
static_assert(offsetof(FDetailedMapRowDataCell, Width) == 0x000054, "Member 'FDetailedMapRowDataCell::Width' has a wrong offset!");

// ScriptStruct BattlePrototype.DataItemSpawnState
// 0x0040 (0x0040 - 0x0000)
struct FDataItemSpawnState final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId;                                            // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoTaken;                                        // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        DropParticle;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        AquParticle;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        GetParticle;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharID;                                            // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDataItemSpawnState) == 0x000008, "Wrong alignment on FDataItemSpawnState");
static_assert(sizeof(FDataItemSpawnState) == 0x000040, "Wrong size on FDataItemSpawnState");
static_assert(offsetof(FDataItemSpawnState, Location) == 0x000000, "Member 'FDataItemSpawnState::Location' has a wrong offset!");
static_assert(offsetof(FDataItemSpawnState, ItemId) == 0x00000C, "Member 'FDataItemSpawnState::ItemId' has a wrong offset!");
static_assert(offsetof(FDataItemSpawnState, ItemNum) == 0x000014, "Member 'FDataItemSpawnState::ItemNum' has a wrong offset!");
static_assert(offsetof(FDataItemSpawnState, bAutoTaken) == 0x000018, "Member 'FDataItemSpawnState::bAutoTaken' has a wrong offset!");
static_assert(offsetof(FDataItemSpawnState, DropParticle) == 0x000020, "Member 'FDataItemSpawnState::DropParticle' has a wrong offset!");
static_assert(offsetof(FDataItemSpawnState, AquParticle) == 0x000028, "Member 'FDataItemSpawnState::AquParticle' has a wrong offset!");
static_assert(offsetof(FDataItemSpawnState, GetParticle) == 0x000030, "Member 'FDataItemSpawnState::GetParticle' has a wrong offset!");
static_assert(offsetof(FDataItemSpawnState, CharID) == 0x000038, "Member 'FDataItemSpawnState::CharID' has a wrong offset!");

// ScriptStruct BattlePrototype.LoadTipsParam
// 0x0001 (0x0001 - 0x0000)
struct FLoadTipsParam final
{
public:
	bool                                          IsAlreadyCalled;                                   // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLoadTipsParam) == 0x000001, "Wrong alignment on FLoadTipsParam");
static_assert(sizeof(FLoadTipsParam) == 0x000001, "Wrong size on FLoadTipsParam");
static_assert(offsetof(FLoadTipsParam, IsAlreadyCalled) == 0x000000, "Member 'FLoadTipsParam::IsAlreadyCalled' has a wrong offset!");

// ScriptStruct BattlePrototype.EasyNavRouteInfo
// 0x0010 (0x0010 - 0x0000)
struct FEasyNavRouteInfo final
{
public:
	TArray<class AEasyNavNode*>                   NavNodeList;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEasyNavRouteInfo) == 0x000008, "Wrong alignment on FEasyNavRouteInfo");
static_assert(sizeof(FEasyNavRouteInfo) == 0x000010, "Wrong size on FEasyNavRouteInfo");
static_assert(offsetof(FEasyNavRouteInfo, NavNodeList) == 0x000000, "Member 'FEasyNavRouteInfo::NavNodeList' has a wrong offset!");

// ScriptStruct BattlePrototype.UILoading3DGeneralLineData
// 0x0010 (0x0010 - 0x0000)
struct FUILoading3DGeneralLineData final
{
public:
	struct FVector2D                              Translate;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUILoading3DGeneralLineData) == 0x000004, "Wrong alignment on FUILoading3DGeneralLineData");
static_assert(sizeof(FUILoading3DGeneralLineData) == 0x000010, "Wrong size on FUILoading3DGeneralLineData");
static_assert(offsetof(FUILoading3DGeneralLineData, Translate) == 0x000000, "Member 'FUILoading3DGeneralLineData::Translate' has a wrong offset!");
static_assert(offsetof(FUILoading3DGeneralLineData, Rotation) == 0x000008, "Member 'FUILoading3DGeneralLineData::Rotation' has a wrong offset!");
static_assert(offsetof(FUILoading3DGeneralLineData, Thickness) == 0x00000C, "Member 'FUILoading3DGeneralLineData::Thickness' has a wrong offset!");

// ScriptStruct BattlePrototype.EffectBackgroundParameterVector
// 0x0018 (0x0018 - 0x0000)
struct FEffectBackgroundParameterVector final
{
public:
	float                                         XMin;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XMax;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YMin;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YMax;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZMin;                                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZMax;                                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectBackgroundParameterVector) == 0x000004, "Wrong alignment on FEffectBackgroundParameterVector");
static_assert(sizeof(FEffectBackgroundParameterVector) == 0x000018, "Wrong size on FEffectBackgroundParameterVector");
static_assert(offsetof(FEffectBackgroundParameterVector, XMin) == 0x000000, "Member 'FEffectBackgroundParameterVector::XMin' has a wrong offset!");
static_assert(offsetof(FEffectBackgroundParameterVector, XMax) == 0x000004, "Member 'FEffectBackgroundParameterVector::XMax' has a wrong offset!");
static_assert(offsetof(FEffectBackgroundParameterVector, YMin) == 0x000008, "Member 'FEffectBackgroundParameterVector::YMin' has a wrong offset!");
static_assert(offsetof(FEffectBackgroundParameterVector, YMax) == 0x00000C, "Member 'FEffectBackgroundParameterVector::YMax' has a wrong offset!");
static_assert(offsetof(FEffectBackgroundParameterVector, ZMin) == 0x000010, "Member 'FEffectBackgroundParameterVector::ZMin' has a wrong offset!");
static_assert(offsetof(FEffectBackgroundParameterVector, ZMax) == 0x000014, "Member 'FEffectBackgroundParameterVector::ZMax' has a wrong offset!");

// ScriptStruct BattlePrototype.EffectBackgroundParameter
// 0x0060 (0x0060 - 0x0000)
struct FEffectBackgroundParameter final
{
public:
	bool                                          bUseSpawnParamter;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeMin;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeMax;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnMin;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnMax;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownTimeMin;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownTimeMax;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEffectBackgroundParameterVector       Rotation;                                          // 0x001C(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEffectBackgroundParameterVector       Scale;                                             // 0x0034(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FParticleSysParam>              InstanceParameters;                                // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectBackgroundParameter) == 0x000008, "Wrong alignment on FEffectBackgroundParameter");
static_assert(sizeof(FEffectBackgroundParameter) == 0x000060, "Wrong size on FEffectBackgroundParameter");
static_assert(offsetof(FEffectBackgroundParameter, bUseSpawnParamter) == 0x000000, "Member 'FEffectBackgroundParameter::bUseSpawnParamter' has a wrong offset!");
static_assert(offsetof(FEffectBackgroundParameter, TimeMin) == 0x000004, "Member 'FEffectBackgroundParameter::TimeMin' has a wrong offset!");
static_assert(offsetof(FEffectBackgroundParameter, TimeMax) == 0x000008, "Member 'FEffectBackgroundParameter::TimeMax' has a wrong offset!");
static_assert(offsetof(FEffectBackgroundParameter, SpawnMin) == 0x00000C, "Member 'FEffectBackgroundParameter::SpawnMin' has a wrong offset!");
static_assert(offsetof(FEffectBackgroundParameter, SpawnMax) == 0x000010, "Member 'FEffectBackgroundParameter::SpawnMax' has a wrong offset!");
static_assert(offsetof(FEffectBackgroundParameter, CooldownTimeMin) == 0x000014, "Member 'FEffectBackgroundParameter::CooldownTimeMin' has a wrong offset!");
static_assert(offsetof(FEffectBackgroundParameter, CooldownTimeMax) == 0x000018, "Member 'FEffectBackgroundParameter::CooldownTimeMax' has a wrong offset!");
static_assert(offsetof(FEffectBackgroundParameter, Rotation) == 0x00001C, "Member 'FEffectBackgroundParameter::Rotation' has a wrong offset!");
static_assert(offsetof(FEffectBackgroundParameter, Scale) == 0x000034, "Member 'FEffectBackgroundParameter::Scale' has a wrong offset!");
static_assert(offsetof(FEffectBackgroundParameter, InstanceParameters) == 0x000050, "Member 'FEffectBackgroundParameter::InstanceParameters' has a wrong offset!");

// ScriptStruct BattlePrototype.MessageDataCell
// 0x0058 (0x0060 - 0x0008)
struct FMessageDataCell final : public FTableRowBase
{
public:
	class FString                                 DisplayName;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Text;                                              // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundAtomCue>           Voice;                                             // 0x0028(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceAttachToActor;                                // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceAttachToBone;                                 // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMessageDataCell) == 0x000008, "Wrong alignment on FMessageDataCell");
static_assert(sizeof(FMessageDataCell) == 0x000060, "Wrong size on FMessageDataCell");
static_assert(offsetof(FMessageDataCell, DisplayName) == 0x000008, "Member 'FMessageDataCell::DisplayName' has a wrong offset!");
static_assert(offsetof(FMessageDataCell, Text) == 0x000018, "Member 'FMessageDataCell::Text' has a wrong offset!");
static_assert(offsetof(FMessageDataCell, Voice) == 0x000028, "Member 'FMessageDataCell::Voice' has a wrong offset!");
static_assert(offsetof(FMessageDataCell, VoiceAttachToActor) == 0x000050, "Member 'FMessageDataCell::VoiceAttachToActor' has a wrong offset!");
static_assert(offsetof(FMessageDataCell, VoiceAttachToBone) == 0x000058, "Member 'FMessageDataCell::VoiceAttachToBone' has a wrong offset!");

// ScriptStruct BattlePrototype.ElevatorFloorParameter
// 0x0020 (0x0020 - 0x0000)
struct FElevatorFloorParameter final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          OpenAnim;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CloseAnim;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FElevatorFloorParameter) == 0x000008, "Wrong alignment on FElevatorFloorParameter");
static_assert(sizeof(FElevatorFloorParameter) == 0x000020, "Wrong size on FElevatorFloorParameter");
static_assert(offsetof(FElevatorFloorParameter, Location) == 0x000000, "Member 'FElevatorFloorParameter::Location' has a wrong offset!");
static_assert(offsetof(FElevatorFloorParameter, OpenAnim) == 0x000010, "Member 'FElevatorFloorParameter::OpenAnim' has a wrong offset!");
static_assert(offsetof(FElevatorFloorParameter, CloseAnim) == 0x000018, "Member 'FElevatorFloorParameter::CloseAnim' has a wrong offset!");

// ScriptStruct BattlePrototype.EnemyAssumptionLvRangeData
// 0x0010 (0x0018 - 0x0008)
struct FEnemyAssumptionLvRangeData final : public FTableRowBase
{
public:
	int32                                         StartProgressID;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FinishProgressID;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AssumptionLv;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RelativeLv;                                        // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnemyAssumptionLvRangeData) == 0x000008, "Wrong alignment on FEnemyAssumptionLvRangeData");
static_assert(sizeof(FEnemyAssumptionLvRangeData) == 0x000018, "Wrong size on FEnemyAssumptionLvRangeData");
static_assert(offsetof(FEnemyAssumptionLvRangeData, StartProgressID) == 0x000008, "Member 'FEnemyAssumptionLvRangeData::StartProgressID' has a wrong offset!");
static_assert(offsetof(FEnemyAssumptionLvRangeData, FinishProgressID) == 0x00000C, "Member 'FEnemyAssumptionLvRangeData::FinishProgressID' has a wrong offset!");
static_assert(offsetof(FEnemyAssumptionLvRangeData, AssumptionLv) == 0x000010, "Member 'FEnemyAssumptionLvRangeData::AssumptionLv' has a wrong offset!");
static_assert(offsetof(FEnemyAssumptionLvRangeData, RelativeLv) == 0x000014, "Member 'FEnemyAssumptionLvRangeData::RelativeLv' has a wrong offset!");

// ScriptStruct BattlePrototype.UIMapIconAdjust
// 0x0024 (0x0024 - 0x0000)
struct FUIMapIconAdjust final
{
public:
	struct FVector                                IconWideArea;                                      // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IconNarrowArea;                                    // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IconDetailMap;                                     // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIMapIconAdjust) == 0x000004, "Wrong alignment on FUIMapIconAdjust");
static_assert(sizeof(FUIMapIconAdjust) == 0x000024, "Wrong size on FUIMapIconAdjust");
static_assert(offsetof(FUIMapIconAdjust, IconWideArea) == 0x000000, "Member 'FUIMapIconAdjust::IconWideArea' has a wrong offset!");
static_assert(offsetof(FUIMapIconAdjust, IconNarrowArea) == 0x00000C, "Member 'FUIMapIconAdjust::IconNarrowArea' has a wrong offset!");
static_assert(offsetof(FUIMapIconAdjust, IconDetailMap) == 0x000018, "Member 'FUIMapIconAdjust::IconDetailMap' has a wrong offset!");

// ScriptStruct BattlePrototype.MACMaterialParameter
// 0x0010 (0x0010 - 0x0000)
struct FMACMaterialParameter final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               Mid;                                               // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMACMaterialParameter) == 0x000008, "Wrong alignment on FMACMaterialParameter");
static_assert(sizeof(FMACMaterialParameter) == 0x000010, "Wrong size on FMACMaterialParameter");
static_assert(offsetof(FMACMaterialParameter, Mid) == 0x000008, "Member 'FMACMaterialParameter::Mid' has a wrong offset!");

// ScriptStruct BattlePrototype.MACSlotParameter
// 0x0020 (0x0020 - 0x0000)
struct FMACSlotParameter final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMACMaterialParameter>          MaterialParameter;                                 // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMACSlotParameter) == 0x000008, "Wrong alignment on FMACSlotParameter");
static_assert(sizeof(FMACSlotParameter) == 0x000020, "Wrong size on FMACSlotParameter");
static_assert(offsetof(FMACSlotParameter, MaterialParameter) == 0x000010, "Member 'FMACSlotParameter::MaterialParameter' has a wrong offset!");

// ScriptStruct BattlePrototype.EnemyAssumptionLvMainPlayerIdData
// 0x0010 (0x0018 - 0x0008)
struct FEnemyAssumptionLvMainPlayerIdData final : public FTableRowBase
{
public:
	EPlayerID                                     MainPlayerID;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProgressId;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AssumptionLv;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RelativeLv;                                        // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnemyAssumptionLvMainPlayerIdData) == 0x000008, "Wrong alignment on FEnemyAssumptionLvMainPlayerIdData");
static_assert(sizeof(FEnemyAssumptionLvMainPlayerIdData) == 0x000018, "Wrong size on FEnemyAssumptionLvMainPlayerIdData");
static_assert(offsetof(FEnemyAssumptionLvMainPlayerIdData, MainPlayerID) == 0x000008, "Member 'FEnemyAssumptionLvMainPlayerIdData::MainPlayerID' has a wrong offset!");
static_assert(offsetof(FEnemyAssumptionLvMainPlayerIdData, ProgressId) == 0x00000C, "Member 'FEnemyAssumptionLvMainPlayerIdData::ProgressId' has a wrong offset!");
static_assert(offsetof(FEnemyAssumptionLvMainPlayerIdData, AssumptionLv) == 0x000010, "Member 'FEnemyAssumptionLvMainPlayerIdData::AssumptionLv' has a wrong offset!");
static_assert(offsetof(FEnemyAssumptionLvMainPlayerIdData, RelativeLv) == 0x000014, "Member 'FEnemyAssumptionLvMainPlayerIdData::RelativeLv' has a wrong offset!");

// ScriptStruct BattlePrototype.EnemyAssumptionLvPlayerIdData
// 0x0020 (0x0028 - 0x0008)
struct FEnemyAssumptionLvPlayerIdData final : public FTableRowBase
{
public:
	class FString                                 MainPlayerID;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressId;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AssumptionLv;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RelativeLv;                                        // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnemyAssumptionLvPlayerIdData) == 0x000008, "Wrong alignment on FEnemyAssumptionLvPlayerIdData");
static_assert(sizeof(FEnemyAssumptionLvPlayerIdData) == 0x000028, "Wrong size on FEnemyAssumptionLvPlayerIdData");
static_assert(offsetof(FEnemyAssumptionLvPlayerIdData, MainPlayerID) == 0x000008, "Member 'FEnemyAssumptionLvPlayerIdData::MainPlayerID' has a wrong offset!");
static_assert(offsetof(FEnemyAssumptionLvPlayerIdData, ProgressId) == 0x000018, "Member 'FEnemyAssumptionLvPlayerIdData::ProgressId' has a wrong offset!");
static_assert(offsetof(FEnemyAssumptionLvPlayerIdData, AssumptionLv) == 0x00001C, "Member 'FEnemyAssumptionLvPlayerIdData::AssumptionLv' has a wrong offset!");
static_assert(offsetof(FEnemyAssumptionLvPlayerIdData, RelativeLv) == 0x000020, "Member 'FEnemyAssumptionLvPlayerIdData::RelativeLv' has a wrong offset!");

// ScriptStruct BattlePrototype.PsychicRoadStepInfo
// 0x0008 (0x0010 - 0x0008)
struct FPsychicRoadStepInfo final : public FTableRowBase
{
public:
	int32                                         StopSplineIdx;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToNextStop;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPsychicRoadStepInfo) == 0x000008, "Wrong alignment on FPsychicRoadStepInfo");
static_assert(sizeof(FPsychicRoadStepInfo) == 0x000010, "Wrong size on FPsychicRoadStepInfo");
static_assert(offsetof(FPsychicRoadStepInfo, StopSplineIdx) == 0x000008, "Member 'FPsychicRoadStepInfo::StopSplineIdx' has a wrong offset!");
static_assert(offsetof(FPsychicRoadStepInfo, TimeToNextStop) == 0x00000C, "Member 'FPsychicRoadStepInfo::TimeToNextStop' has a wrong offset!");

// ScriptStruct BattlePrototype.EnemyWeakMaterialData
// 0x0020 (0x0020 - 0x0000)
struct FEnemyWeakMaterialData final
{
public:
	class FString                                 MaterialEmissiveName;                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timer;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          End;                                               // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EndTimer;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnemyWeakMaterialData) == 0x000008, "Wrong alignment on FEnemyWeakMaterialData");
static_assert(sizeof(FEnemyWeakMaterialData) == 0x000020, "Wrong size on FEnemyWeakMaterialData");
static_assert(offsetof(FEnemyWeakMaterialData, MaterialEmissiveName) == 0x000000, "Member 'FEnemyWeakMaterialData::MaterialEmissiveName' has a wrong offset!");
static_assert(offsetof(FEnemyWeakMaterialData, Timer) == 0x000010, "Member 'FEnemyWeakMaterialData::Timer' has a wrong offset!");
static_assert(offsetof(FEnemyWeakMaterialData, End) == 0x000014, "Member 'FEnemyWeakMaterialData::End' has a wrong offset!");
static_assert(offsetof(FEnemyWeakMaterialData, EndTimer) == 0x000018, "Member 'FEnemyWeakMaterialData::EndTimer' has a wrong offset!");

// ScriptStruct BattlePrototype.EnemyEnableWeakData
// 0x0040 (0x0040 - 0x0000)
struct FEnemyEnableWeakData final
{
public:
	TArray<class FString>                         WeakNameList;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         DummyWeakNameList;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableTime;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StartEnableWeak;                                   // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WeakSlotName;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DispAroundEffectWhenInactive;                      // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnemyEnableWeakData) == 0x000008, "Wrong alignment on FEnemyEnableWeakData");
static_assert(sizeof(FEnemyEnableWeakData) == 0x000040, "Wrong size on FEnemyEnableWeakData");
static_assert(offsetof(FEnemyEnableWeakData, WeakNameList) == 0x000000, "Member 'FEnemyEnableWeakData::WeakNameList' has a wrong offset!");
static_assert(offsetof(FEnemyEnableWeakData, DummyWeakNameList) == 0x000010, "Member 'FEnemyEnableWeakData::DummyWeakNameList' has a wrong offset!");
static_assert(offsetof(FEnemyEnableWeakData, EnableTime) == 0x000020, "Member 'FEnemyEnableWeakData::EnableTime' has a wrong offset!");
static_assert(offsetof(FEnemyEnableWeakData, StartEnableWeak) == 0x000024, "Member 'FEnemyEnableWeakData::StartEnableWeak' has a wrong offset!");
static_assert(offsetof(FEnemyEnableWeakData, WeakSlotName) == 0x000028, "Member 'FEnemyEnableWeakData::WeakSlotName' has a wrong offset!");
static_assert(offsetof(FEnemyEnableWeakData, DispAroundEffectWhenInactive) == 0x000038, "Member 'FEnemyEnableWeakData::DispAroundEffectWhenInactive' has a wrong offset!");

// ScriptStruct BattlePrototype.MaterialSwitchCacheData
// 0x0018 (0x0018 - 0x0000)
struct FMaterialSwitchCacheData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             BaseMaterial;                                      // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialSwitchCacheData) == 0x000008, "Wrong alignment on FMaterialSwitchCacheData");
static_assert(sizeof(FMaterialSwitchCacheData) == 0x000018, "Wrong size on FMaterialSwitchCacheData");
static_assert(offsetof(FMaterialSwitchCacheData, BaseMaterial) == 0x000008, "Member 'FMaterialSwitchCacheData::BaseMaterial' has a wrong offset!");

// ScriptStruct BattlePrototype.MaterialSwitchCache
// 0x0010 (0x0010 - 0x0000)
struct FMaterialSwitchCache final
{
public:
	TArray<struct FMaterialSwitchCacheData>       DataList;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialSwitchCache) == 0x000008, "Wrong alignment on FMaterialSwitchCache");
static_assert(sizeof(FMaterialSwitchCache) == 0x000010, "Wrong size on FMaterialSwitchCache");
static_assert(offsetof(FMaterialSwitchCache, DataList) == 0x000000, "Member 'FMaterialSwitchCache::DataList' has a wrong offset!");

// ScriptStruct BattlePrototype.AiParamEnemyInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FAiParamEnemyInfo final
{
public:
	EEnemyThinkActionType                         MThinkActionType;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MNeedRay;                                          // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MProbability;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MProbability2;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MRange;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MNoRange;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAngle;                                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MNoAngle;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MCoolTime;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MSpeedScale;                                       // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MHp;                                               // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTime;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MValue;                                            // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAnother_Probability1;                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAnother_Probability2;                             // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAnother_Probability3;                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAnother_Probability4;                             // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAnother_Probability5;                             // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAnother_Value1;                                   // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAnother_Value2;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAnother_Value3;                                   // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 MNextProbabilities;                                // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 MNextValues0;                                      // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 MNextValues1;                                      // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsBerserk;                                        // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 MUniqueConditions;                                 // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIgnoreOutOfScreen;                                // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIgnoreRestrictAttackOther;                        // 0x0099(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MNotAddAttackingList;                              // 0x009A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MNotBrainField;                                    // 0x009B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAiParamEnemyInfo) == 0x000008, "Wrong alignment on FAiParamEnemyInfo");
static_assert(sizeof(FAiParamEnemyInfo) == 0x0000A0, "Wrong size on FAiParamEnemyInfo");
static_assert(offsetof(FAiParamEnemyInfo, MThinkActionType) == 0x000000, "Member 'FAiParamEnemyInfo::MThinkActionType' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MNeedRay) == 0x000001, "Member 'FAiParamEnemyInfo::MNeedRay' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MProbability) == 0x000004, "Member 'FAiParamEnemyInfo::MProbability' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MProbability2) == 0x000008, "Member 'FAiParamEnemyInfo::MProbability2' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MRange) == 0x00000C, "Member 'FAiParamEnemyInfo::MRange' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MNoRange) == 0x000010, "Member 'FAiParamEnemyInfo::MNoRange' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MAngle) == 0x000014, "Member 'FAiParamEnemyInfo::MAngle' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MNoAngle) == 0x000018, "Member 'FAiParamEnemyInfo::MNoAngle' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MCoolTime) == 0x00001C, "Member 'FAiParamEnemyInfo::MCoolTime' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MSpeedScale) == 0x000020, "Member 'FAiParamEnemyInfo::MSpeedScale' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MHp) == 0x000024, "Member 'FAiParamEnemyInfo::MHp' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MTime) == 0x000028, "Member 'FAiParamEnemyInfo::MTime' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MValue) == 0x00002C, "Member 'FAiParamEnemyInfo::MValue' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MAnother_Probability1) == 0x000030, "Member 'FAiParamEnemyInfo::MAnother_Probability1' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MAnother_Probability2) == 0x000034, "Member 'FAiParamEnemyInfo::MAnother_Probability2' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MAnother_Probability3) == 0x000038, "Member 'FAiParamEnemyInfo::MAnother_Probability3' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MAnother_Probability4) == 0x00003C, "Member 'FAiParamEnemyInfo::MAnother_Probability4' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MAnother_Probability5) == 0x000040, "Member 'FAiParamEnemyInfo::MAnother_Probability5' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MAnother_Value1) == 0x000044, "Member 'FAiParamEnemyInfo::MAnother_Value1' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MAnother_Value2) == 0x000048, "Member 'FAiParamEnemyInfo::MAnother_Value2' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MAnother_Value3) == 0x00004C, "Member 'FAiParamEnemyInfo::MAnother_Value3' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MNextProbabilities) == 0x000050, "Member 'FAiParamEnemyInfo::MNextProbabilities' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MNextValues0) == 0x000060, "Member 'FAiParamEnemyInfo::MNextValues0' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MNextValues1) == 0x000070, "Member 'FAiParamEnemyInfo::MNextValues1' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MIsBerserk) == 0x000080, "Member 'FAiParamEnemyInfo::MIsBerserk' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MUniqueConditions) == 0x000088, "Member 'FAiParamEnemyInfo::MUniqueConditions' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MIgnoreOutOfScreen) == 0x000098, "Member 'FAiParamEnemyInfo::MIgnoreOutOfScreen' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MIgnoreRestrictAttackOther) == 0x000099, "Member 'FAiParamEnemyInfo::MIgnoreRestrictAttackOther' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MNotAddAttackingList) == 0x00009A, "Member 'FAiParamEnemyInfo::MNotAddAttackingList' has a wrong offset!");
static_assert(offsetof(FAiParamEnemyInfo, MNotBrainField) == 0x00009B, "Member 'FAiParamEnemyInfo::MNotBrainField' has a wrong offset!");

// ScriptStruct BattlePrototype.EnemyDefine
// 0x0001 (0x0001 - 0x0000)
struct FEnemyDefine final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnemyDefine) == 0x000001, "Wrong alignment on FEnemyDefine");
static_assert(sizeof(FEnemyDefine) == 0x000001, "Wrong size on FEnemyDefine");

// ScriptStruct BattlePrototype.AjitoNpcAttachInfo
// 0x0018 (0x0020 - 0x0008)
struct FAjitoNpcAttachInfo final : public FTableRowBase
{
public:
	ENpcAnimationKind                             AnimKind;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAjitoNpcAttach>                Attaches;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAjitoNpcAttachInfo) == 0x000008, "Wrong alignment on FAjitoNpcAttachInfo");
static_assert(sizeof(FAjitoNpcAttachInfo) == 0x000020, "Wrong size on FAjitoNpcAttachInfo");
static_assert(offsetof(FAjitoNpcAttachInfo, AnimKind) == 0x000008, "Member 'FAjitoNpcAttachInfo::AnimKind' has a wrong offset!");
static_assert(offsetof(FAjitoNpcAttachInfo, Attaches) == 0x000010, "Member 'FAjitoNpcAttachInfo::Attaches' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoNpcAnimInfo
// 0x0010 (0x0018 - 0x0008)
struct FAjitoNpcAnimInfo final : public FTableRowBase
{
public:
	TArray<struct FAjitoNpcAttachInfo>            AttachInfo;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAjitoNpcAnimInfo) == 0x000008, "Wrong alignment on FAjitoNpcAnimInfo");
static_assert(sizeof(FAjitoNpcAnimInfo) == 0x000018, "Wrong size on FAjitoNpcAnimInfo");
static_assert(offsetof(FAjitoNpcAnimInfo, AttachInfo) == 0x000008, "Member 'FAjitoNpcAnimInfo::AttachInfo' has a wrong offset!");

// ScriptStruct BattlePrototype.VisionFogAreaInfo
// 0x0020 (0x0020 - 0x0000)
struct FVisionFogAreaInfo final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UniqueName;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVisionFogAreaInfo) == 0x000008, "Wrong alignment on FVisionFogAreaInfo");
static_assert(sizeof(FVisionFogAreaInfo) == 0x000020, "Wrong size on FVisionFogAreaInfo");
static_assert(offsetof(FVisionFogAreaInfo, Location) == 0x000000, "Member 'FVisionFogAreaInfo::Location' has a wrong offset!");
static_assert(offsetof(FVisionFogAreaInfo, Radius) == 0x00000C, "Member 'FVisionFogAreaInfo::Radius' has a wrong offset!");
static_assert(offsetof(FVisionFogAreaInfo, UniqueName) == 0x000010, "Member 'FVisionFogAreaInfo::UniqueName' has a wrong offset!");

// ScriptStruct BattlePrototype.EmLostActionInfo
// 0x0008 (0x0008 - 0x0000)
struct FEmLostActionInfo final
{
public:
	EnemyActionAnimKind                           LostActionKind;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Probability;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmLostActionInfo) == 0x000004, "Wrong alignment on FEmLostActionInfo");
static_assert(sizeof(FEmLostActionInfo) == 0x000008, "Wrong size on FEmLostActionInfo");
static_assert(offsetof(FEmLostActionInfo, LostActionKind) == 0x000000, "Member 'FEmLostActionInfo::LostActionKind' has a wrong offset!");
static_assert(offsetof(FEmLostActionInfo, Probability) == 0x000004, "Member 'FEmLostActionInfo::Probability' has a wrong offset!");

// ScriptStruct BattlePrototype.MsgViewerData
// 0x0028 (0x0028 - 0x0000)
struct FMsgViewerData final
{
public:
	EMsgViewerDataType                            Type;                                              // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DispName;                                          // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DataPath;                                          // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgViewerData) == 0x000008, "Wrong alignment on FMsgViewerData");
static_assert(sizeof(FMsgViewerData) == 0x000028, "Wrong size on FMsgViewerData");
static_assert(offsetof(FMsgViewerData, Type) == 0x000000, "Member 'FMsgViewerData::Type' has a wrong offset!");
static_assert(offsetof(FMsgViewerData, DispName) == 0x000008, "Member 'FMsgViewerData::DispName' has a wrong offset!");
static_assert(offsetof(FMsgViewerData, DataPath) == 0x000018, "Member 'FMsgViewerData::DataPath' has a wrong offset!");

// ScriptStruct BattlePrototype.EnemyFindChangeParam
// 0x0010 (0x0010 - 0x0000)
struct FEnemyFindChangeParam final
{
public:
	float                                         NMin;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NMax;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M;                                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         K;                                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyFindChangeParam) == 0x000004, "Wrong alignment on FEnemyFindChangeParam");
static_assert(sizeof(FEnemyFindChangeParam) == 0x000010, "Wrong size on FEnemyFindChangeParam");
static_assert(offsetof(FEnemyFindChangeParam, NMin) == 0x000000, "Member 'FEnemyFindChangeParam::NMin' has a wrong offset!");
static_assert(offsetof(FEnemyFindChangeParam, NMax) == 0x000004, "Member 'FEnemyFindChangeParam::NMax' has a wrong offset!");
static_assert(offsetof(FEnemyFindChangeParam, M) == 0x000008, "Member 'FEnemyFindChangeParam::M' has a wrong offset!");
static_assert(offsetof(FEnemyFindChangeParam, K) == 0x00000C, "Member 'FEnemyFindChangeParam::K' has a wrong offset!");

// ScriptStruct BattlePrototype.SearchTestInfo
// 0x0003 (0x0003 - 0x0000)
struct FSearchTestInfo final
{
public:
	bool                                          MbViewTest;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbSearchTest;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbCaptureTest;                                     // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSearchTestInfo) == 0x000001, "Wrong alignment on FSearchTestInfo");
static_assert(sizeof(FSearchTestInfo) == 0x000003, "Wrong size on FSearchTestInfo");
static_assert(offsetof(FSearchTestInfo, MbViewTest) == 0x000000, "Member 'FSearchTestInfo::MbViewTest' has a wrong offset!");
static_assert(offsetof(FSearchTestInfo, MbSearchTest) == 0x000001, "Member 'FSearchTestInfo::MbSearchTest' has a wrong offset!");
static_assert(offsetof(FSearchTestInfo, MbCaptureTest) == 0x000002, "Member 'FSearchTestInfo::MbCaptureTest' has a wrong offset!");

// ScriptStruct BattlePrototype.MaterialLocationParam
// 0x001C (0x001C - 0x0000)
struct FMaterialLocationParam final
{
public:
	struct FLinearColor                           FogColor;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogDensity;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogStartDistance;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogFalloffDistance;                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialLocationParam) == 0x000004, "Wrong alignment on FMaterialLocationParam");
static_assert(sizeof(FMaterialLocationParam) == 0x00001C, "Wrong size on FMaterialLocationParam");
static_assert(offsetof(FMaterialLocationParam, FogColor) == 0x000000, "Member 'FMaterialLocationParam::FogColor' has a wrong offset!");
static_assert(offsetof(FMaterialLocationParam, FogDensity) == 0x000010, "Member 'FMaterialLocationParam::FogDensity' has a wrong offset!");
static_assert(offsetof(FMaterialLocationParam, FogStartDistance) == 0x000014, "Member 'FMaterialLocationParam::FogStartDistance' has a wrong offset!");
static_assert(offsetof(FMaterialLocationParam, FogFalloffDistance) == 0x000018, "Member 'FMaterialLocationParam::FogFalloffDistance' has a wrong offset!");

// ScriptStruct BattlePrototype.MaterialLocationParamTable
// 0x0020 (0x0028 - 0x0008)
struct FMaterialLocationParamTable final : public FTableRowBase
{
public:
	struct FMaterialLocationParam                 Setting;                                           // 0x0008(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaterialLocationParamTable) == 0x000008, "Wrong alignment on FMaterialLocationParamTable");
static_assert(sizeof(FMaterialLocationParamTable) == 0x000028, "Wrong size on FMaterialLocationParamTable");
static_assert(offsetof(FMaterialLocationParamTable, Setting) == 0x000008, "Member 'FMaterialLocationParamTable::Setting' has a wrong offset!");

// ScriptStruct BattlePrototype.UIMain3DCharacterGeneralSetting
// 0x0020 (0x0020 - 0x0000)
struct FUIMain3DCharacterGeneralSetting final
{
public:
	float                                         DirectionalLightIntensity;                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DirectionalLightColor;                             // 0x0004(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DirectionalLightRotation;                          // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIMain3DCharacterGeneralSetting) == 0x000004, "Wrong alignment on FUIMain3DCharacterGeneralSetting");
static_assert(sizeof(FUIMain3DCharacterGeneralSetting) == 0x000020, "Wrong size on FUIMain3DCharacterGeneralSetting");
static_assert(offsetof(FUIMain3DCharacterGeneralSetting, DirectionalLightIntensity) == 0x000000, "Member 'FUIMain3DCharacterGeneralSetting::DirectionalLightIntensity' has a wrong offset!");
static_assert(offsetof(FUIMain3DCharacterGeneralSetting, DirectionalLightColor) == 0x000004, "Member 'FUIMain3DCharacterGeneralSetting::DirectionalLightColor' has a wrong offset!");
static_assert(offsetof(FUIMain3DCharacterGeneralSetting, DirectionalLightRotation) == 0x000014, "Member 'FUIMain3DCharacterGeneralSetting::DirectionalLightRotation' has a wrong offset!");

// ScriptStruct BattlePrototype.UIMain3DCharacterGeneralSettingTableRow
// 0x0020 (0x0028 - 0x0008)
struct FUIMain3DCharacterGeneralSettingTableRow final : public FTableRowBase
{
public:
	struct FUIMain3DCharacterGeneralSetting       Setting;                                           // 0x0008(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIMain3DCharacterGeneralSettingTableRow) == 0x000008, "Wrong alignment on FUIMain3DCharacterGeneralSettingTableRow");
static_assert(sizeof(FUIMain3DCharacterGeneralSettingTableRow) == 0x000028, "Wrong size on FUIMain3DCharacterGeneralSettingTableRow");
static_assert(offsetof(FUIMain3DCharacterGeneralSettingTableRow, Setting) == 0x000008, "Member 'FUIMain3DCharacterGeneralSettingTableRow::Setting' has a wrong offset!");

// ScriptStruct BattlePrototype.SearchBasicInfo
// 0x001C (0x001C - 0x0000)
struct FSearchBasicInfo final
{
public:
	TWeakObjectPtr<class ARSCharacterBase>        MTargetCharacter;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MSearchAngle;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MSearchDistance3D;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MSearchDistance2D;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MSearchHeight;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbRayThrough;                                      // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSearchBasicInfo) == 0x000004, "Wrong alignment on FSearchBasicInfo");
static_assert(sizeof(FSearchBasicInfo) == 0x00001C, "Wrong size on FSearchBasicInfo");
static_assert(offsetof(FSearchBasicInfo, MTargetCharacter) == 0x000000, "Member 'FSearchBasicInfo::MTargetCharacter' has a wrong offset!");
static_assert(offsetof(FSearchBasicInfo, MSearchAngle) == 0x000008, "Member 'FSearchBasicInfo::MSearchAngle' has a wrong offset!");
static_assert(offsetof(FSearchBasicInfo, MSearchDistance3D) == 0x00000C, "Member 'FSearchBasicInfo::MSearchDistance3D' has a wrong offset!");
static_assert(offsetof(FSearchBasicInfo, MSearchDistance2D) == 0x000010, "Member 'FSearchBasicInfo::MSearchDistance2D' has a wrong offset!");
static_assert(offsetof(FSearchBasicInfo, MSearchHeight) == 0x000014, "Member 'FSearchBasicInfo::MSearchHeight' has a wrong offset!");
static_assert(offsetof(FSearchBasicInfo, MbRayThrough) == 0x000018, "Member 'FSearchBasicInfo::MbRayThrough' has a wrong offset!");

// ScriptStruct BattlePrototype.ArrangeItemPopItemDataCell
// 0x0018 (0x0020 - 0x0008)
struct FArrangeItemPopItemDataCell final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GetProbability;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GetNumMin;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GetNumMax;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArrangeItemPopItemDataCell) == 0x000008, "Wrong alignment on FArrangeItemPopItemDataCell");
static_assert(sizeof(FArrangeItemPopItemDataCell) == 0x000020, "Wrong size on FArrangeItemPopItemDataCell");
static_assert(offsetof(FArrangeItemPopItemDataCell, ItemId) == 0x000008, "Member 'FArrangeItemPopItemDataCell::ItemId' has a wrong offset!");
static_assert(offsetof(FArrangeItemPopItemDataCell, GetProbability) == 0x000010, "Member 'FArrangeItemPopItemDataCell::GetProbability' has a wrong offset!");
static_assert(offsetof(FArrangeItemPopItemDataCell, GetNumMin) == 0x000014, "Member 'FArrangeItemPopItemDataCell::GetNumMin' has a wrong offset!");
static_assert(offsetof(FArrangeItemPopItemDataCell, GetNumMax) == 0x000018, "Member 'FArrangeItemPopItemDataCell::GetNumMax' has a wrong offset!");
static_assert(offsetof(FArrangeItemPopItemDataCell, Rarity) == 0x00001C, "Member 'FArrangeItemPopItemDataCell::Rarity' has a wrong offset!");

// ScriptStruct BattlePrototype.EnemyItemDropDataCell
// 0x0028 (0x0030 - 0x0008)
struct FEnemyItemDropDataCell final : public FTableRowBase
{
public:
	float                                         DropItemProbability;                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FArrangeItemPopItemDataCell>    DataDropItems;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FArrangeItemPopItemDataCell>    CoreDropItems;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyItemDropDataCell) == 0x000008, "Wrong alignment on FEnemyItemDropDataCell");
static_assert(sizeof(FEnemyItemDropDataCell) == 0x000030, "Wrong size on FEnemyItemDropDataCell");
static_assert(offsetof(FEnemyItemDropDataCell, DropItemProbability) == 0x000008, "Member 'FEnemyItemDropDataCell::DropItemProbability' has a wrong offset!");
static_assert(offsetof(FEnemyItemDropDataCell, DataDropItems) == 0x000010, "Member 'FEnemyItemDropDataCell::DataDropItems' has a wrong offset!");
static_assert(offsetof(FEnemyItemDropDataCell, CoreDropItems) == 0x000020, "Member 'FEnemyItemDropDataCell::CoreDropItems' has a wrong offset!");

// ScriptStruct BattlePrototype.WorldmapBatchOpenDataCell
// 0x0018 (0x0020 - 0x0008)
struct FWorldmapBatchOpenDataCell final : public FTableRowBase
{
public:
	int32                                         ProgressId;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AllSelectable;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SealedL;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SealedH;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OpenedL;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OpenedH;                                           // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWorldmapBatchOpenDataCell) == 0x000008, "Wrong alignment on FWorldmapBatchOpenDataCell");
static_assert(sizeof(FWorldmapBatchOpenDataCell) == 0x000020, "Wrong size on FWorldmapBatchOpenDataCell");
static_assert(offsetof(FWorldmapBatchOpenDataCell, ProgressId) == 0x000008, "Member 'FWorldmapBatchOpenDataCell::ProgressId' has a wrong offset!");
static_assert(offsetof(FWorldmapBatchOpenDataCell, AllSelectable) == 0x00000C, "Member 'FWorldmapBatchOpenDataCell::AllSelectable' has a wrong offset!");
static_assert(offsetof(FWorldmapBatchOpenDataCell, SealedL) == 0x000010, "Member 'FWorldmapBatchOpenDataCell::SealedL' has a wrong offset!");
static_assert(offsetof(FWorldmapBatchOpenDataCell, SealedH) == 0x000014, "Member 'FWorldmapBatchOpenDataCell::SealedH' has a wrong offset!");
static_assert(offsetof(FWorldmapBatchOpenDataCell, OpenedL) == 0x000018, "Member 'FWorldmapBatchOpenDataCell::OpenedL' has a wrong offset!");
static_assert(offsetof(FWorldmapBatchOpenDataCell, OpenedH) == 0x00001C, "Member 'FWorldmapBatchOpenDataCell::OpenedH' has a wrong offset!");

// ScriptStruct BattlePrototype.PresentLocationCameraContainData
// 0x0018 (0x0020 - 0x0008)
struct FPresentLocationCameraContainData final : public FTableRowBase
{
public:
	struct FVector                                Location;                                          // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPresentLocationCameraContainData) == 0x000008, "Wrong alignment on FPresentLocationCameraContainData");
static_assert(sizeof(FPresentLocationCameraContainData) == 0x000020, "Wrong size on FPresentLocationCameraContainData");
static_assert(offsetof(FPresentLocationCameraContainData, Location) == 0x000008, "Member 'FPresentLocationCameraContainData::Location' has a wrong offset!");
static_assert(offsetof(FPresentLocationCameraContainData, Yaw) == 0x000014, "Member 'FPresentLocationCameraContainData::Yaw' has a wrong offset!");
static_assert(offsetof(FPresentLocationCameraContainData, Pitch) == 0x000018, "Member 'FPresentLocationCameraContainData::Pitch' has a wrong offset!");

// ScriptStruct BattlePrototype.EnemyMoneyDataCell
// 0x0010 (0x0018 - 0x0008)
struct FEnemyMoneyDataCell final : public FTableRowBase
{
public:
	TArray<int32>                                 Money;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyMoneyDataCell) == 0x000008, "Wrong alignment on FEnemyMoneyDataCell");
static_assert(sizeof(FEnemyMoneyDataCell) == 0x000018, "Wrong size on FEnemyMoneyDataCell");
static_assert(offsetof(FEnemyMoneyDataCell, Money) == 0x000008, "Member 'FEnemyMoneyDataCell::Money' has a wrong offset!");

// ScriptStruct BattlePrototype.NpcMeshAssetSetting
// 0x0170 (0x0170 - 0x0000)
struct FNpcMeshAssetSetting final
{
public:
	TSoftObjectPtr<class USkeletalMesh>           Body;                                              // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           BodyLower;                                         // 0x0028(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Face;                                              // 0x0050(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Hair;                                              // 0x0078(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Parts;                                             // 0x00A0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Parts2;                                            // 0x00C8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Parts3;                                            // 0x00F0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Parts4;                                            // 0x0118(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Parts5;                                            // 0x0140(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENpcMeshSkeletonType                          SkeletonType;                                      // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNpcMeshAssetSetting) == 0x000008, "Wrong alignment on FNpcMeshAssetSetting");
static_assert(sizeof(FNpcMeshAssetSetting) == 0x000170, "Wrong size on FNpcMeshAssetSetting");
static_assert(offsetof(FNpcMeshAssetSetting, Body) == 0x000000, "Member 'FNpcMeshAssetSetting::Body' has a wrong offset!");
static_assert(offsetof(FNpcMeshAssetSetting, BodyLower) == 0x000028, "Member 'FNpcMeshAssetSetting::BodyLower' has a wrong offset!");
static_assert(offsetof(FNpcMeshAssetSetting, Face) == 0x000050, "Member 'FNpcMeshAssetSetting::Face' has a wrong offset!");
static_assert(offsetof(FNpcMeshAssetSetting, Hair) == 0x000078, "Member 'FNpcMeshAssetSetting::Hair' has a wrong offset!");
static_assert(offsetof(FNpcMeshAssetSetting, Parts) == 0x0000A0, "Member 'FNpcMeshAssetSetting::Parts' has a wrong offset!");
static_assert(offsetof(FNpcMeshAssetSetting, Parts2) == 0x0000C8, "Member 'FNpcMeshAssetSetting::Parts2' has a wrong offset!");
static_assert(offsetof(FNpcMeshAssetSetting, Parts3) == 0x0000F0, "Member 'FNpcMeshAssetSetting::Parts3' has a wrong offset!");
static_assert(offsetof(FNpcMeshAssetSetting, Parts4) == 0x000118, "Member 'FNpcMeshAssetSetting::Parts4' has a wrong offset!");
static_assert(offsetof(FNpcMeshAssetSetting, Parts5) == 0x000140, "Member 'FNpcMeshAssetSetting::Parts5' has a wrong offset!");
static_assert(offsetof(FNpcMeshAssetSetting, SkeletonType) == 0x000168, "Member 'FNpcMeshAssetSetting::SkeletonType' has a wrong offset!");

// ScriptStruct BattlePrototype.NpcMeshSetting
// 0x0180 (0x0188 - 0x0008)
struct FNpcMeshSetting final : public FTableRowBase
{
public:
	class FString                                 Comment;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNpcMeshAssetSetting                   Assets;                                            // 0x0018(0x0170)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcMeshSetting) == 0x000008, "Wrong alignment on FNpcMeshSetting");
static_assert(sizeof(FNpcMeshSetting) == 0x000188, "Wrong size on FNpcMeshSetting");
static_assert(offsetof(FNpcMeshSetting, Comment) == 0x000008, "Member 'FNpcMeshSetting::Comment' has a wrong offset!");
static_assert(offsetof(FNpcMeshSetting, Assets) == 0x000018, "Member 'FNpcMeshSetting::Assets' has a wrong offset!");

// ScriptStruct BattlePrototype.EnemyExpDataCell
// 0x0010 (0x0018 - 0x0008)
struct FEnemyExpDataCell final : public FTableRowBase
{
public:
	TArray<int32>                                 Experiences;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyExpDataCell) == 0x000008, "Wrong alignment on FEnemyExpDataCell");
static_assert(sizeof(FEnemyExpDataCell) == 0x000018, "Wrong size on FEnemyExpDataCell");
static_assert(offsetof(FEnemyExpDataCell, Experiences) == 0x000008, "Member 'FEnemyExpDataCell::Experiences' has a wrong offset!");

// ScriptStruct BattlePrototype.EnemyDropDataCell
// 0x0030 (0x0038 - 0x0008)
struct FEnemyDropDataCell final : public FTableRowBase
{
public:
	int32                                         Experience;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Money;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropItemProbability;                               // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FArrangeItemPopItemDataCell>    DataDropItems;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FArrangeItemPopItemDataCell>    CoreDropItems;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyDropDataCell) == 0x000008, "Wrong alignment on FEnemyDropDataCell");
static_assert(sizeof(FEnemyDropDataCell) == 0x000038, "Wrong size on FEnemyDropDataCell");
static_assert(offsetof(FEnemyDropDataCell, Experience) == 0x000008, "Member 'FEnemyDropDataCell::Experience' has a wrong offset!");
static_assert(offsetof(FEnemyDropDataCell, Money) == 0x00000C, "Member 'FEnemyDropDataCell::Money' has a wrong offset!");
static_assert(offsetof(FEnemyDropDataCell, DropItemProbability) == 0x000010, "Member 'FEnemyDropDataCell::DropItemProbability' has a wrong offset!");
static_assert(offsetof(FEnemyDropDataCell, DataDropItems) == 0x000018, "Member 'FEnemyDropDataCell::DataDropItems' has a wrong offset!");
static_assert(offsetof(FEnemyDropDataCell, CoreDropItems) == 0x000028, "Member 'FEnemyDropDataCell::CoreDropItems' has a wrong offset!");

// ScriptStruct BattlePrototype.PresentContainMessageData
// 0x0010 (0x0018 - 0x0008)
struct FPresentContainMessageData final : public FTableRowBase
{
public:
	class FName                                   Dialogue;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Expression;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPresentContainMessageData) == 0x000008, "Wrong alignment on FPresentContainMessageData");
static_assert(sizeof(FPresentContainMessageData) == 0x000018, "Wrong size on FPresentContainMessageData");
static_assert(offsetof(FPresentContainMessageData, Dialogue) == 0x000008, "Member 'FPresentContainMessageData::Dialogue' has a wrong offset!");
static_assert(offsetof(FPresentContainMessageData, Expression) == 0x000010, "Member 'FPresentContainMessageData::Expression' has a wrong offset!");

// ScriptStruct BattlePrototype.PresentDataCell
// 0x0038 (0x0040 - 0x0008)
struct FPresentDataCell final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FromCharaID;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ForCharaID;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPresentContainMessageData>     FirstReaction;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPresentContainMessageData>     ExperiencedReaction;                               // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPresentDataCell) == 0x000008, "Wrong alignment on FPresentDataCell");
static_assert(sizeof(FPresentDataCell) == 0x000040, "Wrong size on FPresentDataCell");
static_assert(offsetof(FPresentDataCell, ItemId) == 0x000008, "Member 'FPresentDataCell::ItemId' has a wrong offset!");
static_assert(offsetof(FPresentDataCell, FromCharaID) == 0x000010, "Member 'FPresentDataCell::FromCharaID' has a wrong offset!");
static_assert(offsetof(FPresentDataCell, ForCharaID) == 0x000018, "Member 'FPresentDataCell::ForCharaID' has a wrong offset!");
static_assert(offsetof(FPresentDataCell, FirstReaction) == 0x000020, "Member 'FPresentDataCell::FirstReaction' has a wrong offset!");
static_assert(offsetof(FPresentDataCell, ExperiencedReaction) == 0x000030, "Member 'FPresentDataCell::ExperiencedReaction' has a wrong offset!");

// ScriptStruct BattlePrototype.EnemyRepopExtendInfo
// 0x0024 (0x0024 - 0x0000)
struct FEnemyRepopExtendInfo final
{
public:
	bool                                          IsIgnoreRestrictAttackOther;                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsIgnoreAllowance;                                 // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNoCheckCaptureArea;                              // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsChangeSearchAngle;                               // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeSearchAngle;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAlwayChangeSearchAngle;                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsChangeSearchRange;                               // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChangeSearchRange;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAlwayChangeSearchRange;                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsChangeSensingAngle;                              // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChangeSensingAngle;                                // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAlwaySensingAngle;                               // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsChangeCaptureArea;                               // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChangeCaptureArea;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAlwayCaptureArea;                                // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnemyRepopExtendInfo) == 0x000004, "Wrong alignment on FEnemyRepopExtendInfo");
static_assert(sizeof(FEnemyRepopExtendInfo) == 0x000024, "Wrong size on FEnemyRepopExtendInfo");
static_assert(offsetof(FEnemyRepopExtendInfo, IsIgnoreRestrictAttackOther) == 0x000000, "Member 'FEnemyRepopExtendInfo::IsIgnoreRestrictAttackOther' has a wrong offset!");
static_assert(offsetof(FEnemyRepopExtendInfo, IsIgnoreAllowance) == 0x000001, "Member 'FEnemyRepopExtendInfo::IsIgnoreAllowance' has a wrong offset!");
static_assert(offsetof(FEnemyRepopExtendInfo, IsNoCheckCaptureArea) == 0x000002, "Member 'FEnemyRepopExtendInfo::IsNoCheckCaptureArea' has a wrong offset!");
static_assert(offsetof(FEnemyRepopExtendInfo, IsChangeSearchAngle) == 0x000003, "Member 'FEnemyRepopExtendInfo::IsChangeSearchAngle' has a wrong offset!");
static_assert(offsetof(FEnemyRepopExtendInfo, ChangeSearchAngle) == 0x000004, "Member 'FEnemyRepopExtendInfo::ChangeSearchAngle' has a wrong offset!");
static_assert(offsetof(FEnemyRepopExtendInfo, IsAlwayChangeSearchAngle) == 0x000008, "Member 'FEnemyRepopExtendInfo::IsAlwayChangeSearchAngle' has a wrong offset!");
static_assert(offsetof(FEnemyRepopExtendInfo, IsChangeSearchRange) == 0x000009, "Member 'FEnemyRepopExtendInfo::IsChangeSearchRange' has a wrong offset!");
static_assert(offsetof(FEnemyRepopExtendInfo, ChangeSearchRange) == 0x00000C, "Member 'FEnemyRepopExtendInfo::ChangeSearchRange' has a wrong offset!");
static_assert(offsetof(FEnemyRepopExtendInfo, IsAlwayChangeSearchRange) == 0x000010, "Member 'FEnemyRepopExtendInfo::IsAlwayChangeSearchRange' has a wrong offset!");
static_assert(offsetof(FEnemyRepopExtendInfo, IsChangeSensingAngle) == 0x000011, "Member 'FEnemyRepopExtendInfo::IsChangeSensingAngle' has a wrong offset!");
static_assert(offsetof(FEnemyRepopExtendInfo, ChangeSensingAngle) == 0x000014, "Member 'FEnemyRepopExtendInfo::ChangeSensingAngle' has a wrong offset!");
static_assert(offsetof(FEnemyRepopExtendInfo, IsAlwaySensingAngle) == 0x000018, "Member 'FEnemyRepopExtendInfo::IsAlwaySensingAngle' has a wrong offset!");
static_assert(offsetof(FEnemyRepopExtendInfo, IsChangeCaptureArea) == 0x000019, "Member 'FEnemyRepopExtendInfo::IsChangeCaptureArea' has a wrong offset!");
static_assert(offsetof(FEnemyRepopExtendInfo, ChangeCaptureArea) == 0x00001C, "Member 'FEnemyRepopExtendInfo::ChangeCaptureArea' has a wrong offset!");
static_assert(offsetof(FEnemyRepopExtendInfo, IsAlwayCaptureArea) == 0x000020, "Member 'FEnemyRepopExtendInfo::IsAlwayCaptureArea' has a wrong offset!");

// ScriptStruct BattlePrototype.EnemyRepopInfo
// 0x0068 (0x0070 - 0x0008)
struct FEnemyRepopInfo final : public FTableRowBase
{
public:
	float                                         RepopTimeBase;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepopTime;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepopRange;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepopProbability;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ClassBpPath;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitPos;                                           // 0x0028(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveArea;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UniqueId;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Level;                                             // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropId;                                            // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEnemyRepopExtendInfo                  ExtendInfo;                                        // 0x004C(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyRepopInfo) == 0x000008, "Wrong alignment on FEnemyRepopInfo");
static_assert(sizeof(FEnemyRepopInfo) == 0x000070, "Wrong size on FEnemyRepopInfo");
static_assert(offsetof(FEnemyRepopInfo, RepopTimeBase) == 0x000008, "Member 'FEnemyRepopInfo::RepopTimeBase' has a wrong offset!");
static_assert(offsetof(FEnemyRepopInfo, RepopTime) == 0x00000C, "Member 'FEnemyRepopInfo::RepopTime' has a wrong offset!");
static_assert(offsetof(FEnemyRepopInfo, RepopRange) == 0x000010, "Member 'FEnemyRepopInfo::RepopRange' has a wrong offset!");
static_assert(offsetof(FEnemyRepopInfo, RepopProbability) == 0x000014, "Member 'FEnemyRepopInfo::RepopProbability' has a wrong offset!");
static_assert(offsetof(FEnemyRepopInfo, ClassBpPath) == 0x000018, "Member 'FEnemyRepopInfo::ClassBpPath' has a wrong offset!");
static_assert(offsetof(FEnemyRepopInfo, InitPos) == 0x000028, "Member 'FEnemyRepopInfo::InitPos' has a wrong offset!");
static_assert(offsetof(FEnemyRepopInfo, MoveArea) == 0x000034, "Member 'FEnemyRepopInfo::MoveArea' has a wrong offset!");
static_assert(offsetof(FEnemyRepopInfo, UniqueId) == 0x000038, "Member 'FEnemyRepopInfo::UniqueId' has a wrong offset!");
static_assert(offsetof(FEnemyRepopInfo, Level) == 0x000040, "Member 'FEnemyRepopInfo::Level' has a wrong offset!");
static_assert(offsetof(FEnemyRepopInfo, DropId) == 0x000048, "Member 'FEnemyRepopInfo::DropId' has a wrong offset!");
static_assert(offsetof(FEnemyRepopInfo, ExtendInfo) == 0x00004C, "Member 'FEnemyRepopInfo::ExtendInfo' has a wrong offset!");

// ScriptStruct BattlePrototype.EnemyRepopGroupInfo
// 0x0020 (0x0028 - 0x0008)
struct FEnemyRepopGroupInfo final : public FTableRowBase
{
public:
	int32                                         Group;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubGroup;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEnemyRepopInfo>                RepopInfoList;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnbale;                                          // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnemyRepopGroupInfo) == 0x000008, "Wrong alignment on FEnemyRepopGroupInfo");
static_assert(sizeof(FEnemyRepopGroupInfo) == 0x000028, "Wrong size on FEnemyRepopGroupInfo");
static_assert(offsetof(FEnemyRepopGroupInfo, Group) == 0x000008, "Member 'FEnemyRepopGroupInfo::Group' has a wrong offset!");
static_assert(offsetof(FEnemyRepopGroupInfo, SubGroup) == 0x00000C, "Member 'FEnemyRepopGroupInfo::SubGroup' has a wrong offset!");
static_assert(offsetof(FEnemyRepopGroupInfo, RepopInfoList) == 0x000010, "Member 'FEnemyRepopGroupInfo::RepopInfoList' has a wrong offset!");
static_assert(offsetof(FEnemyRepopGroupInfo, IsEnbale) == 0x000020, "Member 'FEnemyRepopGroupInfo::IsEnbale' has a wrong offset!");

// ScriptStruct BattlePrototype.EnemyRepopLevelInfo
// 0x0010 (0x0018 - 0x0008)
struct FEnemyRepopLevelInfo final : public FTableRowBase
{
public:
	TArray<struct FEnemyRepopGroupInfo>           RepopGroupInfoList;                                // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyRepopLevelInfo) == 0x000008, "Wrong alignment on FEnemyRepopLevelInfo");
static_assert(sizeof(FEnemyRepopLevelInfo) == 0x000018, "Wrong size on FEnemyRepopLevelInfo");
static_assert(offsetof(FEnemyRepopLevelInfo, RepopGroupInfoList) == 0x000008, "Member 'FEnemyRepopLevelInfo::RepopGroupInfoList' has a wrong offset!");

// ScriptStruct BattlePrototype.SASHologramAttackCheckData
// 0x0030 (0x0038 - 0x0008)
struct FSASHologramAttackCheckData final : public FTableRowBase
{
public:
	float                                         Parameter;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESASHologramAttackTiming>              Timing;                                            // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  bEnableFlag;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSASHologramAttackCheckData) == 0x000008, "Wrong alignment on FSASHologramAttackCheckData");
static_assert(sizeof(FSASHologramAttackCheckData) == 0x000038, "Wrong size on FSASHologramAttackCheckData");
static_assert(offsetof(FSASHologramAttackCheckData, Parameter) == 0x000008, "Member 'FSASHologramAttackCheckData::Parameter' has a wrong offset!");
static_assert(offsetof(FSASHologramAttackCheckData, Priority) == 0x00000C, "Member 'FSASHologramAttackCheckData::Priority' has a wrong offset!");
static_assert(offsetof(FSASHologramAttackCheckData, Probability) == 0x000010, "Member 'FSASHologramAttackCheckData::Probability' has a wrong offset!");
static_assert(offsetof(FSASHologramAttackCheckData, Timing) == 0x000018, "Member 'FSASHologramAttackCheckData::Timing' has a wrong offset!");
static_assert(offsetof(FSASHologramAttackCheckData, bEnableFlag) == 0x000028, "Member 'FSASHologramAttackCheckData::bEnableFlag' has a wrong offset!");

// ScriptStruct BattlePrototype.NpcMaterialSkeletonSetting
// 0x0028 (0x0028 - 0x0000)
struct FNpcMaterialSkeletonSetting final
{
public:
	struct FVector                                HG1_LowerPosition;                                 // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HG1_GradationLength;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HG1_MidpointRatio;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HG2_LowerPosition;                                 // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HG2_GradationLength;                               // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HG2_MidpointRatio;                                 // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcMaterialSkeletonSetting) == 0x000004, "Wrong alignment on FNpcMaterialSkeletonSetting");
static_assert(sizeof(FNpcMaterialSkeletonSetting) == 0x000028, "Wrong size on FNpcMaterialSkeletonSetting");
static_assert(offsetof(FNpcMaterialSkeletonSetting, HG1_LowerPosition) == 0x000000, "Member 'FNpcMaterialSkeletonSetting::HG1_LowerPosition' has a wrong offset!");
static_assert(offsetof(FNpcMaterialSkeletonSetting, HG1_GradationLength) == 0x00000C, "Member 'FNpcMaterialSkeletonSetting::HG1_GradationLength' has a wrong offset!");
static_assert(offsetof(FNpcMaterialSkeletonSetting, HG1_MidpointRatio) == 0x000010, "Member 'FNpcMaterialSkeletonSetting::HG1_MidpointRatio' has a wrong offset!");
static_assert(offsetof(FNpcMaterialSkeletonSetting, HG2_LowerPosition) == 0x000014, "Member 'FNpcMaterialSkeletonSetting::HG2_LowerPosition' has a wrong offset!");
static_assert(offsetof(FNpcMaterialSkeletonSetting, HG2_GradationLength) == 0x000020, "Member 'FNpcMaterialSkeletonSetting::HG2_GradationLength' has a wrong offset!");
static_assert(offsetof(FNpcMaterialSkeletonSetting, HG2_MidpointRatio) == 0x000024, "Member 'FNpcMaterialSkeletonSetting::HG2_MidpointRatio' has a wrong offset!");

// ScriptStruct BattlePrototype.NpcMaterialSkeletonSettingTable
// 0x0028 (0x0030 - 0x0008)
struct FNpcMaterialSkeletonSettingTable final : public FTableRowBase
{
public:
	struct FNpcMaterialSkeletonSetting            Setting;                                           // 0x0008(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcMaterialSkeletonSettingTable) == 0x000008, "Wrong alignment on FNpcMaterialSkeletonSettingTable");
static_assert(sizeof(FNpcMaterialSkeletonSettingTable) == 0x000030, "Wrong size on FNpcMaterialSkeletonSettingTable");
static_assert(offsetof(FNpcMaterialSkeletonSettingTable, Setting) == 0x000008, "Member 'FNpcMaterialSkeletonSettingTable::Setting' has a wrong offset!");

// ScriptStruct BattlePrototype.EnemyListInfo
// 0x0010 (0x0010 - 0x0000)
struct FEnemyListInfo final
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyListInfo) == 0x000008, "Wrong alignment on FEnemyListInfo");
static_assert(sizeof(FEnemyListInfo) == 0x000010, "Wrong size on FEnemyListInfo");
static_assert(offsetof(FEnemyListInfo, Actors) == 0x000000, "Member 'FEnemyListInfo::Actors' has a wrong offset!");

// ScriptStruct BattlePrototype.EnemyStateDataCell
// 0x0028 (0x0030 - 0x0008)
struct FEnemyStateDataCell final : public FTableRowBase
{
public:
	EHCSkillAttribute                             Attribute;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x000C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmissiveMaxPower;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmissiveMinPower;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmissiveRange;                                     // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValueEmissiveRange;                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbnormalSpan;                                      // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyStateDataCell) == 0x000008, "Wrong alignment on FEnemyStateDataCell");
static_assert(sizeof(FEnemyStateDataCell) == 0x000030, "Wrong size on FEnemyStateDataCell");
static_assert(offsetof(FEnemyStateDataCell, Attribute) == 0x000008, "Member 'FEnemyStateDataCell::Attribute' has a wrong offset!");
static_assert(offsetof(FEnemyStateDataCell, Color) == 0x00000C, "Member 'FEnemyStateDataCell::Color' has a wrong offset!");
static_assert(offsetof(FEnemyStateDataCell, EmissiveMaxPower) == 0x00001C, "Member 'FEnemyStateDataCell::EmissiveMaxPower' has a wrong offset!");
static_assert(offsetof(FEnemyStateDataCell, EmissiveMinPower) == 0x000020, "Member 'FEnemyStateDataCell::EmissiveMinPower' has a wrong offset!");
static_assert(offsetof(FEnemyStateDataCell, EmissiveRange) == 0x000024, "Member 'FEnemyStateDataCell::EmissiveRange' has a wrong offset!");
static_assert(offsetof(FEnemyStateDataCell, MaxValueEmissiveRange) == 0x000028, "Member 'FEnemyStateDataCell::MaxValueEmissiveRange' has a wrong offset!");
static_assert(offsetof(FEnemyStateDataCell, AbnormalSpan) == 0x00002C, "Member 'FEnemyStateDataCell::AbnormalSpan' has a wrong offset!");

// ScriptStruct BattlePrototype.BoardAnimationInfo
// 0x0048 (0x0048 - 0x0000)
struct FBoardAnimationInfo final
{
public:
	class FString                                 boardAnimationName;                                // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLoop;                                            // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0014(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAddMotion;                                       // 0x001C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStaticPlType                                 StaticPlType;                                      // 0x001D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             PlayRateCurveData;                                 // 0x0020(0x0028)(BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoardAnimationInfo) == 0x000008, "Wrong alignment on FBoardAnimationInfo");
static_assert(sizeof(FBoardAnimationInfo) == 0x000048, "Wrong size on FBoardAnimationInfo");
static_assert(offsetof(FBoardAnimationInfo, boardAnimationName) == 0x000000, "Member 'FBoardAnimationInfo::boardAnimationName' has a wrong offset!");
static_assert(offsetof(FBoardAnimationInfo, IsLoop) == 0x000010, "Member 'FBoardAnimationInfo::IsLoop' has a wrong offset!");
static_assert(offsetof(FBoardAnimationInfo, SocketName) == 0x000014, "Member 'FBoardAnimationInfo::SocketName' has a wrong offset!");
static_assert(offsetof(FBoardAnimationInfo, IsAddMotion) == 0x00001C, "Member 'FBoardAnimationInfo::IsAddMotion' has a wrong offset!");
static_assert(offsetof(FBoardAnimationInfo, StaticPlType) == 0x00001D, "Member 'FBoardAnimationInfo::StaticPlType' has a wrong offset!");
static_assert(offsetof(FBoardAnimationInfo, PlayRateCurveData) == 0x000020, "Member 'FBoardAnimationInfo::PlayRateCurveData' has a wrong offset!");

// ScriptStruct BattlePrototype.EventCacheActorHiddenInGameActor
// 0x0028 (0x0028 - 0x0000)
struct FEventCacheActorHiddenInGameActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            PrimitiveComponents;                               // 0x0008(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Interp, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ECollisionEnabled>                     PrimitiveCollisions;                               // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Interp, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventCacheActorHiddenInGameActor) == 0x000008, "Wrong alignment on FEventCacheActorHiddenInGameActor");
static_assert(sizeof(FEventCacheActorHiddenInGameActor) == 0x000028, "Wrong size on FEventCacheActorHiddenInGameActor");
static_assert(offsetof(FEventCacheActorHiddenInGameActor, Actor) == 0x000000, "Member 'FEventCacheActorHiddenInGameActor::Actor' has a wrong offset!");
static_assert(offsetof(FEventCacheActorHiddenInGameActor, PrimitiveComponents) == 0x000008, "Member 'FEventCacheActorHiddenInGameActor::PrimitiveComponents' has a wrong offset!");
static_assert(offsetof(FEventCacheActorHiddenInGameActor, PrimitiveCollisions) == 0x000018, "Member 'FEventCacheActorHiddenInGameActor::PrimitiveCollisions' has a wrong offset!");

// ScriptStruct BattlePrototype.EventCacheActorHiddenInGame
// 0x0010 (0x0010 - 0x0000)
struct FEventCacheActorHiddenInGame final
{
public:
	TArray<struct FEventCacheActorHiddenInGameActor> Actors;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Interp, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventCacheActorHiddenInGame) == 0x000008, "Wrong alignment on FEventCacheActorHiddenInGame");
static_assert(sizeof(FEventCacheActorHiddenInGame) == 0x000010, "Wrong size on FEventCacheActorHiddenInGame");
static_assert(offsetof(FEventCacheActorHiddenInGame, Actors) == 0x000000, "Member 'FEventCacheActorHiddenInGame::Actors' has a wrong offset!");

// ScriptStruct BattlePrototype.NpcTownPeopleCrowdType
// 0x0008 (0x0010 - 0x0008)
struct FNpcTownPeopleCrowdType final : public FTableRowBase
{
public:
	int32                                         NpcMeshDataTableID;                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NpcMaterialDataTableID;                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcTownPeopleCrowdType) == 0x000008, "Wrong alignment on FNpcTownPeopleCrowdType");
static_assert(sizeof(FNpcTownPeopleCrowdType) == 0x000010, "Wrong size on FNpcTownPeopleCrowdType");
static_assert(offsetof(FNpcTownPeopleCrowdType, NpcMeshDataTableID) == 0x000008, "Member 'FNpcTownPeopleCrowdType::NpcMeshDataTableID' has a wrong offset!");
static_assert(offsetof(FNpcTownPeopleCrowdType, NpcMaterialDataTableID) == 0x00000C, "Member 'FNpcTownPeopleCrowdType::NpcMaterialDataTableID' has a wrong offset!");

// ScriptStruct BattlePrototype.EventPPMRedStringsSingParam
// 0x0078 (0x0078 - 0x0000)
struct FEventPPMRedStringsSingParam final
{
public:
	float                                         DotCrawBlendWeight;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DotCrawTexelScale;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DotCrawYtoIQInterferenceIntensity;                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GhostingBlendWeight;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrobingBlendWeight;                               // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TapeDistortionBlendWeight;                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TapeDistortionCrease1NoiseSpeed;                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TapeDistortionCrease1Speed;                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TapeDistortionCrease2NoiseSpeed;                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TapeDistortionCrease2Speed;                        // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TapeDistortionCrease3NoiseSpeed;                   // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TapeDistortionCrease3Speed;                        // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TapeDistortionOctave1Speed;                        // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TapeDistortionOctave2Speed;                        // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TapeDistortionOctave3Speed;                        // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TapeDistortionCrease1SignalInfluence;              // 0x003C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TapeDistortionCrease2SignalInfluence;              // 0x004C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TapeDistortionCrease3SignalInfluence;              // 0x005C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YIQManipulationBlendWeight;                        // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YIQManipulationIScale;                             // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YIQManipulationYNoiseIntensity;                    // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventPPMRedStringsSingParam) == 0x000004, "Wrong alignment on FEventPPMRedStringsSingParam");
static_assert(sizeof(FEventPPMRedStringsSingParam) == 0x000078, "Wrong size on FEventPPMRedStringsSingParam");
static_assert(offsetof(FEventPPMRedStringsSingParam, DotCrawBlendWeight) == 0x000000, "Member 'FEventPPMRedStringsSingParam::DotCrawBlendWeight' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, DotCrawTexelScale) == 0x000004, "Member 'FEventPPMRedStringsSingParam::DotCrawTexelScale' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, DotCrawYtoIQInterferenceIntensity) == 0x000008, "Member 'FEventPPMRedStringsSingParam::DotCrawYtoIQInterferenceIntensity' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, GhostingBlendWeight) == 0x00000C, "Member 'FEventPPMRedStringsSingParam::GhostingBlendWeight' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, StrobingBlendWeight) == 0x000010, "Member 'FEventPPMRedStringsSingParam::StrobingBlendWeight' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, TapeDistortionBlendWeight) == 0x000014, "Member 'FEventPPMRedStringsSingParam::TapeDistortionBlendWeight' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, TapeDistortionCrease1NoiseSpeed) == 0x000018, "Member 'FEventPPMRedStringsSingParam::TapeDistortionCrease1NoiseSpeed' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, TapeDistortionCrease1Speed) == 0x00001C, "Member 'FEventPPMRedStringsSingParam::TapeDistortionCrease1Speed' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, TapeDistortionCrease2NoiseSpeed) == 0x000020, "Member 'FEventPPMRedStringsSingParam::TapeDistortionCrease2NoiseSpeed' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, TapeDistortionCrease2Speed) == 0x000024, "Member 'FEventPPMRedStringsSingParam::TapeDistortionCrease2Speed' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, TapeDistortionCrease3NoiseSpeed) == 0x000028, "Member 'FEventPPMRedStringsSingParam::TapeDistortionCrease3NoiseSpeed' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, TapeDistortionCrease3Speed) == 0x00002C, "Member 'FEventPPMRedStringsSingParam::TapeDistortionCrease3Speed' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, TapeDistortionOctave1Speed) == 0x000030, "Member 'FEventPPMRedStringsSingParam::TapeDistortionOctave1Speed' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, TapeDistortionOctave2Speed) == 0x000034, "Member 'FEventPPMRedStringsSingParam::TapeDistortionOctave2Speed' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, TapeDistortionOctave3Speed) == 0x000038, "Member 'FEventPPMRedStringsSingParam::TapeDistortionOctave3Speed' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, TapeDistortionCrease1SignalInfluence) == 0x00003C, "Member 'FEventPPMRedStringsSingParam::TapeDistortionCrease1SignalInfluence' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, TapeDistortionCrease2SignalInfluence) == 0x00004C, "Member 'FEventPPMRedStringsSingParam::TapeDistortionCrease2SignalInfluence' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, TapeDistortionCrease3SignalInfluence) == 0x00005C, "Member 'FEventPPMRedStringsSingParam::TapeDistortionCrease3SignalInfluence' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, YIQManipulationBlendWeight) == 0x00006C, "Member 'FEventPPMRedStringsSingParam::YIQManipulationBlendWeight' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, YIQManipulationIScale) == 0x000070, "Member 'FEventPPMRedStringsSingParam::YIQManipulationIScale' has a wrong offset!");
static_assert(offsetof(FEventPPMRedStringsSingParam, YIQManipulationYNoiseIntensity) == 0x000074, "Member 'FEventPPMRedStringsSingParam::YIQManipulationYNoiseIntensity' has a wrong offset!");

// ScriptStruct BattlePrototype.NpcMaterialColorSetting
// 0x0180 (0x0180 - 0x0000)
struct FNpcMaterialColorSetting final
{
public:
	struct FLinearColor                           BaseColorRed_4;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmbientColorRed_4;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BaseColorRed_1;                                    // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmbientColorRed_1;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BaseColorBlue_3;                                   // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmbientColorBlue_3;                                // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BaseColorRed_3;                                    // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmbientColorRed_3;                                 // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BaseColorRed_2;                                    // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmbientColorRed_2;                                 // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BaseColorBlue_4;                                   // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmbientColorBlue_4;                                // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BaseColorGreen_4;                                  // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmbientColorGreen_4;                               // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BaseColorGreen_3;                                  // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmbientColorGreen_3;                               // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BaseColorGreen_2;                                  // 0x0100(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmbientColorGreen_2;                               // 0x0110(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BaseColorGreen_1;                                  // 0x0120(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmbientColorGreen_1;                               // 0x0130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BaseColorBlue_2;                                   // 0x0140(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmbientColorBlue_2;                                // 0x0150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BaseColorBlue_1;                                   // 0x0160(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmbientColorBlue_1;                                // 0x0170(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcMaterialColorSetting) == 0x000004, "Wrong alignment on FNpcMaterialColorSetting");
static_assert(sizeof(FNpcMaterialColorSetting) == 0x000180, "Wrong size on FNpcMaterialColorSetting");
static_assert(offsetof(FNpcMaterialColorSetting, BaseColorRed_4) == 0x000000, "Member 'FNpcMaterialColorSetting::BaseColorRed_4' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, AmbientColorRed_4) == 0x000010, "Member 'FNpcMaterialColorSetting::AmbientColorRed_4' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, BaseColorRed_1) == 0x000020, "Member 'FNpcMaterialColorSetting::BaseColorRed_1' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, AmbientColorRed_1) == 0x000030, "Member 'FNpcMaterialColorSetting::AmbientColorRed_1' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, BaseColorBlue_3) == 0x000040, "Member 'FNpcMaterialColorSetting::BaseColorBlue_3' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, AmbientColorBlue_3) == 0x000050, "Member 'FNpcMaterialColorSetting::AmbientColorBlue_3' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, BaseColorRed_3) == 0x000060, "Member 'FNpcMaterialColorSetting::BaseColorRed_3' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, AmbientColorRed_3) == 0x000070, "Member 'FNpcMaterialColorSetting::AmbientColorRed_3' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, BaseColorRed_2) == 0x000080, "Member 'FNpcMaterialColorSetting::BaseColorRed_2' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, AmbientColorRed_2) == 0x000090, "Member 'FNpcMaterialColorSetting::AmbientColorRed_2' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, BaseColorBlue_4) == 0x0000A0, "Member 'FNpcMaterialColorSetting::BaseColorBlue_4' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, AmbientColorBlue_4) == 0x0000B0, "Member 'FNpcMaterialColorSetting::AmbientColorBlue_4' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, BaseColorGreen_4) == 0x0000C0, "Member 'FNpcMaterialColorSetting::BaseColorGreen_4' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, AmbientColorGreen_4) == 0x0000D0, "Member 'FNpcMaterialColorSetting::AmbientColorGreen_4' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, BaseColorGreen_3) == 0x0000E0, "Member 'FNpcMaterialColorSetting::BaseColorGreen_3' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, AmbientColorGreen_3) == 0x0000F0, "Member 'FNpcMaterialColorSetting::AmbientColorGreen_3' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, BaseColorGreen_2) == 0x000100, "Member 'FNpcMaterialColorSetting::BaseColorGreen_2' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, AmbientColorGreen_2) == 0x000110, "Member 'FNpcMaterialColorSetting::AmbientColorGreen_2' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, BaseColorGreen_1) == 0x000120, "Member 'FNpcMaterialColorSetting::BaseColorGreen_1' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, AmbientColorGreen_1) == 0x000130, "Member 'FNpcMaterialColorSetting::AmbientColorGreen_1' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, BaseColorBlue_2) == 0x000140, "Member 'FNpcMaterialColorSetting::BaseColorBlue_2' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, AmbientColorBlue_2) == 0x000150, "Member 'FNpcMaterialColorSetting::AmbientColorBlue_2' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, BaseColorBlue_1) == 0x000160, "Member 'FNpcMaterialColorSetting::BaseColorBlue_1' has a wrong offset!");
static_assert(offsetof(FNpcMaterialColorSetting, AmbientColorBlue_1) == 0x000170, "Member 'FNpcMaterialColorSetting::AmbientColorBlue_1' has a wrong offset!");

// ScriptStruct BattlePrototype.NpcMaterialSetting
// 0x01E0 (0x01E8 - 0x0008)
struct FNpcMaterialSetting final : public FTableRowBase
{
public:
	class FString                                 Comment;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNpcMaterialColorSetting               Color;                                             // 0x0018(0x0180)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FString, TSoftObjectPtr<class UMaterialInstance>> MaterialList;                                      // 0x0198(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcMaterialSetting) == 0x000008, "Wrong alignment on FNpcMaterialSetting");
static_assert(sizeof(FNpcMaterialSetting) == 0x0001E8, "Wrong size on FNpcMaterialSetting");
static_assert(offsetof(FNpcMaterialSetting, Comment) == 0x000008, "Member 'FNpcMaterialSetting::Comment' has a wrong offset!");
static_assert(offsetof(FNpcMaterialSetting, Color) == 0x000018, "Member 'FNpcMaterialSetting::Color' has a wrong offset!");
static_assert(offsetof(FNpcMaterialSetting, MaterialList) == 0x000198, "Member 'FNpcMaterialSetting::MaterialList' has a wrong offset!");

// ScriptStruct BattlePrototype.EventFacialCaptureRenderSettings
// 0x08A0 (0x08A0 - 0x0000)
struct FEventFacialCaptureRenderSettings final
{
public:
	uint8                                         bOverride_OutlineWidth : 1;                        // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_OutlineSizeModulate : 1;                 // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_OutlineWidthMax : 1;                     // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_OutlineWidthMin : 1;                     // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_OutlinePushLength : 1;                   // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_NoiseRate : 1;                           // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RimlightSunnyOffset : 1;                 // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RimlightSunnyPower : 1;                  // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RimlightAmbientOffset : 1;               // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RimlightAmbientPower : 1;                // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_EvCelBaseToAmb : 1;                      // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_EvCelAmbToBase : 1;                      // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_EvWireDepthOffset : 1;                   // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutlineWidth;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutlineSizeModulate;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutlineWidthMax;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutlineWidthMin;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutlinePushLength;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseRate;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RimlightSunnyOffset;                               // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RimlightSunnyPower;                                // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RimlightAmbientOffset;                             // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RimlightAmbientPower;                              // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EvCelBaseToAmb;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EvCelAmbToBase;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EvWireDepthOffset;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStageParameterSettings                StageSettings;                                     // 0x0038(0x00E0)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0120(0x0780)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventFacialCaptureRenderSettings) == 0x000010, "Wrong alignment on FEventFacialCaptureRenderSettings");
static_assert(sizeof(FEventFacialCaptureRenderSettings) == 0x0008A0, "Wrong size on FEventFacialCaptureRenderSettings");
static_assert(offsetof(FEventFacialCaptureRenderSettings, OutlineWidth) == 0x000004, "Member 'FEventFacialCaptureRenderSettings::OutlineWidth' has a wrong offset!");
static_assert(offsetof(FEventFacialCaptureRenderSettings, OutlineSizeModulate) == 0x000008, "Member 'FEventFacialCaptureRenderSettings::OutlineSizeModulate' has a wrong offset!");
static_assert(offsetof(FEventFacialCaptureRenderSettings, OutlineWidthMax) == 0x00000C, "Member 'FEventFacialCaptureRenderSettings::OutlineWidthMax' has a wrong offset!");
static_assert(offsetof(FEventFacialCaptureRenderSettings, OutlineWidthMin) == 0x000010, "Member 'FEventFacialCaptureRenderSettings::OutlineWidthMin' has a wrong offset!");
static_assert(offsetof(FEventFacialCaptureRenderSettings, OutlinePushLength) == 0x000014, "Member 'FEventFacialCaptureRenderSettings::OutlinePushLength' has a wrong offset!");
static_assert(offsetof(FEventFacialCaptureRenderSettings, NoiseRate) == 0x000018, "Member 'FEventFacialCaptureRenderSettings::NoiseRate' has a wrong offset!");
static_assert(offsetof(FEventFacialCaptureRenderSettings, RimlightSunnyOffset) == 0x00001C, "Member 'FEventFacialCaptureRenderSettings::RimlightSunnyOffset' has a wrong offset!");
static_assert(offsetof(FEventFacialCaptureRenderSettings, RimlightSunnyPower) == 0x000020, "Member 'FEventFacialCaptureRenderSettings::RimlightSunnyPower' has a wrong offset!");
static_assert(offsetof(FEventFacialCaptureRenderSettings, RimlightAmbientOffset) == 0x000024, "Member 'FEventFacialCaptureRenderSettings::RimlightAmbientOffset' has a wrong offset!");
static_assert(offsetof(FEventFacialCaptureRenderSettings, RimlightAmbientPower) == 0x000028, "Member 'FEventFacialCaptureRenderSettings::RimlightAmbientPower' has a wrong offset!");
static_assert(offsetof(FEventFacialCaptureRenderSettings, EvCelBaseToAmb) == 0x00002C, "Member 'FEventFacialCaptureRenderSettings::EvCelBaseToAmb' has a wrong offset!");
static_assert(offsetof(FEventFacialCaptureRenderSettings, EvCelAmbToBase) == 0x000030, "Member 'FEventFacialCaptureRenderSettings::EvCelAmbToBase' has a wrong offset!");
static_assert(offsetof(FEventFacialCaptureRenderSettings, EvWireDepthOffset) == 0x000034, "Member 'FEventFacialCaptureRenderSettings::EvWireDepthOffset' has a wrong offset!");
static_assert(offsetof(FEventFacialCaptureRenderSettings, StageSettings) == 0x000038, "Member 'FEventFacialCaptureRenderSettings::StageSettings' has a wrong offset!");
static_assert(offsetof(FEventFacialCaptureRenderSettings, PostProcessSettings) == 0x000120, "Member 'FEventFacialCaptureRenderSettings::PostProcessSettings' has a wrong offset!");

// ScriptStruct BattlePrototype.FEventFacialCaptureRenderSettingsTable
// 0x08A8 (0x08B0 - 0x0008)
struct FFEventFacialCaptureRenderSettingsTable final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEventFacialCaptureRenderSettings      Setting;                                           // 0x0010(0x08A0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFEventFacialCaptureRenderSettingsTable) == 0x000010, "Wrong alignment on FFEventFacialCaptureRenderSettingsTable");
static_assert(sizeof(FFEventFacialCaptureRenderSettingsTable) == 0x0008B0, "Wrong size on FFEventFacialCaptureRenderSettingsTable");
static_assert(offsetof(FFEventFacialCaptureRenderSettingsTable, Setting) == 0x000010, "Member 'FFEventFacialCaptureRenderSettingsTable::Setting' has a wrong offset!");

// ScriptStruct BattlePrototype.OptimizeMaterialOverrideSetting
// 0x0058 (0x0058 - 0x0000)
struct FOptimizeMaterialOverrideSetting final
{
public:
	bool                                          bOveride;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UMaterialInterface*, class UMaterialInterface*> Materials;                                         // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOptimizeMaterialOverrideSetting) == 0x000008, "Wrong alignment on FOptimizeMaterialOverrideSetting");
static_assert(sizeof(FOptimizeMaterialOverrideSetting) == 0x000058, "Wrong size on FOptimizeMaterialOverrideSetting");
static_assert(offsetof(FOptimizeMaterialOverrideSetting, bOveride) == 0x000000, "Member 'FOptimizeMaterialOverrideSetting::bOveride' has a wrong offset!");
static_assert(offsetof(FOptimizeMaterialOverrideSetting, Materials) == 0x000008, "Member 'FOptimizeMaterialOverrideSetting::Materials' has a wrong offset!");

// ScriptStruct BattlePrototype.FallingFloorBlockOne
// 0x0010 (0x0010 - 0x0000)
struct FFallingFloorBlockOne final
{
public:
	class UStaticMesh*                            BlockStatic;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDestructibleMesh*                      BlockDestructible;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFallingFloorBlockOne) == 0x000008, "Wrong alignment on FFallingFloorBlockOne");
static_assert(sizeof(FFallingFloorBlockOne) == 0x000010, "Wrong size on FFallingFloorBlockOne");
static_assert(offsetof(FFallingFloorBlockOne, BlockStatic) == 0x000000, "Member 'FFallingFloorBlockOne::BlockStatic' has a wrong offset!");
static_assert(offsetof(FFallingFloorBlockOne, BlockDestructible) == 0x000008, "Member 'FFallingFloorBlockOne::BlockDestructible' has a wrong offset!");

// ScriptStruct BattlePrototype.FallingFloorBlockInfo
// 0x0010 (0x0018 - 0x0008)
struct FFallingFloorBlockInfo final : public FTableRowBase
{
public:
	TArray<struct FFallingFloorBlockOne>          BlockInfos;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFallingFloorBlockInfo) == 0x000008, "Wrong alignment on FFallingFloorBlockInfo");
static_assert(sizeof(FFallingFloorBlockInfo) == 0x000018, "Wrong size on FFallingFloorBlockInfo");
static_assert(offsetof(FFallingFloorBlockInfo, BlockInfos) == 0x000008, "Member 'FFallingFloorBlockInfo::BlockInfos' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerAICheckMoveWallParamIn
// 0x0020 (0x0020 - 0x0000)
struct FPlayerAICheckMoveWallParamIn final
{
public:
	bool                                          bNeedsCheck;                                       // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ActorLoc;                                          // 0x0004(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MoveDir;                                           // 0x0010(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkableFloorAngle;                                // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerAICheckMoveWallParamIn) == 0x000004, "Wrong alignment on FPlayerAICheckMoveWallParamIn");
static_assert(sizeof(FPlayerAICheckMoveWallParamIn) == 0x000020, "Wrong size on FPlayerAICheckMoveWallParamIn");
static_assert(offsetof(FPlayerAICheckMoveWallParamIn, bNeedsCheck) == 0x000000, "Member 'FPlayerAICheckMoveWallParamIn::bNeedsCheck' has a wrong offset!");
static_assert(offsetof(FPlayerAICheckMoveWallParamIn, ActorLoc) == 0x000004, "Member 'FPlayerAICheckMoveWallParamIn::ActorLoc' has a wrong offset!");
static_assert(offsetof(FPlayerAICheckMoveWallParamIn, MoveDir) == 0x000010, "Member 'FPlayerAICheckMoveWallParamIn::MoveDir' has a wrong offset!");
static_assert(offsetof(FPlayerAICheckMoveWallParamIn, WalkableFloorAngle) == 0x00001C, "Member 'FPlayerAICheckMoveWallParamIn::WalkableFloorAngle' has a wrong offset!");

// ScriptStruct BattlePrototype.FlagListStruct
// 0x0010 (0x0010 - 0x0000)
struct FFlagListStruct final
{
public:
	TArray<bool>                                  Flags;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFlagListStruct) == 0x000008, "Wrong alignment on FFlagListStruct");
static_assert(sizeof(FFlagListStruct) == 0x000010, "Wrong size on FFlagListStruct");
static_assert(offsetof(FFlagListStruct, Flags) == 0x000000, "Member 'FFlagListStruct::Flags' has a wrong offset!");

// ScriptStruct BattlePrototype.Flag
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FFlag final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFlag) == 0x000008, "Wrong alignment on FFlag");
static_assert(sizeof(FFlag) == 0x000010, "Wrong size on FFlag");

// ScriptStruct BattlePrototype.PerformShotData
// 0x07B0 (0x07B0 - 0x0000)
struct FPerformShotData final
{
public:
	float                                         Priority;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StartInterpolateTimeline;                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EndInterpolateTimeline;                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartInterpolateSeconds;                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopInterpolateSeconds;                            // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndInterpolateSeconds;                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlurPower;                                         // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlurSize;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FovAdd;                                            // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0030(0x0780)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerformShotData) == 0x000010, "Wrong alignment on FPerformShotData");
static_assert(sizeof(FPerformShotData) == 0x0007B0, "Wrong size on FPerformShotData");
static_assert(offsetof(FPerformShotData, Priority) == 0x000000, "Member 'FPerformShotData::Priority' has a wrong offset!");
static_assert(offsetof(FPerformShotData, StartInterpolateTimeline) == 0x000008, "Member 'FPerformShotData::StartInterpolateTimeline' has a wrong offset!");
static_assert(offsetof(FPerformShotData, EndInterpolateTimeline) == 0x000010, "Member 'FPerformShotData::EndInterpolateTimeline' has a wrong offset!");
static_assert(offsetof(FPerformShotData, StartInterpolateSeconds) == 0x000018, "Member 'FPerformShotData::StartInterpolateSeconds' has a wrong offset!");
static_assert(offsetof(FPerformShotData, LoopInterpolateSeconds) == 0x00001C, "Member 'FPerformShotData::LoopInterpolateSeconds' has a wrong offset!");
static_assert(offsetof(FPerformShotData, EndInterpolateSeconds) == 0x000020, "Member 'FPerformShotData::EndInterpolateSeconds' has a wrong offset!");
static_assert(offsetof(FPerformShotData, BlurPower) == 0x000024, "Member 'FPerformShotData::BlurPower' has a wrong offset!");
static_assert(offsetof(FPerformShotData, BlurSize) == 0x000028, "Member 'FPerformShotData::BlurSize' has a wrong offset!");
static_assert(offsetof(FPerformShotData, FovAdd) == 0x00002C, "Member 'FPerformShotData::FovAdd' has a wrong offset!");
static_assert(offsetof(FPerformShotData, PostProcessSettings) == 0x000030, "Member 'FPerformShotData::PostProcessSettings' has a wrong offset!");

// ScriptStruct BattlePrototype.PerformShotDataTable
// 0x07B8 (0x07C0 - 0x0008)
struct FPerformShotDataTable final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPerformShotData                       Setting;                                           // 0x0010(0x07B0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerformShotDataTable) == 0x000010, "Wrong alignment on FPerformShotDataTable");
static_assert(sizeof(FPerformShotDataTable) == 0x0007C0, "Wrong size on FPerformShotDataTable");
static_assert(offsetof(FPerformShotDataTable, Setting) == 0x000010, "Member 'FPerformShotDataTable::Setting' has a wrong offset!");

// ScriptStruct BattlePrototype.GeneralPhysicalSurfaceActionSoundResourceArray
// 0x0010 (0x0010 - 0x0000)
struct FGeneralPhysicalSurfaceActionSoundResourceArray final
{
public:
	TArray<class USoundAtomCue*>                  ResList;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneralPhysicalSurfaceActionSoundResourceArray) == 0x000008, "Wrong alignment on FGeneralPhysicalSurfaceActionSoundResourceArray");
static_assert(sizeof(FGeneralPhysicalSurfaceActionSoundResourceArray) == 0x000010, "Wrong size on FGeneralPhysicalSurfaceActionSoundResourceArray");
static_assert(offsetof(FGeneralPhysicalSurfaceActionSoundResourceArray, ResList) == 0x000000, "Member 'FGeneralPhysicalSurfaceActionSoundResourceArray::ResList' has a wrong offset!");

// ScriptStruct BattlePrototype.GeneralPhysicalSurfaceActionEffectResourceArray
// 0x0010 (0x0010 - 0x0000)
struct FGeneralPhysicalSurfaceActionEffectResourceArray final
{
public:
	TArray<class UParticleSystem*>                ResList;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneralPhysicalSurfaceActionEffectResourceArray) == 0x000008, "Wrong alignment on FGeneralPhysicalSurfaceActionEffectResourceArray");
static_assert(sizeof(FGeneralPhysicalSurfaceActionEffectResourceArray) == 0x000010, "Wrong size on FGeneralPhysicalSurfaceActionEffectResourceArray");
static_assert(offsetof(FGeneralPhysicalSurfaceActionEffectResourceArray, ResList) == 0x000000, "Member 'FGeneralPhysicalSurfaceActionEffectResourceArray::ResList' has a wrong offset!");

// ScriptStruct BattlePrototype.OptimizeMaterialSettingMesh
// 0x0030 (0x0030 - 0x0000)
struct FOptimizeMaterialSettingMesh final
{
public:
	TArray<class UMaterialInstanceDynamic*>       MIDs;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x20];                                      // 0x0010(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOptimizeMaterialSettingMesh) == 0x000008, "Wrong alignment on FOptimizeMaterialSettingMesh");
static_assert(sizeof(FOptimizeMaterialSettingMesh) == 0x000030, "Wrong size on FOptimizeMaterialSettingMesh");
static_assert(offsetof(FOptimizeMaterialSettingMesh, MIDs) == 0x000000, "Member 'FOptimizeMaterialSettingMesh::MIDs' has a wrong offset!");

// ScriptStruct BattlePrototype.OptimizeMaterialSetting
// 0x00C8 (0x00C8 - 0x0000)
struct FOptimizeMaterialSetting final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FOptimizeMaterialOverrideSetting> SlotMaterials;                                     // 0x0010(0x0050)(NativeAccessSpecifierPublic)
	struct FOptimizeMaterialOverrideSetting       OtherSlotMaterial;                                 // 0x0060(0x0058)(NativeAccessSpecifierPublic)
	TArray<struct FOptimizeMaterialSettingMesh>   Meshes;                                            // 0x00B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOptimizeMaterialSetting) == 0x000008, "Wrong alignment on FOptimizeMaterialSetting");
static_assert(sizeof(FOptimizeMaterialSetting) == 0x0000C8, "Wrong size on FOptimizeMaterialSetting");
static_assert(offsetof(FOptimizeMaterialSetting, SlotMaterials) == 0x000010, "Member 'FOptimizeMaterialSetting::SlotMaterials' has a wrong offset!");
static_assert(offsetof(FOptimizeMaterialSetting, OtherSlotMaterial) == 0x000060, "Member 'FOptimizeMaterialSetting::OtherSlotMaterial' has a wrong offset!");
static_assert(offsetof(FOptimizeMaterialSetting, Meshes) == 0x0000B8, "Member 'FOptimizeMaterialSetting::Meshes' has a wrong offset!");

// ScriptStruct BattlePrototype.CharacterPhysicalSurfaceActionSoundResourceArrray
// 0x0010 (0x0010 - 0x0000)
struct FCharacterPhysicalSurfaceActionSoundResourceArrray final
{
public:
	TArray<class USoundAtomCue*>                  ResList;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterPhysicalSurfaceActionSoundResourceArrray) == 0x000008, "Wrong alignment on FCharacterPhysicalSurfaceActionSoundResourceArrray");
static_assert(sizeof(FCharacterPhysicalSurfaceActionSoundResourceArrray) == 0x000010, "Wrong size on FCharacterPhysicalSurfaceActionSoundResourceArrray");
static_assert(offsetof(FCharacterPhysicalSurfaceActionSoundResourceArrray, ResList) == 0x000000, "Member 'FCharacterPhysicalSurfaceActionSoundResourceArrray::ResList' has a wrong offset!");

// ScriptStruct BattlePrototype.CharacterPhysicalSurfaceActionEffectResourceArray
// 0x0010 (0x0010 - 0x0000)
struct FCharacterPhysicalSurfaceActionEffectResourceArray final
{
public:
	TArray<class UParticleSystem*>                ResList;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterPhysicalSurfaceActionEffectResourceArray) == 0x000008, "Wrong alignment on FCharacterPhysicalSurfaceActionEffectResourceArray");
static_assert(sizeof(FCharacterPhysicalSurfaceActionEffectResourceArray) == 0x000010, "Wrong size on FCharacterPhysicalSurfaceActionEffectResourceArray");
static_assert(offsetof(FCharacterPhysicalSurfaceActionEffectResourceArray, ResList) == 0x000000, "Member 'FCharacterPhysicalSurfaceActionEffectResourceArray::ResList' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerAIEvaluateTargetParameter
// 0x0040 (0x0048 - 0x0008)
struct FPlayerAIEvaluateTargetParameter final : public FTableRowBase
{
public:
	float                                         RangeNear;                                         // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeMiddle;                                       // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeFar;                                          // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowHP;                                             // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetToCh0100;                                    // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetToCh0200;                                    // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetToCh0500;                                    // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetFromCh0100;                                  // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetFromCh0200;                                  // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetToFriend;                                    // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NotTargetFromFriend;                               // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Flying;                                            // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stealth;                                           // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BadStatusOil;                                      // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BadStatusFlooded;                                  // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerAIEvaluateTargetParameter) == 0x000008, "Wrong alignment on FPlayerAIEvaluateTargetParameter");
static_assert(sizeof(FPlayerAIEvaluateTargetParameter) == 0x000048, "Wrong size on FPlayerAIEvaluateTargetParameter");
static_assert(offsetof(FPlayerAIEvaluateTargetParameter, RangeNear) == 0x000008, "Member 'FPlayerAIEvaluateTargetParameter::RangeNear' has a wrong offset!");
static_assert(offsetof(FPlayerAIEvaluateTargetParameter, RangeMiddle) == 0x00000C, "Member 'FPlayerAIEvaluateTargetParameter::RangeMiddle' has a wrong offset!");
static_assert(offsetof(FPlayerAIEvaluateTargetParameter, RangeFar) == 0x000010, "Member 'FPlayerAIEvaluateTargetParameter::RangeFar' has a wrong offset!");
static_assert(offsetof(FPlayerAIEvaluateTargetParameter, LowHP) == 0x000014, "Member 'FPlayerAIEvaluateTargetParameter::LowHP' has a wrong offset!");
static_assert(offsetof(FPlayerAIEvaluateTargetParameter, TargetToCh0100) == 0x000018, "Member 'FPlayerAIEvaluateTargetParameter::TargetToCh0100' has a wrong offset!");
static_assert(offsetof(FPlayerAIEvaluateTargetParameter, TargetToCh0200) == 0x00001C, "Member 'FPlayerAIEvaluateTargetParameter::TargetToCh0200' has a wrong offset!");
static_assert(offsetof(FPlayerAIEvaluateTargetParameter, TargetToCh0500) == 0x000020, "Member 'FPlayerAIEvaluateTargetParameter::TargetToCh0500' has a wrong offset!");
static_assert(offsetof(FPlayerAIEvaluateTargetParameter, TargetFromCh0100) == 0x000024, "Member 'FPlayerAIEvaluateTargetParameter::TargetFromCh0100' has a wrong offset!");
static_assert(offsetof(FPlayerAIEvaluateTargetParameter, TargetFromCh0200) == 0x000028, "Member 'FPlayerAIEvaluateTargetParameter::TargetFromCh0200' has a wrong offset!");
static_assert(offsetof(FPlayerAIEvaluateTargetParameter, TargetToFriend) == 0x00002C, "Member 'FPlayerAIEvaluateTargetParameter::TargetToFriend' has a wrong offset!");
static_assert(offsetof(FPlayerAIEvaluateTargetParameter, NotTargetFromFriend) == 0x000030, "Member 'FPlayerAIEvaluateTargetParameter::NotTargetFromFriend' has a wrong offset!");
static_assert(offsetof(FPlayerAIEvaluateTargetParameter, Flying) == 0x000034, "Member 'FPlayerAIEvaluateTargetParameter::Flying' has a wrong offset!");
static_assert(offsetof(FPlayerAIEvaluateTargetParameter, Stealth) == 0x000038, "Member 'FPlayerAIEvaluateTargetParameter::Stealth' has a wrong offset!");
static_assert(offsetof(FPlayerAIEvaluateTargetParameter, BadStatusOil) == 0x00003C, "Member 'FPlayerAIEvaluateTargetParameter::BadStatusOil' has a wrong offset!");
static_assert(offsetof(FPlayerAIEvaluateTargetParameter, BadStatusFlooded) == 0x000040, "Member 'FPlayerAIEvaluateTargetParameter::BadStatusFlooded' has a wrong offset!");

// ScriptStruct BattlePrototype.GeneralPhysicalActionSoundContent
// 0x0030 (0x0030 - 0x0000)
struct FGeneralPhysicalActionSoundContent final
{
public:
	bool                                          NotGenerate;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundAtomCue>           SoundAsset;                                        // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneralPhysicalActionSoundContent) == 0x000008, "Wrong alignment on FGeneralPhysicalActionSoundContent");
static_assert(sizeof(FGeneralPhysicalActionSoundContent) == 0x000030, "Wrong size on FGeneralPhysicalActionSoundContent");
static_assert(offsetof(FGeneralPhysicalActionSoundContent, NotGenerate) == 0x000000, "Member 'FGeneralPhysicalActionSoundContent::NotGenerate' has a wrong offset!");
static_assert(offsetof(FGeneralPhysicalActionSoundContent, SoundAsset) == 0x000008, "Member 'FGeneralPhysicalActionSoundContent::SoundAsset' has a wrong offset!");

// ScriptStruct BattlePrototype.GeneralPhysicalActionSound
// 0x04F0 (0x04F8 - 0x0008)
struct FGeneralPhysicalActionSound final : public FTableRowBase
{
public:
	class FString                                 Comment;                                           // 0x0008(0x0010)(Edit, EditFixedSize, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGeneralPhysicalActionSoundContent     Surfaces[0x1A];                                    // 0x0018(0x0030)(Edit, EditFixedSize, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneralPhysicalActionSound) == 0x000008, "Wrong alignment on FGeneralPhysicalActionSound");
static_assert(sizeof(FGeneralPhysicalActionSound) == 0x0004F8, "Wrong size on FGeneralPhysicalActionSound");
static_assert(offsetof(FGeneralPhysicalActionSound, Comment) == 0x000008, "Member 'FGeneralPhysicalActionSound::Comment' has a wrong offset!");
static_assert(offsetof(FGeneralPhysicalActionSound, Surfaces) == 0x000018, "Member 'FGeneralPhysicalActionSound::Surfaces' has a wrong offset!");

// ScriptStruct BattlePrototype.SkillSASRecoverData
// 0x0010 (0x0018 - 0x0008)
struct FSkillSASRecoverData final : public FTableRowBase
{
public:
	float                                         RecoverRate1;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoverRate2;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoverRate3;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoverRate4;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillSASRecoverData) == 0x000008, "Wrong alignment on FSkillSASRecoverData");
static_assert(sizeof(FSkillSASRecoverData) == 0x000018, "Wrong size on FSkillSASRecoverData");
static_assert(offsetof(FSkillSASRecoverData, RecoverRate1) == 0x000008, "Member 'FSkillSASRecoverData::RecoverRate1' has a wrong offset!");
static_assert(offsetof(FSkillSASRecoverData, RecoverRate2) == 0x00000C, "Member 'FSkillSASRecoverData::RecoverRate2' has a wrong offset!");
static_assert(offsetof(FSkillSASRecoverData, RecoverRate3) == 0x000010, "Member 'FSkillSASRecoverData::RecoverRate3' has a wrong offset!");
static_assert(offsetof(FSkillSASRecoverData, RecoverRate4) == 0x000014, "Member 'FSkillSASRecoverData::RecoverRate4' has a wrong offset!");

// ScriptStruct BattlePrototype.GeneralPhysicalActionEffectContent
// 0x0030 (0x0030 - 0x0000)
struct FGeneralPhysicalActionEffectContent final
{
public:
	bool                                          NotGenerate;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UParticleSystem>         ParticleAsset;                                     // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneralPhysicalActionEffectContent) == 0x000008, "Wrong alignment on FGeneralPhysicalActionEffectContent");
static_assert(sizeof(FGeneralPhysicalActionEffectContent) == 0x000030, "Wrong size on FGeneralPhysicalActionEffectContent");
static_assert(offsetof(FGeneralPhysicalActionEffectContent, NotGenerate) == 0x000000, "Member 'FGeneralPhysicalActionEffectContent::NotGenerate' has a wrong offset!");
static_assert(offsetof(FGeneralPhysicalActionEffectContent, ParticleAsset) == 0x000008, "Member 'FGeneralPhysicalActionEffectContent::ParticleAsset' has a wrong offset!");

// ScriptStruct BattlePrototype.GeneralPhysicalActionEffect
// 0x04F0 (0x04F8 - 0x0008)
struct FGeneralPhysicalActionEffect final : public FTableRowBase
{
public:
	class FString                                 Comment;                                           // 0x0008(0x0010)(Edit, EditFixedSize, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGeneralPhysicalActionEffectContent    Surfaces[0x1A];                                    // 0x0018(0x0030)(Edit, EditFixedSize, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneralPhysicalActionEffect) == 0x000008, "Wrong alignment on FGeneralPhysicalActionEffect");
static_assert(sizeof(FGeneralPhysicalActionEffect) == 0x0004F8, "Wrong size on FGeneralPhysicalActionEffect");
static_assert(offsetof(FGeneralPhysicalActionEffect, Comment) == 0x000008, "Member 'FGeneralPhysicalActionEffect::Comment' has a wrong offset!");
static_assert(offsetof(FGeneralPhysicalActionEffect, Surfaces) == 0x000018, "Member 'FGeneralPhysicalActionEffect::Surfaces' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerAIParameter
// 0x0048 (0x0050 - 0x0008)
struct FPlayerAIParameter final : public FTableRowBase
{
public:
	EAIBattleRange                                Range_Type;                                        // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RANGE_NEAR;                                        // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range_Middle;                                      // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RANGE_FAR;                                         // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width_Near;                                        // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width_Far;                                         // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_Init;                                     // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_TargetActor;                              // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_NotTargetActor;                           // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_AttackActor;                              // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_Friend;                                   // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_TargetFront;                              // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_TargetSide;                               // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_TargetBack;                               // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_TargetActorBehind;                        // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_TargetActorInfront;                       // 0x0044(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_CurrentLocation;                          // 0x0048(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerAIParameter) == 0x000008, "Wrong alignment on FPlayerAIParameter");
static_assert(sizeof(FPlayerAIParameter) == 0x000050, "Wrong size on FPlayerAIParameter");
static_assert(offsetof(FPlayerAIParameter, Range_Type) == 0x000008, "Member 'FPlayerAIParameter::Range_Type' has a wrong offset!");
static_assert(offsetof(FPlayerAIParameter, RANGE_NEAR) == 0x00000C, "Member 'FPlayerAIParameter::RANGE_NEAR' has a wrong offset!");
static_assert(offsetof(FPlayerAIParameter, Range_Middle) == 0x000010, "Member 'FPlayerAIParameter::Range_Middle' has a wrong offset!");
static_assert(offsetof(FPlayerAIParameter, RANGE_FAR) == 0x000014, "Member 'FPlayerAIParameter::RANGE_FAR' has a wrong offset!");
static_assert(offsetof(FPlayerAIParameter, Width_Near) == 0x000018, "Member 'FPlayerAIParameter::Width_Near' has a wrong offset!");
static_assert(offsetof(FPlayerAIParameter, Width_Far) == 0x00001C, "Member 'FPlayerAIParameter::Width_Far' has a wrong offset!");
static_assert(offsetof(FPlayerAIParameter, Priority_Init) == 0x000020, "Member 'FPlayerAIParameter::Priority_Init' has a wrong offset!");
static_assert(offsetof(FPlayerAIParameter, Priority_TargetActor) == 0x000024, "Member 'FPlayerAIParameter::Priority_TargetActor' has a wrong offset!");
static_assert(offsetof(FPlayerAIParameter, Priority_NotTargetActor) == 0x000028, "Member 'FPlayerAIParameter::Priority_NotTargetActor' has a wrong offset!");
static_assert(offsetof(FPlayerAIParameter, Priority_AttackActor) == 0x00002C, "Member 'FPlayerAIParameter::Priority_AttackActor' has a wrong offset!");
static_assert(offsetof(FPlayerAIParameter, Priority_Friend) == 0x000030, "Member 'FPlayerAIParameter::Priority_Friend' has a wrong offset!");
static_assert(offsetof(FPlayerAIParameter, Priority_TargetFront) == 0x000034, "Member 'FPlayerAIParameter::Priority_TargetFront' has a wrong offset!");
static_assert(offsetof(FPlayerAIParameter, Priority_TargetSide) == 0x000038, "Member 'FPlayerAIParameter::Priority_TargetSide' has a wrong offset!");
static_assert(offsetof(FPlayerAIParameter, Priority_TargetBack) == 0x00003C, "Member 'FPlayerAIParameter::Priority_TargetBack' has a wrong offset!");
static_assert(offsetof(FPlayerAIParameter, Priority_TargetActorBehind) == 0x000040, "Member 'FPlayerAIParameter::Priority_TargetActorBehind' has a wrong offset!");
static_assert(offsetof(FPlayerAIParameter, Priority_TargetActorInfront) == 0x000044, "Member 'FPlayerAIParameter::Priority_TargetActorInfront' has a wrong offset!");
static_assert(offsetof(FPlayerAIParameter, Priority_CurrentLocation) == 0x000048, "Member 'FPlayerAIParameter::Priority_CurrentLocation' has a wrong offset!");

// ScriptStruct BattlePrototype.CharacterPhysicalActionSound
// 0x0260 (0x0260 - 0x0000)
struct FCharacterPhysicalActionSound final
{
public:
	bool                                          UseOverride;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundAtomCue>           Actions[0xF];                                      // 0x0008(0x0028)(Edit, EditFixedSize, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterPhysicalActionSound) == 0x000008, "Wrong alignment on FCharacterPhysicalActionSound");
static_assert(sizeof(FCharacterPhysicalActionSound) == 0x000260, "Wrong size on FCharacterPhysicalActionSound");
static_assert(offsetof(FCharacterPhysicalActionSound, UseOverride) == 0x000000, "Member 'FCharacterPhysicalActionSound::UseOverride' has a wrong offset!");
static_assert(offsetof(FCharacterPhysicalActionSound, Actions) == 0x000008, "Member 'FCharacterPhysicalActionSound::Actions' has a wrong offset!");

// ScriptStruct BattlePrototype.CharacterPhysicalSurfaceActionSound
// 0x3DC0 (0x3DC8 - 0x0008)
struct FCharacterPhysicalSurfaceActionSound final : public FTableRowBase
{
public:
	struct FCharacterPhysicalActionSound          Surfaces[0x1A];                                    // 0x0008(0x0260)(Edit, EditFixedSize, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterPhysicalSurfaceActionSound) == 0x000008, "Wrong alignment on FCharacterPhysicalSurfaceActionSound");
static_assert(sizeof(FCharacterPhysicalSurfaceActionSound) == 0x003DC8, "Wrong size on FCharacterPhysicalSurfaceActionSound");
static_assert(offsetof(FCharacterPhysicalSurfaceActionSound, Surfaces) == 0x000008, "Member 'FCharacterPhysicalSurfaceActionSound::Surfaces' has a wrong offset!");

// ScriptStruct BattlePrototype.ActivityDataTable
// 0x0030 (0x0038 - 0x0008)
struct FActivityDataTable final : public FTableRowBase
{
public:
	class FString                                 ObjectID;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActivityID;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DebugMessage;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActivityDataTable) == 0x000008, "Wrong alignment on FActivityDataTable");
static_assert(sizeof(FActivityDataTable) == 0x000038, "Wrong size on FActivityDataTable");
static_assert(offsetof(FActivityDataTable, ObjectID) == 0x000008, "Member 'FActivityDataTable::ObjectID' has a wrong offset!");
static_assert(offsetof(FActivityDataTable, ActivityID) == 0x000018, "Member 'FActivityDataTable::ActivityID' has a wrong offset!");
static_assert(offsetof(FActivityDataTable, DebugMessage) == 0x000028, "Member 'FActivityDataTable::DebugMessage' has a wrong offset!");

// ScriptStruct BattlePrototype.CharacterPhysicalActionEffect
// 0x0260 (0x0260 - 0x0000)
struct FCharacterPhysicalActionEffect final
{
public:
	bool                                          UseOverride;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UParticleSystem>         Actions[0xF];                                      // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterPhysicalActionEffect) == 0x000008, "Wrong alignment on FCharacterPhysicalActionEffect");
static_assert(sizeof(FCharacterPhysicalActionEffect) == 0x000260, "Wrong size on FCharacterPhysicalActionEffect");
static_assert(offsetof(FCharacterPhysicalActionEffect, UseOverride) == 0x000000, "Member 'FCharacterPhysicalActionEffect::UseOverride' has a wrong offset!");
static_assert(offsetof(FCharacterPhysicalActionEffect, Actions) == 0x000008, "Member 'FCharacterPhysicalActionEffect::Actions' has a wrong offset!");

// ScriptStruct BattlePrototype.CharacterPhysicalSurfaceActionEffect
// 0x3DC0 (0x3DC8 - 0x0008)
struct FCharacterPhysicalSurfaceActionEffect final : public FTableRowBase
{
public:
	struct FCharacterPhysicalActionEffect         Surfaces[0x1A];                                    // 0x0008(0x0260)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterPhysicalSurfaceActionEffect) == 0x000008, "Wrong alignment on FCharacterPhysicalSurfaceActionEffect");
static_assert(sizeof(FCharacterPhysicalSurfaceActionEffect) == 0x003DC8, "Wrong size on FCharacterPhysicalSurfaceActionEffect");
static_assert(offsetof(FCharacterPhysicalSurfaceActionEffect, Surfaces) == 0x000008, "Member 'FCharacterPhysicalSurfaceActionEffect::Surfaces' has a wrong offset!");

// ScriptStruct BattlePrototype.RetryLoadingTipsParam
// 0x0008 (0x0008 - 0x0000)
struct FRetryLoadingTipsParam final
{
public:
	int32                                         ProgressBeginNo;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressEndNo;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRetryLoadingTipsParam) == 0x000004, "Wrong alignment on FRetryLoadingTipsParam");
static_assert(sizeof(FRetryLoadingTipsParam) == 0x000008, "Wrong size on FRetryLoadingTipsParam");
static_assert(offsetof(FRetryLoadingTipsParam, ProgressBeginNo) == 0x000000, "Member 'FRetryLoadingTipsParam::ProgressBeginNo' has a wrong offset!");
static_assert(offsetof(FRetryLoadingTipsParam, ProgressEndNo) == 0x000004, "Member 'FRetryLoadingTipsParam::ProgressEndNo' has a wrong offset!");

// ScriptStruct BattlePrototype.GameTimer
// 0x000C (0x000C - 0x0000)
struct FGameTimer final
{
public:
	float                                         CurrentTime;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOver;                                             // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPause;                                            // 0x000A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameTimer) == 0x000004, "Wrong alignment on FGameTimer");
static_assert(sizeof(FGameTimer) == 0x00000C, "Wrong size on FGameTimer");
static_assert(offsetof(FGameTimer, CurrentTime) == 0x000000, "Member 'FGameTimer::CurrentTime' has a wrong offset!");
static_assert(offsetof(FGameTimer, EndTime) == 0x000004, "Member 'FGameTimer::EndTime' has a wrong offset!");
static_assert(offsetof(FGameTimer, bEnable) == 0x000008, "Member 'FGameTimer::bEnable' has a wrong offset!");
static_assert(offsetof(FGameTimer, bOver) == 0x000009, "Member 'FGameTimer::bOver' has a wrong offset!");
static_assert(offsetof(FGameTimer, bPause) == 0x00000A, "Member 'FGameTimer::bPause' has a wrong offset!");

// ScriptStruct BattlePrototype.HateParam
// 0x0080 (0x0080 - 0x0000)
struct FHateParam final
{
public:
	float                                         MHateAttack;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MHateFirstAttack;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MHateDownPlayer;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MHateDownFriend;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MHateDownOthers;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MHateFirstPlayer;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MHateFirstFriend;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MHateFirstOthers;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetLockTime;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetLockRange;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetLockUpdateTime;                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetLockNearTime;                               // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetLockNearRange;                              // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetLockNearUpdateTime;                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFreeHateNum1;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFreeHateNum2;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFreeHateNum3;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MProvoke;                                          // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDecreaseAccHate;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDecreaseTempHate;                                 // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MPlayerHateRate;                                   // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MNpcHateRate;                                      // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDefaultBerserkHateRate;                           // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MSubHateRate;                                      // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFlameAddHate;                                     // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MElecAddHate;                                      // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFloodedAddHate;                                   // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MOilAddHate;                                       // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MConfusionAddHate;                                 // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MBasis;                                            // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MBasisDistance;                                    // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MBasisPlayer;                                      // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHateParam) == 0x000004, "Wrong alignment on FHateParam");
static_assert(sizeof(FHateParam) == 0x000080, "Wrong size on FHateParam");
static_assert(offsetof(FHateParam, MHateAttack) == 0x000000, "Member 'FHateParam::MHateAttack' has a wrong offset!");
static_assert(offsetof(FHateParam, MHateFirstAttack) == 0x000004, "Member 'FHateParam::MHateFirstAttack' has a wrong offset!");
static_assert(offsetof(FHateParam, MHateDownPlayer) == 0x000008, "Member 'FHateParam::MHateDownPlayer' has a wrong offset!");
static_assert(offsetof(FHateParam, MHateDownFriend) == 0x00000C, "Member 'FHateParam::MHateDownFriend' has a wrong offset!");
static_assert(offsetof(FHateParam, MHateDownOthers) == 0x000010, "Member 'FHateParam::MHateDownOthers' has a wrong offset!");
static_assert(offsetof(FHateParam, MHateFirstPlayer) == 0x000014, "Member 'FHateParam::MHateFirstPlayer' has a wrong offset!");
static_assert(offsetof(FHateParam, MHateFirstFriend) == 0x000018, "Member 'FHateParam::MHateFirstFriend' has a wrong offset!");
static_assert(offsetof(FHateParam, MHateFirstOthers) == 0x00001C, "Member 'FHateParam::MHateFirstOthers' has a wrong offset!");
static_assert(offsetof(FHateParam, MTargetLockTime) == 0x000020, "Member 'FHateParam::MTargetLockTime' has a wrong offset!");
static_assert(offsetof(FHateParam, MTargetLockRange) == 0x000024, "Member 'FHateParam::MTargetLockRange' has a wrong offset!");
static_assert(offsetof(FHateParam, MTargetLockUpdateTime) == 0x000028, "Member 'FHateParam::MTargetLockUpdateTime' has a wrong offset!");
static_assert(offsetof(FHateParam, MTargetLockNearTime) == 0x00002C, "Member 'FHateParam::MTargetLockNearTime' has a wrong offset!");
static_assert(offsetof(FHateParam, MTargetLockNearRange) == 0x000030, "Member 'FHateParam::MTargetLockNearRange' has a wrong offset!");
static_assert(offsetof(FHateParam, MTargetLockNearUpdateTime) == 0x000034, "Member 'FHateParam::MTargetLockNearUpdateTime' has a wrong offset!");
static_assert(offsetof(FHateParam, MFreeHateNum1) == 0x000038, "Member 'FHateParam::MFreeHateNum1' has a wrong offset!");
static_assert(offsetof(FHateParam, MFreeHateNum2) == 0x00003C, "Member 'FHateParam::MFreeHateNum2' has a wrong offset!");
static_assert(offsetof(FHateParam, MFreeHateNum3) == 0x000040, "Member 'FHateParam::MFreeHateNum3' has a wrong offset!");
static_assert(offsetof(FHateParam, MProvoke) == 0x000044, "Member 'FHateParam::MProvoke' has a wrong offset!");
static_assert(offsetof(FHateParam, MDecreaseAccHate) == 0x000048, "Member 'FHateParam::MDecreaseAccHate' has a wrong offset!");
static_assert(offsetof(FHateParam, MDecreaseTempHate) == 0x00004C, "Member 'FHateParam::MDecreaseTempHate' has a wrong offset!");
static_assert(offsetof(FHateParam, MPlayerHateRate) == 0x000050, "Member 'FHateParam::MPlayerHateRate' has a wrong offset!");
static_assert(offsetof(FHateParam, MNpcHateRate) == 0x000054, "Member 'FHateParam::MNpcHateRate' has a wrong offset!");
static_assert(offsetof(FHateParam, MDefaultBerserkHateRate) == 0x000058, "Member 'FHateParam::MDefaultBerserkHateRate' has a wrong offset!");
static_assert(offsetof(FHateParam, MSubHateRate) == 0x00005C, "Member 'FHateParam::MSubHateRate' has a wrong offset!");
static_assert(offsetof(FHateParam, MFlameAddHate) == 0x000060, "Member 'FHateParam::MFlameAddHate' has a wrong offset!");
static_assert(offsetof(FHateParam, MElecAddHate) == 0x000064, "Member 'FHateParam::MElecAddHate' has a wrong offset!");
static_assert(offsetof(FHateParam, MFloodedAddHate) == 0x000068, "Member 'FHateParam::MFloodedAddHate' has a wrong offset!");
static_assert(offsetof(FHateParam, MOilAddHate) == 0x00006C, "Member 'FHateParam::MOilAddHate' has a wrong offset!");
static_assert(offsetof(FHateParam, MConfusionAddHate) == 0x000070, "Member 'FHateParam::MConfusionAddHate' has a wrong offset!");
static_assert(offsetof(FHateParam, MBasis) == 0x000074, "Member 'FHateParam::MBasis' has a wrong offset!");
static_assert(offsetof(FHateParam, MBasisDistance) == 0x000078, "Member 'FHateParam::MBasisDistance' has a wrong offset!");
static_assert(offsetof(FHateParam, MBasisPlayer) == 0x00007C, "Member 'FHateParam::MBasisPlayer' has a wrong offset!");

// ScriptStruct BattlePrototype.CameraTriggerInfo
// 0x0020 (0x0028 - 0x0008)
struct FCameraTriggerInfo final : public FTableRowBase
{
public:
	int32                                         Priority;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerCameraPreset                           PresetBasic;                                       // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerCameraPreset                           PresetOffset;                                      // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PInterpolateCurve;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEndInterpolateCurve;                           // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PEndInterpolateCurve;                              // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraTriggerInfo) == 0x000008, "Wrong alignment on FCameraTriggerInfo");
static_assert(sizeof(FCameraTriggerInfo) == 0x000028, "Wrong size on FCameraTriggerInfo");
static_assert(offsetof(FCameraTriggerInfo, Priority) == 0x000008, "Member 'FCameraTriggerInfo::Priority' has a wrong offset!");
static_assert(offsetof(FCameraTriggerInfo, PresetBasic) == 0x00000C, "Member 'FCameraTriggerInfo::PresetBasic' has a wrong offset!");
static_assert(offsetof(FCameraTriggerInfo, PresetOffset) == 0x00000D, "Member 'FCameraTriggerInfo::PresetOffset' has a wrong offset!");
static_assert(offsetof(FCameraTriggerInfo, PInterpolateCurve) == 0x000010, "Member 'FCameraTriggerInfo::PInterpolateCurve' has a wrong offset!");
static_assert(offsetof(FCameraTriggerInfo, bUseEndInterpolateCurve) == 0x000018, "Member 'FCameraTriggerInfo::bUseEndInterpolateCurve' has a wrong offset!");
static_assert(offsetof(FCameraTriggerInfo, PEndInterpolateCurve) == 0x000020, "Member 'FCameraTriggerInfo::PEndInterpolateCurve' has a wrong offset!");

// ScriptStruct BattlePrototype.HateTargetParam
// 0x0020 (0x0020 - 0x0000)
struct FHateTargetParam final
{
public:
	TWeakObjectPtr<class ARSCharacterBase>        MTarget;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MHate;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MHateDown;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAccumulationHate;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTemporaryHate;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDecreaseAccumulationHate;                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDecreaseTemporaryHate;                            // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHateTargetParam) == 0x000004, "Wrong alignment on FHateTargetParam");
static_assert(sizeof(FHateTargetParam) == 0x000020, "Wrong size on FHateTargetParam");
static_assert(offsetof(FHateTargetParam, MTarget) == 0x000000, "Member 'FHateTargetParam::MTarget' has a wrong offset!");
static_assert(offsetof(FHateTargetParam, MHate) == 0x000008, "Member 'FHateTargetParam::MHate' has a wrong offset!");
static_assert(offsetof(FHateTargetParam, MHateDown) == 0x00000C, "Member 'FHateTargetParam::MHateDown' has a wrong offset!");
static_assert(offsetof(FHateTargetParam, MAccumulationHate) == 0x000010, "Member 'FHateTargetParam::MAccumulationHate' has a wrong offset!");
static_assert(offsetof(FHateTargetParam, MTemporaryHate) == 0x000014, "Member 'FHateTargetParam::MTemporaryHate' has a wrong offset!");
static_assert(offsetof(FHateTargetParam, MDecreaseAccumulationHate) == 0x000018, "Member 'FHateTargetParam::MDecreaseAccumulationHate' has a wrong offset!");
static_assert(offsetof(FHateTargetParam, MDecreaseTemporaryHate) == 0x00001C, "Member 'FHateTargetParam::MDecreaseTemporaryHate' has a wrong offset!");

// ScriptStruct BattlePrototype.HeightGradationSettings
// 0x0040 (0x0040 - 0x0000)
struct FHeightGradationSettings final
{
public:
	class UMaterialInterface*                     TargetMaterial;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GradationName;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpperSocketName;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LowerSocketName;                                   // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperOffsetLength;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerOffsetLength;                                 // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MidpointRatio;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GradationCylinderRadius;                           // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GlobalHorizontal;                                  // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHeightGradationSettings) == 0x000008, "Wrong alignment on FHeightGradationSettings");
static_assert(sizeof(FHeightGradationSettings) == 0x000040, "Wrong size on FHeightGradationSettings");
static_assert(offsetof(FHeightGradationSettings, TargetMaterial) == 0x000000, "Member 'FHeightGradationSettings::TargetMaterial' has a wrong offset!");
static_assert(offsetof(FHeightGradationSettings, GradationName) == 0x000008, "Member 'FHeightGradationSettings::GradationName' has a wrong offset!");
static_assert(offsetof(FHeightGradationSettings, UpperSocketName) == 0x000018, "Member 'FHeightGradationSettings::UpperSocketName' has a wrong offset!");
static_assert(offsetof(FHeightGradationSettings, LowerSocketName) == 0x000020, "Member 'FHeightGradationSettings::LowerSocketName' has a wrong offset!");
static_assert(offsetof(FHeightGradationSettings, UpperOffsetLength) == 0x000028, "Member 'FHeightGradationSettings::UpperOffsetLength' has a wrong offset!");
static_assert(offsetof(FHeightGradationSettings, LowerOffsetLength) == 0x00002C, "Member 'FHeightGradationSettings::LowerOffsetLength' has a wrong offset!");
static_assert(offsetof(FHeightGradationSettings, MidpointRatio) == 0x000030, "Member 'FHeightGradationSettings::MidpointRatio' has a wrong offset!");
static_assert(offsetof(FHeightGradationSettings, GradationCylinderRadius) == 0x000034, "Member 'FHeightGradationSettings::GradationCylinderRadius' has a wrong offset!");
static_assert(offsetof(FHeightGradationSettings, Alpha) == 0x000038, "Member 'FHeightGradationSettings::Alpha' has a wrong offset!");
static_assert(offsetof(FHeightGradationSettings, GlobalHorizontal) == 0x00003C, "Member 'FHeightGradationSettings::GlobalHorizontal' has a wrong offset!");

// ScriptStruct BattlePrototype.LoadTipsDataCell_Deprecated
// 0x0008 (0x0010 - 0x0008)
struct FLoadTipsDataCell_Deprecated final : public FTableRowBase
{
public:
	int32                                         MsgID;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadTipsDataCell_Deprecated) == 0x000008, "Wrong alignment on FLoadTipsDataCell_Deprecated");
static_assert(sizeof(FLoadTipsDataCell_Deprecated) == 0x000010, "Wrong size on FLoadTipsDataCell_Deprecated");
static_assert(offsetof(FLoadTipsDataCell_Deprecated, MsgID) == 0x000008, "Member 'FLoadTipsDataCell_Deprecated::MsgID' has a wrong offset!");

// ScriptStruct BattlePrototype.HelpListSortDataCell
// 0x0008 (0x0010 - 0x0008)
struct FHelpListSortDataCell final : public FTableRowBase
{
public:
	EHelpListCategory                             Category;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHelpTutorial                                 HelpID;                                            // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHelpListSortDataCell) == 0x000008, "Wrong alignment on FHelpListSortDataCell");
static_assert(sizeof(FHelpListSortDataCell) == 0x000010, "Wrong size on FHelpListSortDataCell");
static_assert(offsetof(FHelpListSortDataCell, Category) == 0x000008, "Member 'FHelpListSortDataCell::Category' has a wrong offset!");
static_assert(offsetof(FHelpListSortDataCell, HelpID) == 0x000009, "Member 'FHelpListSortDataCell::HelpID' has a wrong offset!");

// ScriptStruct BattlePrototype.HelpContentData
// 0x0030 (0x0038 - 0x0008)
struct FHelpContentData final : public FTableRowBase
{
public:
	class FName                                   HelpTitleMessageID;                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HelpCSmessageID;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHelpImageType                                HelpImageType;                                     // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ImagePath;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHelpImageDisplayPattern                      HelpImageDisplayPattern;                           // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHelpContentData) == 0x000008, "Wrong alignment on FHelpContentData");
static_assert(sizeof(FHelpContentData) == 0x000038, "Wrong size on FHelpContentData");
static_assert(offsetof(FHelpContentData, HelpTitleMessageID) == 0x000008, "Member 'FHelpContentData::HelpTitleMessageID' has a wrong offset!");
static_assert(offsetof(FHelpContentData, HelpCSmessageID) == 0x000010, "Member 'FHelpContentData::HelpCSmessageID' has a wrong offset!");
static_assert(offsetof(FHelpContentData, HelpImageType) == 0x000018, "Member 'FHelpContentData::HelpImageType' has a wrong offset!");
static_assert(offsetof(FHelpContentData, ImagePath) == 0x000020, "Member 'FHelpContentData::ImagePath' has a wrong offset!");
static_assert(offsetof(FHelpContentData, HelpImageDisplayPattern) == 0x000030, "Member 'FHelpContentData::HelpImageDisplayPattern' has a wrong offset!");

// ScriptStruct BattlePrototype.HelpDBDataCell
// 0x0018 (0x0020 - 0x0008)
struct FHelpDBDataCell final : public FTableRowBase
{
public:
	class FName                                   HelpListMessageID;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHelpContentData>               ContentHelpData;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHelpDBDataCell) == 0x000008, "Wrong alignment on FHelpDBDataCell");
static_assert(sizeof(FHelpDBDataCell) == 0x000020, "Wrong size on FHelpDBDataCell");
static_assert(offsetof(FHelpDBDataCell, HelpListMessageID) == 0x000008, "Member 'FHelpDBDataCell::HelpListMessageID' has a wrong offset!");
static_assert(offsetof(FHelpDBDataCell, ContentHelpData) == 0x000010, "Member 'FHelpDBDataCell::ContentHelpData' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryEnemyParamData
// 0x0020 (0x0020 - 0x0000)
struct FLibraryEnemyParamData final
{
public:
	bool                                          IsOpened;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KillNum;                                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  DropItems;                                         // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryEnemyParamData) == 0x000008, "Wrong alignment on FLibraryEnemyParamData");
static_assert(sizeof(FLibraryEnemyParamData) == 0x000020, "Wrong size on FLibraryEnemyParamData");
static_assert(offsetof(FLibraryEnemyParamData, IsOpened) == 0x000000, "Member 'FLibraryEnemyParamData::IsOpened' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyParamData, KillNum) == 0x000004, "Member 'FLibraryEnemyParamData::KillNum' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyParamData, DropItems) == 0x000010, "Member 'FLibraryEnemyParamData::DropItems' has a wrong offset!");

// ScriptStruct BattlePrototype.UiSceneMapIconNode
// 0x00C8 (0x00C8 - 0x0000)
struct FUiSceneMapIconNode final
{
public:
	EUiSceneMapIconType                           Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapGimmickType                               Subtype;                                           // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActorName;                                         // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ScenarioFlagName;                                  // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0014(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Rotation;                                          // 0x0020(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x002C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PortalNo;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LocationNoJumpTo;                                  // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaNoJumpTo;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartPortalNoJumpTo;                               // 0x0044(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x004C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUIMapIconAdjust                       MapIconAdjust;                                     // 0x0058(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FUIMapIconPGAdjust                     MapIconPGAdjust;                                   // 0x007C(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           IdList;                                            // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DispToDetailSubArea;                               // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAreaInfoTweakCondition>        DispConditions;                                    // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUiSceneMapIconNode) == 0x000008, "Wrong alignment on FUiSceneMapIconNode");
static_assert(sizeof(FUiSceneMapIconNode) == 0x0000C8, "Wrong size on FUiSceneMapIconNode");
static_assert(offsetof(FUiSceneMapIconNode, Type) == 0x000000, "Member 'FUiSceneMapIconNode::Type' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconNode, Subtype) == 0x000001, "Member 'FUiSceneMapIconNode::Subtype' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconNode, ActorName) == 0x000004, "Member 'FUiSceneMapIconNode::ActorName' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconNode, ScenarioFlagName) == 0x00000C, "Member 'FUiSceneMapIconNode::ScenarioFlagName' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconNode, Translation) == 0x000014, "Member 'FUiSceneMapIconNode::Translation' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconNode, Rotation) == 0x000020, "Member 'FUiSceneMapIconNode::Rotation' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconNode, Scale) == 0x00002C, "Member 'FUiSceneMapIconNode::Scale' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconNode, PortalNo) == 0x000038, "Member 'FUiSceneMapIconNode::PortalNo' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconNode, LocationNoJumpTo) == 0x00003C, "Member 'FUiSceneMapIconNode::LocationNoJumpTo' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconNode, AreaNoJumpTo) == 0x000040, "Member 'FUiSceneMapIconNode::AreaNoJumpTo' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconNode, StartPortalNoJumpTo) == 0x000044, "Member 'FUiSceneMapIconNode::StartPortalNoJumpTo' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconNode, BoxExtent) == 0x00004C, "Member 'FUiSceneMapIconNode::BoxExtent' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconNode, MapIconAdjust) == 0x000058, "Member 'FUiSceneMapIconNode::MapIconAdjust' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconNode, MapIconPGAdjust) == 0x00007C, "Member 'FUiSceneMapIconNode::MapIconPGAdjust' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconNode, IdList) == 0x0000A0, "Member 'FUiSceneMapIconNode::IdList' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconNode, DispToDetailSubArea) == 0x0000B0, "Member 'FUiSceneMapIconNode::DispToDetailSubArea' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconNode, DispConditions) == 0x0000B8, "Member 'FUiSceneMapIconNode::DispConditions' has a wrong offset!");

// ScriptStruct BattlePrototype.UiSceneMapIconDataCell
// 0x0028 (0x0030 - 0x0008)
struct FUiSceneMapIconDataCell final : public FTableRowBase
{
public:
	class FName                                   LocationName;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaName;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LocationNo;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaNo;                                            // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FUiSceneMapIconNode>            NodeList;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUiSceneMapIconDataCell) == 0x000008, "Wrong alignment on FUiSceneMapIconDataCell");
static_assert(sizeof(FUiSceneMapIconDataCell) == 0x000030, "Wrong size on FUiSceneMapIconDataCell");
static_assert(offsetof(FUiSceneMapIconDataCell, LocationName) == 0x000008, "Member 'FUiSceneMapIconDataCell::LocationName' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconDataCell, AreaName) == 0x000010, "Member 'FUiSceneMapIconDataCell::AreaName' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconDataCell, LocationNo) == 0x000018, "Member 'FUiSceneMapIconDataCell::LocationNo' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconDataCell, AreaNo) == 0x00001C, "Member 'FUiSceneMapIconDataCell::AreaNo' has a wrong offset!");
static_assert(offsetof(FUiSceneMapIconDataCell, NodeList) == 0x000020, "Member 'FUiSceneMapIconDataCell::NodeList' has a wrong offset!");

// ScriptStruct BattlePrototype.HelpRowDataCell
// 0x0038 (0x0040 - 0x0008)
struct FHelpRowDataCell final : public FTableRowBase
{
public:
	EHelpTutorial                                 HelpID;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HelpListMessageID;                                 // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HelpTitleMessageID;                                // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HelpCSmessageID;                                   // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHelpImageType                                HelpImageType;                                     // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ImagePath;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHelpImageDisplayPattern                      HelpImageDisplayPattern;                           // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHelpRowDataCell) == 0x000008, "Wrong alignment on FHelpRowDataCell");
static_assert(sizeof(FHelpRowDataCell) == 0x000040, "Wrong size on FHelpRowDataCell");
static_assert(offsetof(FHelpRowDataCell, HelpID) == 0x000008, "Member 'FHelpRowDataCell::HelpID' has a wrong offset!");
static_assert(offsetof(FHelpRowDataCell, HelpListMessageID) == 0x00000C, "Member 'FHelpRowDataCell::HelpListMessageID' has a wrong offset!");
static_assert(offsetof(FHelpRowDataCell, HelpTitleMessageID) == 0x000014, "Member 'FHelpRowDataCell::HelpTitleMessageID' has a wrong offset!");
static_assert(offsetof(FHelpRowDataCell, HelpCSmessageID) == 0x00001C, "Member 'FHelpRowDataCell::HelpCSmessageID' has a wrong offset!");
static_assert(offsetof(FHelpRowDataCell, HelpImageType) == 0x000024, "Member 'FHelpRowDataCell::HelpImageType' has a wrong offset!");
static_assert(offsetof(FHelpRowDataCell, ImagePath) == 0x000028, "Member 'FHelpRowDataCell::ImagePath' has a wrong offset!");
static_assert(offsetof(FHelpRowDataCell, HelpImageDisplayPattern) == 0x000038, "Member 'FHelpRowDataCell::HelpImageDisplayPattern' has a wrong offset!");

// ScriptStruct BattlePrototype.WireNeon
// 0x0030 (0x0038 - 0x0008)
struct FWireNeon final : public FTableRowBase
{
public:
	float                                         EvUseEmAlwFlicker;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OverrideBaseColor;                                 // 0x000C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OverrideEmAlwColor;                                // 0x001C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UseOverrideBaseColor;                              // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UseOverrideEmAlwColor;                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmAlwFlicker;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWireNeon) == 0x000008, "Wrong alignment on FWireNeon");
static_assert(sizeof(FWireNeon) == 0x000038, "Wrong size on FWireNeon");
static_assert(offsetof(FWireNeon, EvUseEmAlwFlicker) == 0x000008, "Member 'FWireNeon::EvUseEmAlwFlicker' has a wrong offset!");
static_assert(offsetof(FWireNeon, OverrideBaseColor) == 0x00000C, "Member 'FWireNeon::OverrideBaseColor' has a wrong offset!");
static_assert(offsetof(FWireNeon, OverrideEmAlwColor) == 0x00001C, "Member 'FWireNeon::OverrideEmAlwColor' has a wrong offset!");
static_assert(offsetof(FWireNeon, UseOverrideBaseColor) == 0x00002C, "Member 'FWireNeon::UseOverrideBaseColor' has a wrong offset!");
static_assert(offsetof(FWireNeon, UseOverrideEmAlwColor) == 0x000030, "Member 'FWireNeon::UseOverrideEmAlwColor' has a wrong offset!");
static_assert(offsetof(FWireNeon, EmAlwFlicker) == 0x000034, "Member 'FWireNeon::EmAlwFlicker' has a wrong offset!");

// ScriptStruct BattlePrototype.HelpListSortParam
// 0x0002 (0x0002 - 0x0000)
struct FHelpListSortParam final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHelpListSortParam) == 0x000001, "Wrong alignment on FHelpListSortParam");
static_assert(sizeof(FHelpListSortParam) == 0x000002, "Wrong size on FHelpListSortParam");

// ScriptStruct BattlePrototype.DamageRate
// 0x0018 (0x0018 - 0x0000)
struct FDamageRate final
{
public:
	float                                         DamageRate;                                        // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlameRate;                                         // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElectricRate;                                      // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloodedRate;                                       // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OilRate;                                           // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionRate;                                     // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageRate) == 0x000004, "Wrong alignment on FDamageRate");
static_assert(sizeof(FDamageRate) == 0x000018, "Wrong size on FDamageRate");
static_assert(offsetof(FDamageRate, DamageRate) == 0x000000, "Member 'FDamageRate::DamageRate' has a wrong offset!");
static_assert(offsetof(FDamageRate, FlameRate) == 0x000004, "Member 'FDamageRate::FlameRate' has a wrong offset!");
static_assert(offsetof(FDamageRate, ElectricRate) == 0x000008, "Member 'FDamageRate::ElectricRate' has a wrong offset!");
static_assert(offsetof(FDamageRate, FloodedRate) == 0x00000C, "Member 'FDamageRate::FloodedRate' has a wrong offset!");
static_assert(offsetof(FDamageRate, OilRate) == 0x000010, "Member 'FDamageRate::OilRate' has a wrong offset!");
static_assert(offsetof(FDamageRate, ConfusionRate) == 0x000014, "Member 'FDamageRate::ConfusionRate' has a wrong offset!");

// ScriptStruct BattlePrototype.ChapterPlayerInfo
// 0x0030 (0x0030 - 0x0000)
struct FChapterPlayerInfo final
{
public:
	EPlayerID                                     PlayerId;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Esp;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponId;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccessoryID0;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccessoryID1;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccessoryID2;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostumeId;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttachmentID0;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttachmentID1;                                     // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttachmentID2;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerAIOrder                                AIOrder;                                           // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChapterPlayerInfo) == 0x000004, "Wrong alignment on FChapterPlayerInfo");
static_assert(sizeof(FChapterPlayerInfo) == 0x000030, "Wrong size on FChapterPlayerInfo");
static_assert(offsetof(FChapterPlayerInfo, PlayerId) == 0x000000, "Member 'FChapterPlayerInfo::PlayerId' has a wrong offset!");
static_assert(offsetof(FChapterPlayerInfo, Level) == 0x000004, "Member 'FChapterPlayerInfo::Level' has a wrong offset!");
static_assert(offsetof(FChapterPlayerInfo, Esp) == 0x000008, "Member 'FChapterPlayerInfo::Esp' has a wrong offset!");
static_assert(offsetof(FChapterPlayerInfo, WeaponId) == 0x00000C, "Member 'FChapterPlayerInfo::WeaponId' has a wrong offset!");
static_assert(offsetof(FChapterPlayerInfo, AccessoryID0) == 0x000010, "Member 'FChapterPlayerInfo::AccessoryID0' has a wrong offset!");
static_assert(offsetof(FChapterPlayerInfo, AccessoryID1) == 0x000014, "Member 'FChapterPlayerInfo::AccessoryID1' has a wrong offset!");
static_assert(offsetof(FChapterPlayerInfo, AccessoryID2) == 0x000018, "Member 'FChapterPlayerInfo::AccessoryID2' has a wrong offset!");
static_assert(offsetof(FChapterPlayerInfo, CostumeId) == 0x00001C, "Member 'FChapterPlayerInfo::CostumeId' has a wrong offset!");
static_assert(offsetof(FChapterPlayerInfo, AttachmentID0) == 0x000020, "Member 'FChapterPlayerInfo::AttachmentID0' has a wrong offset!");
static_assert(offsetof(FChapterPlayerInfo, AttachmentID1) == 0x000024, "Member 'FChapterPlayerInfo::AttachmentID1' has a wrong offset!");
static_assert(offsetof(FChapterPlayerInfo, AttachmentID2) == 0x000028, "Member 'FChapterPlayerInfo::AttachmentID2' has a wrong offset!");
static_assert(offsetof(FChapterPlayerInfo, AIOrder) == 0x00002C, "Member 'FChapterPlayerInfo::AIOrder' has a wrong offset!");

// ScriptStruct BattlePrototype.HCAttackCollisionInfo
// 0x0270 (0x0270 - 0x0000)
struct FHCAttackCollisionInfo final
{
public:
	class FName                                   RootSocketName;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TopSocketName;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootOffset;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TopOffset;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitHeight;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHCCollisionCommonInfo                 Common;                                            // 0x0020(0x0070)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FHCSkillCommonInfo                     Skill;                                             // 0x0090(0x00E8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         EffectiveRangeMin;                                 // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectiveRangeMax;                                 // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHCSkillCommonInfo                     OutEffectiveRangeSkill;                            // 0x0180(0x00E8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FHCHitEffectInfo                       EffectInfo;                                        // 0x0268(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHCAttackCollisionInfo) == 0x000008, "Wrong alignment on FHCAttackCollisionInfo");
static_assert(sizeof(FHCAttackCollisionInfo) == 0x000270, "Wrong size on FHCAttackCollisionInfo");
static_assert(offsetof(FHCAttackCollisionInfo, RootSocketName) == 0x000000, "Member 'FHCAttackCollisionInfo::RootSocketName' has a wrong offset!");
static_assert(offsetof(FHCAttackCollisionInfo, TopSocketName) == 0x000008, "Member 'FHCAttackCollisionInfo::TopSocketName' has a wrong offset!");
static_assert(offsetof(FHCAttackCollisionInfo, Radius) == 0x000010, "Member 'FHCAttackCollisionInfo::Radius' has a wrong offset!");
static_assert(offsetof(FHCAttackCollisionInfo, RootOffset) == 0x000014, "Member 'FHCAttackCollisionInfo::RootOffset' has a wrong offset!");
static_assert(offsetof(FHCAttackCollisionInfo, TopOffset) == 0x000018, "Member 'FHCAttackCollisionInfo::TopOffset' has a wrong offset!");
static_assert(offsetof(FHCAttackCollisionInfo, LimitHeight) == 0x00001C, "Member 'FHCAttackCollisionInfo::LimitHeight' has a wrong offset!");
static_assert(offsetof(FHCAttackCollisionInfo, Common) == 0x000020, "Member 'FHCAttackCollisionInfo::Common' has a wrong offset!");
static_assert(offsetof(FHCAttackCollisionInfo, Skill) == 0x000090, "Member 'FHCAttackCollisionInfo::Skill' has a wrong offset!");
static_assert(offsetof(FHCAttackCollisionInfo, EffectiveRangeMin) == 0x000178, "Member 'FHCAttackCollisionInfo::EffectiveRangeMin' has a wrong offset!");
static_assert(offsetof(FHCAttackCollisionInfo, EffectiveRangeMax) == 0x00017C, "Member 'FHCAttackCollisionInfo::EffectiveRangeMax' has a wrong offset!");
static_assert(offsetof(FHCAttackCollisionInfo, OutEffectiveRangeSkill) == 0x000180, "Member 'FHCAttackCollisionInfo::OutEffectiveRangeSkill' has a wrong offset!");
static_assert(offsetof(FHCAttackCollisionInfo, EffectInfo) == 0x000268, "Member 'FHCAttackCollisionInfo::EffectInfo' has a wrong offset!");

// ScriptStruct BattlePrototype.HitDamageInfo
// 0x0060 (0x0060 - 0x0000)
struct FHitDamageInfo final
{
public:
	EHCSkillAttackType                            AttackType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCSkillType                                  AttackSkillType;                                   // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SkillAttributeFlags;                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHDamageEffectType                            DamagePointType;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCSkillEnemyHitEffect                        EnemyHitEffectType;                                // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHCSkillEnemyHitEffect                        EnemyHitSoundType;                                 // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             HitTransform;                                      // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Attacker;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  AttackOwner;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Defencer;                                          // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCritical;                                        // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFirstWeakAttack;                                 // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitDamageInfo) == 0x000010, "Wrong alignment on FHitDamageInfo");
static_assert(sizeof(FHitDamageInfo) == 0x000060, "Wrong size on FHitDamageInfo");
static_assert(offsetof(FHitDamageInfo, AttackType) == 0x000000, "Member 'FHitDamageInfo::AttackType' has a wrong offset!");
static_assert(offsetof(FHitDamageInfo, AttackSkillType) == 0x000001, "Member 'FHitDamageInfo::AttackSkillType' has a wrong offset!");
static_assert(offsetof(FHitDamageInfo, SkillAttributeFlags) == 0x000004, "Member 'FHitDamageInfo::SkillAttributeFlags' has a wrong offset!");
static_assert(offsetof(FHitDamageInfo, DamagePointType) == 0x000008, "Member 'FHitDamageInfo::DamagePointType' has a wrong offset!");
static_assert(offsetof(FHitDamageInfo, EnemyHitEffectType) == 0x000009, "Member 'FHitDamageInfo::EnemyHitEffectType' has a wrong offset!");
static_assert(offsetof(FHitDamageInfo, EnemyHitSoundType) == 0x00000A, "Member 'FHitDamageInfo::EnemyHitSoundType' has a wrong offset!");
static_assert(offsetof(FHitDamageInfo, HitTransform) == 0x000010, "Member 'FHitDamageInfo::HitTransform' has a wrong offset!");
static_assert(offsetof(FHitDamageInfo, Attacker) == 0x000040, "Member 'FHitDamageInfo::Attacker' has a wrong offset!");
static_assert(offsetof(FHitDamageInfo, AttackOwner) == 0x000048, "Member 'FHitDamageInfo::AttackOwner' has a wrong offset!");
static_assert(offsetof(FHitDamageInfo, Defencer) == 0x000050, "Member 'FHitDamageInfo::Defencer' has a wrong offset!");
static_assert(offsetof(FHitDamageInfo, IsCritical) == 0x000058, "Member 'FHitDamageInfo::IsCritical' has a wrong offset!");
static_assert(offsetof(FHitDamageInfo, IsFirstWeakAttack) == 0x000059, "Member 'FHitDamageInfo::IsFirstWeakAttack' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerCameraPreset
// 0x00D0 (0x00D8 - 0x0008)
struct FPlayerCameraPreset final : public FTableRowBase
{
public:
	float                                         Distance;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceK;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RootOffset;                                        // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RootOffsetK;                                       // 0x001C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookAtOffset;                                      // 0x0028(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookAtOffsetK;                                     // 0x0034(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldOfView;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleVtMax;                                        // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleVtMaxK;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleVtMin;                                        // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleVtMinK;                                       // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleVtDistanceRateUp;                             // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleVtDistanceRateDn;                             // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AngleVtRootOffsetUp;                               // 0x005C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AngleVtRootOffsetDn;                               // 0x0068(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnCameraDistanceOffset;                        // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnCameraDistanceOffsetK;                       // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnLookAtRate;                                  // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnLookAtRateK;                                 // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnLookAtDistanceMax;                           // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnLookAtRateObj;                               // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnLookAtRateObjK;                              // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnLimitAngleHzRate;                            // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnLimitAngleVtRate;                            // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnLimitAngleVtRateK;                           // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnAngleVtMax;                                  // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnAngleVtMaxK;                                 // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnAngleVtMin;                                  // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnAngleVtMinK;                                 // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnDefaultAngleVt;                              // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnDefaultAngleVtK;                             // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleCameraDistance;                              // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleCameraDistanceK;                             // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BattleCameraOffset;                                // 0x00BC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BattleCameraOffsetK;                               // 0x00C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerCameraPreset) == 0x000008, "Wrong alignment on FPlayerCameraPreset");
static_assert(sizeof(FPlayerCameraPreset) == 0x0000D8, "Wrong size on FPlayerCameraPreset");
static_assert(offsetof(FPlayerCameraPreset, Distance) == 0x000008, "Member 'FPlayerCameraPreset::Distance' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, DistanceK) == 0x00000C, "Member 'FPlayerCameraPreset::DistanceK' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, RootOffset) == 0x000010, "Member 'FPlayerCameraPreset::RootOffset' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, RootOffsetK) == 0x00001C, "Member 'FPlayerCameraPreset::RootOffsetK' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, LookAtOffset) == 0x000028, "Member 'FPlayerCameraPreset::LookAtOffset' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, LookAtOffsetK) == 0x000034, "Member 'FPlayerCameraPreset::LookAtOffsetK' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, FieldOfView) == 0x000040, "Member 'FPlayerCameraPreset::FieldOfView' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, AngleVtMax) == 0x000044, "Member 'FPlayerCameraPreset::AngleVtMax' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, AngleVtMaxK) == 0x000048, "Member 'FPlayerCameraPreset::AngleVtMaxK' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, AngleVtMin) == 0x00004C, "Member 'FPlayerCameraPreset::AngleVtMin' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, AngleVtMinK) == 0x000050, "Member 'FPlayerCameraPreset::AngleVtMinK' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, AngleVtDistanceRateUp) == 0x000054, "Member 'FPlayerCameraPreset::AngleVtDistanceRateUp' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, AngleVtDistanceRateDn) == 0x000058, "Member 'FPlayerCameraPreset::AngleVtDistanceRateDn' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, AngleVtRootOffsetUp) == 0x00005C, "Member 'FPlayerCameraPreset::AngleVtRootOffsetUp' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, AngleVtRootOffsetDn) == 0x000068, "Member 'FPlayerCameraPreset::AngleVtRootOffsetDn' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, LockOnCameraDistanceOffset) == 0x000074, "Member 'FPlayerCameraPreset::LockOnCameraDistanceOffset' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, LockOnCameraDistanceOffsetK) == 0x000078, "Member 'FPlayerCameraPreset::LockOnCameraDistanceOffsetK' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, LockOnLookAtRate) == 0x00007C, "Member 'FPlayerCameraPreset::LockOnLookAtRate' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, LockOnLookAtRateK) == 0x000080, "Member 'FPlayerCameraPreset::LockOnLookAtRateK' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, LockOnLookAtDistanceMax) == 0x000084, "Member 'FPlayerCameraPreset::LockOnLookAtDistanceMax' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, LockOnLookAtRateObj) == 0x000088, "Member 'FPlayerCameraPreset::LockOnLookAtRateObj' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, LockOnLookAtRateObjK) == 0x00008C, "Member 'FPlayerCameraPreset::LockOnLookAtRateObjK' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, LockOnLimitAngleHzRate) == 0x000090, "Member 'FPlayerCameraPreset::LockOnLimitAngleHzRate' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, LockOnLimitAngleVtRate) == 0x000094, "Member 'FPlayerCameraPreset::LockOnLimitAngleVtRate' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, LockOnLimitAngleVtRateK) == 0x000098, "Member 'FPlayerCameraPreset::LockOnLimitAngleVtRateK' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, LockOnAngleVtMax) == 0x00009C, "Member 'FPlayerCameraPreset::LockOnAngleVtMax' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, LockOnAngleVtMaxK) == 0x0000A0, "Member 'FPlayerCameraPreset::LockOnAngleVtMaxK' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, LockOnAngleVtMin) == 0x0000A4, "Member 'FPlayerCameraPreset::LockOnAngleVtMin' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, LockOnAngleVtMinK) == 0x0000A8, "Member 'FPlayerCameraPreset::LockOnAngleVtMinK' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, LockOnDefaultAngleVt) == 0x0000AC, "Member 'FPlayerCameraPreset::LockOnDefaultAngleVt' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, LockOnDefaultAngleVtK) == 0x0000B0, "Member 'FPlayerCameraPreset::LockOnDefaultAngleVtK' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, BattleCameraDistance) == 0x0000B4, "Member 'FPlayerCameraPreset::BattleCameraDistance' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, BattleCameraDistanceK) == 0x0000B8, "Member 'FPlayerCameraPreset::BattleCameraDistanceK' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, BattleCameraOffset) == 0x0000BC, "Member 'FPlayerCameraPreset::BattleCameraOffset' has a wrong offset!");
static_assert(offsetof(FPlayerCameraPreset, BattleCameraOffsetK) == 0x0000C8, "Member 'FPlayerCameraPreset::BattleCameraOffsetK' has a wrong offset!");

// ScriptStruct BattlePrototype.SpecialDamageParticleOne
// 0x0038 (0x0040 - 0x0008)
struct FSpecialDamageParticleOne final : public FTableRowBase
{
public:
	class UParticleSystem*                        Particle;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachLocationOnly;                               // 0x003D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecialDamageParticleOne) == 0x000008, "Wrong alignment on FSpecialDamageParticleOne");
static_assert(sizeof(FSpecialDamageParticleOne) == 0x000040, "Wrong size on FSpecialDamageParticleOne");
static_assert(offsetof(FSpecialDamageParticleOne, Particle) == 0x000008, "Member 'FSpecialDamageParticleOne::Particle' has a wrong offset!");
static_assert(offsetof(FSpecialDamageParticleOne, AttachPointName) == 0x000010, "Member 'FSpecialDamageParticleOne::AttachPointName' has a wrong offset!");
static_assert(offsetof(FSpecialDamageParticleOne, Location) == 0x000018, "Member 'FSpecialDamageParticleOne::Location' has a wrong offset!");
static_assert(offsetof(FSpecialDamageParticleOne, Rotation) == 0x000024, "Member 'FSpecialDamageParticleOne::Rotation' has a wrong offset!");
static_assert(offsetof(FSpecialDamageParticleOne, Scale) == 0x000030, "Member 'FSpecialDamageParticleOne::Scale' has a wrong offset!");
static_assert(offsetof(FSpecialDamageParticleOne, LocationType) == 0x00003C, "Member 'FSpecialDamageParticleOne::LocationType' has a wrong offset!");
static_assert(offsetof(FSpecialDamageParticleOne, bAttachLocationOnly) == 0x00003D, "Member 'FSpecialDamageParticleOne::bAttachLocationOnly' has a wrong offset!");

// ScriptStruct BattlePrototype.SpecialDamageParticle
// 0x0140 (0x0148 - 0x0008)
struct FSpecialDamageParticle final : public FTableRowBase
{
public:
	struct FSpecialDamageParticleOne              Electric;                                          // 0x0008(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSpecialDamageParticleOne              Fire;                                              // 0x0048(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSpecialDamageParticleOne              Water;                                             // 0x0088(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSpecialDamageParticleOne              Oil;                                               // 0x00C8(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSpecialDamageParticleOne              Confusion;                                         // 0x0108(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialDamageParticle) == 0x000008, "Wrong alignment on FSpecialDamageParticle");
static_assert(sizeof(FSpecialDamageParticle) == 0x000148, "Wrong size on FSpecialDamageParticle");
static_assert(offsetof(FSpecialDamageParticle, Electric) == 0x000008, "Member 'FSpecialDamageParticle::Electric' has a wrong offset!");
static_assert(offsetof(FSpecialDamageParticle, Fire) == 0x000048, "Member 'FSpecialDamageParticle::Fire' has a wrong offset!");
static_assert(offsetof(FSpecialDamageParticle, Water) == 0x000088, "Member 'FSpecialDamageParticle::Water' has a wrong offset!");
static_assert(offsetof(FSpecialDamageParticle, Oil) == 0x0000C8, "Member 'FSpecialDamageParticle::Oil' has a wrong offset!");
static_assert(offsetof(FSpecialDamageParticle, Confusion) == 0x000108, "Member 'FSpecialDamageParticle::Confusion' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerBrainFieldHelpData
// 0x00A0 (0x00A8 - 0x0008)
struct FPlayerBrainFieldHelpData final : public FTableRowBase
{
public:
	TArray<class FName>                           TalkID_ch0100;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           TalkID_ch0200;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           TalkID_ch0300;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           TalkID_ch0400;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           TalkID_ch0500;                                     // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           TalkID_ch0600;                                     // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           TalkID_ch0700;                                     // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           TalkID_ch0800;                                     // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           TalkID_ch0900;                                     // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           TalkID_ch1000;                                     // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerBrainFieldHelpData) == 0x000008, "Wrong alignment on FPlayerBrainFieldHelpData");
static_assert(sizeof(FPlayerBrainFieldHelpData) == 0x0000A8, "Wrong size on FPlayerBrainFieldHelpData");
static_assert(offsetof(FPlayerBrainFieldHelpData, TalkID_ch0100) == 0x000008, "Member 'FPlayerBrainFieldHelpData::TalkID_ch0100' has a wrong offset!");
static_assert(offsetof(FPlayerBrainFieldHelpData, TalkID_ch0200) == 0x000018, "Member 'FPlayerBrainFieldHelpData::TalkID_ch0200' has a wrong offset!");
static_assert(offsetof(FPlayerBrainFieldHelpData, TalkID_ch0300) == 0x000028, "Member 'FPlayerBrainFieldHelpData::TalkID_ch0300' has a wrong offset!");
static_assert(offsetof(FPlayerBrainFieldHelpData, TalkID_ch0400) == 0x000038, "Member 'FPlayerBrainFieldHelpData::TalkID_ch0400' has a wrong offset!");
static_assert(offsetof(FPlayerBrainFieldHelpData, TalkID_ch0500) == 0x000048, "Member 'FPlayerBrainFieldHelpData::TalkID_ch0500' has a wrong offset!");
static_assert(offsetof(FPlayerBrainFieldHelpData, TalkID_ch0600) == 0x000058, "Member 'FPlayerBrainFieldHelpData::TalkID_ch0600' has a wrong offset!");
static_assert(offsetof(FPlayerBrainFieldHelpData, TalkID_ch0700) == 0x000068, "Member 'FPlayerBrainFieldHelpData::TalkID_ch0700' has a wrong offset!");
static_assert(offsetof(FPlayerBrainFieldHelpData, TalkID_ch0800) == 0x000078, "Member 'FPlayerBrainFieldHelpData::TalkID_ch0800' has a wrong offset!");
static_assert(offsetof(FPlayerBrainFieldHelpData, TalkID_ch0900) == 0x000088, "Member 'FPlayerBrainFieldHelpData::TalkID_ch0900' has a wrong offset!");
static_assert(offsetof(FPlayerBrainFieldHelpData, TalkID_ch1000) == 0x000098, "Member 'FPlayerBrainFieldHelpData::TalkID_ch1000' has a wrong offset!");

// ScriptStruct BattlePrototype.DamageParticle
// 0x0060 (0x0068 - 0x0008)
struct FDamageParticle final : public FTableRowBase
{
public:
	class UParticleSystem*                        Normal;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Slash;                                             // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        OutRange;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Armor;                                             // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Invincible;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Weak;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Human;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        HumanOutRange;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Penetrate;                                         // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Water;                                             // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Ice;                                               // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        IceOutRange;                                       // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageParticle) == 0x000008, "Wrong alignment on FDamageParticle");
static_assert(sizeof(FDamageParticle) == 0x000068, "Wrong size on FDamageParticle");
static_assert(offsetof(FDamageParticle, Normal) == 0x000008, "Member 'FDamageParticle::Normal' has a wrong offset!");
static_assert(offsetof(FDamageParticle, Slash) == 0x000010, "Member 'FDamageParticle::Slash' has a wrong offset!");
static_assert(offsetof(FDamageParticle, OutRange) == 0x000018, "Member 'FDamageParticle::OutRange' has a wrong offset!");
static_assert(offsetof(FDamageParticle, Armor) == 0x000020, "Member 'FDamageParticle::Armor' has a wrong offset!");
static_assert(offsetof(FDamageParticle, Invincible) == 0x000028, "Member 'FDamageParticle::Invincible' has a wrong offset!");
static_assert(offsetof(FDamageParticle, Weak) == 0x000030, "Member 'FDamageParticle::Weak' has a wrong offset!");
static_assert(offsetof(FDamageParticle, Human) == 0x000038, "Member 'FDamageParticle::Human' has a wrong offset!");
static_assert(offsetof(FDamageParticle, HumanOutRange) == 0x000040, "Member 'FDamageParticle::HumanOutRange' has a wrong offset!");
static_assert(offsetof(FDamageParticle, Penetrate) == 0x000048, "Member 'FDamageParticle::Penetrate' has a wrong offset!");
static_assert(offsetof(FDamageParticle, Water) == 0x000050, "Member 'FDamageParticle::Water' has a wrong offset!");
static_assert(offsetof(FDamageParticle, Ice) == 0x000058, "Member 'FDamageParticle::Ice' has a wrong offset!");
static_assert(offsetof(FDamageParticle, IceOutRange) == 0x000060, "Member 'FDamageParticle::IceOutRange' has a wrong offset!");

// ScriptStruct BattlePrototype.HitParticleOne
// 0x0040 (0x0048 - 0x0008)
struct FHitParticleOne final : public FTableRowBase
{
public:
	class UParticleSystem*                        Particle;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitParticleRotateType                        RotateType;                                        // 0x003D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          Sound;                                             // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitParticleOne) == 0x000008, "Wrong alignment on FHitParticleOne");
static_assert(sizeof(FHitParticleOne) == 0x000048, "Wrong size on FHitParticleOne");
static_assert(offsetof(FHitParticleOne, Particle) == 0x000008, "Member 'FHitParticleOne::Particle' has a wrong offset!");
static_assert(offsetof(FHitParticleOne, AttachPointName) == 0x000010, "Member 'FHitParticleOne::AttachPointName' has a wrong offset!");
static_assert(offsetof(FHitParticleOne, Location) == 0x000018, "Member 'FHitParticleOne::Location' has a wrong offset!");
static_assert(offsetof(FHitParticleOne, Rotation) == 0x000024, "Member 'FHitParticleOne::Rotation' has a wrong offset!");
static_assert(offsetof(FHitParticleOne, Scale) == 0x000030, "Member 'FHitParticleOne::Scale' has a wrong offset!");
static_assert(offsetof(FHitParticleOne, LocationType) == 0x00003C, "Member 'FHitParticleOne::LocationType' has a wrong offset!");
static_assert(offsetof(FHitParticleOne, RotateType) == 0x00003D, "Member 'FHitParticleOne::RotateType' has a wrong offset!");
static_assert(offsetof(FHitParticleOne, Sound) == 0x000040, "Member 'FHitParticleOne::Sound' has a wrong offset!");

// ScriptStruct BattlePrototype.HitParticle
// 0x0090 (0x0098 - 0x0008)
struct FHitParticle final : public FTableRowBase
{
public:
	struct FHitParticleOne                        Normal;                                            // 0x0008(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FHitParticleOne                        Metal;                                             // 0x0050(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitParticle) == 0x000008, "Wrong alignment on FHitParticle");
static_assert(sizeof(FHitParticle) == 0x000098, "Wrong size on FHitParticle");
static_assert(offsetof(FHitParticle, Normal) == 0x000008, "Member 'FHitParticle::Normal' has a wrong offset!");
static_assert(offsetof(FHitParticle, Metal) == 0x000050, "Member 'FHitParticle::Metal' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerCameraParameter
// 0x0038 (0x0040 - 0x0008)
struct FPlayerCameraParameter final : public FTableRowBase
{
public:
	float                                         TriggerInfoLerpTime;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            TriggerInfoLerpCurve;                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KeepAngleEnable;                                   // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KeepAngleSpeedApply;                               // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KeepAngleSpeedHz;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepAngleSpeedVt;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LockOnLookAtDistAngleVtEnable;                     // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LockOnLookAtDistAngleVtCurve;                      // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LockOnLookAtDistCamDistEnable;                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LockOnLookAtDistCamDistCurve;                      // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerCameraParameter) == 0x000008, "Wrong alignment on FPlayerCameraParameter");
static_assert(sizeof(FPlayerCameraParameter) == 0x000040, "Wrong size on FPlayerCameraParameter");
static_assert(offsetof(FPlayerCameraParameter, TriggerInfoLerpTime) == 0x000008, "Member 'FPlayerCameraParameter::TriggerInfoLerpTime' has a wrong offset!");
static_assert(offsetof(FPlayerCameraParameter, TriggerInfoLerpCurve) == 0x000010, "Member 'FPlayerCameraParameter::TriggerInfoLerpCurve' has a wrong offset!");
static_assert(offsetof(FPlayerCameraParameter, KeepAngleEnable) == 0x000018, "Member 'FPlayerCameraParameter::KeepAngleEnable' has a wrong offset!");
static_assert(offsetof(FPlayerCameraParameter, KeepAngleSpeedApply) == 0x000019, "Member 'FPlayerCameraParameter::KeepAngleSpeedApply' has a wrong offset!");
static_assert(offsetof(FPlayerCameraParameter, KeepAngleSpeedHz) == 0x00001C, "Member 'FPlayerCameraParameter::KeepAngleSpeedHz' has a wrong offset!");
static_assert(offsetof(FPlayerCameraParameter, KeepAngleSpeedVt) == 0x000020, "Member 'FPlayerCameraParameter::KeepAngleSpeedVt' has a wrong offset!");
static_assert(offsetof(FPlayerCameraParameter, LockOnLookAtDistAngleVtEnable) == 0x000024, "Member 'FPlayerCameraParameter::LockOnLookAtDistAngleVtEnable' has a wrong offset!");
static_assert(offsetof(FPlayerCameraParameter, LockOnLookAtDistAngleVtCurve) == 0x000028, "Member 'FPlayerCameraParameter::LockOnLookAtDistAngleVtCurve' has a wrong offset!");
static_assert(offsetof(FPlayerCameraParameter, LockOnLookAtDistCamDistEnable) == 0x000030, "Member 'FPlayerCameraParameter::LockOnLookAtDistCamDistEnable' has a wrong offset!");
static_assert(offsetof(FPlayerCameraParameter, LockOnLookAtDistCamDistCurve) == 0x000038, "Member 'FPlayerCameraParameter::LockOnLookAtDistCamDistCurve' has a wrong offset!");

// ScriptStruct BattlePrototype.HitParticleOld
// 0x0040 (0x0048 - 0x0008)
struct FHitParticleOld final : public FTableRowBase
{
public:
	class UParticleSystem*                        Normal;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitParticleRotateType                        RotateType;                                        // 0x003D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          Sound;                                             // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitParticleOld) == 0x000008, "Wrong alignment on FHitParticleOld");
static_assert(sizeof(FHitParticleOld) == 0x000048, "Wrong size on FHitParticleOld");
static_assert(offsetof(FHitParticleOld, Normal) == 0x000008, "Member 'FHitParticleOld::Normal' has a wrong offset!");
static_assert(offsetof(FHitParticleOld, AttachPointName) == 0x000010, "Member 'FHitParticleOld::AttachPointName' has a wrong offset!");
static_assert(offsetof(FHitParticleOld, Location) == 0x000018, "Member 'FHitParticleOld::Location' has a wrong offset!");
static_assert(offsetof(FHitParticleOld, Rotation) == 0x000024, "Member 'FHitParticleOld::Rotation' has a wrong offset!");
static_assert(offsetof(FHitParticleOld, Scale) == 0x000030, "Member 'FHitParticleOld::Scale' has a wrong offset!");
static_assert(offsetof(FHitParticleOld, LocationType) == 0x00003C, "Member 'FHitParticleOld::LocationType' has a wrong offset!");
static_assert(offsetof(FHitParticleOld, RotateType) == 0x00003D, "Member 'FHitParticleOld::RotateType' has a wrong offset!");
static_assert(offsetof(FHitParticleOld, Sound) == 0x000040, "Member 'FHitParticleOld::Sound' has a wrong offset!");

// ScriptStruct BattlePrototype.AccessoryDataCache
// 0x0014 (0x0014 - 0x0000)
struct FAccessoryDataCache final
{
public:
	EEffecacyType                                 EffecacyType;                                      // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ParameterValue;                                    // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParameterDefence;                                  // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParameterESP;                                      // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParameterVitality;                                 // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccessoryDataCache) == 0x000004, "Wrong alignment on FAccessoryDataCache");
static_assert(sizeof(FAccessoryDataCache) == 0x000014, "Wrong size on FAccessoryDataCache");
static_assert(offsetof(FAccessoryDataCache, EffecacyType) == 0x000000, "Member 'FAccessoryDataCache::EffecacyType' has a wrong offset!");
static_assert(offsetof(FAccessoryDataCache, ParameterValue) == 0x000004, "Member 'FAccessoryDataCache::ParameterValue' has a wrong offset!");
static_assert(offsetof(FAccessoryDataCache, ParameterDefence) == 0x000008, "Member 'FAccessoryDataCache::ParameterDefence' has a wrong offset!");
static_assert(offsetof(FAccessoryDataCache, ParameterESP) == 0x00000C, "Member 'FAccessoryDataCache::ParameterESP' has a wrong offset!");
static_assert(offsetof(FAccessoryDataCache, ParameterVitality) == 0x000010, "Member 'FAccessoryDataCache::ParameterVitality' has a wrong offset!");

// ScriptStruct BattlePrototype.PartyPlayerCacheData
// 0x0010 (0x0010 - 0x0000)
struct FPartyPlayerCacheData final
{
public:
	TArray<struct FAccessoryDataCache>            AccessoryDataCache;                                // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPartyPlayerCacheData) == 0x000008, "Wrong alignment on FPartyPlayerCacheData");
static_assert(sizeof(FPartyPlayerCacheData) == 0x000010, "Wrong size on FPartyPlayerCacheData");
static_assert(offsetof(FPartyPlayerCacheData, AccessoryDataCache) == 0x000000, "Member 'FPartyPlayerCacheData::AccessoryDataCache' has a wrong offset!");

// ScriptStruct BattlePrototype.InfoAtRetry
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FInfoAtRetry final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInfoAtRetry) == 0x000008, "Wrong alignment on FInfoAtRetry");
static_assert(sizeof(FInfoAtRetry) == 0x000020, "Wrong size on FInfoAtRetry");

// ScriptStruct BattlePrototype.ItemDataLightStructRaw
// 0x0028 (0x0028 - 0x0000)
struct FItemDataLightStructRaw final
{
public:
	int32                                         M_type;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_transform;                                       // 0x0004(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_rotation;                                        // 0x0010(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_parameter;                                       // 0x001C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemDataLightStructRaw) == 0x000004, "Wrong alignment on FItemDataLightStructRaw");
static_assert(sizeof(FItemDataLightStructRaw) == 0x000028, "Wrong size on FItemDataLightStructRaw");
static_assert(offsetof(FItemDataLightStructRaw, M_type) == 0x000000, "Member 'FItemDataLightStructRaw::M_type' has a wrong offset!");
static_assert(offsetof(FItemDataLightStructRaw, M_transform) == 0x000004, "Member 'FItemDataLightStructRaw::M_transform' has a wrong offset!");
static_assert(offsetof(FItemDataLightStructRaw, M_rotation) == 0x000010, "Member 'FItemDataLightStructRaw::M_rotation' has a wrong offset!");
static_assert(offsetof(FItemDataLightStructRaw, M_parameter) == 0x00001C, "Member 'FItemDataLightStructRaw::M_parameter' has a wrong offset!");

// ScriptStruct BattlePrototype.ItemDataTableTypeRaw
// 0x0058 (0x0058 - 0x0000)
struct FItemDataTableTypeRaw final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_name;                                            // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_attitude;                                        // 0x0020(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_distance;                                        // 0x002C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_bgColor;                                         // 0x0038(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemDataLightStructRaw>        M_lights;                                          // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemDataTableTypeRaw) == 0x000008, "Wrong alignment on FItemDataTableTypeRaw");
static_assert(sizeof(FItemDataTableTypeRaw) == 0x000058, "Wrong size on FItemDataTableTypeRaw");
static_assert(offsetof(FItemDataTableTypeRaw, Name) == 0x000000, "Member 'FItemDataTableTypeRaw::Name' has a wrong offset!");
static_assert(offsetof(FItemDataTableTypeRaw, M_name) == 0x000010, "Member 'FItemDataTableTypeRaw::M_name' has a wrong offset!");
static_assert(offsetof(FItemDataTableTypeRaw, M_attitude) == 0x000020, "Member 'FItemDataTableTypeRaw::M_attitude' has a wrong offset!");
static_assert(offsetof(FItemDataTableTypeRaw, M_distance) == 0x00002C, "Member 'FItemDataTableTypeRaw::M_distance' has a wrong offset!");
static_assert(offsetof(FItemDataTableTypeRaw, M_bgColor) == 0x000038, "Member 'FItemDataTableTypeRaw::M_bgColor' has a wrong offset!");
static_assert(offsetof(FItemDataTableTypeRaw, M_lights) == 0x000048, "Member 'FItemDataTableTypeRaw::M_lights' has a wrong offset!");

// ScriptStruct BattlePrototype.ItemDataTableRaw
// 0x0010 (0x0010 - 0x0000)
struct FItemDataTableRaw final
{
public:
	TArray<struct FItemDataTableTypeRaw>          M_dataTable;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemDataTableRaw) == 0x000008, "Wrong alignment on FItemDataTableRaw");
static_assert(sizeof(FItemDataTableRaw) == 0x000010, "Wrong size on FItemDataTableRaw");
static_assert(offsetof(FItemDataTableRaw, M_dataTable) == 0x000000, "Member 'FItemDataTableRaw::M_dataTable' has a wrong offset!");

// ScriptStruct BattlePrototype.AssassinAttackData
// 0x0038 (0x0040 - 0x0008)
struct FAssassinAttackData final : public FTableRowBase
{
public:
	TArray<float>                                 ProbabirityList;                                   // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SasSeeThroughOffsetRate;                           // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpperLevelMin;                                     // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpperLevelMax;                                     // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperLevelOffsetMin;                               // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperLevelOffsetMax;                               // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LowerLevelMin;                                     // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LowerLevelMax;                                     // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerLevelOffsetMin;                               // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerLevelOffsetMax;                               // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAssassinAttackData) == 0x000008, "Wrong alignment on FAssassinAttackData");
static_assert(sizeof(FAssassinAttackData) == 0x000040, "Wrong size on FAssassinAttackData");
static_assert(offsetof(FAssassinAttackData, ProbabirityList) == 0x000008, "Member 'FAssassinAttackData::ProbabirityList' has a wrong offset!");
static_assert(offsetof(FAssassinAttackData, SasSeeThroughOffsetRate) == 0x000018, "Member 'FAssassinAttackData::SasSeeThroughOffsetRate' has a wrong offset!");
static_assert(offsetof(FAssassinAttackData, UpperLevelMin) == 0x00001C, "Member 'FAssassinAttackData::UpperLevelMin' has a wrong offset!");
static_assert(offsetof(FAssassinAttackData, UpperLevelMax) == 0x000020, "Member 'FAssassinAttackData::UpperLevelMax' has a wrong offset!");
static_assert(offsetof(FAssassinAttackData, UpperLevelOffsetMin) == 0x000024, "Member 'FAssassinAttackData::UpperLevelOffsetMin' has a wrong offset!");
static_assert(offsetof(FAssassinAttackData, UpperLevelOffsetMax) == 0x000028, "Member 'FAssassinAttackData::UpperLevelOffsetMax' has a wrong offset!");
static_assert(offsetof(FAssassinAttackData, LowerLevelMin) == 0x00002C, "Member 'FAssassinAttackData::LowerLevelMin' has a wrong offset!");
static_assert(offsetof(FAssassinAttackData, LowerLevelMax) == 0x000030, "Member 'FAssassinAttackData::LowerLevelMax' has a wrong offset!");
static_assert(offsetof(FAssassinAttackData, LowerLevelOffsetMin) == 0x000034, "Member 'FAssassinAttackData::LowerLevelOffsetMin' has a wrong offset!");
static_assert(offsetof(FAssassinAttackData, LowerLevelOffsetMax) == 0x000038, "Member 'FAssassinAttackData::LowerLevelOffsetMax' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerCameraAssistParameter
// 0x0108 (0x0110 - 0x0008)
struct FPlayerCameraAssistParameter final : public FTableRowBase
{
public:
	float                                         InputMoveCamRootDelayValue;                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputMoveCamRootDelayValueVt;                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputMoveCamRootDelayDistanceMax;                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            InputMoveCamRootDelayDistanceCurve;                // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputMoveCamRootDelayMoveLerpValue;                // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputMoveCamRootDelayLerpValue;                    // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputMoveRotateLerpValue;                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputMoveRotateRotateDecel;                        // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputMoveAngleVtLimitMin;                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputMoveAngleVtLimitMax;                          // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleOffsetLerpTime;                              // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CaptureLookAtObjLerpTimeStart;                     // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CaptureLookAtObjLerpTimeEnd;                       // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CaptureLookAtObjLerpAngleMax;                      // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CaptureLookAtObjLerpDelayTime;                     // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnLerpTime;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LockOnLookAtDistAngleVtEnable;                     // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LockOnLookAtDistAngleVtCurve;                      // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LockOnLookAtDistCamDistEnable;                     // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LockOnLookAtDistCamDistCurve;                      // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LockOnKeepAngleEnable;                             // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LockOnKeepAngleSpeedApply;                         // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LockOnKeepAngleSpeedVt;                            // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnKeepAngleSpeedHz;                            // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LockOnReturnEnable;                                // 0x007C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LockOnReturnLerpTime;                              // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LockOnLockRootEnable;                              // 0x0084(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LockOnLockRootLockDistance;                        // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnLockRootReleaseDistance;                     // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnLockRootReleaseLerpValue;                    // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LockOnLockEnemyEnable;                             // 0x0094(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LockOnLockEnemyUpdateApply;                        // 0x0095(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_96[0x2];                                       // 0x0096(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LockOnLockEnemyLockDistanceVt;                     // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnLockEnemyLockDistanceHz;                     // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnLockEnemyReleaseDistanceVt;                  // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnLockEnemyReleaseDistanceHz;                  // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnLockEnemyReleaseLerpValue;                   // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LockOnRotateSpeedEnable;                           // 0x00AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LockOnRotateSpeedFovRateVt;                        // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnRotateSpeedFovRateHz;                        // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnRotateSpeedDecelTime;                        // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnRotateSpeedReturnTime;                       // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SlopeAssistEnable;                                 // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlopeAssistCheckNum;                               // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistCheckInterval;                          // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistCheckIntervalAngle;                     // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistCheckAngleVtStt;                        // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistCheckAngleVtEnd;                        // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistCheckAngleHz;                           // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistLerpRate;                               // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistDelayTime;                              // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SlopeAssistSpeedLerpEnable;                        // 0x00E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlopeAssistSpeedLerpMin;                           // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistSpeedLerpMax;                           // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistSpeedLerpRateMax;                       // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SlopeAssistCheckBgEnable;                          // 0x00F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SlopeAssistCheckBgOffset;                          // 0x00F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SlopeAssistFixAngleEnable;                         // 0x0104(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlopeAssistFixAngleInterval;                       // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistFixAngleRange;                          // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerCameraAssistParameter) == 0x000008, "Wrong alignment on FPlayerCameraAssistParameter");
static_assert(sizeof(FPlayerCameraAssistParameter) == 0x000110, "Wrong size on FPlayerCameraAssistParameter");
static_assert(offsetof(FPlayerCameraAssistParameter, InputMoveCamRootDelayValue) == 0x000008, "Member 'FPlayerCameraAssistParameter::InputMoveCamRootDelayValue' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, InputMoveCamRootDelayValueVt) == 0x00000C, "Member 'FPlayerCameraAssistParameter::InputMoveCamRootDelayValueVt' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, InputMoveCamRootDelayDistanceMax) == 0x000010, "Member 'FPlayerCameraAssistParameter::InputMoveCamRootDelayDistanceMax' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, InputMoveCamRootDelayDistanceCurve) == 0x000018, "Member 'FPlayerCameraAssistParameter::InputMoveCamRootDelayDistanceCurve' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, InputMoveCamRootDelayMoveLerpValue) == 0x000020, "Member 'FPlayerCameraAssistParameter::InputMoveCamRootDelayMoveLerpValue' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, InputMoveCamRootDelayLerpValue) == 0x000024, "Member 'FPlayerCameraAssistParameter::InputMoveCamRootDelayLerpValue' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, InputMoveRotateLerpValue) == 0x000028, "Member 'FPlayerCameraAssistParameter::InputMoveRotateLerpValue' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, InputMoveRotateRotateDecel) == 0x00002C, "Member 'FPlayerCameraAssistParameter::InputMoveRotateRotateDecel' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, InputMoveAngleVtLimitMin) == 0x000030, "Member 'FPlayerCameraAssistParameter::InputMoveAngleVtLimitMin' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, InputMoveAngleVtLimitMax) == 0x000034, "Member 'FPlayerCameraAssistParameter::InputMoveAngleVtLimitMax' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, BattleOffsetLerpTime) == 0x000038, "Member 'FPlayerCameraAssistParameter::BattleOffsetLerpTime' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, CaptureLookAtObjLerpTimeStart) == 0x00003C, "Member 'FPlayerCameraAssistParameter::CaptureLookAtObjLerpTimeStart' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, CaptureLookAtObjLerpTimeEnd) == 0x000040, "Member 'FPlayerCameraAssistParameter::CaptureLookAtObjLerpTimeEnd' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, CaptureLookAtObjLerpAngleMax) == 0x000044, "Member 'FPlayerCameraAssistParameter::CaptureLookAtObjLerpAngleMax' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, CaptureLookAtObjLerpDelayTime) == 0x000048, "Member 'FPlayerCameraAssistParameter::CaptureLookAtObjLerpDelayTime' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnLerpTime) == 0x00004C, "Member 'FPlayerCameraAssistParameter::LockOnLerpTime' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnLookAtDistAngleVtEnable) == 0x000050, "Member 'FPlayerCameraAssistParameter::LockOnLookAtDistAngleVtEnable' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnLookAtDistAngleVtCurve) == 0x000058, "Member 'FPlayerCameraAssistParameter::LockOnLookAtDistAngleVtCurve' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnLookAtDistCamDistEnable) == 0x000060, "Member 'FPlayerCameraAssistParameter::LockOnLookAtDistCamDistEnable' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnLookAtDistCamDistCurve) == 0x000068, "Member 'FPlayerCameraAssistParameter::LockOnLookAtDistCamDistCurve' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnKeepAngleEnable) == 0x000070, "Member 'FPlayerCameraAssistParameter::LockOnKeepAngleEnable' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnKeepAngleSpeedApply) == 0x000071, "Member 'FPlayerCameraAssistParameter::LockOnKeepAngleSpeedApply' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnKeepAngleSpeedVt) == 0x000074, "Member 'FPlayerCameraAssistParameter::LockOnKeepAngleSpeedVt' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnKeepAngleSpeedHz) == 0x000078, "Member 'FPlayerCameraAssistParameter::LockOnKeepAngleSpeedHz' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnReturnEnable) == 0x00007C, "Member 'FPlayerCameraAssistParameter::LockOnReturnEnable' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnReturnLerpTime) == 0x000080, "Member 'FPlayerCameraAssistParameter::LockOnReturnLerpTime' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnLockRootEnable) == 0x000084, "Member 'FPlayerCameraAssistParameter::LockOnLockRootEnable' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnLockRootLockDistance) == 0x000088, "Member 'FPlayerCameraAssistParameter::LockOnLockRootLockDistance' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnLockRootReleaseDistance) == 0x00008C, "Member 'FPlayerCameraAssistParameter::LockOnLockRootReleaseDistance' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnLockRootReleaseLerpValue) == 0x000090, "Member 'FPlayerCameraAssistParameter::LockOnLockRootReleaseLerpValue' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnLockEnemyEnable) == 0x000094, "Member 'FPlayerCameraAssistParameter::LockOnLockEnemyEnable' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnLockEnemyUpdateApply) == 0x000095, "Member 'FPlayerCameraAssistParameter::LockOnLockEnemyUpdateApply' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnLockEnemyLockDistanceVt) == 0x000098, "Member 'FPlayerCameraAssistParameter::LockOnLockEnemyLockDistanceVt' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnLockEnemyLockDistanceHz) == 0x00009C, "Member 'FPlayerCameraAssistParameter::LockOnLockEnemyLockDistanceHz' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnLockEnemyReleaseDistanceVt) == 0x0000A0, "Member 'FPlayerCameraAssistParameter::LockOnLockEnemyReleaseDistanceVt' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnLockEnemyReleaseDistanceHz) == 0x0000A4, "Member 'FPlayerCameraAssistParameter::LockOnLockEnemyReleaseDistanceHz' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnLockEnemyReleaseLerpValue) == 0x0000A8, "Member 'FPlayerCameraAssistParameter::LockOnLockEnemyReleaseLerpValue' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnRotateSpeedEnable) == 0x0000AC, "Member 'FPlayerCameraAssistParameter::LockOnRotateSpeedEnable' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnRotateSpeedFovRateVt) == 0x0000B0, "Member 'FPlayerCameraAssistParameter::LockOnRotateSpeedFovRateVt' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnRotateSpeedFovRateHz) == 0x0000B4, "Member 'FPlayerCameraAssistParameter::LockOnRotateSpeedFovRateHz' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnRotateSpeedDecelTime) == 0x0000B8, "Member 'FPlayerCameraAssistParameter::LockOnRotateSpeedDecelTime' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, LockOnRotateSpeedReturnTime) == 0x0000BC, "Member 'FPlayerCameraAssistParameter::LockOnRotateSpeedReturnTime' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, SlopeAssistEnable) == 0x0000C0, "Member 'FPlayerCameraAssistParameter::SlopeAssistEnable' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, SlopeAssistCheckNum) == 0x0000C4, "Member 'FPlayerCameraAssistParameter::SlopeAssistCheckNum' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, SlopeAssistCheckInterval) == 0x0000C8, "Member 'FPlayerCameraAssistParameter::SlopeAssistCheckInterval' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, SlopeAssistCheckIntervalAngle) == 0x0000CC, "Member 'FPlayerCameraAssistParameter::SlopeAssistCheckIntervalAngle' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, SlopeAssistCheckAngleVtStt) == 0x0000D0, "Member 'FPlayerCameraAssistParameter::SlopeAssistCheckAngleVtStt' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, SlopeAssistCheckAngleVtEnd) == 0x0000D4, "Member 'FPlayerCameraAssistParameter::SlopeAssistCheckAngleVtEnd' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, SlopeAssistCheckAngleHz) == 0x0000D8, "Member 'FPlayerCameraAssistParameter::SlopeAssistCheckAngleHz' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, SlopeAssistLerpRate) == 0x0000DC, "Member 'FPlayerCameraAssistParameter::SlopeAssistLerpRate' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, SlopeAssistDelayTime) == 0x0000E0, "Member 'FPlayerCameraAssistParameter::SlopeAssistDelayTime' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, SlopeAssistSpeedLerpEnable) == 0x0000E4, "Member 'FPlayerCameraAssistParameter::SlopeAssistSpeedLerpEnable' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, SlopeAssistSpeedLerpMin) == 0x0000E8, "Member 'FPlayerCameraAssistParameter::SlopeAssistSpeedLerpMin' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, SlopeAssistSpeedLerpMax) == 0x0000EC, "Member 'FPlayerCameraAssistParameter::SlopeAssistSpeedLerpMax' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, SlopeAssistSpeedLerpRateMax) == 0x0000F0, "Member 'FPlayerCameraAssistParameter::SlopeAssistSpeedLerpRateMax' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, SlopeAssistCheckBgEnable) == 0x0000F4, "Member 'FPlayerCameraAssistParameter::SlopeAssistCheckBgEnable' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, SlopeAssistCheckBgOffset) == 0x0000F8, "Member 'FPlayerCameraAssistParameter::SlopeAssistCheckBgOffset' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, SlopeAssistFixAngleEnable) == 0x000104, "Member 'FPlayerCameraAssistParameter::SlopeAssistFixAngleEnable' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, SlopeAssistFixAngleInterval) == 0x000108, "Member 'FPlayerCameraAssistParameter::SlopeAssistFixAngleInterval' has a wrong offset!");
static_assert(offsetof(FPlayerCameraAssistParameter, SlopeAssistFixAngleRange) == 0x00010C, "Member 'FPlayerCameraAssistParameter::SlopeAssistFixAngleRange' has a wrong offset!");

// ScriptStruct BattlePrototype.ItemIDArray
// 0x0010 (0x0010 - 0x0000)
struct FItemIDArray final
{
public:
	TArray<class FName>                           IdArray;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemIDArray) == 0x000008, "Wrong alignment on FItemIDArray");
static_assert(sizeof(FItemIDArray) == 0x000010, "Wrong size on FItemIDArray");
static_assert(offsetof(FItemIDArray, IdArray) == 0x000000, "Member 'FItemIDArray::IdArray' has a wrong offset!");

// ScriptStruct BattlePrototype.ItemDataCell
// 0x0070 (0x0078 - 0x0008)
struct FItemDataCell final : public FTableRowBase
{
public:
	class FName                                   NameId;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DescriptionId;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemIcon                                     Icon;                                              // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 Category;                                          // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x001A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x1];                                       // 0x001B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CarryMax;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuyPrice;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SellPrice;                                         // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsConsumption;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEffecacyRange                                EffecacyRange;                                     // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEffecacyType                                 EffecacyId;                                        // 0x002A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x1];                                       // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ParameterValue;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParameterAttack;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParameterESP;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParameterVitality;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParameterDefense;                                  // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEquipmentable_ch0100;                            // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEquipmentable_ch0200;                            // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEquipmentable_ch0300;                            // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEquipmentable_ch0400;                            // 0x0043(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEquipmentable_ch0500;                            // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEquipmentable_ch0600;                            // 0x0045(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEquipmentable_ch0700;                            // 0x0046(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEquipmentable_ch0800;                            // 0x0047(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEquipmentable_ch0900;                            // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEquipmentable_ch1000;                            // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemFavorability                             Favorability_ch0100;                               // 0x004A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemFavorability                             Favorability_ch0200;                               // 0x004B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemFavorability                             Favorability_ch0300;                               // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemFavorability                             Favorability_ch0400;                               // 0x004D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemFavorability                             Favorability_ch0500;                               // 0x004E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemFavorability                             Favorability_ch0600;                               // 0x004F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemFavorability                             Favorability_ch0700;                               // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemFavorability                             Favorability_ch0800;                               // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemFavorability                             Favorability_ch0900;                               // 0x0052(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemFavorability                             Favorability_ch1000;                               // 0x0053(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IsItPossibleToPresent;                             // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemPresentSender                            PresentSender;                                     // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PresentSortNo;                                     // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanitPresentManyTimes;                             // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EnemyLibraryID;                                    // 0x0064(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIMain3DEquipCameraID                        EquipCameraID;                                     // 0x006C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SortListM;                                         // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortListF;                                         // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemDataCell) == 0x000008, "Wrong alignment on FItemDataCell");
static_assert(sizeof(FItemDataCell) == 0x000078, "Wrong size on FItemDataCell");
static_assert(offsetof(FItemDataCell, NameId) == 0x000008, "Member 'FItemDataCell::NameId' has a wrong offset!");
static_assert(offsetof(FItemDataCell, DescriptionId) == 0x000010, "Member 'FItemDataCell::DescriptionId' has a wrong offset!");
static_assert(offsetof(FItemDataCell, Icon) == 0x000018, "Member 'FItemDataCell::Icon' has a wrong offset!");
static_assert(offsetof(FItemDataCell, Category) == 0x000019, "Member 'FItemDataCell::Category' has a wrong offset!");
static_assert(offsetof(FItemDataCell, Rarity) == 0x00001A, "Member 'FItemDataCell::Rarity' has a wrong offset!");
static_assert(offsetof(FItemDataCell, CarryMax) == 0x00001C, "Member 'FItemDataCell::CarryMax' has a wrong offset!");
static_assert(offsetof(FItemDataCell, BuyPrice) == 0x000020, "Member 'FItemDataCell::BuyPrice' has a wrong offset!");
static_assert(offsetof(FItemDataCell, SellPrice) == 0x000024, "Member 'FItemDataCell::SellPrice' has a wrong offset!");
static_assert(offsetof(FItemDataCell, IsConsumption) == 0x000028, "Member 'FItemDataCell::IsConsumption' has a wrong offset!");
static_assert(offsetof(FItemDataCell, EffecacyRange) == 0x000029, "Member 'FItemDataCell::EffecacyRange' has a wrong offset!");
static_assert(offsetof(FItemDataCell, EffecacyId) == 0x00002A, "Member 'FItemDataCell::EffecacyId' has a wrong offset!");
static_assert(offsetof(FItemDataCell, ParameterValue) == 0x00002C, "Member 'FItemDataCell::ParameterValue' has a wrong offset!");
static_assert(offsetof(FItemDataCell, ParameterAttack) == 0x000030, "Member 'FItemDataCell::ParameterAttack' has a wrong offset!");
static_assert(offsetof(FItemDataCell, ParameterESP) == 0x000034, "Member 'FItemDataCell::ParameterESP' has a wrong offset!");
static_assert(offsetof(FItemDataCell, ParameterVitality) == 0x000038, "Member 'FItemDataCell::ParameterVitality' has a wrong offset!");
static_assert(offsetof(FItemDataCell, ParameterDefense) == 0x00003C, "Member 'FItemDataCell::ParameterDefense' has a wrong offset!");
static_assert(offsetof(FItemDataCell, IsEquipmentable_ch0100) == 0x000040, "Member 'FItemDataCell::IsEquipmentable_ch0100' has a wrong offset!");
static_assert(offsetof(FItemDataCell, IsEquipmentable_ch0200) == 0x000041, "Member 'FItemDataCell::IsEquipmentable_ch0200' has a wrong offset!");
static_assert(offsetof(FItemDataCell, IsEquipmentable_ch0300) == 0x000042, "Member 'FItemDataCell::IsEquipmentable_ch0300' has a wrong offset!");
static_assert(offsetof(FItemDataCell, IsEquipmentable_ch0400) == 0x000043, "Member 'FItemDataCell::IsEquipmentable_ch0400' has a wrong offset!");
static_assert(offsetof(FItemDataCell, IsEquipmentable_ch0500) == 0x000044, "Member 'FItemDataCell::IsEquipmentable_ch0500' has a wrong offset!");
static_assert(offsetof(FItemDataCell, IsEquipmentable_ch0600) == 0x000045, "Member 'FItemDataCell::IsEquipmentable_ch0600' has a wrong offset!");
static_assert(offsetof(FItemDataCell, IsEquipmentable_ch0700) == 0x000046, "Member 'FItemDataCell::IsEquipmentable_ch0700' has a wrong offset!");
static_assert(offsetof(FItemDataCell, IsEquipmentable_ch0800) == 0x000047, "Member 'FItemDataCell::IsEquipmentable_ch0800' has a wrong offset!");
static_assert(offsetof(FItemDataCell, IsEquipmentable_ch0900) == 0x000048, "Member 'FItemDataCell::IsEquipmentable_ch0900' has a wrong offset!");
static_assert(offsetof(FItemDataCell, IsEquipmentable_ch1000) == 0x000049, "Member 'FItemDataCell::IsEquipmentable_ch1000' has a wrong offset!");
static_assert(offsetof(FItemDataCell, Favorability_ch0100) == 0x00004A, "Member 'FItemDataCell::Favorability_ch0100' has a wrong offset!");
static_assert(offsetof(FItemDataCell, Favorability_ch0200) == 0x00004B, "Member 'FItemDataCell::Favorability_ch0200' has a wrong offset!");
static_assert(offsetof(FItemDataCell, Favorability_ch0300) == 0x00004C, "Member 'FItemDataCell::Favorability_ch0300' has a wrong offset!");
static_assert(offsetof(FItemDataCell, Favorability_ch0400) == 0x00004D, "Member 'FItemDataCell::Favorability_ch0400' has a wrong offset!");
static_assert(offsetof(FItemDataCell, Favorability_ch0500) == 0x00004E, "Member 'FItemDataCell::Favorability_ch0500' has a wrong offset!");
static_assert(offsetof(FItemDataCell, Favorability_ch0600) == 0x00004F, "Member 'FItemDataCell::Favorability_ch0600' has a wrong offset!");
static_assert(offsetof(FItemDataCell, Favorability_ch0700) == 0x000050, "Member 'FItemDataCell::Favorability_ch0700' has a wrong offset!");
static_assert(offsetof(FItemDataCell, Favorability_ch0800) == 0x000051, "Member 'FItemDataCell::Favorability_ch0800' has a wrong offset!");
static_assert(offsetof(FItemDataCell, Favorability_ch0900) == 0x000052, "Member 'FItemDataCell::Favorability_ch0900' has a wrong offset!");
static_assert(offsetof(FItemDataCell, Favorability_ch1000) == 0x000053, "Member 'FItemDataCell::Favorability_ch1000' has a wrong offset!");
static_assert(offsetof(FItemDataCell, IsItPossibleToPresent) == 0x000054, "Member 'FItemDataCell::IsItPossibleToPresent' has a wrong offset!");
static_assert(offsetof(FItemDataCell, PresentSender) == 0x000058, "Member 'FItemDataCell::PresentSender' has a wrong offset!");
static_assert(offsetof(FItemDataCell, PresentSortNo) == 0x00005C, "Member 'FItemDataCell::PresentSortNo' has a wrong offset!");
static_assert(offsetof(FItemDataCell, CanitPresentManyTimes) == 0x000060, "Member 'FItemDataCell::CanitPresentManyTimes' has a wrong offset!");
static_assert(offsetof(FItemDataCell, EnemyLibraryID) == 0x000064, "Member 'FItemDataCell::EnemyLibraryID' has a wrong offset!");
static_assert(offsetof(FItemDataCell, EquipCameraID) == 0x00006C, "Member 'FItemDataCell::EquipCameraID' has a wrong offset!");
static_assert(offsetof(FItemDataCell, SortListM) == 0x000070, "Member 'FItemDataCell::SortListM' has a wrong offset!");
static_assert(offsetof(FItemDataCell, SortListF) == 0x000074, "Member 'FItemDataCell::SortListF' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerDriveParameter
// 0x0038 (0x0040 - 0x0008)
struct FPlayerDriveParameter final : public FTableRowBase
{
public:
	float                                         BaseMaxTime;                                       // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParameterMaxTime;                                  // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NotBattleTimeRate;                                 // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeedRate;                                     // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackSpeedRateMin;                                // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackSpeedRateMax;                                // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponAttackRateMin;                               // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponAttackRateMax;                               // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CaptureTimeRateMin;                                // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CaptureTimeRateMax;                                // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PsychicCostRateMin;                                // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PsychicCostRateMax;                                // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrashRateMin;                                      // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrashRateMax;                                      // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDriveParameter) == 0x000008, "Wrong alignment on FPlayerDriveParameter");
static_assert(sizeof(FPlayerDriveParameter) == 0x000040, "Wrong size on FPlayerDriveParameter");
static_assert(offsetof(FPlayerDriveParameter, BaseMaxTime) == 0x000008, "Member 'FPlayerDriveParameter::BaseMaxTime' has a wrong offset!");
static_assert(offsetof(FPlayerDriveParameter, ParameterMaxTime) == 0x00000C, "Member 'FPlayerDriveParameter::ParameterMaxTime' has a wrong offset!");
static_assert(offsetof(FPlayerDriveParameter, NotBattleTimeRate) == 0x000010, "Member 'FPlayerDriveParameter::NotBattleTimeRate' has a wrong offset!");
static_assert(offsetof(FPlayerDriveParameter, MoveSpeedRate) == 0x000014, "Member 'FPlayerDriveParameter::MoveSpeedRate' has a wrong offset!");
static_assert(offsetof(FPlayerDriveParameter, AttackSpeedRateMin) == 0x000018, "Member 'FPlayerDriveParameter::AttackSpeedRateMin' has a wrong offset!");
static_assert(offsetof(FPlayerDriveParameter, AttackSpeedRateMax) == 0x00001C, "Member 'FPlayerDriveParameter::AttackSpeedRateMax' has a wrong offset!");
static_assert(offsetof(FPlayerDriveParameter, WeaponAttackRateMin) == 0x000020, "Member 'FPlayerDriveParameter::WeaponAttackRateMin' has a wrong offset!");
static_assert(offsetof(FPlayerDriveParameter, WeaponAttackRateMax) == 0x000024, "Member 'FPlayerDriveParameter::WeaponAttackRateMax' has a wrong offset!");
static_assert(offsetof(FPlayerDriveParameter, CaptureTimeRateMin) == 0x000028, "Member 'FPlayerDriveParameter::CaptureTimeRateMin' has a wrong offset!");
static_assert(offsetof(FPlayerDriveParameter, CaptureTimeRateMax) == 0x00002C, "Member 'FPlayerDriveParameter::CaptureTimeRateMax' has a wrong offset!");
static_assert(offsetof(FPlayerDriveParameter, PsychicCostRateMin) == 0x000030, "Member 'FPlayerDriveParameter::PsychicCostRateMin' has a wrong offset!");
static_assert(offsetof(FPlayerDriveParameter, PsychicCostRateMax) == 0x000034, "Member 'FPlayerDriveParameter::PsychicCostRateMax' has a wrong offset!");
static_assert(offsetof(FPlayerDriveParameter, CrashRateMin) == 0x000038, "Member 'FPlayerDriveParameter::CrashRateMin' has a wrong offset!");
static_assert(offsetof(FPlayerDriveParameter, CrashRateMax) == 0x00003C, "Member 'FPlayerDriveParameter::CrashRateMax' has a wrong offset!");

// ScriptStruct BattlePrototype.ItemFavorabilityParamDataCell
// 0x0008 (0x0010 - 0x0008)
struct FItemFavorabilityParamDataCell final : public FTableRowBase
{
public:
	float                                         ExpUp[0x2];                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemFavorabilityParamDataCell) == 0x000008, "Wrong alignment on FItemFavorabilityParamDataCell");
static_assert(sizeof(FItemFavorabilityParamDataCell) == 0x000010, "Wrong size on FItemFavorabilityParamDataCell");
static_assert(offsetof(FItemFavorabilityParamDataCell, ExpUp) == 0x000008, "Member 'FItemFavorabilityParamDataCell::ExpUp' has a wrong offset!");

// ScriptStruct BattlePrototype.RandomArrangeItemInfoCell
// 0x0028 (0x0030 - 0x0008)
struct FRandomArrangeItemInfoCell final : public FTableRowBase
{
public:
	class FString                                 RandomArrangeItemID;                               // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArrangeNum;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOverrideArrangeItemId;                           // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ArrangeItemId;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomArrangeItemInfoCell) == 0x000008, "Wrong alignment on FRandomArrangeItemInfoCell");
static_assert(sizeof(FRandomArrangeItemInfoCell) == 0x000030, "Wrong size on FRandomArrangeItemInfoCell");
static_assert(offsetof(FRandomArrangeItemInfoCell, RandomArrangeItemID) == 0x000008, "Member 'FRandomArrangeItemInfoCell::RandomArrangeItemID' has a wrong offset!");
static_assert(offsetof(FRandomArrangeItemInfoCell, ArrangeNum) == 0x000018, "Member 'FRandomArrangeItemInfoCell::ArrangeNum' has a wrong offset!");
static_assert(offsetof(FRandomArrangeItemInfoCell, IsOverrideArrangeItemId) == 0x00001C, "Member 'FRandomArrangeItemInfoCell::IsOverrideArrangeItemId' has a wrong offset!");
static_assert(offsetof(FRandomArrangeItemInfoCell, ArrangeItemId) == 0x000020, "Member 'FRandomArrangeItemInfoCell::ArrangeItemId' has a wrong offset!");

// ScriptStruct BattlePrototype.ArrangeItemDataCell
// 0x0020 (0x0028 - 0x0008)
struct FArrangeItemDataCell final : public FTableRowBase
{
public:
	float                                         IntervalTime;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FArrangeItemPopItemDataCell>    PopItemList;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDispGetLog;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArrangeItemDataCell) == 0x000008, "Wrong alignment on FArrangeItemDataCell");
static_assert(sizeof(FArrangeItemDataCell) == 0x000028, "Wrong size on FArrangeItemDataCell");
static_assert(offsetof(FArrangeItemDataCell, IntervalTime) == 0x000008, "Member 'FArrangeItemDataCell::IntervalTime' has a wrong offset!");
static_assert(offsetof(FArrangeItemDataCell, PopItemList) == 0x000010, "Member 'FArrangeItemDataCell::PopItemList' has a wrong offset!");
static_assert(offsetof(FArrangeItemDataCell, IsDispGetLog) == 0x000020, "Member 'FArrangeItemDataCell::IsDispGetLog' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerMaterialManageScalar
// 0x0010 (0x0010 - 0x0000)
struct FPlayerMaterialManageScalar final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayer;                                           // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeapon;                                           // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCable;                                            // 0x000E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCopy;                                             // 0x000F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerMaterialManageScalar) == 0x000004, "Wrong alignment on FPlayerMaterialManageScalar");
static_assert(sizeof(FPlayerMaterialManageScalar) == 0x000010, "Wrong size on FPlayerMaterialManageScalar");
static_assert(offsetof(FPlayerMaterialManageScalar, ParamName) == 0x000000, "Member 'FPlayerMaterialManageScalar::ParamName' has a wrong offset!");
static_assert(offsetof(FPlayerMaterialManageScalar, Value) == 0x000008, "Member 'FPlayerMaterialManageScalar::Value' has a wrong offset!");
static_assert(offsetof(FPlayerMaterialManageScalar, bPlayer) == 0x00000C, "Member 'FPlayerMaterialManageScalar::bPlayer' has a wrong offset!");
static_assert(offsetof(FPlayerMaterialManageScalar, bWeapon) == 0x00000D, "Member 'FPlayerMaterialManageScalar::bWeapon' has a wrong offset!");
static_assert(offsetof(FPlayerMaterialManageScalar, bCable) == 0x00000E, "Member 'FPlayerMaterialManageScalar::bCable' has a wrong offset!");
static_assert(offsetof(FPlayerMaterialManageScalar, bCopy) == 0x00000F, "Member 'FPlayerMaterialManageScalar::bCopy' has a wrong offset!");

// ScriptStruct BattlePrototype.AreaJumpInfo
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FAreaJumpInfo final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAreaJumpInfo) == 0x000004, "Wrong alignment on FAreaJumpInfo");
static_assert(sizeof(FAreaJumpInfo) == 0x00001C, "Wrong size on FAreaJumpInfo");

// ScriptStruct BattlePrototype.BossFloorInfo
// 0x0010 (0x0018 - 0x0008)
struct FBossFloorInfo final : public FTableRowBase
{
public:
	class AMapGimmickObject*                      FloorActor;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFall;                                            // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBossFloorInfo) == 0x000008, "Wrong alignment on FBossFloorInfo");
static_assert(sizeof(FBossFloorInfo) == 0x000018, "Wrong size on FBossFloorInfo");
static_assert(offsetof(FBossFloorInfo, FloorActor) == 0x000008, "Member 'FBossFloorInfo::FloorActor' has a wrong offset!");
static_assert(offsetof(FBossFloorInfo, Offset) == 0x000010, "Member 'FBossFloorInfo::Offset' has a wrong offset!");
static_assert(offsetof(FBossFloorInfo, IsFall) == 0x000014, "Member 'FBossFloorInfo::IsFall' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerDriveGaugeParameter
// 0x0048 (0x0050 - 0x0008)
struct FPlayerDriveGaugeParameter final : public FTableRowBase
{
public:
	float                                         GaugeMax;                                          // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncreaseSAS;                                       // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncreaseJustDodge;                                 // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncreasePsychicComboHit;                           // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncreaseDefeated;                                  // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncreaseBrainCrash;                                // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncreaseDefeatedNpc;                               // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncreaseTakeDamage;                                // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncreaseWeaponHitCh0100;                           // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncreaseWeaponHitCh0200;                           // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncreasePsychicAttack;                             // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncreasePsychicUnique;                             // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncreaseHologramAttack;                            // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 IncreaseCombinationVision;                         // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDriveGaugeParameter) == 0x000008, "Wrong alignment on FPlayerDriveGaugeParameter");
static_assert(sizeof(FPlayerDriveGaugeParameter) == 0x000050, "Wrong size on FPlayerDriveGaugeParameter");
static_assert(offsetof(FPlayerDriveGaugeParameter, GaugeMax) == 0x000008, "Member 'FPlayerDriveGaugeParameter::GaugeMax' has a wrong offset!");
static_assert(offsetof(FPlayerDriveGaugeParameter, IncreaseSAS) == 0x00000C, "Member 'FPlayerDriveGaugeParameter::IncreaseSAS' has a wrong offset!");
static_assert(offsetof(FPlayerDriveGaugeParameter, IncreaseJustDodge) == 0x000010, "Member 'FPlayerDriveGaugeParameter::IncreaseJustDodge' has a wrong offset!");
static_assert(offsetof(FPlayerDriveGaugeParameter, IncreasePsychicComboHit) == 0x000014, "Member 'FPlayerDriveGaugeParameter::IncreasePsychicComboHit' has a wrong offset!");
static_assert(offsetof(FPlayerDriveGaugeParameter, IncreaseDefeated) == 0x000018, "Member 'FPlayerDriveGaugeParameter::IncreaseDefeated' has a wrong offset!");
static_assert(offsetof(FPlayerDriveGaugeParameter, IncreaseBrainCrash) == 0x00001C, "Member 'FPlayerDriveGaugeParameter::IncreaseBrainCrash' has a wrong offset!");
static_assert(offsetof(FPlayerDriveGaugeParameter, IncreaseDefeatedNpc) == 0x000020, "Member 'FPlayerDriveGaugeParameter::IncreaseDefeatedNpc' has a wrong offset!");
static_assert(offsetof(FPlayerDriveGaugeParameter, IncreaseTakeDamage) == 0x000024, "Member 'FPlayerDriveGaugeParameter::IncreaseTakeDamage' has a wrong offset!");
static_assert(offsetof(FPlayerDriveGaugeParameter, IncreaseWeaponHitCh0100) == 0x000028, "Member 'FPlayerDriveGaugeParameter::IncreaseWeaponHitCh0100' has a wrong offset!");
static_assert(offsetof(FPlayerDriveGaugeParameter, IncreaseWeaponHitCh0200) == 0x00002C, "Member 'FPlayerDriveGaugeParameter::IncreaseWeaponHitCh0200' has a wrong offset!");
static_assert(offsetof(FPlayerDriveGaugeParameter, IncreasePsychicAttack) == 0x000030, "Member 'FPlayerDriveGaugeParameter::IncreasePsychicAttack' has a wrong offset!");
static_assert(offsetof(FPlayerDriveGaugeParameter, IncreasePsychicUnique) == 0x000034, "Member 'FPlayerDriveGaugeParameter::IncreasePsychicUnique' has a wrong offset!");
static_assert(offsetof(FPlayerDriveGaugeParameter, IncreaseHologramAttack) == 0x000038, "Member 'FPlayerDriveGaugeParameter::IncreaseHologramAttack' has a wrong offset!");
static_assert(offsetof(FPlayerDriveGaugeParameter, IncreaseCombinationVision) == 0x000040, "Member 'FPlayerDriveGaugeParameter::IncreaseCombinationVision' has a wrong offset!");

// ScriptStruct BattlePrototype.SelectVariationInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x04) FSelectVariationInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSelectVariationInfo) == 0x000004, "Wrong alignment on FSelectVariationInfo");
static_assert(sizeof(FSelectVariationInfo) == 0x000020, "Wrong size on FSelectVariationInfo");

// ScriptStruct BattlePrototype.TeamBondsLevelupDataCell
// 0x0018 (0x0020 - 0x0008)
struct FTeamBondsLevelupDataCell final : public FTableRowBase
{
public:
	int32                                         Level;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Progress;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTeamBondsLevelupCharData>      Params;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamBondsLevelupDataCell) == 0x000008, "Wrong alignment on FTeamBondsLevelupDataCell");
static_assert(sizeof(FTeamBondsLevelupDataCell) == 0x000020, "Wrong size on FTeamBondsLevelupDataCell");
static_assert(offsetof(FTeamBondsLevelupDataCell, Level) == 0x000008, "Member 'FTeamBondsLevelupDataCell::Level' has a wrong offset!");
static_assert(offsetof(FTeamBondsLevelupDataCell, Progress) == 0x00000C, "Member 'FTeamBondsLevelupDataCell::Progress' has a wrong offset!");
static_assert(offsetof(FTeamBondsLevelupDataCell, Params) == 0x000010, "Member 'FTeamBondsLevelupDataCell::Params' has a wrong offset!");

// ScriptStruct BattlePrototype.BondsLevelupExpDataCell
// 0x0010 (0x0018 - 0x0008)
struct FBondsLevelupExpDataCell final : public FTableRowBase
{
public:
	TArray<int32>                                 ExpList;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBondsLevelupExpDataCell) == 0x000008, "Wrong alignment on FBondsLevelupExpDataCell");
static_assert(sizeof(FBondsLevelupExpDataCell) == 0x000018, "Wrong size on FBondsLevelupExpDataCell");
static_assert(offsetof(FBondsLevelupExpDataCell, ExpList) == 0x000008, "Member 'FBondsLevelupExpDataCell::ExpList' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryCharaOpenDataCell
// 0x0008 (0x0010 - 0x0008)
struct FLibraryCharaOpenDataCell final : public FTableRowBase
{
public:
	int32                                         ProgressNo;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLibraryCharaOpenDataCell) == 0x000008, "Wrong alignment on FLibraryCharaOpenDataCell");
static_assert(sizeof(FLibraryCharaOpenDataCell) == 0x000010, "Wrong size on FLibraryCharaOpenDataCell");
static_assert(offsetof(FLibraryCharaOpenDataCell, ProgressNo) == 0x000008, "Member 'FLibraryCharaOpenDataCell::ProgressNo' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryCharaDay1DataCell
// 0x0030 (0x0030 - 0x0000)
struct FLibraryCharaDay1DataCell final
{
public:
	class FName                                   FavoriteCollect;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NotgoodCollect;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Hobby;                                             // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpecialSkill;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DetailsMini;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DetailsPage4;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryCharaDay1DataCell) == 0x000004, "Wrong alignment on FLibraryCharaDay1DataCell");
static_assert(sizeof(FLibraryCharaDay1DataCell) == 0x000030, "Wrong size on FLibraryCharaDay1DataCell");
static_assert(offsetof(FLibraryCharaDay1DataCell, FavoriteCollect) == 0x000000, "Member 'FLibraryCharaDay1DataCell::FavoriteCollect' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDay1DataCell, NotgoodCollect) == 0x000008, "Member 'FLibraryCharaDay1DataCell::NotgoodCollect' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDay1DataCell, Hobby) == 0x000010, "Member 'FLibraryCharaDay1DataCell::Hobby' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDay1DataCell, SpecialSkill) == 0x000018, "Member 'FLibraryCharaDay1DataCell::SpecialSkill' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDay1DataCell, DetailsMini) == 0x000020, "Member 'FLibraryCharaDay1DataCell::DetailsMini' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDay1DataCell, DetailsPage4) == 0x000028, "Member 'FLibraryCharaDay1DataCell::DetailsPage4' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryIntegerParam
// 0x0008 (0x0008 - 0x0000)
struct FLibraryIntegerParam final
{
public:
	ELibraryFlagType                              ChkFlag;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IntParem;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryIntegerParam) == 0x000004, "Wrong alignment on FLibraryIntegerParam");
static_assert(sizeof(FLibraryIntegerParam) == 0x000008, "Wrong size on FLibraryIntegerParam");
static_assert(offsetof(FLibraryIntegerParam, ChkFlag) == 0x000000, "Member 'FLibraryIntegerParam::ChkFlag' has a wrong offset!");
static_assert(offsetof(FLibraryIntegerParam, IntParem) == 0x000004, "Member 'FLibraryIntegerParam::IntParem' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryEnemyDBCell
// 0x0050 (0x0050 - 0x0000)
struct FLibraryEnemyDBCell final
{
public:
	class FName                                   EnemyID;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryMessageParam>           DetailMsg;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLibraryIntegerParam                   ImageNum;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           DropItems;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryHabitatParam>           Habitat_m;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryHabitatParam>           Habitat_f;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryEnemyDBCell) == 0x000008, "Wrong alignment on FLibraryEnemyDBCell");
static_assert(sizeof(FLibraryEnemyDBCell) == 0x000050, "Wrong size on FLibraryEnemyDBCell");
static_assert(offsetof(FLibraryEnemyDBCell, EnemyID) == 0x000000, "Member 'FLibraryEnemyDBCell::EnemyID' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyDBCell, DetailMsg) == 0x000008, "Member 'FLibraryEnemyDBCell::DetailMsg' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyDBCell, ImageNum) == 0x000018, "Member 'FLibraryEnemyDBCell::ImageNum' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyDBCell, DropItems) == 0x000020, "Member 'FLibraryEnemyDBCell::DropItems' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyDBCell, Habitat_m) == 0x000030, "Member 'FLibraryEnemyDBCell::Habitat_m' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyDBCell, Habitat_f) == 0x000040, "Member 'FLibraryEnemyDBCell::Habitat_f' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryBoolParam
// 0x0002 (0x0002 - 0x0000)
struct FLibraryBoolParam final
{
public:
	ELibraryFlagType                              ChkFlag;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoolParam;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryBoolParam) == 0x000001, "Wrong alignment on FLibraryBoolParam");
static_assert(sizeof(FLibraryBoolParam) == 0x000002, "Wrong size on FLibraryBoolParam");
static_assert(offsetof(FLibraryBoolParam, ChkFlag) == 0x000000, "Member 'FLibraryBoolParam::ChkFlag' has a wrong offset!");
static_assert(offsetof(FLibraryBoolParam, BoolParam) == 0x000001, "Member 'FLibraryBoolParam::BoolParam' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryCharaDBCell
// 0x0148 (0x0148 - 0x0000)
struct FLibraryCharaDBCell final
{
public:
	EPlayerID                                     PlayerId;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SortID;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryMessageParam>           Gender;                                            // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryMessageParam>           Birthday;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryMessageParam>           Height;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryMessageParam>           Psychic;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryMessageParam>           Weapon;                                            // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryMessageParam>           MilitaryID;                                        // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryMessageParam>           MilitaryYear;                                      // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryMessageParam>           FavoriteFood;                                      // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryMessageParam>           Character;                                         // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryBoolParam>              Hood;                                              // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryMessageParam>           Details;                                           // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           VoiceCast;                                         // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryVoiceParam>             Voices;                                            // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryMessageParam>           FavoriteCollect;                                   // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryMessageParam>           NotgoodCollect;                                    // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryMessageParam>           Hobby;                                             // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryMessageParam>           SpecialSkill;                                      // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryMessageParam>           DetailsMini;                                       // 0x0128(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLibraryMessageParam>           DetailsPage4;                                      // 0x0138(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryCharaDBCell) == 0x000008, "Wrong alignment on FLibraryCharaDBCell");
static_assert(sizeof(FLibraryCharaDBCell) == 0x000148, "Wrong size on FLibraryCharaDBCell");
static_assert(offsetof(FLibraryCharaDBCell, PlayerId) == 0x000000, "Member 'FLibraryCharaDBCell::PlayerId' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, SortID) == 0x000008, "Member 'FLibraryCharaDBCell::SortID' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, Gender) == 0x000018, "Member 'FLibraryCharaDBCell::Gender' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, Birthday) == 0x000028, "Member 'FLibraryCharaDBCell::Birthday' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, Height) == 0x000038, "Member 'FLibraryCharaDBCell::Height' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, Psychic) == 0x000048, "Member 'FLibraryCharaDBCell::Psychic' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, Weapon) == 0x000058, "Member 'FLibraryCharaDBCell::Weapon' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, MilitaryID) == 0x000068, "Member 'FLibraryCharaDBCell::MilitaryID' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, MilitaryYear) == 0x000078, "Member 'FLibraryCharaDBCell::MilitaryYear' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, FavoriteFood) == 0x000088, "Member 'FLibraryCharaDBCell::FavoriteFood' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, Character) == 0x000098, "Member 'FLibraryCharaDBCell::Character' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, Hood) == 0x0000A8, "Member 'FLibraryCharaDBCell::Hood' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, Details) == 0x0000B8, "Member 'FLibraryCharaDBCell::Details' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, VoiceCast) == 0x0000C8, "Member 'FLibraryCharaDBCell::VoiceCast' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, Voices) == 0x0000D8, "Member 'FLibraryCharaDBCell::Voices' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, FavoriteCollect) == 0x0000E8, "Member 'FLibraryCharaDBCell::FavoriteCollect' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, NotgoodCollect) == 0x0000F8, "Member 'FLibraryCharaDBCell::NotgoodCollect' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, Hobby) == 0x000108, "Member 'FLibraryCharaDBCell::Hobby' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, SpecialSkill) == 0x000118, "Member 'FLibraryCharaDBCell::SpecialSkill' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, DetailsMini) == 0x000128, "Member 'FLibraryCharaDBCell::DetailsMini' has a wrong offset!");
static_assert(offsetof(FLibraryCharaDBCell, DetailsPage4) == 0x000138, "Member 'FLibraryCharaDBCell::DetailsPage4' has a wrong offset!");

// ScriptStruct BattlePrototype.LibraryEnemyDataCell_Deprecated
// 0x0038 (0x0040 - 0x0008)
struct FLibraryEnemyDataCell_Deprecated final : public FTableRowBase
{
public:
	class FName                                   EnemyID;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DetailMsg;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ImageNum;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DropItems;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Habitat;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLibraryEnemyDataCell_Deprecated) == 0x000008, "Wrong alignment on FLibraryEnemyDataCell_Deprecated");
static_assert(sizeof(FLibraryEnemyDataCell_Deprecated) == 0x000040, "Wrong size on FLibraryEnemyDataCell_Deprecated");
static_assert(offsetof(FLibraryEnemyDataCell_Deprecated, EnemyID) == 0x000008, "Member 'FLibraryEnemyDataCell_Deprecated::EnemyID' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyDataCell_Deprecated, DetailMsg) == 0x000010, "Member 'FLibraryEnemyDataCell_Deprecated::DetailMsg' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyDataCell_Deprecated, ImageNum) == 0x000018, "Member 'FLibraryEnemyDataCell_Deprecated::ImageNum' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyDataCell_Deprecated, DropItems) == 0x000020, "Member 'FLibraryEnemyDataCell_Deprecated::DropItems' has a wrong offset!");
static_assert(offsetof(FLibraryEnemyDataCell_Deprecated, Habitat) == 0x000030, "Member 'FLibraryEnemyDataCell_Deprecated::Habitat' has a wrong offset!");

// ScriptStruct BattlePrototype.RetryLoadingTipsDataCell
// 0x0018 (0x0020 - 0x0008)
struct FRetryLoadingTipsDataCell final : public FTableRowBase
{
public:
	int32                                         TipsMsgID;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELoadingTipsCategory                          Category;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     PlayerId;                                          // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRetryLoadingTipsParam                 Param;                                             // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRetryLoadingTipsDataCell) == 0x000008, "Wrong alignment on FRetryLoadingTipsDataCell");
static_assert(sizeof(FRetryLoadingTipsDataCell) == 0x000020, "Wrong size on FRetryLoadingTipsDataCell");
static_assert(offsetof(FRetryLoadingTipsDataCell, TipsMsgID) == 0x000008, "Member 'FRetryLoadingTipsDataCell::TipsMsgID' has a wrong offset!");
static_assert(offsetof(FRetryLoadingTipsDataCell, Weight) == 0x00000C, "Member 'FRetryLoadingTipsDataCell::Weight' has a wrong offset!");
static_assert(offsetof(FRetryLoadingTipsDataCell, Category) == 0x000010, "Member 'FRetryLoadingTipsDataCell::Category' has a wrong offset!");
static_assert(offsetof(FRetryLoadingTipsDataCell, PlayerId) == 0x000011, "Member 'FRetryLoadingTipsDataCell::PlayerId' has a wrong offset!");
static_assert(offsetof(FRetryLoadingTipsDataCell, Param) == 0x000014, "Member 'FRetryLoadingTipsDataCell::Param' has a wrong offset!");

// ScriptStruct BattlePrototype.LoadingTipsDataCell
// 0x0028 (0x0030 - 0x0008)
struct FLoadingTipsDataCell final : public FTableRowBase
{
public:
	int32                                         TipsMsgID;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELoadingTipsCategory                          Category;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     PlayerId;                                          // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLoadingTipsParam                      Param;                                             // 0x0014(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingTipsDataCell) == 0x000008, "Wrong alignment on FLoadingTipsDataCell");
static_assert(sizeof(FLoadingTipsDataCell) == 0x000030, "Wrong size on FLoadingTipsDataCell");
static_assert(offsetof(FLoadingTipsDataCell, TipsMsgID) == 0x000008, "Member 'FLoadingTipsDataCell::TipsMsgID' has a wrong offset!");
static_assert(offsetof(FLoadingTipsDataCell, Weight) == 0x00000C, "Member 'FLoadingTipsDataCell::Weight' has a wrong offset!");
static_assert(offsetof(FLoadingTipsDataCell, Category) == 0x000010, "Member 'FLoadingTipsDataCell::Category' has a wrong offset!");
static_assert(offsetof(FLoadingTipsDataCell, PlayerId) == 0x000011, "Member 'FLoadingTipsDataCell::PlayerId' has a wrong offset!");
static_assert(offsetof(FLoadingTipsDataCell, Param) == 0x000014, "Member 'FLoadingTipsDataCell::Param' has a wrong offset!");

// ScriptStruct BattlePrototype.LoadTipsBlockDataCell_Deprecated
// 0x0018 (0x0020 - 0x0008)
struct FLoadTipsBlockDataCell_Deprecated final : public FTableRowBase
{
public:
	int32                                         ProgressData;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 UseTipsID;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadTipsBlockDataCell_Deprecated) == 0x000008, "Wrong alignment on FLoadTipsBlockDataCell_Deprecated");
static_assert(sizeof(FLoadTipsBlockDataCell_Deprecated) == 0x000020, "Wrong size on FLoadTipsBlockDataCell_Deprecated");
static_assert(offsetof(FLoadTipsBlockDataCell_Deprecated, ProgressData) == 0x000008, "Member 'FLoadTipsBlockDataCell_Deprecated::ProgressData' has a wrong offset!");
static_assert(offsetof(FLoadTipsBlockDataCell_Deprecated, UseTipsID) == 0x000010, "Member 'FLoadTipsBlockDataCell_Deprecated::UseTipsID' has a wrong offset!");

// ScriptStruct BattlePrototype.LoadTipsBlockParam
// 0x0001 (0x0001 - 0x0000)
struct FLoadTipsBlockParam final
{
public:
	bool                                          IsReadyBlock;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLoadTipsBlockParam) == 0x000001, "Wrong alignment on FLoadTipsBlockParam");
static_assert(sizeof(FLoadTipsBlockParam) == 0x000001, "Wrong size on FLoadTipsBlockParam");
static_assert(offsetof(FLoadTipsBlockParam, IsReadyBlock) == 0x000000, "Member 'FLoadTipsBlockParam::IsReadyBlock' has a wrong offset!");

// ScriptStruct BattlePrototype.MapGimmickPlayerFinishAnimations
// 0x0020 (0x0028 - 0x0008)
struct FMapGimmickPlayerFinishAnimations final : public FTableRowBase
{
public:
	class UAnimMontage*                           Finish_Forward;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Finish_Right;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Finish_Left;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Finish_Backward;                                   // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapGimmickPlayerFinishAnimations) == 0x000008, "Wrong alignment on FMapGimmickPlayerFinishAnimations");
static_assert(sizeof(FMapGimmickPlayerFinishAnimations) == 0x000028, "Wrong size on FMapGimmickPlayerFinishAnimations");
static_assert(offsetof(FMapGimmickPlayerFinishAnimations, Finish_Forward) == 0x000008, "Member 'FMapGimmickPlayerFinishAnimations::Finish_Forward' has a wrong offset!");
static_assert(offsetof(FMapGimmickPlayerFinishAnimations, Finish_Right) == 0x000010, "Member 'FMapGimmickPlayerFinishAnimations::Finish_Right' has a wrong offset!");
static_assert(offsetof(FMapGimmickPlayerFinishAnimations, Finish_Left) == 0x000018, "Member 'FMapGimmickPlayerFinishAnimations::Finish_Left' has a wrong offset!");
static_assert(offsetof(FMapGimmickPlayerFinishAnimations, Finish_Backward) == 0x000020, "Member 'FMapGimmickPlayerFinishAnimations::Finish_Backward' has a wrong offset!");

// ScriptStruct BattlePrototype.PsychicRoadInfo
// 0x0010 (0x0018 - 0x0008)
struct FPsychicRoadInfo final : public FTableRowBase
{
public:
	TArray<struct FPsychicRoadStepInfo>           StepInfos;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPsychicRoadInfo) == 0x000008, "Wrong alignment on FPsychicRoadInfo");
static_assert(sizeof(FPsychicRoadInfo) == 0x000018, "Wrong size on FPsychicRoadInfo");
static_assert(offsetof(FPsychicRoadInfo, StepInfos) == 0x000008, "Member 'FPsychicRoadInfo::StepInfos' has a wrong offset!");

// ScriptStruct BattlePrototype.MapIconNodeListDataCell
// 0x0048 (0x0050 - 0x0008)
struct FMapIconNodeListDataCell final : public FTableRowBase
{
public:
	class FName                                   TypeName;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorName;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActorTranslation;                                  // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LocationNum;                                       // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaNum;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartPortalNoJumpTo;                               // 0x002C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x0034(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActorRotation;                                     // 0x0040(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapIconNodeListDataCell) == 0x000008, "Wrong alignment on FMapIconNodeListDataCell");
static_assert(sizeof(FMapIconNodeListDataCell) == 0x000050, "Wrong size on FMapIconNodeListDataCell");
static_assert(offsetof(FMapIconNodeListDataCell, TypeName) == 0x000008, "Member 'FMapIconNodeListDataCell::TypeName' has a wrong offset!");
static_assert(offsetof(FMapIconNodeListDataCell, ActorName) == 0x000010, "Member 'FMapIconNodeListDataCell::ActorName' has a wrong offset!");
static_assert(offsetof(FMapIconNodeListDataCell, ActorTranslation) == 0x000018, "Member 'FMapIconNodeListDataCell::ActorTranslation' has a wrong offset!");
static_assert(offsetof(FMapIconNodeListDataCell, LocationNum) == 0x000024, "Member 'FMapIconNodeListDataCell::LocationNum' has a wrong offset!");
static_assert(offsetof(FMapIconNodeListDataCell, AreaNum) == 0x000028, "Member 'FMapIconNodeListDataCell::AreaNum' has a wrong offset!");
static_assert(offsetof(FMapIconNodeListDataCell, StartPortalNoJumpTo) == 0x00002C, "Member 'FMapIconNodeListDataCell::StartPortalNoJumpTo' has a wrong offset!");
static_assert(offsetof(FMapIconNodeListDataCell, BoxExtent) == 0x000034, "Member 'FMapIconNodeListDataCell::BoxExtent' has a wrong offset!");
static_assert(offsetof(FMapIconNodeListDataCell, ActorRotation) == 0x000040, "Member 'FMapIconNodeListDataCell::ActorRotation' has a wrong offset!");

// ScriptStruct BattlePrototype.MapIconDBDataCell
// 0x0028 (0x0030 - 0x0008)
struct FMapIconDBDataCell final : public FTableRowBase
{
public:
	class FName                                   LocationName;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaName;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LocationNum;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaNum;                                           // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMapIconNodeListDataCell>       NodeList;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapIconDBDataCell) == 0x000008, "Wrong alignment on FMapIconDBDataCell");
static_assert(sizeof(FMapIconDBDataCell) == 0x000030, "Wrong size on FMapIconDBDataCell");
static_assert(offsetof(FMapIconDBDataCell, LocationName) == 0x000008, "Member 'FMapIconDBDataCell::LocationName' has a wrong offset!");
static_assert(offsetof(FMapIconDBDataCell, AreaName) == 0x000010, "Member 'FMapIconDBDataCell::AreaName' has a wrong offset!");
static_assert(offsetof(FMapIconDBDataCell, LocationNum) == 0x000018, "Member 'FMapIconDBDataCell::LocationNum' has a wrong offset!");
static_assert(offsetof(FMapIconDBDataCell, AreaNum) == 0x00001C, "Member 'FMapIconDBDataCell::AreaNum' has a wrong offset!");
static_assert(offsetof(FMapIconDBDataCell, NodeList) == 0x000020, "Member 'FMapIconDBDataCell::NodeList' has a wrong offset!");

// ScriptStruct BattlePrototype.MsgViewerLoadedData
// 0x000C (0x000C - 0x0000)
struct FMsgViewerLoadedData final
{
public:
	EMsgViewerDataType                            Type;                                              // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UDataTable>              RefDataTable;                                      // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgViewerLoadedData) == 0x000004, "Wrong alignment on FMsgViewerLoadedData");
static_assert(sizeof(FMsgViewerLoadedData) == 0x00000C, "Wrong size on FMsgViewerLoadedData");
static_assert(offsetof(FMsgViewerLoadedData, Type) == 0x000000, "Member 'FMsgViewerLoadedData::Type' has a wrong offset!");
static_assert(offsetof(FMsgViewerLoadedData, RefDataTable) == 0x000004, "Member 'FMsgViewerLoadedData::RefDataTable' has a wrong offset!");

// ScriptStruct BattlePrototype.MsgViewerCategoryDataCell
// 0x0020 (0x0028 - 0x0008)
struct FMsgViewerCategoryDataCell final : public FTableRowBase
{
public:
	EMsgViewerDataType                            Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SearchPath;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRecursive;                                       // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgViewerCategoryDataCell) == 0x000008, "Wrong alignment on FMsgViewerCategoryDataCell");
static_assert(sizeof(FMsgViewerCategoryDataCell) == 0x000028, "Wrong size on FMsgViewerCategoryDataCell");
static_assert(offsetof(FMsgViewerCategoryDataCell, Type) == 0x000008, "Member 'FMsgViewerCategoryDataCell::Type' has a wrong offset!");
static_assert(offsetof(FMsgViewerCategoryDataCell, SearchPath) == 0x000010, "Member 'FMsgViewerCategoryDataCell::SearchPath' has a wrong offset!");
static_assert(offsetof(FMsgViewerCategoryDataCell, IsRecursive) == 0x000020, "Member 'FMsgViewerCategoryDataCell::IsRecursive' has a wrong offset!");

// ScriptStruct BattlePrototype.MiniHelpRowDataCell
// 0x0018 (0x0020 - 0x0008)
struct FMiniHelpRowDataCell final : public FTableRowBase
{
public:
	EHelpTutorial                                 HelpID;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisplayHelpMenu;                                   // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HelpListMessageID;                                 // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayTime;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TopPriority;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMiniHelpRowDataCell) == 0x000008, "Wrong alignment on FMiniHelpRowDataCell");
static_assert(sizeof(FMiniHelpRowDataCell) == 0x000020, "Wrong size on FMiniHelpRowDataCell");
static_assert(offsetof(FMiniHelpRowDataCell, HelpID) == 0x000008, "Member 'FMiniHelpRowDataCell::HelpID' has a wrong offset!");
static_assert(offsetof(FMiniHelpRowDataCell, DisplayHelpMenu) == 0x000009, "Member 'FMiniHelpRowDataCell::DisplayHelpMenu' has a wrong offset!");
static_assert(offsetof(FMiniHelpRowDataCell, HelpListMessageID) == 0x00000C, "Member 'FMiniHelpRowDataCell::HelpListMessageID' has a wrong offset!");
static_assert(offsetof(FMiniHelpRowDataCell, DisplayTime) == 0x000014, "Member 'FMiniHelpRowDataCell::DisplayTime' has a wrong offset!");
static_assert(offsetof(FMiniHelpRowDataCell, TopPriority) == 0x000018, "Member 'FMiniHelpRowDataCell::TopPriority' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoNpcActor
// 0x0008 (0x0010 - 0x0008)
struct FAjitoNpcActor final : public FTableRowBase
{
public:
	TSubclassOf<class ANpcAjitoPeople>            AjitoNpcActor;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAjitoNpcActor) == 0x000008, "Wrong alignment on FAjitoNpcActor");
static_assert(sizeof(FAjitoNpcActor) == 0x000010, "Wrong size on FAjitoNpcActor");
static_assert(offsetof(FAjitoNpcActor, AjitoNpcActor) == 0x000008, "Member 'FAjitoNpcActor::AjitoNpcActor' has a wrong offset!");

// ScriptStruct BattlePrototype.NpcIconOffsetInfo
// 0x0008 (0x0010 - 0x0008)
struct FNpcIconOffsetInfo final : public FTableRowBase
{
public:
	float                                         HeadHeight;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionIconOffsetZ;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcIconOffsetInfo) == 0x000008, "Wrong alignment on FNpcIconOffsetInfo");
static_assert(sizeof(FNpcIconOffsetInfo) == 0x000010, "Wrong size on FNpcIconOffsetInfo");
static_assert(offsetof(FNpcIconOffsetInfo, HeadHeight) == 0x000008, "Member 'FNpcIconOffsetInfo::HeadHeight' has a wrong offset!");
static_assert(offsetof(FNpcIconOffsetInfo, ActionIconOffsetZ) == 0x00000C, "Member 'FNpcIconOffsetInfo::ActionIconOffsetZ' has a wrong offset!");

// ScriptStruct BattlePrototype.OnlineTestData
// 0x0008 (0x0008 - 0x0000)
struct FOnlineTestData final
{
public:
	int32                                         HP;                                                // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Vit;                                               // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnlineTestData) == 0x000004, "Wrong alignment on FOnlineTestData");
static_assert(sizeof(FOnlineTestData) == 0x000008, "Wrong size on FOnlineTestData");
static_assert(offsetof(FOnlineTestData, HP) == 0x000000, "Member 'FOnlineTestData::HP' has a wrong offset!");
static_assert(offsetof(FOnlineTestData, Vit) == 0x000004, "Member 'FOnlineTestData::Vit' has a wrong offset!");

// ScriptStruct BattlePrototype.Patch01Param
// 0x0058 (0x0058 - 0x0000)
struct FPatch01Param final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           InformedNewAddContentsNameList;                    // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           InformedPurchasedAddContentsNameList;              // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           NotifiedNotAppliedAddContentsNameListAllSlotShare; // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        InformedPatchBitFlag;                              // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x14];                                      // 0x0044(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPatch01Param) == 0x000008, "Wrong alignment on FPatch01Param");
static_assert(sizeof(FPatch01Param) == 0x000058, "Wrong size on FPatch01Param");
static_assert(offsetof(FPatch01Param, InformedNewAddContentsNameList) == 0x000010, "Member 'FPatch01Param::InformedNewAddContentsNameList' has a wrong offset!");
static_assert(offsetof(FPatch01Param, InformedPurchasedAddContentsNameList) == 0x000020, "Member 'FPatch01Param::InformedPurchasedAddContentsNameList' has a wrong offset!");
static_assert(offsetof(FPatch01Param, NotifiedNotAppliedAddContentsNameListAllSlotShare) == 0x000030, "Member 'FPatch01Param::NotifiedNotAppliedAddContentsNameListAllSlotShare' has a wrong offset!");
static_assert(offsetof(FPatch01Param, InformedPatchBitFlag) == 0x000040, "Member 'FPatch01Param::InformedPatchBitFlag' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerAICheckMoveWallParamResult
// 0x0028 (0x0028 - 0x0000)
struct FPlayerAICheckMoveWallParamResult final
{
public:
	struct FVector                                InActorLoc;                                        // 0x0000(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InMoveDir;                                         // 0x000C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutLoc;                                            // 0x0018(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerAIMoveWallCPP                          OutWallType;                                       // 0x0024(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerAICheckMoveWallParamResult) == 0x000004, "Wrong alignment on FPlayerAICheckMoveWallParamResult");
static_assert(sizeof(FPlayerAICheckMoveWallParamResult) == 0x000028, "Wrong size on FPlayerAICheckMoveWallParamResult");
static_assert(offsetof(FPlayerAICheckMoveWallParamResult, InActorLoc) == 0x000000, "Member 'FPlayerAICheckMoveWallParamResult::InActorLoc' has a wrong offset!");
static_assert(offsetof(FPlayerAICheckMoveWallParamResult, InMoveDir) == 0x00000C, "Member 'FPlayerAICheckMoveWallParamResult::InMoveDir' has a wrong offset!");
static_assert(offsetof(FPlayerAICheckMoveWallParamResult, OutLoc) == 0x000018, "Member 'FPlayerAICheckMoveWallParamResult::OutLoc' has a wrong offset!");
static_assert(offsetof(FPlayerAICheckMoveWallParamResult, OutWallType) == 0x000024, "Member 'FPlayerAICheckMoveWallParamResult::OutWallType' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerAIComponentInitializeParam
// 0x0040 (0x0040 - 0x0000)
struct FPlayerAIComponentInitializeParam final
{
public:
	float                                         RANGE_NEAR;                                        // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RANGE_FAR;                                         // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CONFUSION_FRIEND_PRIORITY_OFFSET;                  // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPC_WARY_HP_RATE_1;                                // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPC_WARY_HP_RATE_2;                                // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPC_WARY_PROBABILITY_DOWN_1;                       // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPC_WARY_PROBABILITY_DOWN_2;                       // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPC_ATTACK_PROBABILITY_UP_TIME_1;                  // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPC_ATTACK_PROBABILITY_UP_TIME_2;                  // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPC_ATTACK_PROBABILITY_UP_VALUE_1;                 // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPC_ATTACK_PROBABILITY_UP_VALUE_2;                 // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPC_MOVE_PROBABILITY_DOWN_TIME;                    // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPC_MOVE_PROBABILITY_DOWN_VALUE;                   // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPC_ASSIST_ATTACK_PROBABILITY_UP_VALUE;            // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPC_REVIVE_DISTANCE;                               // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPC_REVIVE_DISTANCE_FAR;                           // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerAIComponentInitializeParam) == 0x000004, "Wrong alignment on FPlayerAIComponentInitializeParam");
static_assert(sizeof(FPlayerAIComponentInitializeParam) == 0x000040, "Wrong size on FPlayerAIComponentInitializeParam");
static_assert(offsetof(FPlayerAIComponentInitializeParam, RANGE_NEAR) == 0x000000, "Member 'FPlayerAIComponentInitializeParam::RANGE_NEAR' has a wrong offset!");
static_assert(offsetof(FPlayerAIComponentInitializeParam, RANGE_FAR) == 0x000004, "Member 'FPlayerAIComponentInitializeParam::RANGE_FAR' has a wrong offset!");
static_assert(offsetof(FPlayerAIComponentInitializeParam, CONFUSION_FRIEND_PRIORITY_OFFSET) == 0x000008, "Member 'FPlayerAIComponentInitializeParam::CONFUSION_FRIEND_PRIORITY_OFFSET' has a wrong offset!");
static_assert(offsetof(FPlayerAIComponentInitializeParam, NPC_WARY_HP_RATE_1) == 0x00000C, "Member 'FPlayerAIComponentInitializeParam::NPC_WARY_HP_RATE_1' has a wrong offset!");
static_assert(offsetof(FPlayerAIComponentInitializeParam, NPC_WARY_HP_RATE_2) == 0x000010, "Member 'FPlayerAIComponentInitializeParam::NPC_WARY_HP_RATE_2' has a wrong offset!");
static_assert(offsetof(FPlayerAIComponentInitializeParam, NPC_WARY_PROBABILITY_DOWN_1) == 0x000014, "Member 'FPlayerAIComponentInitializeParam::NPC_WARY_PROBABILITY_DOWN_1' has a wrong offset!");
static_assert(offsetof(FPlayerAIComponentInitializeParam, NPC_WARY_PROBABILITY_DOWN_2) == 0x000018, "Member 'FPlayerAIComponentInitializeParam::NPC_WARY_PROBABILITY_DOWN_2' has a wrong offset!");
static_assert(offsetof(FPlayerAIComponentInitializeParam, NPC_ATTACK_PROBABILITY_UP_TIME_1) == 0x00001C, "Member 'FPlayerAIComponentInitializeParam::NPC_ATTACK_PROBABILITY_UP_TIME_1' has a wrong offset!");
static_assert(offsetof(FPlayerAIComponentInitializeParam, NPC_ATTACK_PROBABILITY_UP_TIME_2) == 0x000020, "Member 'FPlayerAIComponentInitializeParam::NPC_ATTACK_PROBABILITY_UP_TIME_2' has a wrong offset!");
static_assert(offsetof(FPlayerAIComponentInitializeParam, NPC_ATTACK_PROBABILITY_UP_VALUE_1) == 0x000024, "Member 'FPlayerAIComponentInitializeParam::NPC_ATTACK_PROBABILITY_UP_VALUE_1' has a wrong offset!");
static_assert(offsetof(FPlayerAIComponentInitializeParam, NPC_ATTACK_PROBABILITY_UP_VALUE_2) == 0x000028, "Member 'FPlayerAIComponentInitializeParam::NPC_ATTACK_PROBABILITY_UP_VALUE_2' has a wrong offset!");
static_assert(offsetof(FPlayerAIComponentInitializeParam, NPC_MOVE_PROBABILITY_DOWN_TIME) == 0x00002C, "Member 'FPlayerAIComponentInitializeParam::NPC_MOVE_PROBABILITY_DOWN_TIME' has a wrong offset!");
static_assert(offsetof(FPlayerAIComponentInitializeParam, NPC_MOVE_PROBABILITY_DOWN_VALUE) == 0x000030, "Member 'FPlayerAIComponentInitializeParam::NPC_MOVE_PROBABILITY_DOWN_VALUE' has a wrong offset!");
static_assert(offsetof(FPlayerAIComponentInitializeParam, NPC_ASSIST_ATTACK_PROBABILITY_UP_VALUE) == 0x000034, "Member 'FPlayerAIComponentInitializeParam::NPC_ASSIST_ATTACK_PROBABILITY_UP_VALUE' has a wrong offset!");
static_assert(offsetof(FPlayerAIComponentInitializeParam, NPC_REVIVE_DISTANCE) == 0x000038, "Member 'FPlayerAIComponentInitializeParam::NPC_REVIVE_DISTANCE' has a wrong offset!");
static_assert(offsetof(FPlayerAIComponentInitializeParam, NPC_REVIVE_DISTANCE_FAR) == 0x00003C, "Member 'FPlayerAIComponentInitializeParam::NPC_REVIVE_DISTANCE_FAR' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerAsyncParameter
// 0x00A8 (0x00A8 - 0x0000)
struct FPlayerAsyncParameter final
{
public:
	bool                                          bEnemyPlayer;                                      // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CollisionCheckDir;                                 // 0x0004(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionCheckDistance;                            // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionCheckHeightTop;                           // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionCheckHeightBottom;                        // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckEnemyCollision;                              // 0x001C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EnemyCheckDir;                                     // 0x0020(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyCheckDistance;                                // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyCheckDistanceForMoveTo;                       // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckTargetLocation;                              // 0x0034(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetLocation;                                    // 0x0038(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetRadius;                                      // 0x0044(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckCopy;                                        // 0x0048(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CopyCheckOffsetRight;                              // 0x004C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CopyCheckOffsetLeft;                               // 0x0058(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CopyCheckHeightTop;                                // 0x0064(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CopyCheckHeightBottom;                             // 0x0068(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerAICheckGoalLocation;                        // 0x006C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PlayerAIGoalBaseLocation;                          // 0x0070(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlayerAIGoalDesiredRelativeLocation;               // 0x007C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerAICheckMoveWallParamIn          CheckWallParam;                                    // 0x0088(0x0020)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerAsyncParameter) == 0x000004, "Wrong alignment on FPlayerAsyncParameter");
static_assert(sizeof(FPlayerAsyncParameter) == 0x0000A8, "Wrong size on FPlayerAsyncParameter");
static_assert(offsetof(FPlayerAsyncParameter, bEnemyPlayer) == 0x000000, "Member 'FPlayerAsyncParameter::bEnemyPlayer' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, CollisionCheckDir) == 0x000004, "Member 'FPlayerAsyncParameter::CollisionCheckDir' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, CollisionCheckDistance) == 0x000010, "Member 'FPlayerAsyncParameter::CollisionCheckDistance' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, CollisionCheckHeightTop) == 0x000014, "Member 'FPlayerAsyncParameter::CollisionCheckHeightTop' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, CollisionCheckHeightBottom) == 0x000018, "Member 'FPlayerAsyncParameter::CollisionCheckHeightBottom' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, bCheckEnemyCollision) == 0x00001C, "Member 'FPlayerAsyncParameter::bCheckEnemyCollision' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, EnemyCheckDir) == 0x000020, "Member 'FPlayerAsyncParameter::EnemyCheckDir' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, EnemyCheckDistance) == 0x00002C, "Member 'FPlayerAsyncParameter::EnemyCheckDistance' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, EnemyCheckDistanceForMoveTo) == 0x000030, "Member 'FPlayerAsyncParameter::EnemyCheckDistanceForMoveTo' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, bCheckTargetLocation) == 0x000034, "Member 'FPlayerAsyncParameter::bCheckTargetLocation' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, TargetLocation) == 0x000038, "Member 'FPlayerAsyncParameter::TargetLocation' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, TargetRadius) == 0x000044, "Member 'FPlayerAsyncParameter::TargetRadius' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, bCheckCopy) == 0x000048, "Member 'FPlayerAsyncParameter::bCheckCopy' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, CopyCheckOffsetRight) == 0x00004C, "Member 'FPlayerAsyncParameter::CopyCheckOffsetRight' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, CopyCheckOffsetLeft) == 0x000058, "Member 'FPlayerAsyncParameter::CopyCheckOffsetLeft' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, CopyCheckHeightTop) == 0x000064, "Member 'FPlayerAsyncParameter::CopyCheckHeightTop' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, CopyCheckHeightBottom) == 0x000068, "Member 'FPlayerAsyncParameter::CopyCheckHeightBottom' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, bPlayerAICheckGoalLocation) == 0x00006C, "Member 'FPlayerAsyncParameter::bPlayerAICheckGoalLocation' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, PlayerAIGoalBaseLocation) == 0x000070, "Member 'FPlayerAsyncParameter::PlayerAIGoalBaseLocation' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, PlayerAIGoalDesiredRelativeLocation) == 0x00007C, "Member 'FPlayerAsyncParameter::PlayerAIGoalDesiredRelativeLocation' has a wrong offset!");
static_assert(offsetof(FPlayerAsyncParameter, CheckWallParam) == 0x000088, "Member 'FPlayerAsyncParameter::CheckWallParam' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerAlongWallCheckResult
// 0x001C (0x001C - 0x0000)
struct FPlayerAlongWallCheckResult final
{
public:
	bool                                          bNeedsAlongWall;                                   // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InMoveInput;                                       // 0x0004(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutMoveInput;                                      // 0x0010(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerAlongWallCheckResult) == 0x000004, "Wrong alignment on FPlayerAlongWallCheckResult");
static_assert(sizeof(FPlayerAlongWallCheckResult) == 0x00001C, "Wrong size on FPlayerAlongWallCheckResult");
static_assert(offsetof(FPlayerAlongWallCheckResult, bNeedsAlongWall) == 0x000000, "Member 'FPlayerAlongWallCheckResult::bNeedsAlongWall' has a wrong offset!");
static_assert(offsetof(FPlayerAlongWallCheckResult, InMoveInput) == 0x000004, "Member 'FPlayerAlongWallCheckResult::InMoveInput' has a wrong offset!");
static_assert(offsetof(FPlayerAlongWallCheckResult, OutMoveInput) == 0x000010, "Member 'FPlayerAlongWallCheckResult::OutMoveInput' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerCollisionCheckResult
// 0x0040 (0x0040 - 0x0000)
struct FPlayerCollisionCheckResult final
{
public:
	bool                                          bHit;                                              // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0004(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0010(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Dir;                                               // 0x001C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  HitActor;                                          // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AActor>>          HitActorBackupList;                                // 0x0030(0x0010)(ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerCollisionCheckResult) == 0x000008, "Wrong alignment on FPlayerCollisionCheckResult");
static_assert(sizeof(FPlayerCollisionCheckResult) == 0x000040, "Wrong size on FPlayerCollisionCheckResult");
static_assert(offsetof(FPlayerCollisionCheckResult, bHit) == 0x000000, "Member 'FPlayerCollisionCheckResult::bHit' has a wrong offset!");
static_assert(offsetof(FPlayerCollisionCheckResult, Location) == 0x000004, "Member 'FPlayerCollisionCheckResult::Location' has a wrong offset!");
static_assert(offsetof(FPlayerCollisionCheckResult, ImpactPoint) == 0x000010, "Member 'FPlayerCollisionCheckResult::ImpactPoint' has a wrong offset!");
static_assert(offsetof(FPlayerCollisionCheckResult, Dir) == 0x00001C, "Member 'FPlayerCollisionCheckResult::Dir' has a wrong offset!");
static_assert(offsetof(FPlayerCollisionCheckResult, HitActor) == 0x000028, "Member 'FPlayerCollisionCheckResult::HitActor' has a wrong offset!");
static_assert(offsetof(FPlayerCollisionCheckResult, HitActorBackupList) == 0x000030, "Member 'FPlayerCollisionCheckResult::HitActorBackupList' has a wrong offset!");

// ScriptStruct BattlePrototype._SASParamNative
// 0x0014 (0x0014 - 0x0000)
struct F_SASParamNative final
{
public:
	ESASEffectTiming                              Timing;                                            // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESASEffect                                    Effect;                                            // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESASEffect                                    Effect2;                                           // 0x0002(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Param0;                                            // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param1;                                            // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param2;                                            // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param3;                                            // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(F_SASParamNative) == 0x000004, "Wrong alignment on F_SASParamNative");
static_assert(sizeof(F_SASParamNative) == 0x000014, "Wrong size on F_SASParamNative");
static_assert(offsetof(F_SASParamNative, Timing) == 0x000000, "Member 'F_SASParamNative::Timing' has a wrong offset!");
static_assert(offsetof(F_SASParamNative, Effect) == 0x000001, "Member 'F_SASParamNative::Effect' has a wrong offset!");
static_assert(offsetof(F_SASParamNative, Effect2) == 0x000002, "Member 'F_SASParamNative::Effect2' has a wrong offset!");
static_assert(offsetof(F_SASParamNative, Param0) == 0x000004, "Member 'F_SASParamNative::Param0' has a wrong offset!");
static_assert(offsetof(F_SASParamNative, Param1) == 0x000008, "Member 'F_SASParamNative::Param1' has a wrong offset!");
static_assert(offsetof(F_SASParamNative, Param2) == 0x00000C, "Member 'F_SASParamNative::Param2' has a wrong offset!");
static_assert(offsetof(F_SASParamNative, Param3) == 0x000010, "Member 'F_SASParamNative::Param3' has a wrong offset!");

// ScriptStruct BattlePrototype.SASEffectState
// 0x0018 (0x0018 - 0x0000)
struct FSASEffectState final
{
public:
	uint8                                         bActivate : 1;                                     // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLinkAble : 1;                                     // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWithFriend : 1;                                   // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInitializedFixParam : 1;                          // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentLevel;                                      // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct F_SASParamNative>               FixParam;                                          // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSASEffectState) == 0x000008, "Wrong alignment on FSASEffectState");
static_assert(sizeof(FSASEffectState) == 0x000018, "Wrong size on FSASEffectState");
static_assert(offsetof(FSASEffectState, CurrentLevel) == 0x000004, "Member 'FSASEffectState::CurrentLevel' has a wrong offset!");
static_assert(offsetof(FSASEffectState, FixParam) == 0x000008, "Member 'FSASEffectState::FixParam' has a wrong offset!");

// ScriptStruct BattlePrototype.LevelDifferentExpRateData
// 0x0020 (0x0028 - 0x0008)
struct FLevelDifferentExpRateData final : public FTableRowBase
{
public:
	int32                                         LowerLevelMin;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LowerLevelMax;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerExpRateMin;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerExpRateMax;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HigherLevelMin;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HigherLevelMax;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HigherExpRateMin;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HigherExpRateMax;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelDifferentExpRateData) == 0x000008, "Wrong alignment on FLevelDifferentExpRateData");
static_assert(sizeof(FLevelDifferentExpRateData) == 0x000028, "Wrong size on FLevelDifferentExpRateData");
static_assert(offsetof(FLevelDifferentExpRateData, LowerLevelMin) == 0x000008, "Member 'FLevelDifferentExpRateData::LowerLevelMin' has a wrong offset!");
static_assert(offsetof(FLevelDifferentExpRateData, LowerLevelMax) == 0x00000C, "Member 'FLevelDifferentExpRateData::LowerLevelMax' has a wrong offset!");
static_assert(offsetof(FLevelDifferentExpRateData, LowerExpRateMin) == 0x000010, "Member 'FLevelDifferentExpRateData::LowerExpRateMin' has a wrong offset!");
static_assert(offsetof(FLevelDifferentExpRateData, LowerExpRateMax) == 0x000014, "Member 'FLevelDifferentExpRateData::LowerExpRateMax' has a wrong offset!");
static_assert(offsetof(FLevelDifferentExpRateData, HigherLevelMin) == 0x000018, "Member 'FLevelDifferentExpRateData::HigherLevelMin' has a wrong offset!");
static_assert(offsetof(FLevelDifferentExpRateData, HigherLevelMax) == 0x00001C, "Member 'FLevelDifferentExpRateData::HigherLevelMax' has a wrong offset!");
static_assert(offsetof(FLevelDifferentExpRateData, HigherExpRateMin) == 0x000020, "Member 'FLevelDifferentExpRateData::HigherExpRateMin' has a wrong offset!");
static_assert(offsetof(FLevelDifferentExpRateData, HigherExpRateMax) == 0x000024, "Member 'FLevelDifferentExpRateData::HigherExpRateMax' has a wrong offset!");

// ScriptStruct BattlePrototype.FriendLotData
// 0x0048 (0x0050 - 0x0008)
struct FFriendLotData final : public FTableRowBase
{
public:
	int32                                         LotPoint1;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LotPoint2;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LotPoint3;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LotPoint4;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LotPoint5;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LotPoint6;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinLotPointSum;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLotPointSum;                                    // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinProbabirity;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxProbabirity;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharaLotProbabirity;                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharaLotOffsetBattleMember;                        // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharaLotOffsetBonds2;                              // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharaLotOffsetBonds3;                              // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharaLotOffsetBonds4;                              // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharaLotOffsetBonds5;                              // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharaLotOffsetBonds6;                              // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharaLotOffsetHelped;                              // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFriendLotData) == 0x000008, "Wrong alignment on FFriendLotData");
static_assert(sizeof(FFriendLotData) == 0x000050, "Wrong size on FFriendLotData");
static_assert(offsetof(FFriendLotData, LotPoint1) == 0x000008, "Member 'FFriendLotData::LotPoint1' has a wrong offset!");
static_assert(offsetof(FFriendLotData, LotPoint2) == 0x00000C, "Member 'FFriendLotData::LotPoint2' has a wrong offset!");
static_assert(offsetof(FFriendLotData, LotPoint3) == 0x000010, "Member 'FFriendLotData::LotPoint3' has a wrong offset!");
static_assert(offsetof(FFriendLotData, LotPoint4) == 0x000014, "Member 'FFriendLotData::LotPoint4' has a wrong offset!");
static_assert(offsetof(FFriendLotData, LotPoint5) == 0x000018, "Member 'FFriendLotData::LotPoint5' has a wrong offset!");
static_assert(offsetof(FFriendLotData, LotPoint6) == 0x00001C, "Member 'FFriendLotData::LotPoint6' has a wrong offset!");
static_assert(offsetof(FFriendLotData, MinLotPointSum) == 0x000020, "Member 'FFriendLotData::MinLotPointSum' has a wrong offset!");
static_assert(offsetof(FFriendLotData, MaxLotPointSum) == 0x000024, "Member 'FFriendLotData::MaxLotPointSum' has a wrong offset!");
static_assert(offsetof(FFriendLotData, MinProbabirity) == 0x000028, "Member 'FFriendLotData::MinProbabirity' has a wrong offset!");
static_assert(offsetof(FFriendLotData, MaxProbabirity) == 0x00002C, "Member 'FFriendLotData::MaxProbabirity' has a wrong offset!");
static_assert(offsetof(FFriendLotData, CharaLotProbabirity) == 0x000030, "Member 'FFriendLotData::CharaLotProbabirity' has a wrong offset!");
static_assert(offsetof(FFriendLotData, CharaLotOffsetBattleMember) == 0x000034, "Member 'FFriendLotData::CharaLotOffsetBattleMember' has a wrong offset!");
static_assert(offsetof(FFriendLotData, CharaLotOffsetBonds2) == 0x000038, "Member 'FFriendLotData::CharaLotOffsetBonds2' has a wrong offset!");
static_assert(offsetof(FFriendLotData, CharaLotOffsetBonds3) == 0x00003C, "Member 'FFriendLotData::CharaLotOffsetBonds3' has a wrong offset!");
static_assert(offsetof(FFriendLotData, CharaLotOffsetBonds4) == 0x000040, "Member 'FFriendLotData::CharaLotOffsetBonds4' has a wrong offset!");
static_assert(offsetof(FFriendLotData, CharaLotOffsetBonds5) == 0x000044, "Member 'FFriendLotData::CharaLotOffsetBonds5' has a wrong offset!");
static_assert(offsetof(FFriendLotData, CharaLotOffsetBonds6) == 0x000048, "Member 'FFriendLotData::CharaLotOffsetBonds6' has a wrong offset!");
static_assert(offsetof(FFriendLotData, CharaLotOffsetHelped) == 0x00004C, "Member 'FFriendLotData::CharaLotOffsetHelped' has a wrong offset!");

// ScriptStruct BattlePrototype.BrainFieldPsychicGaugeDirectionData
// 0x0010 (0x0018 - 0x0008)
struct FBrainFieldPsychicGaugeDirectionData final : public FTableRowBase
{
public:
	float                                         IntervalMin;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalMax;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionTimeMin;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionTimeMax;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrainFieldPsychicGaugeDirectionData) == 0x000008, "Wrong alignment on FBrainFieldPsychicGaugeDirectionData");
static_assert(sizeof(FBrainFieldPsychicGaugeDirectionData) == 0x000018, "Wrong size on FBrainFieldPsychicGaugeDirectionData");
static_assert(offsetof(FBrainFieldPsychicGaugeDirectionData, IntervalMin) == 0x000008, "Member 'FBrainFieldPsychicGaugeDirectionData::IntervalMin' has a wrong offset!");
static_assert(offsetof(FBrainFieldPsychicGaugeDirectionData, IntervalMax) == 0x00000C, "Member 'FBrainFieldPsychicGaugeDirectionData::IntervalMax' has a wrong offset!");
static_assert(offsetof(FBrainFieldPsychicGaugeDirectionData, DirectionTimeMin) == 0x000010, "Member 'FBrainFieldPsychicGaugeDirectionData::DirectionTimeMin' has a wrong offset!");
static_assert(offsetof(FBrainFieldPsychicGaugeDirectionData, DirectionTimeMax) == 0x000014, "Member 'FBrainFieldPsychicGaugeDirectionData::DirectionTimeMax' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerBrainFieldData
// 0x0028 (0x0030 - 0x0008)
struct FPlayerBrainFieldData final : public FTableRowBase
{
public:
	float                                         BrainFieldTime;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarningRemainTime1;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarningRemainTime2;                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameOverTime;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HelpExtraTime;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHelpCount;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrainFieldInterval;                                // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LunatickBrainTalkIntervalMin;                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LunatickBrainTalkIntervalMax;                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerBrainFieldData) == 0x000008, "Wrong alignment on FPlayerBrainFieldData");
static_assert(sizeof(FPlayerBrainFieldData) == 0x000030, "Wrong size on FPlayerBrainFieldData");
static_assert(offsetof(FPlayerBrainFieldData, BrainFieldTime) == 0x000008, "Member 'FPlayerBrainFieldData::BrainFieldTime' has a wrong offset!");
static_assert(offsetof(FPlayerBrainFieldData, WarningRemainTime1) == 0x00000C, "Member 'FPlayerBrainFieldData::WarningRemainTime1' has a wrong offset!");
static_assert(offsetof(FPlayerBrainFieldData, WarningRemainTime2) == 0x000010, "Member 'FPlayerBrainFieldData::WarningRemainTime2' has a wrong offset!");
static_assert(offsetof(FPlayerBrainFieldData, GameOverTime) == 0x000014, "Member 'FPlayerBrainFieldData::GameOverTime' has a wrong offset!");
static_assert(offsetof(FPlayerBrainFieldData, HelpExtraTime) == 0x000018, "Member 'FPlayerBrainFieldData::HelpExtraTime' has a wrong offset!");
static_assert(offsetof(FPlayerBrainFieldData, MaxHelpCount) == 0x00001C, "Member 'FPlayerBrainFieldData::MaxHelpCount' has a wrong offset!");
static_assert(offsetof(FPlayerBrainFieldData, BrainFieldInterval) == 0x000020, "Member 'FPlayerBrainFieldData::BrainFieldInterval' has a wrong offset!");
static_assert(offsetof(FPlayerBrainFieldData, LunatickBrainTalkIntervalMin) == 0x000024, "Member 'FPlayerBrainFieldData::LunatickBrainTalkIntervalMin' has a wrong offset!");
static_assert(offsetof(FPlayerBrainFieldData, LunatickBrainTalkIntervalMax) == 0x000028, "Member 'FPlayerBrainFieldData::LunatickBrainTalkIntervalMax' has a wrong offset!");

// ScriptStruct BattlePrototype.CameraUniqueObjectParameter
// 0x0050 (0x0058 - 0x0008)
struct FCameraUniqueObjectParameter final : public FTableRowBase
{
public:
	struct FVector                                CameraOffset;                                      // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFov;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtRate;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayRate;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceNear;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceMiddle;                                    // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceFar;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraOffsetNear;                                  // 0x002C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFovNear;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraOffsetFar;                                   // 0x003C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFovFar;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpTimeStt;                                       // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpTimeEnd;                                       // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraUniqueObjectParameter) == 0x000008, "Wrong alignment on FCameraUniqueObjectParameter");
static_assert(sizeof(FCameraUniqueObjectParameter) == 0x000058, "Wrong size on FCameraUniqueObjectParameter");
static_assert(offsetof(FCameraUniqueObjectParameter, CameraOffset) == 0x000008, "Member 'FCameraUniqueObjectParameter::CameraOffset' has a wrong offset!");
static_assert(offsetof(FCameraUniqueObjectParameter, CameraFov) == 0x000014, "Member 'FCameraUniqueObjectParameter::CameraFov' has a wrong offset!");
static_assert(offsetof(FCameraUniqueObjectParameter, LookAtRate) == 0x000018, "Member 'FCameraUniqueObjectParameter::LookAtRate' has a wrong offset!");
static_assert(offsetof(FCameraUniqueObjectParameter, DelayRate) == 0x00001C, "Member 'FCameraUniqueObjectParameter::DelayRate' has a wrong offset!");
static_assert(offsetof(FCameraUniqueObjectParameter, DistanceNear) == 0x000020, "Member 'FCameraUniqueObjectParameter::DistanceNear' has a wrong offset!");
static_assert(offsetof(FCameraUniqueObjectParameter, DistanceMiddle) == 0x000024, "Member 'FCameraUniqueObjectParameter::DistanceMiddle' has a wrong offset!");
static_assert(offsetof(FCameraUniqueObjectParameter, DistanceFar) == 0x000028, "Member 'FCameraUniqueObjectParameter::DistanceFar' has a wrong offset!");
static_assert(offsetof(FCameraUniqueObjectParameter, CameraOffsetNear) == 0x00002C, "Member 'FCameraUniqueObjectParameter::CameraOffsetNear' has a wrong offset!");
static_assert(offsetof(FCameraUniqueObjectParameter, CameraFovNear) == 0x000038, "Member 'FCameraUniqueObjectParameter::CameraFovNear' has a wrong offset!");
static_assert(offsetof(FCameraUniqueObjectParameter, CameraOffsetFar) == 0x00003C, "Member 'FCameraUniqueObjectParameter::CameraOffsetFar' has a wrong offset!");
static_assert(offsetof(FCameraUniqueObjectParameter, CameraFovFar) == 0x000048, "Member 'FCameraUniqueObjectParameter::CameraFovFar' has a wrong offset!");
static_assert(offsetof(FCameraUniqueObjectParameter, LerpTimeStt) == 0x00004C, "Member 'FCameraUniqueObjectParameter::LerpTimeStt' has a wrong offset!");
static_assert(offsetof(FCameraUniqueObjectParameter, LerpTimeEnd) == 0x000050, "Member 'FCameraUniqueObjectParameter::LerpTimeEnd' has a wrong offset!");

// ScriptStruct BattlePrototype.AreaCameraType
// 0x0008 (0x0010 - 0x0008)
struct FAreaCameraType final : public FTableRowBase
{
public:
	class FName                                   CameraType;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAreaCameraType) == 0x000008, "Wrong alignment on FAreaCameraType");
static_assert(sizeof(FAreaCameraType) == 0x000010, "Wrong size on FAreaCameraType");
static_assert(offsetof(FAreaCameraType, CameraType) == 0x000008, "Member 'FAreaCameraType::CameraType' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerCameraActionParameter
// 0x0010 (0x0018 - 0x0008)
struct FPlayerCameraActionParameter final : public FTableRowBase
{
public:
	EPlayerCameraActionType                       ActionType;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpolationTime;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpValue;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceMax;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerCameraActionParameter) == 0x000008, "Wrong alignment on FPlayerCameraActionParameter");
static_assert(sizeof(FPlayerCameraActionParameter) == 0x000018, "Wrong size on FPlayerCameraActionParameter");
static_assert(offsetof(FPlayerCameraActionParameter, ActionType) == 0x000008, "Member 'FPlayerCameraActionParameter::ActionType' has a wrong offset!");
static_assert(offsetof(FPlayerCameraActionParameter, InterpolationTime) == 0x00000C, "Member 'FPlayerCameraActionParameter::InterpolationTime' has a wrong offset!");
static_assert(offsetof(FPlayerCameraActionParameter, LerpValue) == 0x000010, "Member 'FPlayerCameraActionParameter::LerpValue' has a wrong offset!");
static_assert(offsetof(FPlayerCameraActionParameter, DistanceMax) == 0x000014, "Member 'FPlayerCameraActionParameter::DistanceMax' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerCameraBasicParameter
// 0x0038 (0x0040 - 0x0008)
struct FPlayerCameraBasicParameter final : public FTableRowBase
{
public:
	float                                         AngleVtDefault;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleHzDefault;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateSpeedVt;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateAccelVt;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateDecelVt;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateSpeedHz;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateAccelHz;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateDecelHz;                                     // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadius;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceSpeed;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceAccel;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerInfoLerpTime;                               // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            TriggerInfoLerpCurve;                              // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerCameraBasicParameter) == 0x000008, "Wrong alignment on FPlayerCameraBasicParameter");
static_assert(sizeof(FPlayerCameraBasicParameter) == 0x000040, "Wrong size on FPlayerCameraBasicParameter");
static_assert(offsetof(FPlayerCameraBasicParameter, AngleVtDefault) == 0x000008, "Member 'FPlayerCameraBasicParameter::AngleVtDefault' has a wrong offset!");
static_assert(offsetof(FPlayerCameraBasicParameter, AngleHzDefault) == 0x00000C, "Member 'FPlayerCameraBasicParameter::AngleHzDefault' has a wrong offset!");
static_assert(offsetof(FPlayerCameraBasicParameter, RotateSpeedVt) == 0x000010, "Member 'FPlayerCameraBasicParameter::RotateSpeedVt' has a wrong offset!");
static_assert(offsetof(FPlayerCameraBasicParameter, RotateAccelVt) == 0x000014, "Member 'FPlayerCameraBasicParameter::RotateAccelVt' has a wrong offset!");
static_assert(offsetof(FPlayerCameraBasicParameter, RotateDecelVt) == 0x000018, "Member 'FPlayerCameraBasicParameter::RotateDecelVt' has a wrong offset!");
static_assert(offsetof(FPlayerCameraBasicParameter, RotateSpeedHz) == 0x00001C, "Member 'FPlayerCameraBasicParameter::RotateSpeedHz' has a wrong offset!");
static_assert(offsetof(FPlayerCameraBasicParameter, RotateAccelHz) == 0x000020, "Member 'FPlayerCameraBasicParameter::RotateAccelHz' has a wrong offset!");
static_assert(offsetof(FPlayerCameraBasicParameter, RotateDecelHz) == 0x000024, "Member 'FPlayerCameraBasicParameter::RotateDecelHz' has a wrong offset!");
static_assert(offsetof(FPlayerCameraBasicParameter, CollisionRadius) == 0x000028, "Member 'FPlayerCameraBasicParameter::CollisionRadius' has a wrong offset!");
static_assert(offsetof(FPlayerCameraBasicParameter, DistanceSpeed) == 0x00002C, "Member 'FPlayerCameraBasicParameter::DistanceSpeed' has a wrong offset!");
static_assert(offsetof(FPlayerCameraBasicParameter, DistanceAccel) == 0x000030, "Member 'FPlayerCameraBasicParameter::DistanceAccel' has a wrong offset!");
static_assert(offsetof(FPlayerCameraBasicParameter, TriggerInfoLerpTime) == 0x000034, "Member 'FPlayerCameraBasicParameter::TriggerInfoLerpTime' has a wrong offset!");
static_assert(offsetof(FPlayerCameraBasicParameter, TriggerInfoLerpCurve) == 0x000038, "Member 'FPlayerCameraBasicParameter::TriggerInfoLerpCurve' has a wrong offset!");

// ScriptStruct BattlePrototype.AddPartyPresetData
// 0x0018 (0x0020 - 0x0008)
struct FAddPartyPresetData final : public FTableRowBase
{
public:
	EPlayerID                                     PlayerId;                                          // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponId;                                          // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccessoryID0;                                      // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccessoryID1;                                      // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccessoryID2;                                      // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAddPartyPresetData) == 0x000008, "Wrong alignment on FAddPartyPresetData");
static_assert(sizeof(FAddPartyPresetData) == 0x000020, "Wrong size on FAddPartyPresetData");
static_assert(offsetof(FAddPartyPresetData, PlayerId) == 0x000008, "Member 'FAddPartyPresetData::PlayerId' has a wrong offset!");
static_assert(offsetof(FAddPartyPresetData, Level) == 0x00000C, "Member 'FAddPartyPresetData::Level' has a wrong offset!");
static_assert(offsetof(FAddPartyPresetData, WeaponId) == 0x000010, "Member 'FAddPartyPresetData::WeaponId' has a wrong offset!");
static_assert(offsetof(FAddPartyPresetData, AccessoryID0) == 0x000014, "Member 'FAddPartyPresetData::AccessoryID0' has a wrong offset!");
static_assert(offsetof(FAddPartyPresetData, AccessoryID1) == 0x000018, "Member 'FAddPartyPresetData::AccessoryID1' has a wrong offset!");
static_assert(offsetof(FAddPartyPresetData, AccessoryID2) == 0x00001C, "Member 'FAddPartyPresetData::AccessoryID2' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerInfo
// 0x00AC (0x00AC - 0x0000)
struct FPlayerInfo final
{
public:
	EPlayerID                                     PlayerId;                                          // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalExp;                                          // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Exp;                                               // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HP;                                                // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHp;                                             // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Esp;                                               // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack;                                            // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Defense;                                           // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponId;                                          // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccessoryID0;                                      // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccessoryID1;                                      // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccessoryID2;                                      // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BackupAccessoryID0;                                // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BackupAccessoryID1;                                // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BackupAccessoryID2;                                // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostumeId;                                         // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttachmentID0;                                     // 0x0044(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttachmentID1;                                     // 0x0048(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttachmentID2;                                     // 0x004C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerAIOrder                                AIOrder;                                           // 0x0050(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPartyJoinStatus                              PartyJoinStatus;                                   // 0x0051(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PrevRemovePartyPlayerKind;                         // 0x0052(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x1];                                       // 0x0053(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastSallyTimeMin;                                  // 0x0054(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastSallyTimeMin_LastBTPlayConditionTime;          // 0x0058(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastNoSallyTimeMin;                                // 0x005C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastNoSallyTimeMin_LastBTPlayConditionTime;        // 0x0060(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastUseSasTimeMin;                                 // 0x0064(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastUseSasTimeMin_LastBTPlayConditionTime;         // 0x0068(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlameAccumulation;                                 // 0x006C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElectricAccumulation;                              // 0x0070(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloodedAccumulation;                               // 0x0074(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OilAccumulation;                                   // 0x0078(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionAccumulation;                             // 0x007C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlameRemainingTime;                                // 0x0080(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElectricRemainingTime;                             // 0x0084(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloodedRemainingTime;                              // 0x0088(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OilRemainingTime;                                  // 0x008C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionRemainingTime;                            // 0x0090(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PsychicGauge;                                      // 0x0094(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDriveMode;                                        // 0x0098(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DriveGauge;                                        // 0x009C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DriveTime;                                         // 0x00A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DriveExtendTime;                                   // 0x00A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BrainFieldStock;                                   // 0x00A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerInfo) == 0x000004, "Wrong alignment on FPlayerInfo");
static_assert(sizeof(FPlayerInfo) == 0x0000AC, "Wrong size on FPlayerInfo");
static_assert(offsetof(FPlayerInfo, PlayerId) == 0x000000, "Member 'FPlayerInfo::PlayerId' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, Level) == 0x000004, "Member 'FPlayerInfo::Level' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, TotalExp) == 0x000008, "Member 'FPlayerInfo::TotalExp' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, Exp) == 0x00000C, "Member 'FPlayerInfo::Exp' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, HP) == 0x000010, "Member 'FPlayerInfo::HP' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, MaxHp) == 0x000014, "Member 'FPlayerInfo::MaxHp' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, Esp) == 0x000018, "Member 'FPlayerInfo::Esp' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, Attack) == 0x00001C, "Member 'FPlayerInfo::Attack' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, Defense) == 0x000020, "Member 'FPlayerInfo::Defense' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, WeaponId) == 0x000024, "Member 'FPlayerInfo::WeaponId' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, AccessoryID0) == 0x000028, "Member 'FPlayerInfo::AccessoryID0' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, AccessoryID1) == 0x00002C, "Member 'FPlayerInfo::AccessoryID1' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, AccessoryID2) == 0x000030, "Member 'FPlayerInfo::AccessoryID2' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, BackupAccessoryID0) == 0x000034, "Member 'FPlayerInfo::BackupAccessoryID0' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, BackupAccessoryID1) == 0x000038, "Member 'FPlayerInfo::BackupAccessoryID1' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, BackupAccessoryID2) == 0x00003C, "Member 'FPlayerInfo::BackupAccessoryID2' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, CostumeId) == 0x000040, "Member 'FPlayerInfo::CostumeId' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, AttachmentID0) == 0x000044, "Member 'FPlayerInfo::AttachmentID0' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, AttachmentID1) == 0x000048, "Member 'FPlayerInfo::AttachmentID1' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, AttachmentID2) == 0x00004C, "Member 'FPlayerInfo::AttachmentID2' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, AIOrder) == 0x000050, "Member 'FPlayerInfo::AIOrder' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, PartyJoinStatus) == 0x000051, "Member 'FPlayerInfo::PartyJoinStatus' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, PrevRemovePartyPlayerKind) == 0x000052, "Member 'FPlayerInfo::PrevRemovePartyPlayerKind' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, LastSallyTimeMin) == 0x000054, "Member 'FPlayerInfo::LastSallyTimeMin' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, LastSallyTimeMin_LastBTPlayConditionTime) == 0x000058, "Member 'FPlayerInfo::LastSallyTimeMin_LastBTPlayConditionTime' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, LastNoSallyTimeMin) == 0x00005C, "Member 'FPlayerInfo::LastNoSallyTimeMin' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, LastNoSallyTimeMin_LastBTPlayConditionTime) == 0x000060, "Member 'FPlayerInfo::LastNoSallyTimeMin_LastBTPlayConditionTime' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, LastUseSasTimeMin) == 0x000064, "Member 'FPlayerInfo::LastUseSasTimeMin' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, LastUseSasTimeMin_LastBTPlayConditionTime) == 0x000068, "Member 'FPlayerInfo::LastUseSasTimeMin_LastBTPlayConditionTime' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, FlameAccumulation) == 0x00006C, "Member 'FPlayerInfo::FlameAccumulation' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, ElectricAccumulation) == 0x000070, "Member 'FPlayerInfo::ElectricAccumulation' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, FloodedAccumulation) == 0x000074, "Member 'FPlayerInfo::FloodedAccumulation' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, OilAccumulation) == 0x000078, "Member 'FPlayerInfo::OilAccumulation' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, ConfusionAccumulation) == 0x00007C, "Member 'FPlayerInfo::ConfusionAccumulation' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, FlameRemainingTime) == 0x000080, "Member 'FPlayerInfo::FlameRemainingTime' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, ElectricRemainingTime) == 0x000084, "Member 'FPlayerInfo::ElectricRemainingTime' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, FloodedRemainingTime) == 0x000088, "Member 'FPlayerInfo::FloodedRemainingTime' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, OilRemainingTime) == 0x00008C, "Member 'FPlayerInfo::OilRemainingTime' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, ConfusionRemainingTime) == 0x000090, "Member 'FPlayerInfo::ConfusionRemainingTime' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, PsychicGauge) == 0x000094, "Member 'FPlayerInfo::PsychicGauge' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, bDriveMode) == 0x000098, "Member 'FPlayerInfo::bDriveMode' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, DriveGauge) == 0x00009C, "Member 'FPlayerInfo::DriveGauge' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, DriveTime) == 0x0000A0, "Member 'FPlayerInfo::DriveTime' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, DriveExtendTime) == 0x0000A4, "Member 'FPlayerInfo::DriveExtendTime' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, BrainFieldStock) == 0x0000A8, "Member 'FPlayerInfo::BrainFieldStock' has a wrong offset!");

// ScriptStruct BattlePrototype.NpcDriveData
// 0x0038 (0x0040 - 0x0008)
struct FNpcDriveData final : public FTableRowBase
{
public:
	float                                         DriveInterval;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbabirityOffsetBonds2;                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbabirityOffsetBonds3;                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbabirityOffsetBonds4;                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbabirityOffsetBonds5;                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbabirityOffsetBonds6;                           // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbabirityBattleMin;                              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbabirityBattleMax;                              // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbabirityTargetDamageMin;                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbabirityTargetDamageMax;                        // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbabirityDriveMax;                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbabirityPlayerHP30;                             // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbabirityPlayerHP20;                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbabirityPlayerHP10;                             // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcDriveData) == 0x000008, "Wrong alignment on FNpcDriveData");
static_assert(sizeof(FNpcDriveData) == 0x000040, "Wrong size on FNpcDriveData");
static_assert(offsetof(FNpcDriveData, DriveInterval) == 0x000008, "Member 'FNpcDriveData::DriveInterval' has a wrong offset!");
static_assert(offsetof(FNpcDriveData, ProbabirityOffsetBonds2) == 0x00000C, "Member 'FNpcDriveData::ProbabirityOffsetBonds2' has a wrong offset!");
static_assert(offsetof(FNpcDriveData, ProbabirityOffsetBonds3) == 0x000010, "Member 'FNpcDriveData::ProbabirityOffsetBonds3' has a wrong offset!");
static_assert(offsetof(FNpcDriveData, ProbabirityOffsetBonds4) == 0x000014, "Member 'FNpcDriveData::ProbabirityOffsetBonds4' has a wrong offset!");
static_assert(offsetof(FNpcDriveData, ProbabirityOffsetBonds5) == 0x000018, "Member 'FNpcDriveData::ProbabirityOffsetBonds5' has a wrong offset!");
static_assert(offsetof(FNpcDriveData, ProbabirityOffsetBonds6) == 0x00001C, "Member 'FNpcDriveData::ProbabirityOffsetBonds6' has a wrong offset!");
static_assert(offsetof(FNpcDriveData, ProbabirityBattleMin) == 0x000020, "Member 'FNpcDriveData::ProbabirityBattleMin' has a wrong offset!");
static_assert(offsetof(FNpcDriveData, ProbabirityBattleMax) == 0x000024, "Member 'FNpcDriveData::ProbabirityBattleMax' has a wrong offset!");
static_assert(offsetof(FNpcDriveData, ProbabirityTargetDamageMin) == 0x000028, "Member 'FNpcDriveData::ProbabirityTargetDamageMin' has a wrong offset!");
static_assert(offsetof(FNpcDriveData, ProbabirityTargetDamageMax) == 0x00002C, "Member 'FNpcDriveData::ProbabirityTargetDamageMax' has a wrong offset!");
static_assert(offsetof(FNpcDriveData, ProbabirityDriveMax) == 0x000030, "Member 'FNpcDriveData::ProbabirityDriveMax' has a wrong offset!");
static_assert(offsetof(FNpcDriveData, ProbabirityPlayerHP30) == 0x000034, "Member 'FNpcDriveData::ProbabirityPlayerHP30' has a wrong offset!");
static_assert(offsetof(FNpcDriveData, ProbabirityPlayerHP20) == 0x000038, "Member 'FNpcDriveData::ProbabirityPlayerHP20' has a wrong offset!");
static_assert(offsetof(FNpcDriveData, ProbabirityPlayerHP10) == 0x00003C, "Member 'FNpcDriveData::ProbabirityPlayerHP10' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerDriveCommonParameter
// 0x0028 (0x0030 - 0x0008)
struct FPlayerDriveCommonParameter final : public FTableRowBase
{
public:
	float                                         ExtendTimeLimit;                                   // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CutParameterMaxTimeBrainCrash;                     // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CutParameterMaxTimePsychicCombo;                   // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CutParameterMaxTimeLimit;                          // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisableDriveLastEnemyHpRate;                       // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ExtendTimeCombinationVision;                       // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDriveCommonParameter) == 0x000008, "Wrong alignment on FPlayerDriveCommonParameter");
static_assert(sizeof(FPlayerDriveCommonParameter) == 0x000030, "Wrong size on FPlayerDriveCommonParameter");
static_assert(offsetof(FPlayerDriveCommonParameter, ExtendTimeLimit) == 0x000008, "Member 'FPlayerDriveCommonParameter::ExtendTimeLimit' has a wrong offset!");
static_assert(offsetof(FPlayerDriveCommonParameter, CutParameterMaxTimeBrainCrash) == 0x00000C, "Member 'FPlayerDriveCommonParameter::CutParameterMaxTimeBrainCrash' has a wrong offset!");
static_assert(offsetof(FPlayerDriveCommonParameter, CutParameterMaxTimePsychicCombo) == 0x000010, "Member 'FPlayerDriveCommonParameter::CutParameterMaxTimePsychicCombo' has a wrong offset!");
static_assert(offsetof(FPlayerDriveCommonParameter, CutParameterMaxTimeLimit) == 0x000014, "Member 'FPlayerDriveCommonParameter::CutParameterMaxTimeLimit' has a wrong offset!");
static_assert(offsetof(FPlayerDriveCommonParameter, DisableDriveLastEnemyHpRate) == 0x000018, "Member 'FPlayerDriveCommonParameter::DisableDriveLastEnemyHpRate' has a wrong offset!");
static_assert(offsetof(FPlayerDriveCommonParameter, ExtendTimeCombinationVision) == 0x000020, "Member 'FPlayerDriveCommonParameter::ExtendTimeCombinationVision' has a wrong offset!");

// ScriptStruct BattlePrototype.DelayLoadPlayerEquipData
// 0x0005 (0x0005 - 0x0000)
struct FDelayLoadPlayerEquipData final
{
public:
	bool                                          bWeapon;                                           // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCostume;                                          // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachment0;                                      // 0x0002(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachment1;                                      // 0x0003(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachment2;                                      // 0x0004(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelayLoadPlayerEquipData) == 0x000001, "Wrong alignment on FDelayLoadPlayerEquipData");
static_assert(sizeof(FDelayLoadPlayerEquipData) == 0x000005, "Wrong size on FDelayLoadPlayerEquipData");
static_assert(offsetof(FDelayLoadPlayerEquipData, bWeapon) == 0x000000, "Member 'FDelayLoadPlayerEquipData::bWeapon' has a wrong offset!");
static_assert(offsetof(FDelayLoadPlayerEquipData, bCostume) == 0x000001, "Member 'FDelayLoadPlayerEquipData::bCostume' has a wrong offset!");
static_assert(offsetof(FDelayLoadPlayerEquipData, bAttachment0) == 0x000002, "Member 'FDelayLoadPlayerEquipData::bAttachment0' has a wrong offset!");
static_assert(offsetof(FDelayLoadPlayerEquipData, bAttachment1) == 0x000003, "Member 'FDelayLoadPlayerEquipData::bAttachment1' has a wrong offset!");
static_assert(offsetof(FDelayLoadPlayerEquipData, bAttachment2) == 0x000004, "Member 'FDelayLoadPlayerEquipData::bAttachment2' has a wrong offset!");

// ScriptStruct BattlePrototype.PlayerMaterialManageVector
// 0x001C (0x001C - 0x0000)
struct FPlayerMaterialManageVector final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayer;                                           // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeapon;                                           // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCable;                                            // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCopy;                                             // 0x001B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerMaterialManageVector) == 0x000004, "Wrong alignment on FPlayerMaterialManageVector");
static_assert(sizeof(FPlayerMaterialManageVector) == 0x00001C, "Wrong size on FPlayerMaterialManageVector");
static_assert(offsetof(FPlayerMaterialManageVector, ParamName) == 0x000000, "Member 'FPlayerMaterialManageVector::ParamName' has a wrong offset!");
static_assert(offsetof(FPlayerMaterialManageVector, Value) == 0x000008, "Member 'FPlayerMaterialManageVector::Value' has a wrong offset!");
static_assert(offsetof(FPlayerMaterialManageVector, bPlayer) == 0x000018, "Member 'FPlayerMaterialManageVector::bPlayer' has a wrong offset!");
static_assert(offsetof(FPlayerMaterialManageVector, bWeapon) == 0x000019, "Member 'FPlayerMaterialManageVector::bWeapon' has a wrong offset!");
static_assert(offsetof(FPlayerMaterialManageVector, bCable) == 0x00001A, "Member 'FPlayerMaterialManageVector::bCable' has a wrong offset!");
static_assert(offsetof(FPlayerMaterialManageVector, bCopy) == 0x00001B, "Member 'FPlayerMaterialManageVector::bCopy' has a wrong offset!");

// ScriptStruct BattlePrototype.SASHologramAttackProbabilityData
// 0x0008 (0x0010 - 0x0008)
struct FSASHologramAttackProbabilityData final : public FTableRowBase
{
public:
	float                                         Time;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpProbability;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSASHologramAttackProbabilityData) == 0x000008, "Wrong alignment on FSASHologramAttackProbabilityData");
static_assert(sizeof(FSASHologramAttackProbabilityData) == 0x000010, "Wrong size on FSASHologramAttackProbabilityData");
static_assert(offsetof(FSASHologramAttackProbabilityData, Time) == 0x000008, "Member 'FSASHologramAttackProbabilityData::Time' has a wrong offset!");
static_assert(offsetof(FSASHologramAttackProbabilityData, UpProbability) == 0x00000C, "Member 'FSASHologramAttackProbabilityData::UpProbability' has a wrong offset!");

// ScriptStruct BattlePrototype.PresentLocationContainData
// 0x0010 (0x0018 - 0x0008)
struct FPresentLocationContainData final : public FTableRowBase
{
public:
	struct FVector                                Location;                                          // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPresentLocationContainData) == 0x000008, "Wrong alignment on FPresentLocationContainData");
static_assert(sizeof(FPresentLocationContainData) == 0x000018, "Wrong size on FPresentLocationContainData");
static_assert(offsetof(FPresentLocationContainData, Location) == 0x000008, "Member 'FPresentLocationContainData::Location' has a wrong offset!");
static_assert(offsetof(FPresentLocationContainData, Yaw) == 0x000014, "Member 'FPresentLocationContainData::Yaw' has a wrong offset!");

// ScriptStruct BattlePrototype.PresentEventDataCell
// 0x0088 (0x0090 - 0x0008)
struct FPresentEventDataCell final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FromCharaID;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ForCharaID;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPresentContainMessageData>     FirstReaction;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPresentContainMessageData>     ExperiencedReaction;                               // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPresentLocationContainData            PlayerLocationAndYaw;                              // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPresentLocationContainData            ForCharaLocationAndYaw;                            // 0x0058(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPresentLocationCameraContainData      CameraLocationAndYawPitch;                         // 0x0070(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPresentEventDataCell) == 0x000008, "Wrong alignment on FPresentEventDataCell");
static_assert(sizeof(FPresentEventDataCell) == 0x000090, "Wrong size on FPresentEventDataCell");
static_assert(offsetof(FPresentEventDataCell, ItemId) == 0x000008, "Member 'FPresentEventDataCell::ItemId' has a wrong offset!");
static_assert(offsetof(FPresentEventDataCell, FromCharaID) == 0x000010, "Member 'FPresentEventDataCell::FromCharaID' has a wrong offset!");
static_assert(offsetof(FPresentEventDataCell, ForCharaID) == 0x000018, "Member 'FPresentEventDataCell::ForCharaID' has a wrong offset!");
static_assert(offsetof(FPresentEventDataCell, FirstReaction) == 0x000020, "Member 'FPresentEventDataCell::FirstReaction' has a wrong offset!");
static_assert(offsetof(FPresentEventDataCell, ExperiencedReaction) == 0x000030, "Member 'FPresentEventDataCell::ExperiencedReaction' has a wrong offset!");
static_assert(offsetof(FPresentEventDataCell, PlayerLocationAndYaw) == 0x000040, "Member 'FPresentEventDataCell::PlayerLocationAndYaw' has a wrong offset!");
static_assert(offsetof(FPresentEventDataCell, ForCharaLocationAndYaw) == 0x000058, "Member 'FPresentEventDataCell::ForCharaLocationAndYaw' has a wrong offset!");
static_assert(offsetof(FPresentEventDataCell, CameraLocationAndYawPitch) == 0x000070, "Member 'FPresentEventDataCell::CameraLocationAndYawPitch' has a wrong offset!");

// ScriptStruct BattlePrototype.PresentLocationDataCell
// 0x0058 (0x0060 - 0x0008)
struct FPresentLocationDataCell final : public FTableRowBase
{
public:
	class FName                                   ForCharaID;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPresentLocationContainData            PlayerLocationAndYaw;                              // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPresentLocationContainData            ForCharaLocationAndYaw;                            // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPresentLocationCameraContainData      CameraLocationAndYawPitch;                         // 0x0040(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPresentLocationDataCell) == 0x000008, "Wrong alignment on FPresentLocationDataCell");
static_assert(sizeof(FPresentLocationDataCell) == 0x000060, "Wrong size on FPresentLocationDataCell");
static_assert(offsetof(FPresentLocationDataCell, ForCharaID) == 0x000008, "Member 'FPresentLocationDataCell::ForCharaID' has a wrong offset!");
static_assert(offsetof(FPresentLocationDataCell, PlayerLocationAndYaw) == 0x000010, "Member 'FPresentLocationDataCell::PlayerLocationAndYaw' has a wrong offset!");
static_assert(offsetof(FPresentLocationDataCell, ForCharaLocationAndYaw) == 0x000028, "Member 'FPresentLocationDataCell::ForCharaLocationAndYaw' has a wrong offset!");
static_assert(offsetof(FPresentLocationDataCell, CameraLocationAndYawPitch) == 0x000040, "Member 'FPresentLocationDataCell::CameraLocationAndYawPitch' has a wrong offset!");

// ScriptStruct BattlePrototype.PresentCheckArray
// 0x0010 (0x0010 - 0x0000)
struct FPresentCheckArray final
{
public:
	TArray<bool>                                  boolArray;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPresentCheckArray) == 0x000008, "Wrong alignment on FPresentCheckArray");
static_assert(sizeof(FPresentCheckArray) == 0x000010, "Wrong size on FPresentCheckArray");
static_assert(offsetof(FPresentCheckArray, boolArray) == 0x000000, "Member 'FPresentCheckArray::boolArray' has a wrong offset!");

// ScriptStruct BattlePrototype.PresentInfoData
// 0x000C (0x000C - 0x0000)
struct FPresentInfoData final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasPresented;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPresentInfoData) == 0x000004, "Wrong alignment on FPresentInfoData");
static_assert(sizeof(FPresentInfoData) == 0x00000C, "Wrong size on FPresentInfoData");
static_assert(offsetof(FPresentInfoData, ItemId) == 0x000000, "Member 'FPresentInfoData::ItemId' has a wrong offset!");
static_assert(offsetof(FPresentInfoData, HasPresented) == 0x000008, "Member 'FPresentInfoData::HasPresented' has a wrong offset!");

// ScriptStruct BattlePrototype.PsychicGuageDataCell
// 0x0040 (0x0048 - 0x0008)
struct FPsychicGuageDataCell final : public FTableRowBase
{
public:
	float                                         WaveMult;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandWaveSeed;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideBright;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveRange;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SineAdd;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveSlidePower;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 SideColor;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 CenterColor;                                       // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AddBarColorOpacity;                                // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           PsychicAddColor;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPsychicGuageDataCell) == 0x000008, "Wrong alignment on FPsychicGuageDataCell");
static_assert(sizeof(FPsychicGuageDataCell) == 0x000048, "Wrong size on FPsychicGuageDataCell");
static_assert(offsetof(FPsychicGuageDataCell, WaveMult) == 0x000008, "Member 'FPsychicGuageDataCell::WaveMult' has a wrong offset!");
static_assert(offsetof(FPsychicGuageDataCell, RandWaveSeed) == 0x00000C, "Member 'FPsychicGuageDataCell::RandWaveSeed' has a wrong offset!");
static_assert(offsetof(FPsychicGuageDataCell, SideBright) == 0x000010, "Member 'FPsychicGuageDataCell::SideBright' has a wrong offset!");
static_assert(offsetof(FPsychicGuageDataCell, WaveRange) == 0x000014, "Member 'FPsychicGuageDataCell::WaveRange' has a wrong offset!");
static_assert(offsetof(FPsychicGuageDataCell, SineAdd) == 0x000018, "Member 'FPsychicGuageDataCell::SineAdd' has a wrong offset!");
static_assert(offsetof(FPsychicGuageDataCell, WaveSlidePower) == 0x00001C, "Member 'FPsychicGuageDataCell::WaveSlidePower' has a wrong offset!");
static_assert(offsetof(FPsychicGuageDataCell, SideColor) == 0x000020, "Member 'FPsychicGuageDataCell::SideColor' has a wrong offset!");
static_assert(offsetof(FPsychicGuageDataCell, CenterColor) == 0x000024, "Member 'FPsychicGuageDataCell::CenterColor' has a wrong offset!");
static_assert(offsetof(FPsychicGuageDataCell, AddBarColorOpacity) == 0x000028, "Member 'FPsychicGuageDataCell::AddBarColorOpacity' has a wrong offset!");
static_assert(offsetof(FPsychicGuageDataCell, PsychicAddColor) == 0x000038, "Member 'FPsychicGuageDataCell::PsychicAddColor' has a wrong offset!");

// ScriptStruct BattlePrototype.PsychicObjectFocusResult
// 0x0010 (0x0010 - 0x0000)
struct FPsychicObjectFocusResult final
{
public:
	class AActor*                                 NormalObj;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 UniqueObj;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPsychicObjectFocusResult) == 0x000008, "Wrong alignment on FPsychicObjectFocusResult");
static_assert(sizeof(FPsychicObjectFocusResult) == 0x000010, "Wrong size on FPsychicObjectFocusResult");
static_assert(offsetof(FPsychicObjectFocusResult, NormalObj) == 0x000000, "Member 'FPsychicObjectFocusResult::NormalObj' has a wrong offset!");
static_assert(offsetof(FPsychicObjectFocusResult, UniqueObj) == 0x000008, "Member 'FPsychicObjectFocusResult::UniqueObj' has a wrong offset!");

// ScriptStruct BattlePrototype.PsychicObjectEvaluateData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FPsychicObjectEvaluateData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPsychicObjectEvaluateData) == 0x000008, "Wrong alignment on FPsychicObjectEvaluateData");
static_assert(sizeof(FPsychicObjectEvaluateData) == 0x000010, "Wrong size on FPsychicObjectEvaluateData");

// ScriptStruct BattlePrototype.OneShopArrowLR
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FOneShopArrowLR final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOneShopArrowLR) == 0x000008, "Wrong alignment on FOneShopArrowLR");
static_assert(sizeof(FOneShopArrowLR) == 0x000040, "Wrong size on FOneShopArrowLR");

// ScriptStruct BattlePrototype.BondsPurposeMessageData
// 0x0010 (0x0018 - 0x0008)
struct FBondsPurposeMessageData final : public FTableRowBase
{
public:
	EPlayerID                                     HeroID;                                            // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TargetID;                                          // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         bondsProgress;                                     // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgID;                                             // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBondsPurposeMessageData) == 0x000008, "Wrong alignment on FBondsPurposeMessageData");
static_assert(sizeof(FBondsPurposeMessageData) == 0x000018, "Wrong size on FBondsPurposeMessageData");
static_assert(offsetof(FBondsPurposeMessageData, HeroID) == 0x000008, "Member 'FBondsPurposeMessageData::HeroID' has a wrong offset!");
static_assert(offsetof(FBondsPurposeMessageData, TargetID) == 0x000009, "Member 'FBondsPurposeMessageData::TargetID' has a wrong offset!");
static_assert(offsetof(FBondsPurposeMessageData, bondsProgress) == 0x00000C, "Member 'FBondsPurposeMessageData::bondsProgress' has a wrong offset!");
static_assert(offsetof(FBondsPurposeMessageData, MsgID) == 0x000010, "Member 'FBondsPurposeMessageData::MsgID' has a wrong offset!");

// ScriptStruct BattlePrototype.BondsEpisodeContentData
// 0x0028 (0x0028 - 0x0000)
struct FBondsEpisodeContentData final
{
public:
	class FName                                   MsgContent;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ImagePath;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConditionProgressNo;                               // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConditionFlags;                                    // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BondsProgressId;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBondsEpisodeContentData) == 0x000008, "Wrong alignment on FBondsEpisodeContentData");
static_assert(sizeof(FBondsEpisodeContentData) == 0x000028, "Wrong size on FBondsEpisodeContentData");
static_assert(offsetof(FBondsEpisodeContentData, MsgContent) == 0x000000, "Member 'FBondsEpisodeContentData::MsgContent' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeContentData, ImagePath) == 0x000008, "Member 'FBondsEpisodeContentData::ImagePath' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeContentData, ConditionProgressNo) == 0x000018, "Member 'FBondsEpisodeContentData::ConditionProgressNo' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeContentData, ConditionFlags) == 0x00001C, "Member 'FBondsEpisodeContentData::ConditionFlags' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeContentData, BondsProgressId) == 0x000024, "Member 'FBondsEpisodeContentData::BondsProgressId' has a wrong offset!");

// ScriptStruct BattlePrototype.BondsEpisodeDBDataCell
// 0x0040 (0x0048 - 0x0008)
struct FBondsEpisodeDBDataCell final : public FTableRowBase
{
public:
	EScenarioType                                 ScenarioType;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MsgListTitle;                                      // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgDetailTitle;                                    // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTeam;                                            // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     TargetBondsCharID;                                 // 0x001D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBondsEpisodeContentData>       ContentList;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShowDestinationBoolCheckType                 RelationshipOfConditions;                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBondsEpisodeDLCContent>        DLCContent;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBondsEpisodeDBDataCell) == 0x000008, "Wrong alignment on FBondsEpisodeDBDataCell");
static_assert(sizeof(FBondsEpisodeDBDataCell) == 0x000048, "Wrong size on FBondsEpisodeDBDataCell");
static_assert(offsetof(FBondsEpisodeDBDataCell, ScenarioType) == 0x000008, "Member 'FBondsEpisodeDBDataCell::ScenarioType' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeDBDataCell, MsgListTitle) == 0x00000C, "Member 'FBondsEpisodeDBDataCell::MsgListTitle' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeDBDataCell, MsgDetailTitle) == 0x000014, "Member 'FBondsEpisodeDBDataCell::MsgDetailTitle' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeDBDataCell, IsTeam) == 0x00001C, "Member 'FBondsEpisodeDBDataCell::IsTeam' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeDBDataCell, TargetBondsCharID) == 0x00001D, "Member 'FBondsEpisodeDBDataCell::TargetBondsCharID' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeDBDataCell, ContentList) == 0x000020, "Member 'FBondsEpisodeDBDataCell::ContentList' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeDBDataCell, RelationshipOfConditions) == 0x000030, "Member 'FBondsEpisodeDBDataCell::RelationshipOfConditions' has a wrong offset!");
static_assert(offsetof(FBondsEpisodeDBDataCell, DLCContent) == 0x000038, "Member 'FBondsEpisodeDBDataCell::DLCContent' has a wrong offset!");

// ScriptStruct BattlePrototype.MainQuestDBDataCell
// 0x0028 (0x0030 - 0x0008)
struct FMainQuestDBDataCell final : public FTableRowBase
{
public:
	EScenarioType                                 ScenarioType;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MsgListTitle;                                      // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgDetailTitle;                                    // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMainQuestContentData>          ContentList;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMainQuestDBDataCell) == 0x000008, "Wrong alignment on FMainQuestDBDataCell");
static_assert(sizeof(FMainQuestDBDataCell) == 0x000030, "Wrong size on FMainQuestDBDataCell");
static_assert(offsetof(FMainQuestDBDataCell, ScenarioType) == 0x000008, "Member 'FMainQuestDBDataCell::ScenarioType' has a wrong offset!");
static_assert(offsetof(FMainQuestDBDataCell, MsgListTitle) == 0x00000C, "Member 'FMainQuestDBDataCell::MsgListTitle' has a wrong offset!");
static_assert(offsetof(FMainQuestDBDataCell, MsgDetailTitle) == 0x000014, "Member 'FMainQuestDBDataCell::MsgDetailTitle' has a wrong offset!");
static_assert(offsetof(FMainQuestDBDataCell, ContentList) == 0x000020, "Member 'FMainQuestDBDataCell::ContentList' has a wrong offset!");

// ScriptStruct BattlePrototype.QuestContentData
// 0x0028 (0x0028 - 0x0000)
struct FQuestContentData final
{
public:
	class FName                                   MsgContent;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ImagePath;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConditionProgressNo;                               // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConditionFlags;                                    // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestContentData) == 0x000008, "Wrong alignment on FQuestContentData");
static_assert(sizeof(FQuestContentData) == 0x000028, "Wrong size on FQuestContentData");
static_assert(offsetof(FQuestContentData, MsgContent) == 0x000000, "Member 'FQuestContentData::MsgContent' has a wrong offset!");
static_assert(offsetof(FQuestContentData, ImagePath) == 0x000008, "Member 'FQuestContentData::ImagePath' has a wrong offset!");
static_assert(offsetof(FQuestContentData, ConditionProgressNo) == 0x000018, "Member 'FQuestContentData::ConditionProgressNo' has a wrong offset!");
static_assert(offsetof(FQuestContentData, ConditionFlags) == 0x00001C, "Member 'FQuestContentData::ConditionFlags' has a wrong offset!");

// ScriptStruct BattlePrototype.SubquestRequestRawData
// 0x0020 (0x0020 - 0x0000)
struct FSubquestRequestRawData final
{
public:
	ESubQuestRequestType                          RequestType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RequestID;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequestNum;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeansOfKillType                              MeansOfKill;                                       // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubquestRequestRawData) == 0x000008, "Wrong alignment on FSubquestRequestRawData");
static_assert(sizeof(FSubquestRequestRawData) == 0x000020, "Wrong size on FSubquestRequestRawData");
static_assert(offsetof(FSubquestRequestRawData, RequestType) == 0x000000, "Member 'FSubquestRequestRawData::RequestType' has a wrong offset!");
static_assert(offsetof(FSubquestRequestRawData, RequestID) == 0x000008, "Member 'FSubquestRequestRawData::RequestID' has a wrong offset!");
static_assert(offsetof(FSubquestRequestRawData, RequestNum) == 0x000018, "Member 'FSubquestRequestRawData::RequestNum' has a wrong offset!");
static_assert(offsetof(FSubquestRequestRawData, MeansOfKill) == 0x00001C, "Member 'FSubquestRequestRawData::MeansOfKill' has a wrong offset!");

// ScriptStruct BattlePrototype.SubQuestRawDBDataCell
// 0x0120 (0x0128 - 0x0008)
struct FSubQuestRawDBDataCell final : public FTableRowBase
{
public:
	class FName                                   SubQuestID;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScenarioType                                 ScenarioType;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MsgListTitle;                                      // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgDetailTitle;                                    // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgClientName;                                     // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgPlaceName;                                      // 0x002C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSubquestRequestRawData                RequestData0;                                      // 0x0038(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FSubquestRequestRawData                RequestData1;                                      // 0x0058(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FSubquestRequestRawData                RequestData2;                                      // 0x0078(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FSubquestRewardRawData                 RewardData0;                                       // 0x0098(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FSubquestRewardRawData                 RewardData1;                                       // 0x00B8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FSubquestRewardRawData                 RewardData2;                                       // 0x00D8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class FString                                 ContentDataImage;                                  // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ContentDataText1;                                  // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ContentDataText2;                                  // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConditionProgressNo;                               // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConditionFlag;                                     // 0x011C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubQuestRawDBDataCell) == 0x000008, "Wrong alignment on FSubQuestRawDBDataCell");
static_assert(sizeof(FSubQuestRawDBDataCell) == 0x000128, "Wrong size on FSubQuestRawDBDataCell");
static_assert(offsetof(FSubQuestRawDBDataCell, SubQuestID) == 0x000008, "Member 'FSubQuestRawDBDataCell::SubQuestID' has a wrong offset!");
static_assert(offsetof(FSubQuestRawDBDataCell, ScenarioType) == 0x000010, "Member 'FSubQuestRawDBDataCell::ScenarioType' has a wrong offset!");
static_assert(offsetof(FSubQuestRawDBDataCell, MsgListTitle) == 0x000014, "Member 'FSubQuestRawDBDataCell::MsgListTitle' has a wrong offset!");
static_assert(offsetof(FSubQuestRawDBDataCell, MsgDetailTitle) == 0x00001C, "Member 'FSubQuestRawDBDataCell::MsgDetailTitle' has a wrong offset!");
static_assert(offsetof(FSubQuestRawDBDataCell, MsgClientName) == 0x000024, "Member 'FSubQuestRawDBDataCell::MsgClientName' has a wrong offset!");
static_assert(offsetof(FSubQuestRawDBDataCell, MsgPlaceName) == 0x00002C, "Member 'FSubQuestRawDBDataCell::MsgPlaceName' has a wrong offset!");
static_assert(offsetof(FSubQuestRawDBDataCell, RequestData0) == 0x000038, "Member 'FSubQuestRawDBDataCell::RequestData0' has a wrong offset!");
static_assert(offsetof(FSubQuestRawDBDataCell, RequestData1) == 0x000058, "Member 'FSubQuestRawDBDataCell::RequestData1' has a wrong offset!");
static_assert(offsetof(FSubQuestRawDBDataCell, RequestData2) == 0x000078, "Member 'FSubQuestRawDBDataCell::RequestData2' has a wrong offset!");
static_assert(offsetof(FSubQuestRawDBDataCell, RewardData0) == 0x000098, "Member 'FSubQuestRawDBDataCell::RewardData0' has a wrong offset!");
static_assert(offsetof(FSubQuestRawDBDataCell, RewardData1) == 0x0000B8, "Member 'FSubQuestRawDBDataCell::RewardData1' has a wrong offset!");
static_assert(offsetof(FSubQuestRawDBDataCell, RewardData2) == 0x0000D8, "Member 'FSubQuestRawDBDataCell::RewardData2' has a wrong offset!");
static_assert(offsetof(FSubQuestRawDBDataCell, ContentDataImage) == 0x0000F8, "Member 'FSubQuestRawDBDataCell::ContentDataImage' has a wrong offset!");
static_assert(offsetof(FSubQuestRawDBDataCell, ContentDataText1) == 0x000108, "Member 'FSubQuestRawDBDataCell::ContentDataText1' has a wrong offset!");
static_assert(offsetof(FSubQuestRawDBDataCell, ContentDataText2) == 0x000110, "Member 'FSubQuestRawDBDataCell::ContentDataText2' has a wrong offset!");
static_assert(offsetof(FSubQuestRawDBDataCell, ConditionProgressNo) == 0x000118, "Member 'FSubQuestRawDBDataCell::ConditionProgressNo' has a wrong offset!");
static_assert(offsetof(FSubQuestRawDBDataCell, ConditionFlag) == 0x00011C, "Member 'FSubQuestRawDBDataCell::ConditionFlag' has a wrong offset!");

// ScriptStruct BattlePrototype.DLCBondsStartCharData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FDLCBondsStartCharData final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDLCBondsStartCharData) == 0x000004, "Wrong alignment on FDLCBondsStartCharData");
static_assert(sizeof(FDLCBondsStartCharData) == 0x00000C, "Wrong size on FDLCBondsStartCharData");

// ScriptStruct BattlePrototype.ProgressRateQuestParams
// 0x0006 (0x0008 - 0x0002)
struct alignas(0x04) FProgressRateQuestParams final : public FQuestParams
{
public:
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProgressRateQuestParams) == 0x000004, "Wrong alignment on FProgressRateQuestParams");
static_assert(sizeof(FProgressRateQuestParams) == 0x000008, "Wrong size on FProgressRateQuestParams");

// ScriptStruct BattlePrototype.RadialBlurData
// 0x0038 (0x0038 - 0x0000)
struct FRadialBlurData final
{
public:
	int32                                         Priority;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           CurveVector;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timer;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinishTime;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorModulate;                                     // 0x0024(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRadialBlurData) == 0x000008, "Wrong alignment on FRadialBlurData");
static_assert(sizeof(FRadialBlurData) == 0x000038, "Wrong size on FRadialBlurData");
static_assert(offsetof(FRadialBlurData, Priority) == 0x000000, "Member 'FRadialBlurData::Priority' has a wrong offset!");
static_assert(offsetof(FRadialBlurData, CurveVector) == 0x000008, "Member 'FRadialBlurData::CurveVector' has a wrong offset!");
static_assert(offsetof(FRadialBlurData, Timer) == 0x000010, "Member 'FRadialBlurData::Timer' has a wrong offset!");
static_assert(offsetof(FRadialBlurData, FinishTime) == 0x000014, "Member 'FRadialBlurData::FinishTime' has a wrong offset!");
static_assert(offsetof(FRadialBlurData, Location) == 0x000018, "Member 'FRadialBlurData::Location' has a wrong offset!");
static_assert(offsetof(FRadialBlurData, ColorModulate) == 0x000024, "Member 'FRadialBlurData::ColorModulate' has a wrong offset!");

// ScriptStruct BattlePrototype.UIMain3DManagerEquipData
// 0x0100 (0x0100 - 0x0000)
struct FUIMain3DManagerEquipData final
{
public:
	struct FItemDataCell                          EquipWeapon;                                       // 0x0000(0x0078)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FItemDataCell                          EquipCostume;                                      // 0x0078(0x0078)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FItemDataCell>                  EquipAttachment;                                   // 0x00F0(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIMain3DManagerEquipData) == 0x000008, "Wrong alignment on FUIMain3DManagerEquipData");
static_assert(sizeof(FUIMain3DManagerEquipData) == 0x000100, "Wrong size on FUIMain3DManagerEquipData");
static_assert(offsetof(FUIMain3DManagerEquipData, EquipWeapon) == 0x000000, "Member 'FUIMain3DManagerEquipData::EquipWeapon' has a wrong offset!");
static_assert(offsetof(FUIMain3DManagerEquipData, EquipCostume) == 0x000078, "Member 'FUIMain3DManagerEquipData::EquipCostume' has a wrong offset!");
static_assert(offsetof(FUIMain3DManagerEquipData, EquipAttachment) == 0x0000F0, "Member 'FUIMain3DManagerEquipData::EquipAttachment' has a wrong offset!");

// ScriptStruct BattlePrototype.REDLocalizeImageParam
// 0x0014 (0x0014 - 0x0000)
struct FREDLocalizeImageParam final
{
public:
	ELanguageTextPattern                          Pattern;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                Padding;                                           // 0x0004(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FREDLocalizeImageParam) == 0x000004, "Wrong alignment on FREDLocalizeImageParam");
static_assert(sizeof(FREDLocalizeImageParam) == 0x000014, "Wrong size on FREDLocalizeImageParam");
static_assert(offsetof(FREDLocalizeImageParam, Pattern) == 0x000000, "Member 'FREDLocalizeImageParam::Pattern' has a wrong offset!");
static_assert(offsetof(FREDLocalizeImageParam, Padding) == 0x000004, "Member 'FREDLocalizeImageParam::Padding' has a wrong offset!");

// ScriptStruct BattlePrototype.RedScrollBoxWork
// 0x0018 (0x0018 - 0x0000)
struct FRedScrollBoxWork final
{
public:
	class UUserWidget*                            PElementWidget;                                    // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRedScrollBoxWork) == 0x000008, "Wrong alignment on FRedScrollBoxWork");
static_assert(sizeof(FRedScrollBoxWork) == 0x000018, "Wrong size on FRedScrollBoxWork");
static_assert(offsetof(FRedScrollBoxWork, PElementWidget) == 0x000000, "Member 'FRedScrollBoxWork::PElementWidget' has a wrong offset!");

// ScriptStruct BattlePrototype.REDLocalizeTextParam
// 0x0014 (0x0014 - 0x0000)
struct FREDLocalizeTextParam final
{
public:
	ELanguageTextPattern                          Pattern;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FontSize;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RenderTrans;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineHeightPercentage;                              // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FREDLocalizeTextParam) == 0x000004, "Wrong alignment on FREDLocalizeTextParam");
static_assert(sizeof(FREDLocalizeTextParam) == 0x000014, "Wrong size on FREDLocalizeTextParam");
static_assert(offsetof(FREDLocalizeTextParam, Pattern) == 0x000000, "Member 'FREDLocalizeTextParam::Pattern' has a wrong offset!");
static_assert(offsetof(FREDLocalizeTextParam, FontSize) == 0x000004, "Member 'FREDLocalizeTextParam::FontSize' has a wrong offset!");
static_assert(offsetof(FREDLocalizeTextParam, RenderTrans) == 0x000008, "Member 'FREDLocalizeTextParam::RenderTrans' has a wrong offset!");
static_assert(offsetof(FREDLocalizeTextParam, LineHeightPercentage) == 0x000010, "Member 'FREDLocalizeTextParam::LineHeightPercentage' has a wrong offset!");

// ScriptStruct BattlePrototype.OneString
// 0x00D0 (0x00D0 - 0x0000)
struct FOneString final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTextBlock*>                     M_textBlockArray;                                  // 0x0020(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         M_iconFontArray;                                   // 0x0030(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x90];                                      // 0x0040(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOneString) == 0x000008, "Wrong alignment on FOneString");
static_assert(sizeof(FOneString) == 0x0000D0, "Wrong size on FOneString");
static_assert(offsetof(FOneString, M_textBlockArray) == 0x000020, "Member 'FOneString::M_textBlockArray' has a wrong offset!");
static_assert(offsetof(FOneString, M_iconFontArray) == 0x000030, "Member 'FOneString::M_iconFontArray' has a wrong offset!");

// ScriptStruct BattlePrototype.RenderingSettingsDataTable
// 0x0078 (0x0080 - 0x0008)
struct FRenderingSettingsDataTable final : public FTableRowBase
{
public:
	struct FRenderingSettings                     Setting;                                           // 0x0008(0x0078)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRenderingSettingsDataTable) == 0x000008, "Wrong alignment on FRenderingSettingsDataTable");
static_assert(sizeof(FRenderingSettingsDataTable) == 0x000080, "Wrong size on FRenderingSettingsDataTable");
static_assert(offsetof(FRenderingSettingsDataTable, Setting) == 0x000008, "Member 'FRenderingSettingsDataTable::Setting' has a wrong offset!");

// ScriptStruct BattlePrototype.ResourceMipPrestreamEventTable
// 0x0030 (0x0038 - 0x0008)
struct FResourceMipPrestreamEventTable final : public FTableRowBase
{
public:
	TArray<class FName>                           MeshSettingName;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           OptionalMeshSettingName;                           // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           HighPriorityMeshSettingName;                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FResourceMipPrestreamEventTable) == 0x000008, "Wrong alignment on FResourceMipPrestreamEventTable");
static_assert(sizeof(FResourceMipPrestreamEventTable) == 0x000038, "Wrong size on FResourceMipPrestreamEventTable");
static_assert(offsetof(FResourceMipPrestreamEventTable, MeshSettingName) == 0x000008, "Member 'FResourceMipPrestreamEventTable::MeshSettingName' has a wrong offset!");
static_assert(offsetof(FResourceMipPrestreamEventTable, OptionalMeshSettingName) == 0x000018, "Member 'FResourceMipPrestreamEventTable::OptionalMeshSettingName' has a wrong offset!");
static_assert(offsetof(FResourceMipPrestreamEventTable, HighPriorityMeshSettingName) == 0x000028, "Member 'FResourceMipPrestreamEventTable::HighPriorityMeshSettingName' has a wrong offset!");

// ScriptStruct BattlePrototype.AjitoMemberAnimInfo
// 0x0048 (0x0050 - 0x0008)
struct FAjitoMemberAnimInfo final : public FTableRowBase
{
public:
	class UAnimSequence*                          AnimSeq_IdleLoop1;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSeq_IdleStart1;                                // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSeq_IdleEnd1;                                  // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSeq_IdleLoop2;                                 // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSeq_IdleStart2;                                // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSeq_IdleEnd2;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSeq_TalkLoop;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSeq_TalkStart;                                 // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSeq_TalkEnd;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAjitoMemberAnimInfo) == 0x000008, "Wrong alignment on FAjitoMemberAnimInfo");
static_assert(sizeof(FAjitoMemberAnimInfo) == 0x000050, "Wrong size on FAjitoMemberAnimInfo");
static_assert(offsetof(FAjitoMemberAnimInfo, AnimSeq_IdleLoop1) == 0x000008, "Member 'FAjitoMemberAnimInfo::AnimSeq_IdleLoop1' has a wrong offset!");
static_assert(offsetof(FAjitoMemberAnimInfo, AnimSeq_IdleStart1) == 0x000010, "Member 'FAjitoMemberAnimInfo::AnimSeq_IdleStart1' has a wrong offset!");
static_assert(offsetof(FAjitoMemberAnimInfo, AnimSeq_IdleEnd1) == 0x000018, "Member 'FAjitoMemberAnimInfo::AnimSeq_IdleEnd1' has a wrong offset!");
static_assert(offsetof(FAjitoMemberAnimInfo, AnimSeq_IdleLoop2) == 0x000020, "Member 'FAjitoMemberAnimInfo::AnimSeq_IdleLoop2' has a wrong offset!");
static_assert(offsetof(FAjitoMemberAnimInfo, AnimSeq_IdleStart2) == 0x000028, "Member 'FAjitoMemberAnimInfo::AnimSeq_IdleStart2' has a wrong offset!");
static_assert(offsetof(FAjitoMemberAnimInfo, AnimSeq_IdleEnd2) == 0x000030, "Member 'FAjitoMemberAnimInfo::AnimSeq_IdleEnd2' has a wrong offset!");
static_assert(offsetof(FAjitoMemberAnimInfo, AnimSeq_TalkLoop) == 0x000038, "Member 'FAjitoMemberAnimInfo::AnimSeq_TalkLoop' has a wrong offset!");
static_assert(offsetof(FAjitoMemberAnimInfo, AnimSeq_TalkStart) == 0x000040, "Member 'FAjitoMemberAnimInfo::AnimSeq_TalkStart' has a wrong offset!");
static_assert(offsetof(FAjitoMemberAnimInfo, AnimSeq_TalkEnd) == 0x000048, "Member 'FAjitoMemberAnimInfo::AnimSeq_TalkEnd' has a wrong offset!");

// ScriptStruct BattlePrototype.DirectAttackDamageParam
// 0x01C8 (0x01C8 - 0x0000)
struct FDirectAttackDamageParam final
{
public:
	bool                                          bUseFixDamage;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FixDamage;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHCHitResult                           HitResult;                                         // 0x0008(0x01B8)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          IsForceCritical;                                   // 0x01C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDirectAttackDamageParam) == 0x000008, "Wrong alignment on FDirectAttackDamageParam");
static_assert(sizeof(FDirectAttackDamageParam) == 0x0001C8, "Wrong size on FDirectAttackDamageParam");
static_assert(offsetof(FDirectAttackDamageParam, bUseFixDamage) == 0x000000, "Member 'FDirectAttackDamageParam::bUseFixDamage' has a wrong offset!");
static_assert(offsetof(FDirectAttackDamageParam, FixDamage) == 0x000004, "Member 'FDirectAttackDamageParam::FixDamage' has a wrong offset!");
static_assert(offsetof(FDirectAttackDamageParam, HitResult) == 0x000008, "Member 'FDirectAttackDamageParam::HitResult' has a wrong offset!");
static_assert(offsetof(FDirectAttackDamageParam, IsForceCritical) == 0x0001C0, "Member 'FDirectAttackDamageParam::IsForceCritical' has a wrong offset!");

// ScriptStruct BattlePrototype.RSResultCapsule
// 0x001C (0x001C - 0x0000)
struct FRSResultCapsule final
{
public:
	struct FVector                                NearPos0;                                          // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NearPos1;                                          // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverlapLength;                                     // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRSResultCapsule) == 0x000004, "Wrong alignment on FRSResultCapsule");
static_assert(sizeof(FRSResultCapsule) == 0x00001C, "Wrong size on FRSResultCapsule");
static_assert(offsetof(FRSResultCapsule, NearPos0) == 0x000000, "Member 'FRSResultCapsule::NearPos0' has a wrong offset!");
static_assert(offsetof(FRSResultCapsule, NearPos1) == 0x00000C, "Member 'FRSResultCapsule::NearPos1' has a wrong offset!");
static_assert(offsetof(FRSResultCapsule, OverlapLength) == 0x000018, "Member 'FRSResultCapsule::OverlapLength' has a wrong offset!");

// ScriptStruct BattlePrototype.RSBeamEffectInfo
// 0x0030 (0x0030 - 0x0000)
struct FRSBeamEffectInfo final
{
public:
	class URSParticleSystemComponentBase*         Handle;                                            // 0x0000(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectName;                                        // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEffectConnectPoint                           SourceConnectPoint;                                // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SourceSocketName;                                  // 0x0014(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEffectConnectPoint                           TargetConnectPoint;                                // 0x001C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetSocketName;                                  // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Param;                                             // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRSBeamEffectInfo) == 0x000008, "Wrong alignment on FRSBeamEffectInfo");
static_assert(sizeof(FRSBeamEffectInfo) == 0x000030, "Wrong size on FRSBeamEffectInfo");
static_assert(offsetof(FRSBeamEffectInfo, Handle) == 0x000000, "Member 'FRSBeamEffectInfo::Handle' has a wrong offset!");
static_assert(offsetof(FRSBeamEffectInfo, ObjectName) == 0x000008, "Member 'FRSBeamEffectInfo::ObjectName' has a wrong offset!");
static_assert(offsetof(FRSBeamEffectInfo, SourceConnectPoint) == 0x000010, "Member 'FRSBeamEffectInfo::SourceConnectPoint' has a wrong offset!");
static_assert(offsetof(FRSBeamEffectInfo, SourceSocketName) == 0x000014, "Member 'FRSBeamEffectInfo::SourceSocketName' has a wrong offset!");
static_assert(offsetof(FRSBeamEffectInfo, TargetConnectPoint) == 0x00001C, "Member 'FRSBeamEffectInfo::TargetConnectPoint' has a wrong offset!");
static_assert(offsetof(FRSBeamEffectInfo, TargetSocketName) == 0x000020, "Member 'FRSBeamEffectInfo::TargetSocketName' has a wrong offset!");
static_assert(offsetof(FRSBeamEffectInfo, Param) == 0x000028, "Member 'FRSBeamEffectInfo::Param' has a wrong offset!");

// ScriptStruct BattlePrototype.RSEffectObjectDebrisSetting
// 0x0018 (0x0018 - 0x0000)
struct FRSEffectObjectDebrisSetting final
{
public:
	bool                                          UseParticle;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        Particle;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMaterialOverride;                               // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaterialSlot;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRSEffectObjectDebrisSetting) == 0x000008, "Wrong alignment on FRSEffectObjectDebrisSetting");
static_assert(sizeof(FRSEffectObjectDebrisSetting) == 0x000018, "Wrong size on FRSEffectObjectDebrisSetting");
static_assert(offsetof(FRSEffectObjectDebrisSetting, UseParticle) == 0x000000, "Member 'FRSEffectObjectDebrisSetting::UseParticle' has a wrong offset!");
static_assert(offsetof(FRSEffectObjectDebrisSetting, Particle) == 0x000008, "Member 'FRSEffectObjectDebrisSetting::Particle' has a wrong offset!");
static_assert(offsetof(FRSEffectObjectDebrisSetting, UseMaterialOverride) == 0x000010, "Member 'FRSEffectObjectDebrisSetting::UseMaterialOverride' has a wrong offset!");
static_assert(offsetof(FRSEffectObjectDebrisSetting, MaterialSlot) == 0x000014, "Member 'FRSEffectObjectDebrisSetting::MaterialSlot' has a wrong offset!");

// ScriptStruct BattlePrototype.RSEffectObjectDebris
// 0x0008 (0x0010 - 0x0008)
struct FRSEffectObjectDebris final : public FTableRowBase
{
public:
	class UParticleSystem*                        Particle;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRSEffectObjectDebris) == 0x000008, "Wrong alignment on FRSEffectObjectDebris");
static_assert(sizeof(FRSEffectObjectDebris) == 0x000010, "Wrong size on FRSEffectObjectDebris");
static_assert(offsetof(FRSEffectObjectDebris, Particle) == 0x000008, "Member 'FRSEffectObjectDebris::Particle' has a wrong offset!");

// ScriptStruct BattlePrototype.TinyIKInfo
// 0x0024 (0x0024 - 0x0000)
struct FTinyIKInfo final
{
public:
	class FName                                   GroundCheckSocketName;                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectorSocketName;                                // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundCheckOffsetHeight;                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolateSpeed;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IKLocation;                                        // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTinyIKInfo) == 0x000004, "Wrong alignment on FTinyIKInfo");
static_assert(sizeof(FTinyIKInfo) == 0x000024, "Wrong size on FTinyIKInfo");
static_assert(offsetof(FTinyIKInfo, GroundCheckSocketName) == 0x000000, "Member 'FTinyIKInfo::GroundCheckSocketName' has a wrong offset!");
static_assert(offsetof(FTinyIKInfo, EffectorSocketName) == 0x000008, "Member 'FTinyIKInfo::EffectorSocketName' has a wrong offset!");
static_assert(offsetof(FTinyIKInfo, GroundCheckOffsetHeight) == 0x000010, "Member 'FTinyIKInfo::GroundCheckOffsetHeight' has a wrong offset!");
static_assert(offsetof(FTinyIKInfo, InterpolateSpeed) == 0x000014, "Member 'FTinyIKInfo::InterpolateSpeed' has a wrong offset!");
static_assert(offsetof(FTinyIKInfo, IKLocation) == 0x000018, "Member 'FTinyIKInfo::IKLocation' has a wrong offset!");

// ScriptStruct BattlePrototype.SkipStruct
// 0x0008 (0x0008 - 0x0000)
struct FSkipStruct final
{
public:
	class FName                                   SkipName;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkipStruct) == 0x000004, "Wrong alignment on FSkipStruct");
static_assert(sizeof(FSkipStruct) == 0x000008, "Wrong size on FSkipStruct");
static_assert(offsetof(FSkipStruct, SkipName) == 0x000000, "Member 'FSkipStruct::SkipName' has a wrong offset!");

// ScriptStruct BattlePrototype.Hoge
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FHoge final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoge) == 0x000004, "Wrong alignment on FHoge");
static_assert(sizeof(FHoge) == 0x000004, "Wrong size on FHoge");

// ScriptStruct BattlePrototype.UILoading3DSceneCharacterData
// 0x0048 (0x0048 - 0x0000)
struct FUILoading3DSceneCharacterData final
{
public:
	EPlayerID                                     PlayerId;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationX;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Depth;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeedScale;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            AnimationAsset;                                    // 0x0020(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUILoading3DSceneCharacterData) == 0x000008, "Wrong alignment on FUILoading3DSceneCharacterData");
static_assert(sizeof(FUILoading3DSceneCharacterData) == 0x000048, "Wrong size on FUILoading3DSceneCharacterData");
static_assert(offsetof(FUILoading3DSceneCharacterData, PlayerId) == 0x000000, "Member 'FUILoading3DSceneCharacterData::PlayerId' has a wrong offset!");
static_assert(offsetof(FUILoading3DSceneCharacterData, LocationX) == 0x000004, "Member 'FUILoading3DSceneCharacterData::LocationX' has a wrong offset!");
static_assert(offsetof(FUILoading3DSceneCharacterData, Depth) == 0x000008, "Member 'FUILoading3DSceneCharacterData::Depth' has a wrong offset!");
static_assert(offsetof(FUILoading3DSceneCharacterData, Rotation) == 0x00000C, "Member 'FUILoading3DSceneCharacterData::Rotation' has a wrong offset!");
static_assert(offsetof(FUILoading3DSceneCharacterData, Scale) == 0x000018, "Member 'FUILoading3DSceneCharacterData::Scale' has a wrong offset!");
static_assert(offsetof(FUILoading3DSceneCharacterData, MoveSpeedScale) == 0x00001C, "Member 'FUILoading3DSceneCharacterData::MoveSpeedScale' has a wrong offset!");
static_assert(offsetof(FUILoading3DSceneCharacterData, AnimationAsset) == 0x000020, "Member 'FUILoading3DSceneCharacterData::AnimationAsset' has a wrong offset!");

// ScriptStruct BattlePrototype.UILoading3DSceneData
// 0x0018 (0x0020 - 0x0008)
struct FUILoading3DSceneData final : public FTableRowBase
{
public:
	TArray<struct FUILoading3DSceneCharacterData> Characters;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CameraOffset;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUILoading3DSceneData) == 0x000008, "Wrong alignment on FUILoading3DSceneData");
static_assert(sizeof(FUILoading3DSceneData) == 0x000020, "Wrong size on FUILoading3DSceneData");
static_assert(offsetof(FUILoading3DSceneData, Characters) == 0x000008, "Member 'FUILoading3DSceneData::Characters' has a wrong offset!");
static_assert(offsetof(FUILoading3DSceneData, CameraOffset) == 0x000018, "Member 'FUILoading3DSceneData::CameraOffset' has a wrong offset!");

// ScriptStruct BattlePrototype.MeshMaterialOverrideParameters
// 0x0460 (0x0460 - 0x0000)
struct alignas(0x08) FMeshMaterialOverrideParameters final
{
public:
	uint8                                         Pad_0[0x460];                                      // 0x0000(0x0460)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMeshMaterialOverrideParameters) == 0x000008, "Wrong alignment on FMeshMaterialOverrideParameters");
static_assert(sizeof(FMeshMaterialOverrideParameters) == 0x000460, "Wrong size on FMeshMaterialOverrideParameters");

// ScriptStruct BattlePrototype.MaterialOverrideParameters
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FMaterialOverrideParameters final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaterialOverrideParameters) == 0x000008, "Wrong alignment on FMaterialOverrideParameters");
static_assert(sizeof(FMaterialOverrideParameters) == 0x000030, "Wrong size on FMaterialOverrideParameters");

// ScriptStruct BattlePrototype.EventPlAnimationCurveParam
// 0x0014 (0x0014 - 0x0000)
struct FEventPlAnimationCurveParam final
{
public:
	ECurveParamType                               CurveParamType;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   JointID;                                           // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurveName;                                         // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventPlAnimationCurveParam) == 0x000004, "Wrong alignment on FEventPlAnimationCurveParam");
static_assert(sizeof(FEventPlAnimationCurveParam) == 0x000014, "Wrong size on FEventPlAnimationCurveParam");
static_assert(offsetof(FEventPlAnimationCurveParam, CurveParamType) == 0x000000, "Member 'FEventPlAnimationCurveParam::CurveParamType' has a wrong offset!");
static_assert(offsetof(FEventPlAnimationCurveParam, JointID) == 0x000004, "Member 'FEventPlAnimationCurveParam::JointID' has a wrong offset!");
static_assert(offsetof(FEventPlAnimationCurveParam, CurveName) == 0x00000C, "Member 'FEventPlAnimationCurveParam::CurveName' has a wrong offset!");

// ScriptStruct BattlePrototype.ParallelData
// 0x0010 (0x0010 - 0x0000)
struct FParallelData final
{
public:
	TArray<TWeakObjectPtr<class UObject>>         _ObjectArray;                                      // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParallelData) == 0x000008, "Wrong alignment on FParallelData");
static_assert(sizeof(FParallelData) == 0x000010, "Wrong size on FParallelData");
static_assert(offsetof(FParallelData, _ObjectArray) == 0x000000, "Member 'FParallelData::_ObjectArray' has a wrong offset!");

// ScriptStruct BattlePrototype.ParticleSystemBackGroundParameter
// 0x0008 (0x0010 - 0x0008)
struct FParticleSystemBackGroundParameter final : public FTableRowBase
{
public:
	float                                         CellSize;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FParticleSystemBackGroundParameter) == 0x000008, "Wrong alignment on FParticleSystemBackGroundParameter");
static_assert(sizeof(FParticleSystemBackGroundParameter) == 0x000010, "Wrong size on FParticleSystemBackGroundParameter");
static_assert(offsetof(FParticleSystemBackGroundParameter, CellSize) == 0x000008, "Member 'FParticleSystemBackGroundParameter::CellSize' has a wrong offset!");

// ScriptStruct BattlePrototype.SaveDataParameter
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FSaveDataParameter final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveDataParameter) == 0x000008, "Wrong alignment on FSaveDataParameter");
static_assert(sizeof(FSaveDataParameter) == 0x000018, "Wrong size on FSaveDataParameter");

// ScriptStruct BattlePrototype.SaveDataSlotBuffer
// 0x0010 (0x0010 - 0x0000)
struct FSaveDataSlotBuffer final
{
public:
	TArray<uint8>                                 M_buf;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSaveDataSlotBuffer) == 0x000008, "Wrong alignment on FSaveDataSlotBuffer");
static_assert(sizeof(FSaveDataSlotBuffer) == 0x000010, "Wrong size on FSaveDataSlotBuffer");
static_assert(offsetof(FSaveDataSlotBuffer, M_buf) == 0x000000, "Member 'FSaveDataSlotBuffer::M_buf' has a wrong offset!");

// ScriptStruct BattlePrototype.RSSaveGameHeader
// 0x0020 (0x0020 - 0x0000)
struct FRSSaveGameHeader final
{
public:
	TArray<uint8>                                 Identifier;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Version;                                           // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERSSaveGameSaveType                           Type;                                              // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AppVersion;                                        // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        TotalSize;                                         // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRSSaveGameHeader) == 0x000008, "Wrong alignment on FRSSaveGameHeader");
static_assert(sizeof(FRSSaveGameHeader) == 0x000020, "Wrong size on FRSSaveGameHeader");
static_assert(offsetof(FRSSaveGameHeader, Identifier) == 0x000000, "Member 'FRSSaveGameHeader::Identifier' has a wrong offset!");
static_assert(offsetof(FRSSaveGameHeader, Version) == 0x000010, "Member 'FRSSaveGameHeader::Version' has a wrong offset!");
static_assert(offsetof(FRSSaveGameHeader, Type) == 0x000014, "Member 'FRSSaveGameHeader::Type' has a wrong offset!");
static_assert(offsetof(FRSSaveGameHeader, AppVersion) == 0x000018, "Member 'FRSSaveGameHeader::AppVersion' has a wrong offset!");
static_assert(offsetof(FRSSaveGameHeader, TotalSize) == 0x00001C, "Member 'FRSSaveGameHeader::TotalSize' has a wrong offset!");

// ScriptStruct BattlePrototype.RSSkeletalMeshMergeParams
// 0x0030 (0x0030 - 0x0000)
struct FRSSkeletalMeshMergeParams final
{
public:
	TArray<class USkeletalMesh*>                  MeshesToMerge;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StripTopLODS;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNeedsCpuAccess : 1;                               // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bKeepPhysicsAsset : 1;                             // 0x0014(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bKeepShadowPhysicsAsset : 1;                       // 0x0014(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSkeletonBefore : 1;                               // 0x0014(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeleton*                              Skeleton;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DebugName;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRSSkeletalMeshMergeParams) == 0x000008, "Wrong alignment on FRSSkeletalMeshMergeParams");
static_assert(sizeof(FRSSkeletalMeshMergeParams) == 0x000030, "Wrong size on FRSSkeletalMeshMergeParams");
static_assert(offsetof(FRSSkeletalMeshMergeParams, MeshesToMerge) == 0x000000, "Member 'FRSSkeletalMeshMergeParams::MeshesToMerge' has a wrong offset!");
static_assert(offsetof(FRSSkeletalMeshMergeParams, StripTopLODS) == 0x000010, "Member 'FRSSkeletalMeshMergeParams::StripTopLODS' has a wrong offset!");
static_assert(offsetof(FRSSkeletalMeshMergeParams, Skeleton) == 0x000018, "Member 'FRSSkeletalMeshMergeParams::Skeleton' has a wrong offset!");
static_assert(offsetof(FRSSkeletalMeshMergeParams, DebugName) == 0x000020, "Member 'FRSSkeletalMeshMergeParams::DebugName' has a wrong offset!");

// ScriptStruct BattlePrototype.WorldmapOpenAreaParam
// 0x0028 (0x0028 - 0x0000)
struct FWorldmapOpenAreaParam final
{
public:
	int32                                         LocationNo;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LocationId;                                        // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaNo;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaId;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PortalNo;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PortalID;                                          // 0x001C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOpened;                                          // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSelectable;                                      // 0x0025(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewOpened;                                       // 0x0026(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWorldmapOpenAreaParam) == 0x000004, "Wrong alignment on FWorldmapOpenAreaParam");
static_assert(sizeof(FWorldmapOpenAreaParam) == 0x000028, "Wrong size on FWorldmapOpenAreaParam");
static_assert(offsetof(FWorldmapOpenAreaParam, LocationNo) == 0x000000, "Member 'FWorldmapOpenAreaParam::LocationNo' has a wrong offset!");
static_assert(offsetof(FWorldmapOpenAreaParam, LocationId) == 0x000004, "Member 'FWorldmapOpenAreaParam::LocationId' has a wrong offset!");
static_assert(offsetof(FWorldmapOpenAreaParam, AreaNo) == 0x00000C, "Member 'FWorldmapOpenAreaParam::AreaNo' has a wrong offset!");
static_assert(offsetof(FWorldmapOpenAreaParam, AreaId) == 0x000010, "Member 'FWorldmapOpenAreaParam::AreaId' has a wrong offset!");
static_assert(offsetof(FWorldmapOpenAreaParam, PortalNo) == 0x000018, "Member 'FWorldmapOpenAreaParam::PortalNo' has a wrong offset!");
static_assert(offsetof(FWorldmapOpenAreaParam, PortalID) == 0x00001C, "Member 'FWorldmapOpenAreaParam::PortalID' has a wrong offset!");
static_assert(offsetof(FWorldmapOpenAreaParam, IsOpened) == 0x000024, "Member 'FWorldmapOpenAreaParam::IsOpened' has a wrong offset!");
static_assert(offsetof(FWorldmapOpenAreaParam, IsSelectable) == 0x000025, "Member 'FWorldmapOpenAreaParam::IsSelectable' has a wrong offset!");
static_assert(offsetof(FWorldmapOpenAreaParam, IsNewOpened) == 0x000026, "Member 'FWorldmapOpenAreaParam::IsNewOpened' has a wrong offset!");

// ScriptStruct BattlePrototype.WorldmapOpenLCParam
// 0x0020 (0x0020 - 0x0000)
struct FWorldmapOpenLCParam final
{
public:
	int32                                         LocationNo;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LocationId;                                        // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOpened;                                          // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNotSelectable;                                   // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewOpened;                                       // 0x000E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWorldmapOpenAreaParam>         AreaParam;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWorldmapOpenLCParam) == 0x000008, "Wrong alignment on FWorldmapOpenLCParam");
static_assert(sizeof(FWorldmapOpenLCParam) == 0x000020, "Wrong size on FWorldmapOpenLCParam");
static_assert(offsetof(FWorldmapOpenLCParam, LocationNo) == 0x000000, "Member 'FWorldmapOpenLCParam::LocationNo' has a wrong offset!");
static_assert(offsetof(FWorldmapOpenLCParam, LocationId) == 0x000004, "Member 'FWorldmapOpenLCParam::LocationId' has a wrong offset!");
static_assert(offsetof(FWorldmapOpenLCParam, IsOpened) == 0x00000C, "Member 'FWorldmapOpenLCParam::IsOpened' has a wrong offset!");
static_assert(offsetof(FWorldmapOpenLCParam, IsNotSelectable) == 0x00000D, "Member 'FWorldmapOpenLCParam::IsNotSelectable' has a wrong offset!");
static_assert(offsetof(FWorldmapOpenLCParam, IsNewOpened) == 0x00000E, "Member 'FWorldmapOpenLCParam::IsNewOpened' has a wrong offset!");
static_assert(offsetof(FWorldmapOpenLCParam, AreaParam) == 0x000010, "Member 'FWorldmapOpenLCParam::AreaParam' has a wrong offset!");

// ScriptStruct BattlePrototype.RSCollisionSound
// 0x0020 (0x0028 - 0x0008)
struct FRSCollisionSound final : public FTableRowBase
{
public:
	class USoundAtomCue*                          LargeHitSound;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          SmallHitSound;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          LargeRollSound;                                    // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          SmallRollSound;                                    // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRSCollisionSound) == 0x000008, "Wrong alignment on FRSCollisionSound");
static_assert(sizeof(FRSCollisionSound) == 0x000028, "Wrong size on FRSCollisionSound");
static_assert(offsetof(FRSCollisionSound, LargeHitSound) == 0x000008, "Member 'FRSCollisionSound::LargeHitSound' has a wrong offset!");
static_assert(offsetof(FRSCollisionSound, SmallHitSound) == 0x000010, "Member 'FRSCollisionSound::SmallHitSound' has a wrong offset!");
static_assert(offsetof(FRSCollisionSound, LargeRollSound) == 0x000018, "Member 'FRSCollisionSound::LargeRollSound' has a wrong offset!");
static_assert(offsetof(FRSCollisionSound, SmallRollSound) == 0x000020, "Member 'FRSCollisionSound::SmallRollSound' has a wrong offset!");

// ScriptStruct BattlePrototype.RSCollisionSoundInfo
// 0x0010 (0x0010 - 0x0000)
struct FRSCollisionSoundInfo final
{
public:
	class UPhysicalMaterial*                      PhysicalMaterialOwner;                             // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      PhysicalMaterialOther;                             // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRSCollisionSoundInfo) == 0x000008, "Wrong alignment on FRSCollisionSoundInfo");
static_assert(sizeof(FRSCollisionSoundInfo) == 0x000010, "Wrong size on FRSCollisionSoundInfo");
static_assert(offsetof(FRSCollisionSoundInfo, PhysicalMaterialOwner) == 0x000000, "Member 'FRSCollisionSoundInfo::PhysicalMaterialOwner' has a wrong offset!");
static_assert(offsetof(FRSCollisionSoundInfo, PhysicalMaterialOther) == 0x000008, "Member 'FRSCollisionSoundInfo::PhysicalMaterialOther' has a wrong offset!");

// ScriptStruct BattlePrototype.EffectVolumeCategory
// 0x0018 (0x0018 - 0x0000)
struct FEffectVolumeCategory final
{
public:
	class FString                                 VolumeCategoryName;                                // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEffectVolumeCategory) == 0x000008, "Wrong alignment on FEffectVolumeCategory");
static_assert(sizeof(FEffectVolumeCategory) == 0x000018, "Wrong size on FEffectVolumeCategory");
static_assert(offsetof(FEffectVolumeCategory, VolumeCategoryName) == 0x000000, "Member 'FEffectVolumeCategory::VolumeCategoryName' has a wrong offset!");
static_assert(offsetof(FEffectVolumeCategory, Volume) == 0x000010, "Member 'FEffectVolumeCategory::Volume' has a wrong offset!");

// ScriptStruct BattlePrototype.SoundSnapshot
// 0x0008 (0x0008 - 0x0000)
struct FSoundSnapshot final
{
public:
	ESoundSnapshot                                Name;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Time;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundSnapshot) == 0x000004, "Wrong alignment on FSoundSnapshot");
static_assert(sizeof(FSoundSnapshot) == 0x000008, "Wrong size on FSoundSnapshot");
static_assert(offsetof(FSoundSnapshot, Name) == 0x000000, "Member 'FSoundSnapshot::Name' has a wrong offset!");
static_assert(offsetof(FSoundSnapshot, Time) == 0x000004, "Member 'FSoundSnapshot::Time' has a wrong offset!");

// ScriptStruct BattlePrototype.SoundLevelParamByScenario
// 0x0088 (0x0090 - 0x0008)
struct FSoundLevelParamByScenario final : public FTableRowBase
{
public:
	int32                                         ProgressIdMin;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressIdMax;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundAtomCue>           bgm;                                               // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBgmCategory                                  BgmSlot;                                           // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundAtomCue>           CtrlCue;                                           // 0x0040(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundAtomCue>           Env;                                               // 0x0068(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundLevelParamByScenario) == 0x000008, "Wrong alignment on FSoundLevelParamByScenario");
static_assert(sizeof(FSoundLevelParamByScenario) == 0x000090, "Wrong size on FSoundLevelParamByScenario");
static_assert(offsetof(FSoundLevelParamByScenario, ProgressIdMin) == 0x000008, "Member 'FSoundLevelParamByScenario::ProgressIdMin' has a wrong offset!");
static_assert(offsetof(FSoundLevelParamByScenario, ProgressIdMax) == 0x00000C, "Member 'FSoundLevelParamByScenario::ProgressIdMax' has a wrong offset!");
static_assert(offsetof(FSoundLevelParamByScenario, bgm) == 0x000010, "Member 'FSoundLevelParamByScenario::bgm' has a wrong offset!");
static_assert(offsetof(FSoundLevelParamByScenario, BgmSlot) == 0x000038, "Member 'FSoundLevelParamByScenario::BgmSlot' has a wrong offset!");
static_assert(offsetof(FSoundLevelParamByScenario, CtrlCue) == 0x000040, "Member 'FSoundLevelParamByScenario::CtrlCue' has a wrong offset!");
static_assert(offsetof(FSoundLevelParamByScenario, Env) == 0x000068, "Member 'FSoundLevelParamByScenario::Env' has a wrong offset!");

// ScriptStruct BattlePrototype.SoundLevelParam
// 0x0098 (0x00A0 - 0x0008)
struct FSoundLevelParam final : public FTableRowBase
{
public:
	struct FSoundSnapshot                         Snapshot;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundAtomCue>           bgm;                                               // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBgmCategory                                  BgmSlot;                                           // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundAtomCue>           CtrlCue;                                           // 0x0040(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundAtomCue>           Env;                                               // 0x0068(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoundLevelParamByScenario>     ScenarioSoundParamList;                            // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundLevelParam) == 0x000008, "Wrong alignment on FSoundLevelParam");
static_assert(sizeof(FSoundLevelParam) == 0x0000A0, "Wrong size on FSoundLevelParam");
static_assert(offsetof(FSoundLevelParam, Snapshot) == 0x000008, "Member 'FSoundLevelParam::Snapshot' has a wrong offset!");
static_assert(offsetof(FSoundLevelParam, bgm) == 0x000010, "Member 'FSoundLevelParam::bgm' has a wrong offset!");
static_assert(offsetof(FSoundLevelParam, BgmSlot) == 0x000038, "Member 'FSoundLevelParam::BgmSlot' has a wrong offset!");
static_assert(offsetof(FSoundLevelParam, CtrlCue) == 0x000040, "Member 'FSoundLevelParam::CtrlCue' has a wrong offset!");
static_assert(offsetof(FSoundLevelParam, Env) == 0x000068, "Member 'FSoundLevelParam::Env' has a wrong offset!");
static_assert(offsetof(FSoundLevelParam, ScenarioSoundParamList) == 0x000090, "Member 'FSoundLevelParam::ScenarioSoundParamList' has a wrong offset!");

// ScriptStruct BattlePrototype.SoundSelectorLabel
// 0x0002 (0x0002 - 0x0000)
struct FSoundSelectorLabel final
{
public:
	ESoundSelector                                Selector;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESoundSelectorLabel                           Label;                                             // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundSelectorLabel) == 0x000001, "Wrong alignment on FSoundSelectorLabel");
static_assert(sizeof(FSoundSelectorLabel) == 0x000002, "Wrong size on FSoundSelectorLabel");
static_assert(offsetof(FSoundSelectorLabel, Selector) == 0x000000, "Member 'FSoundSelectorLabel::Selector' has a wrong offset!");
static_assert(offsetof(FSoundSelectorLabel, Label) == 0x000001, "Member 'FSoundSelectorLabel::Label' has a wrong offset!");

// ScriptStruct BattlePrototype.SoundAisac
// 0x0008 (0x0008 - 0x0000)
struct FSoundAisac final
{
public:
	ESoundCategory                                Category_id;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESoundAisacControlId                          Control_Id;                                        // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Control_Value;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundAisac) == 0x000004, "Wrong alignment on FSoundAisac");
static_assert(sizeof(FSoundAisac) == 0x000008, "Wrong size on FSoundAisac");
static_assert(offsetof(FSoundAisac, Category_id) == 0x000000, "Member 'FSoundAisac::Category_id' has a wrong offset!");
static_assert(offsetof(FSoundAisac, Control_Id) == 0x000001, "Member 'FSoundAisac::Control_Id' has a wrong offset!");
static_assert(offsetof(FSoundAisac, Control_Value) == 0x000004, "Member 'FSoundAisac::Control_Value' has a wrong offset!");

// ScriptStruct BattlePrototype.SoundEffectDamage
// 0x0078 (0x0080 - 0x0008)
struct FSoundEffectDamage final : public FTableRowBase
{
public:
	class USoundAtomCue*                          Default;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          Slash;                                             // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          OutRange;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          Armor;                                             // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          Invincible;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          Weak;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          WeakFromPlayer;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          WeakPointExposure;                                 // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          Human;                                             // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          HumanOutRange;                                     // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          Penetrate;                                         // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          NoEffect;                                          // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          Water;                                             // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          Ice;                                               // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          IceOutRange;                                       // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundEffectDamage) == 0x000008, "Wrong alignment on FSoundEffectDamage");
static_assert(sizeof(FSoundEffectDamage) == 0x000080, "Wrong size on FSoundEffectDamage");
static_assert(offsetof(FSoundEffectDamage, Default) == 0x000008, "Member 'FSoundEffectDamage::Default' has a wrong offset!");
static_assert(offsetof(FSoundEffectDamage, Slash) == 0x000010, "Member 'FSoundEffectDamage::Slash' has a wrong offset!");
static_assert(offsetof(FSoundEffectDamage, OutRange) == 0x000018, "Member 'FSoundEffectDamage::OutRange' has a wrong offset!");
static_assert(offsetof(FSoundEffectDamage, Armor) == 0x000020, "Member 'FSoundEffectDamage::Armor' has a wrong offset!");
static_assert(offsetof(FSoundEffectDamage, Invincible) == 0x000028, "Member 'FSoundEffectDamage::Invincible' has a wrong offset!");
static_assert(offsetof(FSoundEffectDamage, Weak) == 0x000030, "Member 'FSoundEffectDamage::Weak' has a wrong offset!");
static_assert(offsetof(FSoundEffectDamage, WeakFromPlayer) == 0x000038, "Member 'FSoundEffectDamage::WeakFromPlayer' has a wrong offset!");
static_assert(offsetof(FSoundEffectDamage, WeakPointExposure) == 0x000040, "Member 'FSoundEffectDamage::WeakPointExposure' has a wrong offset!");
static_assert(offsetof(FSoundEffectDamage, Human) == 0x000048, "Member 'FSoundEffectDamage::Human' has a wrong offset!");
static_assert(offsetof(FSoundEffectDamage, HumanOutRange) == 0x000050, "Member 'FSoundEffectDamage::HumanOutRange' has a wrong offset!");
static_assert(offsetof(FSoundEffectDamage, Penetrate) == 0x000058, "Member 'FSoundEffectDamage::Penetrate' has a wrong offset!");
static_assert(offsetof(FSoundEffectDamage, NoEffect) == 0x000060, "Member 'FSoundEffectDamage::NoEffect' has a wrong offset!");
static_assert(offsetof(FSoundEffectDamage, Water) == 0x000068, "Member 'FSoundEffectDamage::Water' has a wrong offset!");
static_assert(offsetof(FSoundEffectDamage, Ice) == 0x000070, "Member 'FSoundEffectDamage::Ice' has a wrong offset!");
static_assert(offsetof(FSoundEffectDamage, IceOutRange) == 0x000078, "Member 'FSoundEffectDamage::IceOutRange' has a wrong offset!");

// ScriptStruct BattlePrototype.SoundEffectAttribute
// 0x0028 (0x0030 - 0x0008)
struct FSoundEffectAttribute final : public FTableRowBase
{
public:
	class USoundAtomCue*                          Flame;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          Electric;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          Water;                                             // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          Oil;                                               // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          Confusion;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundEffectAttribute) == 0x000008, "Wrong alignment on FSoundEffectAttribute");
static_assert(sizeof(FSoundEffectAttribute) == 0x000030, "Wrong size on FSoundEffectAttribute");
static_assert(offsetof(FSoundEffectAttribute, Flame) == 0x000008, "Member 'FSoundEffectAttribute::Flame' has a wrong offset!");
static_assert(offsetof(FSoundEffectAttribute, Electric) == 0x000010, "Member 'FSoundEffectAttribute::Electric' has a wrong offset!");
static_assert(offsetof(FSoundEffectAttribute, Water) == 0x000018, "Member 'FSoundEffectAttribute::Water' has a wrong offset!");
static_assert(offsetof(FSoundEffectAttribute, Oil) == 0x000020, "Member 'FSoundEffectAttribute::Oil' has a wrong offset!");
static_assert(offsetof(FSoundEffectAttribute, Confusion) == 0x000028, "Member 'FSoundEffectAttribute::Confusion' has a wrong offset!");

// ScriptStruct BattlePrototype.SoundEffectAttackEmn
// 0x0010 (0x0018 - 0x0008)
struct FSoundEffectAttackEmn final : public FTableRowBase
{
public:
	class USoundAtomCue*                          Normal;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          Metal;                                             // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundEffectAttackEmn) == 0x000008, "Wrong alignment on FSoundEffectAttackEmn");
static_assert(sizeof(FSoundEffectAttackEmn) == 0x000018, "Wrong size on FSoundEffectAttackEmn");
static_assert(offsetof(FSoundEffectAttackEmn, Normal) == 0x000008, "Member 'FSoundEffectAttackEmn::Normal' has a wrong offset!");
static_assert(offsetof(FSoundEffectAttackEmn, Metal) == 0x000010, "Member 'FSoundEffectAttackEmn::Metal' has a wrong offset!");

// ScriptStruct BattlePrototype.SoundEffectAttackPly
// 0x0008 (0x0010 - 0x0008)
struct FSoundEffectAttackPly final : public FTableRowBase
{
public:
	class USoundAtomCue*                          Normal;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundEffectAttackPly) == 0x000008, "Wrong alignment on FSoundEffectAttackPly");
static_assert(sizeof(FSoundEffectAttackPly) == 0x000010, "Wrong size on FSoundEffectAttackPly");
static_assert(offsetof(FSoundEffectAttackPly, Normal) == 0x000008, "Member 'FSoundEffectAttackPly::Normal' has a wrong offset!");

// ScriptStruct BattlePrototype.LoopSeParam
// 0x0010 (0x0018 - 0x0008)
struct FLoopSeParam final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URSAtomComponentBase*                   PSound;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoopSeParam) == 0x000008, "Wrong alignment on FLoopSeParam");
static_assert(sizeof(FLoopSeParam) == 0x000018, "Wrong size on FLoopSeParam");
static_assert(offsetof(FLoopSeParam, Name) == 0x000008, "Member 'FLoopSeParam::Name' has a wrong offset!");
static_assert(offsetof(FLoopSeParam, PSound) == 0x000010, "Member 'FLoopSeParam::PSound' has a wrong offset!");

// ScriptStruct BattlePrototype.NotifyPlaySoundReplaceParam
// 0x0010 (0x0018 - 0x0008)
struct FNotifyPlaySoundReplaceParam final : public FTableRowBase
{
public:
	class FName                                   ReplaceName;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          ChangeSound;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNotifyPlaySoundReplaceParam) == 0x000008, "Wrong alignment on FNotifyPlaySoundReplaceParam");
static_assert(sizeof(FNotifyPlaySoundReplaceParam) == 0x000018, "Wrong size on FNotifyPlaySoundReplaceParam");
static_assert(offsetof(FNotifyPlaySoundReplaceParam, ReplaceName) == 0x000008, "Member 'FNotifyPlaySoundReplaceParam::ReplaceName' has a wrong offset!");
static_assert(offsetof(FNotifyPlaySoundReplaceParam, ChangeSound) == 0x000010, "Member 'FNotifyPlaySoundReplaceParam::ChangeSound' has a wrong offset!");

// ScriptStruct BattlePrototype.NotifyPlaySoundReplaceProgressIdData
// 0x0010 (0x0018 - 0x0008)
struct FNotifyPlaySoundReplaceProgressIdData final : public FTableRowBase
{
public:
	int32                                         ProgressIdMin;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressIdMax;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ReplaceDataTable;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNotifyPlaySoundReplaceProgressIdData) == 0x000008, "Wrong alignment on FNotifyPlaySoundReplaceProgressIdData");
static_assert(sizeof(FNotifyPlaySoundReplaceProgressIdData) == 0x000018, "Wrong size on FNotifyPlaySoundReplaceProgressIdData");
static_assert(offsetof(FNotifyPlaySoundReplaceProgressIdData, ProgressIdMin) == 0x000008, "Member 'FNotifyPlaySoundReplaceProgressIdData::ProgressIdMin' has a wrong offset!");
static_assert(offsetof(FNotifyPlaySoundReplaceProgressIdData, ProgressIdMax) == 0x00000C, "Member 'FNotifyPlaySoundReplaceProgressIdData::ProgressIdMax' has a wrong offset!");
static_assert(offsetof(FNotifyPlaySoundReplaceProgressIdData, ReplaceDataTable) == 0x000010, "Member 'FNotifyPlaySoundReplaceProgressIdData::ReplaceDataTable' has a wrong offset!");

// ScriptStruct BattlePrototype.RandomArrangeItemIDInfo
// 0x0020 (0x0028 - 0x0008)
struct FRandomArrangeItemIDInfo final : public FTableRowBase
{
public:
	ELocationName                                 LocationId;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RandomArrangeItemID;                               // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x14];                                      // 0x0014(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomArrangeItemIDInfo) == 0x000008, "Wrong alignment on FRandomArrangeItemIDInfo");
static_assert(sizeof(FRandomArrangeItemIDInfo) == 0x000028, "Wrong size on FRandomArrangeItemIDInfo");
static_assert(offsetof(FRandomArrangeItemIDInfo, LocationId) == 0x000008, "Member 'FRandomArrangeItemIDInfo::LocationId' has a wrong offset!");
static_assert(offsetof(FRandomArrangeItemIDInfo, RandomArrangeItemID) == 0x00000C, "Member 'FRandomArrangeItemIDInfo::RandomArrangeItemID' has a wrong offset!");

// ScriptStruct BattlePrototype.ArrangeItemListForSaveData
// 0x0028 (0x0030 - 0x0008)
struct FArrangeItemListForSaveData final : public FTableRowBase
{
public:
	class FName                                   ArrangePointId;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        IntervalTime;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ArrangeItemId;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RandomArrangeItemVisibleFlag;                      // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Acquired;                                          // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Accessed;                                          // 0x002A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArrangeItemListForSaveData) == 0x000008, "Wrong alignment on FArrangeItemListForSaveData");
static_assert(sizeof(FArrangeItemListForSaveData) == 0x000030, "Wrong size on FArrangeItemListForSaveData");
static_assert(offsetof(FArrangeItemListForSaveData, ArrangePointId) == 0x000008, "Member 'FArrangeItemListForSaveData::ArrangePointId' has a wrong offset!");
static_assert(offsetof(FArrangeItemListForSaveData, IntervalTime) == 0x000010, "Member 'FArrangeItemListForSaveData::IntervalTime' has a wrong offset!");
static_assert(offsetof(FArrangeItemListForSaveData, ArrangeItemId) == 0x000018, "Member 'FArrangeItemListForSaveData::ArrangeItemId' has a wrong offset!");
static_assert(offsetof(FArrangeItemListForSaveData, RandomArrangeItemVisibleFlag) == 0x000028, "Member 'FArrangeItemListForSaveData::RandomArrangeItemVisibleFlag' has a wrong offset!");
static_assert(offsetof(FArrangeItemListForSaveData, Acquired) == 0x000029, "Member 'FArrangeItemListForSaveData::Acquired' has a wrong offset!");
static_assert(offsetof(FArrangeItemListForSaveData, Accessed) == 0x00002A, "Member 'FArrangeItemListForSaveData::Accessed' has a wrong offset!");

// ScriptStruct BattlePrototype.SaveLoadPlayerParam
// 0x00C4 (0x00C4 - 0x0000)
struct FSaveLoadPlayerParam final
{
public:
	struct FPlayerInfo                            PlayerInfo;                                        // 0x0000(0x00AC)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x00AC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x00B8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSaveLoadPlayerParam) == 0x000004, "Wrong alignment on FSaveLoadPlayerParam");
static_assert(sizeof(FSaveLoadPlayerParam) == 0x0000C4, "Wrong size on FSaveLoadPlayerParam");
static_assert(offsetof(FSaveLoadPlayerParam, PlayerInfo) == 0x000000, "Member 'FSaveLoadPlayerParam::PlayerInfo' has a wrong offset!");
static_assert(offsetof(FSaveLoadPlayerParam, Position) == 0x0000AC, "Member 'FSaveLoadPlayerParam::Position' has a wrong offset!");
static_assert(offsetof(FSaveLoadPlayerParam, Rotation) == 0x0000B8, "Member 'FSaveLoadPlayerParam::Rotation' has a wrong offset!");

// ScriptStruct BattlePrototype.SaveLoadPsychicObjectParam
// 0x0020 (0x0020 - 0x0000)
struct FSaveLoadPsychicObjectParam final
{
public:
	class FName                                   BPName;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSaveLoadPsychicObjectParam) == 0x000004, "Wrong alignment on FSaveLoadPsychicObjectParam");
static_assert(sizeof(FSaveLoadPsychicObjectParam) == 0x000020, "Wrong size on FSaveLoadPsychicObjectParam");
static_assert(offsetof(FSaveLoadPsychicObjectParam, BPName) == 0x000000, "Member 'FSaveLoadPsychicObjectParam::BPName' has a wrong offset!");
static_assert(offsetof(FSaveLoadPsychicObjectParam, Position) == 0x000008, "Member 'FSaveLoadPsychicObjectParam::Position' has a wrong offset!");
static_assert(offsetof(FSaveLoadPsychicObjectParam, Rotation) == 0x000014, "Member 'FSaveLoadPsychicObjectParam::Rotation' has a wrong offset!");

// ScriptStruct BattlePrototype.SaveLoadScreenParam
// 0x0060 (0x0060 - 0x0000)
struct FSaveLoadScreenParam final
{
public:
	class UTexture2D*                             PCapturePicture;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerLevel;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerLevelMax;                                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ClearNum;                                          // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        LocationId;                                        // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        AreaId;                                            // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PlayTime;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SaveTimeYear;                                      // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SaveTimeMonth;                                     // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SaveTimeDay;                                       // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SaveTimeHour;                                      // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SaveTimeMinute;                                    // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SaveTimeSecond;                                    // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChapterID;                                         // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SaveDataType;                                      // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ProgressId;                                        // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AppVersion;                                        // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AppliedAddContentsNameList;                        // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSaveLoadScreenParam) == 0x000008, "Wrong alignment on FSaveLoadScreenParam");
static_assert(sizeof(FSaveLoadScreenParam) == 0x000060, "Wrong size on FSaveLoadScreenParam");
static_assert(offsetof(FSaveLoadScreenParam, PCapturePicture) == 0x000000, "Member 'FSaveLoadScreenParam::PCapturePicture' has a wrong offset!");
static_assert(offsetof(FSaveLoadScreenParam, PlayerId) == 0x000008, "Member 'FSaveLoadScreenParam::PlayerId' has a wrong offset!");
static_assert(offsetof(FSaveLoadScreenParam, PlayerLevel) == 0x00000C, "Member 'FSaveLoadScreenParam::PlayerLevel' has a wrong offset!");
static_assert(offsetof(FSaveLoadScreenParam, PlayerLevelMax) == 0x000010, "Member 'FSaveLoadScreenParam::PlayerLevelMax' has a wrong offset!");
static_assert(offsetof(FSaveLoadScreenParam, ClearNum) == 0x000014, "Member 'FSaveLoadScreenParam::ClearNum' has a wrong offset!");
static_assert(offsetof(FSaveLoadScreenParam, LocationId) == 0x000018, "Member 'FSaveLoadScreenParam::LocationId' has a wrong offset!");
static_assert(offsetof(FSaveLoadScreenParam, AreaId) == 0x00001C, "Member 'FSaveLoadScreenParam::AreaId' has a wrong offset!");
static_assert(offsetof(FSaveLoadScreenParam, PlayTime) == 0x000020, "Member 'FSaveLoadScreenParam::PlayTime' has a wrong offset!");
static_assert(offsetof(FSaveLoadScreenParam, SaveTimeYear) == 0x000024, "Member 'FSaveLoadScreenParam::SaveTimeYear' has a wrong offset!");
static_assert(offsetof(FSaveLoadScreenParam, SaveTimeMonth) == 0x000028, "Member 'FSaveLoadScreenParam::SaveTimeMonth' has a wrong offset!");
static_assert(offsetof(FSaveLoadScreenParam, SaveTimeDay) == 0x00002C, "Member 'FSaveLoadScreenParam::SaveTimeDay' has a wrong offset!");
static_assert(offsetof(FSaveLoadScreenParam, SaveTimeHour) == 0x000030, "Member 'FSaveLoadScreenParam::SaveTimeHour' has a wrong offset!");
static_assert(offsetof(FSaveLoadScreenParam, SaveTimeMinute) == 0x000034, "Member 'FSaveLoadScreenParam::SaveTimeMinute' has a wrong offset!");
static_assert(offsetof(FSaveLoadScreenParam, SaveTimeSecond) == 0x000038, "Member 'FSaveLoadScreenParam::SaveTimeSecond' has a wrong offset!");
static_assert(offsetof(FSaveLoadScreenParam, ChapterID) == 0x00003C, "Member 'FSaveLoadScreenParam::ChapterID' has a wrong offset!");
static_assert(offsetof(FSaveLoadScreenParam, SaveDataType) == 0x000040, "Member 'FSaveLoadScreenParam::SaveDataType' has a wrong offset!");
static_assert(offsetof(FSaveLoadScreenParam, ProgressId) == 0x000044, "Member 'FSaveLoadScreenParam::ProgressId' has a wrong offset!");
static_assert(offsetof(FSaveLoadScreenParam, AppVersion) == 0x000048, "Member 'FSaveLoadScreenParam::AppVersion' has a wrong offset!");
static_assert(offsetof(FSaveLoadScreenParam, AppliedAddContentsNameList) == 0x000050, "Member 'FSaveLoadScreenParam::AppliedAddContentsNameList' has a wrong offset!");

// ScriptStruct BattlePrototype.ScarColorParam
// 0x0040 (0x0040 - 0x0000)
struct FScarColorParam final
{
public:
	struct FLinearColor                           EmissiveDeep;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EmissiveShallowInside;                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EmissiveShallowOutside;                            // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EmissiveWeak;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScarColorParam) == 0x000004, "Wrong alignment on FScarColorParam");
static_assert(sizeof(FScarColorParam) == 0x000040, "Wrong size on FScarColorParam");
static_assert(offsetof(FScarColorParam, EmissiveDeep) == 0x000000, "Member 'FScarColorParam::EmissiveDeep' has a wrong offset!");
static_assert(offsetof(FScarColorParam, EmissiveShallowInside) == 0x000010, "Member 'FScarColorParam::EmissiveShallowInside' has a wrong offset!");
static_assert(offsetof(FScarColorParam, EmissiveShallowOutside) == 0x000020, "Member 'FScarColorParam::EmissiveShallowOutside' has a wrong offset!");
static_assert(offsetof(FScarColorParam, EmissiveWeak) == 0x000030, "Member 'FScarColorParam::EmissiveWeak' has a wrong offset!");

// ScriptStruct BattlePrototype.ScenarioFlagParam
// 0x0008 (0x0010 - 0x0008)
struct FScenarioFlagParam final : public FTableRowBase
{
public:
	int32                                         bitIndex;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScenarioFlagParam) == 0x000008, "Wrong alignment on FScenarioFlagParam");
static_assert(sizeof(FScenarioFlagParam) == 0x000010, "Wrong size on FScenarioFlagParam");
static_assert(offsetof(FScenarioFlagParam, bitIndex) == 0x000008, "Member 'FScenarioFlagParam::bitIndex' has a wrong offset!");

// ScriptStruct BattlePrototype.PortalEventArg
// 0x0010 (0x0010 - 0x0000)
struct FPortalEventArg final
{
public:
	int32                                         ToLocationID;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ToAreaID;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartPortalName;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPortalEventArg) == 0x000004, "Wrong alignment on FPortalEventArg");
static_assert(sizeof(FPortalEventArg) == 0x000010, "Wrong size on FPortalEventArg");
static_assert(offsetof(FPortalEventArg, ToLocationID) == 0x000000, "Member 'FPortalEventArg::ToLocationID' has a wrong offset!");
static_assert(offsetof(FPortalEventArg, ToAreaID) == 0x000004, "Member 'FPortalEventArg::ToAreaID' has a wrong offset!");
static_assert(offsetof(FPortalEventArg, StartPortalName) == 0x000008, "Member 'FPortalEventArg::StartPortalName' has a wrong offset!");

// ScriptStruct BattlePrototype.GhostTrailInfo
// 0x0050 (0x0050 - 0x0000)
struct FGhostTrailInfo final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      AnimSequence;                                      // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimTime;                                          // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedTime;                                       // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGhostTrailInfo) == 0x000010, "Wrong alignment on FGhostTrailInfo");
static_assert(sizeof(FGhostTrailInfo) == 0x000050, "Wrong size on FGhostTrailInfo");
static_assert(offsetof(FGhostTrailInfo, Transform) == 0x000000, "Member 'FGhostTrailInfo::Transform' has a wrong offset!");
static_assert(offsetof(FGhostTrailInfo, AnimSequence) == 0x000030, "Member 'FGhostTrailInfo::AnimSequence' has a wrong offset!");
static_assert(offsetof(FGhostTrailInfo, AnimTime) == 0x000038, "Member 'FGhostTrailInfo::AnimTime' has a wrong offset!");
static_assert(offsetof(FGhostTrailInfo, ElapsedTime) == 0x00003C, "Member 'FGhostTrailInfo::ElapsedTime' has a wrong offset!");
static_assert(offsetof(FGhostTrailInfo, LifeTime) == 0x000040, "Member 'FGhostTrailInfo::LifeTime' has a wrong offset!");

// ScriptStruct BattlePrototype.ShowDestinationSettingCell
// 0x0050 (0x0058 - 0x0008)
struct FShowDestinationSettingCell final : public FTableRowBase
{
public:
	class FName                                   TargetID;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LevelName;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorName;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShowDestinationApplicationType               ApplicationType;                                   // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuestType                                    SetQuestType;                                      // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   QuestNumber;                                       // 0x0024(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShowDestinationCheckType                     CheckType;                                         // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProgressId;                                        // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpperLimitProgressID;                              // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShowDestinationBoolCheckType                 BoolCheckType;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FlagName;                                          // 0x003C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCheck;                                           // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuestProgressState                           QuestState;                                        // 0x0045(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BondsProgressId;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BondsUpperLimitProgressID;                         // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     BondsHeroID;                                       // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     BondsPartnerID;                                    // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         VisibleWeight;                                     // 0x0052(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x5];                                       // 0x0053(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShowDestinationSettingCell) == 0x000008, "Wrong alignment on FShowDestinationSettingCell");
static_assert(sizeof(FShowDestinationSettingCell) == 0x000058, "Wrong size on FShowDestinationSettingCell");
static_assert(offsetof(FShowDestinationSettingCell, TargetID) == 0x000008, "Member 'FShowDestinationSettingCell::TargetID' has a wrong offset!");
static_assert(offsetof(FShowDestinationSettingCell, LevelName) == 0x000010, "Member 'FShowDestinationSettingCell::LevelName' has a wrong offset!");
static_assert(offsetof(FShowDestinationSettingCell, ActorName) == 0x000018, "Member 'FShowDestinationSettingCell::ActorName' has a wrong offset!");
static_assert(offsetof(FShowDestinationSettingCell, ApplicationType) == 0x000020, "Member 'FShowDestinationSettingCell::ApplicationType' has a wrong offset!");
static_assert(offsetof(FShowDestinationSettingCell, SetQuestType) == 0x000021, "Member 'FShowDestinationSettingCell::SetQuestType' has a wrong offset!");
static_assert(offsetof(FShowDestinationSettingCell, QuestNumber) == 0x000024, "Member 'FShowDestinationSettingCell::QuestNumber' has a wrong offset!");
static_assert(offsetof(FShowDestinationSettingCell, CheckType) == 0x00002C, "Member 'FShowDestinationSettingCell::CheckType' has a wrong offset!");
static_assert(offsetof(FShowDestinationSettingCell, ProgressId) == 0x000030, "Member 'FShowDestinationSettingCell::ProgressId' has a wrong offset!");
static_assert(offsetof(FShowDestinationSettingCell, UpperLimitProgressID) == 0x000034, "Member 'FShowDestinationSettingCell::UpperLimitProgressID' has a wrong offset!");
static_assert(offsetof(FShowDestinationSettingCell, BoolCheckType) == 0x000038, "Member 'FShowDestinationSettingCell::BoolCheckType' has a wrong offset!");
static_assert(offsetof(FShowDestinationSettingCell, FlagName) == 0x00003C, "Member 'FShowDestinationSettingCell::FlagName' has a wrong offset!");
static_assert(offsetof(FShowDestinationSettingCell, IsCheck) == 0x000044, "Member 'FShowDestinationSettingCell::IsCheck' has a wrong offset!");
static_assert(offsetof(FShowDestinationSettingCell, QuestState) == 0x000045, "Member 'FShowDestinationSettingCell::QuestState' has a wrong offset!");
static_assert(offsetof(FShowDestinationSettingCell, BondsProgressId) == 0x000048, "Member 'FShowDestinationSettingCell::BondsProgressId' has a wrong offset!");
static_assert(offsetof(FShowDestinationSettingCell, BondsUpperLimitProgressID) == 0x00004C, "Member 'FShowDestinationSettingCell::BondsUpperLimitProgressID' has a wrong offset!");
static_assert(offsetof(FShowDestinationSettingCell, BondsHeroID) == 0x000050, "Member 'FShowDestinationSettingCell::BondsHeroID' has a wrong offset!");
static_assert(offsetof(FShowDestinationSettingCell, BondsPartnerID) == 0x000051, "Member 'FShowDestinationSettingCell::BondsPartnerID' has a wrong offset!");
static_assert(offsetof(FShowDestinationSettingCell, VisibleWeight) == 0x000052, "Member 'FShowDestinationSettingCell::VisibleWeight' has a wrong offset!");

// ScriptStruct BattlePrototype.ShowDestinationFlgCheck
// 0x0010 (0x0010 - 0x0000)
struct FShowDestinationFlgCheck final
{
public:
	EShowDestinationBoolCheckType                 BoolCheckType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FlgName;                                           // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCheck;                                           // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShowDestinationFlgCheck) == 0x000004, "Wrong alignment on FShowDestinationFlgCheck");
static_assert(sizeof(FShowDestinationFlgCheck) == 0x000010, "Wrong size on FShowDestinationFlgCheck");
static_assert(offsetof(FShowDestinationFlgCheck, BoolCheckType) == 0x000000, "Member 'FShowDestinationFlgCheck::BoolCheckType' has a wrong offset!");
static_assert(offsetof(FShowDestinationFlgCheck, FlgName) == 0x000004, "Member 'FShowDestinationFlgCheck::FlgName' has a wrong offset!");
static_assert(offsetof(FShowDestinationFlgCheck, IsCheck) == 0x00000C, "Member 'FShowDestinationFlgCheck::IsCheck' has a wrong offset!");

// ScriptStruct BattlePrototype.ShowDestinationProgOrFlgCheck
// 0x0038 (0x0038 - 0x0000)
struct FShowDestinationProgOrFlgCheck final
{
public:
	EShowDestinationApplicationType               ApplicationType;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuestType                                    SetQuestType;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   QuestNumber;                                       // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShowDestinationCheckType                     CheckType;                                         // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProgressId;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpperLimitProgressID;                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FShowDestinationFlgCheck>       FlgCheck;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuestProgressState                           QuestState;                                        // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BondsProgressId;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BondsUpperLimitProgressID;                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     BondsHeroID;                                       // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     BondsPartnerID;                                    // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         VisibleWeight;                                     // 0x0036(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37[0x1];                                       // 0x0037(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShowDestinationProgOrFlgCheck) == 0x000008, "Wrong alignment on FShowDestinationProgOrFlgCheck");
static_assert(sizeof(FShowDestinationProgOrFlgCheck) == 0x000038, "Wrong size on FShowDestinationProgOrFlgCheck");
static_assert(offsetof(FShowDestinationProgOrFlgCheck, ApplicationType) == 0x000000, "Member 'FShowDestinationProgOrFlgCheck::ApplicationType' has a wrong offset!");
static_assert(offsetof(FShowDestinationProgOrFlgCheck, SetQuestType) == 0x000001, "Member 'FShowDestinationProgOrFlgCheck::SetQuestType' has a wrong offset!");
static_assert(offsetof(FShowDestinationProgOrFlgCheck, QuestNumber) == 0x000004, "Member 'FShowDestinationProgOrFlgCheck::QuestNumber' has a wrong offset!");
static_assert(offsetof(FShowDestinationProgOrFlgCheck, CheckType) == 0x00000C, "Member 'FShowDestinationProgOrFlgCheck::CheckType' has a wrong offset!");
static_assert(offsetof(FShowDestinationProgOrFlgCheck, ProgressId) == 0x000010, "Member 'FShowDestinationProgOrFlgCheck::ProgressId' has a wrong offset!");
static_assert(offsetof(FShowDestinationProgOrFlgCheck, UpperLimitProgressID) == 0x000014, "Member 'FShowDestinationProgOrFlgCheck::UpperLimitProgressID' has a wrong offset!");
static_assert(offsetof(FShowDestinationProgOrFlgCheck, FlgCheck) == 0x000018, "Member 'FShowDestinationProgOrFlgCheck::FlgCheck' has a wrong offset!");
static_assert(offsetof(FShowDestinationProgOrFlgCheck, QuestState) == 0x000028, "Member 'FShowDestinationProgOrFlgCheck::QuestState' has a wrong offset!");
static_assert(offsetof(FShowDestinationProgOrFlgCheck, BondsProgressId) == 0x00002C, "Member 'FShowDestinationProgOrFlgCheck::BondsProgressId' has a wrong offset!");
static_assert(offsetof(FShowDestinationProgOrFlgCheck, BondsUpperLimitProgressID) == 0x000030, "Member 'FShowDestinationProgOrFlgCheck::BondsUpperLimitProgressID' has a wrong offset!");
static_assert(offsetof(FShowDestinationProgOrFlgCheck, BondsHeroID) == 0x000034, "Member 'FShowDestinationProgOrFlgCheck::BondsHeroID' has a wrong offset!");
static_assert(offsetof(FShowDestinationProgOrFlgCheck, BondsPartnerID) == 0x000035, "Member 'FShowDestinationProgOrFlgCheck::BondsPartnerID' has a wrong offset!");
static_assert(offsetof(FShowDestinationProgOrFlgCheck, VisibleWeight) == 0x000036, "Member 'FShowDestinationProgOrFlgCheck::VisibleWeight' has a wrong offset!");

// ScriptStruct BattlePrototype.ShowDestinationDBDataCell
// 0x0020 (0x0020 - 0x0000)
struct FShowDestinationDBDataCell final
{
public:
	class FName                                   LevelName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FShowDestinationProgOrFlgCheck> ProOrFlgCheck;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShowDestinationDBDataCell) == 0x000008, "Wrong alignment on FShowDestinationDBDataCell");
static_assert(sizeof(FShowDestinationDBDataCell) == 0x000020, "Wrong size on FShowDestinationDBDataCell");
static_assert(offsetof(FShowDestinationDBDataCell, LevelName) == 0x000000, "Member 'FShowDestinationDBDataCell::LevelName' has a wrong offset!");
static_assert(offsetof(FShowDestinationDBDataCell, ActorName) == 0x000008, "Member 'FShowDestinationDBDataCell::ActorName' has a wrong offset!");
static_assert(offsetof(FShowDestinationDBDataCell, ProOrFlgCheck) == 0x000010, "Member 'FShowDestinationDBDataCell::ProOrFlgCheck' has a wrong offset!");

// ScriptStruct BattlePrototype.ScenarioTableStruct
// 0x0020 (0x0020 - 0x0000)
struct FScenarioTableStruct final
{
public:
	int32                                         CheckType;                                         // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CheckName;                                         // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCheck;                                           // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScenarioTableStruct) == 0x000008, "Wrong alignment on FScenarioTableStruct");
static_assert(sizeof(FScenarioTableStruct) == 0x000020, "Wrong size on FScenarioTableStruct");
static_assert(offsetof(FScenarioTableStruct, CheckType) == 0x000000, "Member 'FScenarioTableStruct::CheckType' has a wrong offset!");
static_assert(offsetof(FScenarioTableStruct, CheckName) == 0x000008, "Member 'FScenarioTableStruct::CheckName' has a wrong offset!");
static_assert(offsetof(FScenarioTableStruct, IsCheck) == 0x000018, "Member 'FScenarioTableStruct::IsCheck' has a wrong offset!");

// ScriptStruct BattlePrototype.ShowDestinationTableDataCell
// 0x0028 (0x0030 - 0x0008)
struct FShowDestinationTableDataCell final : public FTableRowBase
{
public:
	int32                                         LocationNum;                                       // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaNum;                                           // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CheckType;                                         // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressId;                                        // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpperLimitProgressID;                              // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FScenarioTableStruct>           BoolCheckType;                                     // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShowDestinationTableDataCell) == 0x000008, "Wrong alignment on FShowDestinationTableDataCell");
static_assert(sizeof(FShowDestinationTableDataCell) == 0x000030, "Wrong size on FShowDestinationTableDataCell");
static_assert(offsetof(FShowDestinationTableDataCell, LocationNum) == 0x000008, "Member 'FShowDestinationTableDataCell::LocationNum' has a wrong offset!");
static_assert(offsetof(FShowDestinationTableDataCell, AreaNum) == 0x00000C, "Member 'FShowDestinationTableDataCell::AreaNum' has a wrong offset!");
static_assert(offsetof(FShowDestinationTableDataCell, CheckType) == 0x000010, "Member 'FShowDestinationTableDataCell::CheckType' has a wrong offset!");
static_assert(offsetof(FShowDestinationTableDataCell, ProgressId) == 0x000014, "Member 'FShowDestinationTableDataCell::ProgressId' has a wrong offset!");
static_assert(offsetof(FShowDestinationTableDataCell, UpperLimitProgressID) == 0x000018, "Member 'FShowDestinationTableDataCell::UpperLimitProgressID' has a wrong offset!");
static_assert(offsetof(FShowDestinationTableDataCell, BoolCheckType) == 0x000020, "Member 'FShowDestinationTableDataCell::BoolCheckType' has a wrong offset!");

// ScriptStruct BattlePrototype.ShowDestinationActorData
// 0x0040 (0x0048 - 0x0008)
struct FShowDestinationActorData final : public FTableRowBase
{
public:
	class FString                                 ActorName;                                         // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FShowDestinationTableDataCell          DesitinationData;                                  // 0x0018(0x0030)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShowDestinationActorData) == 0x000008, "Wrong alignment on FShowDestinationActorData");
static_assert(sizeof(FShowDestinationActorData) == 0x000048, "Wrong size on FShowDestinationActorData");
static_assert(offsetof(FShowDestinationActorData, ActorName) == 0x000008, "Member 'FShowDestinationActorData::ActorName' has a wrong offset!");
static_assert(offsetof(FShowDestinationActorData, DesitinationData) == 0x000018, "Member 'FShowDestinationActorData::DesitinationData' has a wrong offset!");

// ScriptStruct BattlePrototype.UIDetaileMapCheckSubData
// 0x0018 (0x0018 - 0x0000)
struct FUIDetaileMapCheckSubData final
{
public:
	class FName                                   SubName;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FUIDetaileMapCheckConditionList> SubData;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIDetaileMapCheckSubData) == 0x000008, "Wrong alignment on FUIDetaileMapCheckSubData");
static_assert(sizeof(FUIDetaileMapCheckSubData) == 0x000018, "Wrong size on FUIDetaileMapCheckSubData");
static_assert(offsetof(FUIDetaileMapCheckSubData, SubName) == 0x000000, "Member 'FUIDetaileMapCheckSubData::SubName' has a wrong offset!");
static_assert(offsetof(FUIDetaileMapCheckSubData, SubData) == 0x000008, "Member 'FUIDetaileMapCheckSubData::SubData' has a wrong offset!");

// ScriptStruct BattlePrototype.UIDetaileMapCheckAreaData
// 0x0030 (0x0030 - 0x0000)
struct FUIDetaileMapCheckAreaData final
{
public:
	class FName                                   AreaName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaNo;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIDetaileMapCheckConditionList> AreaData;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FUIDetaileMapCheckSubData>      SubList;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIDetaileMapCheckAreaData) == 0x000008, "Wrong alignment on FUIDetaileMapCheckAreaData");
static_assert(sizeof(FUIDetaileMapCheckAreaData) == 0x000030, "Wrong size on FUIDetaileMapCheckAreaData");
static_assert(offsetof(FUIDetaileMapCheckAreaData, AreaName) == 0x000000, "Member 'FUIDetaileMapCheckAreaData::AreaName' has a wrong offset!");
static_assert(offsetof(FUIDetaileMapCheckAreaData, AreaNo) == 0x000008, "Member 'FUIDetaileMapCheckAreaData::AreaNo' has a wrong offset!");
static_assert(offsetof(FUIDetaileMapCheckAreaData, AreaData) == 0x000010, "Member 'FUIDetaileMapCheckAreaData::AreaData' has a wrong offset!");
static_assert(offsetof(FUIDetaileMapCheckAreaData, SubList) == 0x000020, "Member 'FUIDetaileMapCheckAreaData::SubList' has a wrong offset!");

// ScriptStruct BattlePrototype.UIDetaileMapCheckData
// 0x0020 (0x0028 - 0x0008)
struct FUIDetaileMapCheckData final : public FTableRowBase
{
public:
	class FName                                   LocationName;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LocationNo;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIDetaileMapCheckAreaData>     AreaList;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIDetaileMapCheckData) == 0x000008, "Wrong alignment on FUIDetaileMapCheckData");
static_assert(sizeof(FUIDetaileMapCheckData) == 0x000028, "Wrong size on FUIDetaileMapCheckData");
static_assert(offsetof(FUIDetaileMapCheckData, LocationName) == 0x000008, "Member 'FUIDetaileMapCheckData::LocationName' has a wrong offset!");
static_assert(offsetof(FUIDetaileMapCheckData, LocationNo) == 0x000010, "Member 'FUIDetaileMapCheckData::LocationNo' has a wrong offset!");
static_assert(offsetof(FUIDetaileMapCheckData, AreaList) == 0x000018, "Member 'FUIDetaileMapCheckData::AreaList' has a wrong offset!");

// ScriptStruct BattlePrototype.ShowDestinationDataCell
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FShowDestinationDataCell final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShowDestinationDataCell) == 0x000008, "Wrong alignment on FShowDestinationDataCell");
static_assert(sizeof(FShowDestinationDataCell) == 0x000068, "Wrong size on FShowDestinationDataCell");

// ScriptStruct BattlePrototype.ScenarioStruct
// 0x0020 (0x0020 - 0x0000)
struct FScenarioStruct final
{
public:
	int32                                         CheckType;                                         // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CheckName;                                         // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCheck;                                           // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScenarioStruct) == 0x000008, "Wrong alignment on FScenarioStruct");
static_assert(sizeof(FScenarioStruct) == 0x000020, "Wrong size on FScenarioStruct");
static_assert(offsetof(FScenarioStruct, CheckType) == 0x000000, "Member 'FScenarioStruct::CheckType' has a wrong offset!");
static_assert(offsetof(FScenarioStruct, CheckName) == 0x000008, "Member 'FScenarioStruct::CheckName' has a wrong offset!");
static_assert(offsetof(FScenarioStruct, IsCheck) == 0x000018, "Member 'FScenarioStruct::IsCheck' has a wrong offset!");

// ScriptStruct BattlePrototype.SnowTraceActorData
// 0x0010 (0x0010 - 0x0000)
struct FSnowTraceActorData final
{
public:
	class AActor*                                 SnowActor;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseDepthDataNumber;                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSnowTraceActorData) == 0x000008, "Wrong alignment on FSnowTraceActorData");
static_assert(sizeof(FSnowTraceActorData) == 0x000010, "Wrong size on FSnowTraceActorData");
static_assert(offsetof(FSnowTraceActorData, SnowActor) == 0x000000, "Member 'FSnowTraceActorData::SnowActor' has a wrong offset!");
static_assert(offsetof(FSnowTraceActorData, UseDepthDataNumber) == 0x000008, "Member 'FSnowTraceActorData::UseDepthDataNumber' has a wrong offset!");

// ScriptStruct BattlePrototype.SnowDepthData
// 0x0060 (0x0060 - 0x0000)
struct FSnowDepthData final
{
public:
	class UTexture2D*                             DepthTex;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CaptureLocation;                                   // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CaptureOrthoWidth;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Actors;                                            // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               DynamicMaterialInstance;                           // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       SnowMaterialInstances;                             // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ALandscapeProxy*>                Landscape;                                         // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 DepthTargetOdd;                                    // 0x0050(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 DepthTargetEven;                                   // 0x0058(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnowDepthData) == 0x000008, "Wrong alignment on FSnowDepthData");
static_assert(sizeof(FSnowDepthData) == 0x000060, "Wrong size on FSnowDepthData");
static_assert(offsetof(FSnowDepthData, DepthTex) == 0x000000, "Member 'FSnowDepthData::DepthTex' has a wrong offset!");
static_assert(offsetof(FSnowDepthData, CaptureLocation) == 0x000008, "Member 'FSnowDepthData::CaptureLocation' has a wrong offset!");
static_assert(offsetof(FSnowDepthData, CaptureOrthoWidth) == 0x000014, "Member 'FSnowDepthData::CaptureOrthoWidth' has a wrong offset!");
static_assert(offsetof(FSnowDepthData, Actors) == 0x000018, "Member 'FSnowDepthData::Actors' has a wrong offset!");
static_assert(offsetof(FSnowDepthData, DynamicMaterialInstance) == 0x000028, "Member 'FSnowDepthData::DynamicMaterialInstance' has a wrong offset!");
static_assert(offsetof(FSnowDepthData, SnowMaterialInstances) == 0x000030, "Member 'FSnowDepthData::SnowMaterialInstances' has a wrong offset!");
static_assert(offsetof(FSnowDepthData, Landscape) == 0x000040, "Member 'FSnowDepthData::Landscape' has a wrong offset!");
static_assert(offsetof(FSnowDepthData, DepthTargetOdd) == 0x000050, "Member 'FSnowDepthData::DepthTargetOdd' has a wrong offset!");
static_assert(offsetof(FSnowDepthData, DepthTargetEven) == 0x000058, "Member 'FSnowDepthData::DepthTargetEven' has a wrong offset!");

// ScriptStruct BattlePrototype.SoundHardVolumeScale
// 0x0018 (0x0020 - 0x0008)
struct FSoundHardVolumeScale final : public FTableRowBase
{
public:
	float                                         All;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         bgm;                                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Me;                                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Se;                                                // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Voice;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSoundHardVolumeScale) == 0x000008, "Wrong alignment on FSoundHardVolumeScale");
static_assert(sizeof(FSoundHardVolumeScale) == 0x000020, "Wrong size on FSoundHardVolumeScale");
static_assert(offsetof(FSoundHardVolumeScale, All) == 0x000008, "Member 'FSoundHardVolumeScale::All' has a wrong offset!");
static_assert(offsetof(FSoundHardVolumeScale, bgm) == 0x00000C, "Member 'FSoundHardVolumeScale::bgm' has a wrong offset!");
static_assert(offsetof(FSoundHardVolumeScale, Me) == 0x000010, "Member 'FSoundHardVolumeScale::Me' has a wrong offset!");
static_assert(offsetof(FSoundHardVolumeScale, Se) == 0x000014, "Member 'FSoundHardVolumeScale::Se' has a wrong offset!");
static_assert(offsetof(FSoundHardVolumeScale, Voice) == 0x000018, "Member 'FSoundHardVolumeScale::Voice' has a wrong offset!");

// ScriptStruct BattlePrototype.SoundCueSheet
// 0x0010 (0x0010 - 0x0000)
struct FSoundCueSheet final
{
public:
	int32                                         RefCounter;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCueSheet*                     CueSheet;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundCueSheet) == 0x000008, "Wrong alignment on FSoundCueSheet");
static_assert(sizeof(FSoundCueSheet) == 0x000010, "Wrong size on FSoundCueSheet");
static_assert(offsetof(FSoundCueSheet, RefCounter) == 0x000000, "Member 'FSoundCueSheet::RefCounter' has a wrong offset!");
static_assert(offsetof(FSoundCueSheet, CueSheet) == 0x000008, "Member 'FSoundCueSheet::CueSheet' has a wrong offset!");

// ScriptStruct BattlePrototype.FadeSetting
// 0x0024 (0x0024 - 0x0000)
struct FFadeSetting final
{
public:
	float                                         FadeTime;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestVol;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeStartVol;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PassedTime;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TmpFadeTime;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TmpVol;                                            // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TmpDestVol;                                        // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TmpPassedTime;                                     // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFading;                                          // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFadeSetting) == 0x000004, "Wrong alignment on FFadeSetting");
static_assert(sizeof(FFadeSetting) == 0x000024, "Wrong size on FFadeSetting");
static_assert(offsetof(FFadeSetting, FadeTime) == 0x000000, "Member 'FFadeSetting::FadeTime' has a wrong offset!");
static_assert(offsetof(FFadeSetting, DestVol) == 0x000004, "Member 'FFadeSetting::DestVol' has a wrong offset!");
static_assert(offsetof(FFadeSetting, FadeStartVol) == 0x000008, "Member 'FFadeSetting::FadeStartVol' has a wrong offset!");
static_assert(offsetof(FFadeSetting, PassedTime) == 0x00000C, "Member 'FFadeSetting::PassedTime' has a wrong offset!");
static_assert(offsetof(FFadeSetting, TmpFadeTime) == 0x000010, "Member 'FFadeSetting::TmpFadeTime' has a wrong offset!");
static_assert(offsetof(FFadeSetting, TmpVol) == 0x000014, "Member 'FFadeSetting::TmpVol' has a wrong offset!");
static_assert(offsetof(FFadeSetting, TmpDestVol) == 0x000018, "Member 'FFadeSetting::TmpDestVol' has a wrong offset!");
static_assert(offsetof(FFadeSetting, TmpPassedTime) == 0x00001C, "Member 'FFadeSetting::TmpPassedTime' has a wrong offset!");
static_assert(offsetof(FFadeSetting, IsFading) == 0x000020, "Member 'FFadeSetting::IsFading' has a wrong offset!");

// ScriptStruct BattlePrototype.SoundVolumeSetting
// 0x0034 (0x0034 - 0x0000)
struct FSoundVolumeSetting final
{
public:
	float                                         AcfVolume;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfigVolume;                                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaticVolume;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InGameVolume;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFadeSetting                           FadeSetting;                                       // 0x0010(0x0024)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundVolumeSetting) == 0x000004, "Wrong alignment on FSoundVolumeSetting");
static_assert(sizeof(FSoundVolumeSetting) == 0x000034, "Wrong size on FSoundVolumeSetting");
static_assert(offsetof(FSoundVolumeSetting, AcfVolume) == 0x000000, "Member 'FSoundVolumeSetting::AcfVolume' has a wrong offset!");
static_assert(offsetof(FSoundVolumeSetting, ConfigVolume) == 0x000004, "Member 'FSoundVolumeSetting::ConfigVolume' has a wrong offset!");
static_assert(offsetof(FSoundVolumeSetting, StaticVolume) == 0x000008, "Member 'FSoundVolumeSetting::StaticVolume' has a wrong offset!");
static_assert(offsetof(FSoundVolumeSetting, InGameVolume) == 0x00000C, "Member 'FSoundVolumeSetting::InGameVolume' has a wrong offset!");
static_assert(offsetof(FSoundVolumeSetting, FadeSetting) == 0x000010, "Member 'FSoundVolumeSetting::FadeSetting' has a wrong offset!");

// ScriptStruct BattlePrototype.StageEffectParameterSettings
// 0x0014 (0x0014 - 0x0000)
struct FStageEffectParameterSettings final
{
public:
	uint8                                         bOverride_EffectColor : 1;                         // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           EffectColor;                                       // 0x0004(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStageEffectParameterSettings) == 0x000004, "Wrong alignment on FStageEffectParameterSettings");
static_assert(sizeof(FStageEffectParameterSettings) == 0x000014, "Wrong size on FStageEffectParameterSettings");
static_assert(offsetof(FStageEffectParameterSettings, EffectColor) == 0x000004, "Member 'FStageEffectParameterSettings::EffectColor' has a wrong offset!");

// ScriptStruct BattlePrototype.TargetSearchArea
// 0x000C (0x000C - 0x0000)
struct FTargetSearchArea final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTargetSearchArea) == 0x000004, "Wrong alignment on FTargetSearchArea");
static_assert(sizeof(FTargetSearchArea) == 0x00000C, "Wrong size on FTargetSearchArea");
static_assert(offsetof(FTargetSearchArea, Distance) == 0x000000, "Member 'FTargetSearchArea::Distance' has a wrong offset!");
static_assert(offsetof(FTargetSearchArea, Yaw) == 0x000004, "Member 'FTargetSearchArea::Yaw' has a wrong offset!");
static_assert(offsetof(FTargetSearchArea, Pitch) == 0x000008, "Member 'FTargetSearchArea::Pitch' has a wrong offset!");

// ScriptStruct BattlePrototype.SaveTestStruct
// 0x0018 (0x0018 - 0x0000)
struct FSaveTestStruct final
{
public:
	int32                                         StsInt;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StsFloat;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 StsArrayInt;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSaveTestStruct) == 0x000008, "Wrong alignment on FSaveTestStruct");
static_assert(sizeof(FSaveTestStruct) == 0x000018, "Wrong size on FSaveTestStruct");
static_assert(offsetof(FSaveTestStruct, StsInt) == 0x000000, "Member 'FSaveTestStruct::StsInt' has a wrong offset!");
static_assert(offsetof(FSaveTestStruct, StsFloat) == 0x000004, "Member 'FSaveTestStruct::StsFloat' has a wrong offset!");
static_assert(offsetof(FSaveTestStruct, StsArrayInt) == 0x000008, "Member 'FSaveTestStruct::StsArrayInt' has a wrong offset!");

// ScriptStruct BattlePrototype.TextDatabaseData
// 0x0020 (0x0020 - 0x0000)
struct FTextDatabaseData final
{
public:
	ETextType                                     Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Path;                                              // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextData*                              Text;                                              // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextDatabaseData) == 0x000008, "Wrong alignment on FTextDatabaseData");
static_assert(sizeof(FTextDatabaseData) == 0x000020, "Wrong size on FTextDatabaseData");
static_assert(offsetof(FTextDatabaseData, Type) == 0x000000, "Member 'FTextDatabaseData::Type' has a wrong offset!");
static_assert(offsetof(FTextDatabaseData, Path) == 0x000008, "Member 'FTextDatabaseData::Path' has a wrong offset!");
static_assert(offsetof(FTextDatabaseData, Text) == 0x000018, "Member 'FTextDatabaseData::Text' has a wrong offset!");

// ScriptStruct BattlePrototype.TextDataCell
// 0x0010 (0x0018 - 0x0008)
struct FTextDataCell final : public FTableRowBase
{
public:
	class FString                                 Text;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextDataCell) == 0x000008, "Wrong alignment on FTextDataCell");
static_assert(sizeof(FTextDataCell) == 0x000018, "Wrong size on FTextDataCell");
static_assert(offsetof(FTextDataCell, Text) == 0x000008, "Member 'FTextDataCell::Text' has a wrong offset!");

// ScriptStruct BattlePrototype.TradeItem
// 0x0030 (0x0038 - 0x0008)
struct FTradeItem final : public FTableRowBase
{
public:
	class FName                                   TItem_ID;                                          // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TItem_Num;                                         // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MItemA_ID;                                         // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MItemA_Num;                                        // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MItemB_ID;                                         // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MItemB_Num;                                        // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MItemC_ID;                                         // 0x002C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MItemC_Num;                                        // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTradeItem) == 0x000008, "Wrong alignment on FTradeItem");
static_assert(sizeof(FTradeItem) == 0x000038, "Wrong size on FTradeItem");
static_assert(offsetof(FTradeItem, TItem_ID) == 0x000008, "Member 'FTradeItem::TItem_ID' has a wrong offset!");
static_assert(offsetof(FTradeItem, TItem_Num) == 0x000010, "Member 'FTradeItem::TItem_Num' has a wrong offset!");
static_assert(offsetof(FTradeItem, MItemA_ID) == 0x000014, "Member 'FTradeItem::MItemA_ID' has a wrong offset!");
static_assert(offsetof(FTradeItem, MItemA_Num) == 0x00001C, "Member 'FTradeItem::MItemA_Num' has a wrong offset!");
static_assert(offsetof(FTradeItem, MItemB_ID) == 0x000020, "Member 'FTradeItem::MItemB_ID' has a wrong offset!");
static_assert(offsetof(FTradeItem, MItemB_Num) == 0x000028, "Member 'FTradeItem::MItemB_Num' has a wrong offset!");
static_assert(offsetof(FTradeItem, MItemC_ID) == 0x00002C, "Member 'FTradeItem::MItemC_ID' has a wrong offset!");
static_assert(offsetof(FTradeItem, MItemC_Num) == 0x000034, "Member 'FTradeItem::MItemC_Num' has a wrong offset!");

// ScriptStruct BattlePrototype.TrgEffParam
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FTrgEffParam final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETrgEffMode                                   Mode;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Value0;                                            // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Value1;                                            // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Value2;                                            // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrgEffParam) == 0x000008, "Wrong alignment on FTrgEffParam");
static_assert(sizeof(FTrgEffParam) == 0x000010, "Wrong size on FTrgEffParam");
static_assert(offsetof(FTrgEffParam, Mode) == 0x000008, "Member 'FTrgEffParam::Mode' has a wrong offset!");
static_assert(offsetof(FTrgEffParam, Value0) == 0x000009, "Member 'FTrgEffParam::Value0' has a wrong offset!");
static_assert(offsetof(FTrgEffParam, Value1) == 0x00000A, "Member 'FTrgEffParam::Value1' has a wrong offset!");
static_assert(offsetof(FTrgEffParam, Value2) == 0x00000B, "Member 'FTrgEffParam::Value2' has a wrong offset!");

// ScriptStruct BattlePrototype.TrialSystemParam
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FTrialSystemParam final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrialSystemParam) == 0x000004, "Wrong alignment on FTrialSystemParam");
static_assert(sizeof(FTrialSystemParam) == 0x000008, "Wrong size on FTrialSystemParam");

// ScriptStruct BattlePrototype.TutorialContentData
// 0x0020 (0x0028 - 0x0008)
struct FTutorialContentData final : public FTableRowBase
{
public:
	class FName                                   ControlMessageID;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ControlKeyTypeMessageID;                           // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ERSGamepadInputName>                   ControlKeyType;                                    // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTutorialContentData) == 0x000008, "Wrong alignment on FTutorialContentData");
static_assert(sizeof(FTutorialContentData) == 0x000028, "Wrong size on FTutorialContentData");
static_assert(offsetof(FTutorialContentData, ControlMessageID) == 0x000008, "Member 'FTutorialContentData::ControlMessageID' has a wrong offset!");
static_assert(offsetof(FTutorialContentData, ControlKeyTypeMessageID) == 0x000010, "Member 'FTutorialContentData::ControlKeyTypeMessageID' has a wrong offset!");
static_assert(offsetof(FTutorialContentData, ControlKeyType) == 0x000018, "Member 'FTutorialContentData::ControlKeyType' has a wrong offset!");

// ScriptStruct BattlePrototype.TutorialDBDataCell
// 0x0018 (0x0020 - 0x0008)
struct FTutorialDBDataCell final : public FTableRowBase
{
public:
	TArray<struct FTutorialContentData>           ContentTutorialData;                               // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayTime;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTutorialDBDataCell) == 0x000008, "Wrong alignment on FTutorialDBDataCell");
static_assert(sizeof(FTutorialDBDataCell) == 0x000020, "Wrong size on FTutorialDBDataCell");
static_assert(offsetof(FTutorialDBDataCell, ContentTutorialData) == 0x000008, "Member 'FTutorialDBDataCell::ContentTutorialData' has a wrong offset!");
static_assert(offsetof(FTutorialDBDataCell, DisplayTime) == 0x000018, "Member 'FTutorialDBDataCell::DisplayTime' has a wrong offset!");

// ScriptStruct BattlePrototype.TutorialRowDataCell
// 0x0020 (0x0028 - 0x0008)
struct FTutorialRowDataCell final : public FTableRowBase
{
public:
	class FName                                   TutorialID;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ControlMessageID;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ControlKeyTypeMessageID;                           // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayTime;                                       // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTutorialRowDataCell) == 0x000008, "Wrong alignment on FTutorialRowDataCell");
static_assert(sizeof(FTutorialRowDataCell) == 0x000028, "Wrong size on FTutorialRowDataCell");
static_assert(offsetof(FTutorialRowDataCell, TutorialID) == 0x000008, "Member 'FTutorialRowDataCell::TutorialID' has a wrong offset!");
static_assert(offsetof(FTutorialRowDataCell, ControlMessageID) == 0x000010, "Member 'FTutorialRowDataCell::ControlMessageID' has a wrong offset!");
static_assert(offsetof(FTutorialRowDataCell, ControlKeyTypeMessageID) == 0x000018, "Member 'FTutorialRowDataCell::ControlKeyTypeMessageID' has a wrong offset!");
static_assert(offsetof(FTutorialRowDataCell, DisplayTime) == 0x000020, "Member 'FTutorialRowDataCell::DisplayTime' has a wrong offset!");

// ScriptStruct BattlePrototype.UIBrainTalk_PlayReserveParams
// 0x0020 (0x0020 - 0x0000)
struct FUIBrainTalk_PlayReserveParams final
{
public:
	bool                                          IsEnable;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterId;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpressionID;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Message;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIBrainTalk_PlayReserveParams) == 0x000008, "Wrong alignment on FUIBrainTalk_PlayReserveParams");
static_assert(sizeof(FUIBrainTalk_PlayReserveParams) == 0x000020, "Wrong size on FUIBrainTalk_PlayReserveParams");
static_assert(offsetof(FUIBrainTalk_PlayReserveParams, IsEnable) == 0x000000, "Member 'FUIBrainTalk_PlayReserveParams::IsEnable' has a wrong offset!");
static_assert(offsetof(FUIBrainTalk_PlayReserveParams, CharacterId) == 0x000004, "Member 'FUIBrainTalk_PlayReserveParams::CharacterId' has a wrong offset!");
static_assert(offsetof(FUIBrainTalk_PlayReserveParams, ExpressionID) == 0x000008, "Member 'FUIBrainTalk_PlayReserveParams::ExpressionID' has a wrong offset!");
static_assert(offsetof(FUIBrainTalk_PlayReserveParams, Message) == 0x000010, "Member 'FUIBrainTalk_PlayReserveParams::Message' has a wrong offset!");

// ScriptStruct BattlePrototype.OneConfigArrowLR
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FOneConfigArrowLR final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOneConfigArrowLR) == 0x000008, "Wrong alignment on FOneConfigArrowLR");
static_assert(sizeof(FOneConfigArrowLR) == 0x000038, "Wrong size on FOneConfigArrowLR");

// ScriptStruct BattlePrototype.OneConfigIndex
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FOneConfigIndex final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOneConfigIndex) == 0x000008, "Wrong alignment on FOneConfigIndex");
static_assert(sizeof(FOneConfigIndex) == 0x000058, "Wrong size on FOneConfigIndex");

// ScriptStruct BattlePrototype.CreditLogo
// 0x0010 (0x0030 - 0x0020)
struct FCreditLogo final : public FCreditPartsBase
{
public:
	class USpacer*                                Spacer;                                            // 0x0020(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImageLogo;                                         // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreditLogo) == 0x000008, "Wrong alignment on FCreditLogo");
static_assert(sizeof(FCreditLogo) == 0x000030, "Wrong size on FCreditLogo");
static_assert(offsetof(FCreditLogo, Spacer) == 0x000020, "Member 'FCreditLogo::Spacer' has a wrong offset!");
static_assert(offsetof(FCreditLogo, ImageLogo) == 0x000028, "Member 'FCreditLogo::ImageLogo' has a wrong offset!");

// ScriptStruct BattlePrototype.CreditSpace_StaffNameDouble
// 0x0018 (0x0038 - 0x0020)
struct FCreditSpace_StaffNameDouble final : public FCreditPartsBase
{
public:
	class USpacer*                                Spacer;                                            // 0x0020(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextStaff1;                                        // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextStaff2;                                        // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreditSpace_StaffNameDouble) == 0x000008, "Wrong alignment on FCreditSpace_StaffNameDouble");
static_assert(sizeof(FCreditSpace_StaffNameDouble) == 0x000038, "Wrong size on FCreditSpace_StaffNameDouble");
static_assert(offsetof(FCreditSpace_StaffNameDouble, Spacer) == 0x000020, "Member 'FCreditSpace_StaffNameDouble::Spacer' has a wrong offset!");
static_assert(offsetof(FCreditSpace_StaffNameDouble, TextStaff1) == 0x000028, "Member 'FCreditSpace_StaffNameDouble::TextStaff1' has a wrong offset!");
static_assert(offsetof(FCreditSpace_StaffNameDouble, TextStaff2) == 0x000030, "Member 'FCreditSpace_StaffNameDouble::TextStaff2' has a wrong offset!");

// ScriptStruct BattlePrototype.CreditOfficial_StaffNameCombo
// 0x0028 (0x0048 - 0x0020)
struct FCreditOfficial_StaffNameCombo final : public FCreditPartsBase
{
public:
	class USpacer*                                Spacer;                                            // 0x0020(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextPosition1;                                     // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextStaff1;                                        // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextPosition2;                                     // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextStaff2;                                        // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreditOfficial_StaffNameCombo) == 0x000008, "Wrong alignment on FCreditOfficial_StaffNameCombo");
static_assert(sizeof(FCreditOfficial_StaffNameCombo) == 0x000048, "Wrong size on FCreditOfficial_StaffNameCombo");
static_assert(offsetof(FCreditOfficial_StaffNameCombo, Spacer) == 0x000020, "Member 'FCreditOfficial_StaffNameCombo::Spacer' has a wrong offset!");
static_assert(offsetof(FCreditOfficial_StaffNameCombo, TextPosition1) == 0x000028, "Member 'FCreditOfficial_StaffNameCombo::TextPosition1' has a wrong offset!");
static_assert(offsetof(FCreditOfficial_StaffNameCombo, TextStaff1) == 0x000030, "Member 'FCreditOfficial_StaffNameCombo::TextStaff1' has a wrong offset!");
static_assert(offsetof(FCreditOfficial_StaffNameCombo, TextPosition2) == 0x000038, "Member 'FCreditOfficial_StaffNameCombo::TextPosition2' has a wrong offset!");
static_assert(offsetof(FCreditOfficial_StaffNameCombo, TextStaff2) == 0x000040, "Member 'FCreditOfficial_StaffNameCombo::TextStaff2' has a wrong offset!");

// ScriptStruct BattlePrototype.CreditStaffNameQuad
// 0x0028 (0x0048 - 0x0020)
struct FCreditStaffNameQuad final : public FCreditPartsBase
{
public:
	class USpacer*                                Spacer;                                            // 0x0020(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextStaffLeft1;                                    // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextStaffLeft2;                                    // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextStaffRight1;                                   // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextStaffRight2;                                   // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreditStaffNameQuad) == 0x000008, "Wrong alignment on FCreditStaffNameQuad");
static_assert(sizeof(FCreditStaffNameQuad) == 0x000048, "Wrong size on FCreditStaffNameQuad");
static_assert(offsetof(FCreditStaffNameQuad, Spacer) == 0x000020, "Member 'FCreditStaffNameQuad::Spacer' has a wrong offset!");
static_assert(offsetof(FCreditStaffNameQuad, TextStaffLeft1) == 0x000028, "Member 'FCreditStaffNameQuad::TextStaffLeft1' has a wrong offset!");
static_assert(offsetof(FCreditStaffNameQuad, TextStaffLeft2) == 0x000030, "Member 'FCreditStaffNameQuad::TextStaffLeft2' has a wrong offset!");
static_assert(offsetof(FCreditStaffNameQuad, TextStaffRight1) == 0x000038, "Member 'FCreditStaffNameQuad::TextStaffRight1' has a wrong offset!");
static_assert(offsetof(FCreditStaffNameQuad, TextStaffRight2) == 0x000040, "Member 'FCreditStaffNameQuad::TextStaffRight2' has a wrong offset!");

// ScriptStruct BattlePrototype.CreditSpace_StaffName
// 0x0010 (0x0030 - 0x0020)
struct FCreditSpace_StaffName final : public FCreditPartsBase
{
public:
	class USpacer*                                Spacer;                                            // 0x0020(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextStaff;                                         // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreditSpace_StaffName) == 0x000008, "Wrong alignment on FCreditSpace_StaffName");
static_assert(sizeof(FCreditSpace_StaffName) == 0x000030, "Wrong size on FCreditSpace_StaffName");
static_assert(offsetof(FCreditSpace_StaffName, Spacer) == 0x000020, "Member 'FCreditSpace_StaffName::Spacer' has a wrong offset!");
static_assert(offsetof(FCreditSpace_StaffName, TextStaff) == 0x000028, "Member 'FCreditSpace_StaffName::TextStaff' has a wrong offset!");

// ScriptStruct BattlePrototype.CreditOfficial_StaffNameDouble
// 0x0020 (0x0040 - 0x0020)
struct FCreditOfficial_StaffNameDouble final : public FCreditPartsBase
{
public:
	class USpacer*                                Spacer;                                            // 0x0020(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextPosition;                                      // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextStaff1;                                        // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextStaff2;                                        // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreditOfficial_StaffNameDouble) == 0x000008, "Wrong alignment on FCreditOfficial_StaffNameDouble");
static_assert(sizeof(FCreditOfficial_StaffNameDouble) == 0x000040, "Wrong size on FCreditOfficial_StaffNameDouble");
static_assert(offsetof(FCreditOfficial_StaffNameDouble, Spacer) == 0x000020, "Member 'FCreditOfficial_StaffNameDouble::Spacer' has a wrong offset!");
static_assert(offsetof(FCreditOfficial_StaffNameDouble, TextPosition) == 0x000028, "Member 'FCreditOfficial_StaffNameDouble::TextPosition' has a wrong offset!");
static_assert(offsetof(FCreditOfficial_StaffNameDouble, TextStaff1) == 0x000030, "Member 'FCreditOfficial_StaffNameDouble::TextStaff1' has a wrong offset!");
static_assert(offsetof(FCreditOfficial_StaffNameDouble, TextStaff2) == 0x000038, "Member 'FCreditOfficial_StaffNameDouble::TextStaff2' has a wrong offset!");

// ScriptStruct BattlePrototype.CreditStaffName
// 0x0010 (0x0030 - 0x0020)
struct FCreditStaffName final : public FCreditPartsBase
{
public:
	class USpacer*                                Spacer;                                            // 0x0020(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextBlock;                                         // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreditStaffName) == 0x000008, "Wrong alignment on FCreditStaffName");
static_assert(sizeof(FCreditStaffName) == 0x000030, "Wrong size on FCreditStaffName");
static_assert(offsetof(FCreditStaffName, Spacer) == 0x000020, "Member 'FCreditStaffName::Spacer' has a wrong offset!");
static_assert(offsetof(FCreditStaffName, TextBlock) == 0x000028, "Member 'FCreditStaffName::TextBlock' has a wrong offset!");

// ScriptStruct BattlePrototype.CreditCorporateName_Official
// 0x0010 (0x0030 - 0x0020)
struct FCreditCorporateName_Official final : public FCreditPartsBase
{
public:
	class USpacer*                                Spacer;                                            // 0x0020(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UREDTextBlock*                          TextBlock;                                         // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreditCorporateName_Official) == 0x000008, "Wrong alignment on FCreditCorporateName_Official");
static_assert(sizeof(FCreditCorporateName_Official) == 0x000030, "Wrong size on FCreditCorporateName_Official");
static_assert(offsetof(FCreditCorporateName_Official, Spacer) == 0x000020, "Member 'FCreditCorporateName_Official::Spacer' has a wrong offset!");
static_assert(offsetof(FCreditCorporateName_Official, TextBlock) == 0x000028, "Member 'FCreditCorporateName_Official::TextBlock' has a wrong offset!");

// ScriptStruct BattlePrototype.OneGeneralChoiceIndex
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FOneGeneralChoiceIndex final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOneGeneralChoiceIndex) == 0x000008, "Wrong alignment on FOneGeneralChoiceIndex");
static_assert(sizeof(FOneGeneralChoiceIndex) == 0x000048, "Wrong size on FOneGeneralChoiceIndex");

// ScriptStruct BattlePrototype.OneKeyGuide
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FOneKeyGuide final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOneKeyGuide) == 0x000004, "Wrong alignment on FOneKeyGuide");
static_assert(sizeof(FOneKeyGuide) == 0x00000C, "Wrong size on FOneKeyGuide");

// ScriptStruct BattlePrototype.ItemTradeLineupCell
// 0x0008 (0x0010 - 0x0008)
struct FItemTradeLineupCell final : public FTableRowBase
{
public:
	int32                                         RecipeIndex;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemTradeLineupCell) == 0x000008, "Wrong alignment on FItemTradeLineupCell");
static_assert(sizeof(FItemTradeLineupCell) == 0x000010, "Wrong size on FItemTradeLineupCell");
static_assert(offsetof(FItemTradeLineupCell, RecipeIndex) == 0x000008, "Member 'FItemTradeLineupCell::RecipeIndex' has a wrong offset!");

// ScriptStruct BattlePrototype.UILoading3DScenePlayerData
// 0x0030 (0x0030 - 0x0000)
struct FUILoading3DScenePlayerData final
{
public:
	float                                         MoveSpeedScale;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimMontage>            DefaultAnimationAsset;                             // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUILoading3DScenePlayerData) == 0x000008, "Wrong alignment on FUILoading3DScenePlayerData");
static_assert(sizeof(FUILoading3DScenePlayerData) == 0x000030, "Wrong size on FUILoading3DScenePlayerData");
static_assert(offsetof(FUILoading3DScenePlayerData, MoveSpeedScale) == 0x000000, "Member 'FUILoading3DScenePlayerData::MoveSpeedScale' has a wrong offset!");
static_assert(offsetof(FUILoading3DScenePlayerData, DefaultAnimationAsset) == 0x000008, "Member 'FUILoading3DScenePlayerData::DefaultAnimationAsset' has a wrong offset!");

// ScriptStruct BattlePrototype.UILoading3DGeneral
// 0x0038 (0x0040 - 0x0008)
struct FUILoading3DGeneral final : public FTableRowBase
{
public:
	float                                         CaptureSize;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraHeight;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputMoveRangeMax;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputMoveSpeed;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputMoveBackSpeed;                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUILoading3DGeneralLineData>    Lines;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FUILoading3DScenePlayerData>    PlayerData;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUILoading3DGeneral) == 0x000008, "Wrong alignment on FUILoading3DGeneral");
static_assert(sizeof(FUILoading3DGeneral) == 0x000040, "Wrong size on FUILoading3DGeneral");
static_assert(offsetof(FUILoading3DGeneral, CaptureSize) == 0x000008, "Member 'FUILoading3DGeneral::CaptureSize' has a wrong offset!");
static_assert(offsetof(FUILoading3DGeneral, CameraHeight) == 0x00000C, "Member 'FUILoading3DGeneral::CameraHeight' has a wrong offset!");
static_assert(offsetof(FUILoading3DGeneral, InputMoveRangeMax) == 0x000010, "Member 'FUILoading3DGeneral::InputMoveRangeMax' has a wrong offset!");
static_assert(offsetof(FUILoading3DGeneral, InputMoveSpeed) == 0x000014, "Member 'FUILoading3DGeneral::InputMoveSpeed' has a wrong offset!");
static_assert(offsetof(FUILoading3DGeneral, InputMoveBackSpeed) == 0x000018, "Member 'FUILoading3DGeneral::InputMoveBackSpeed' has a wrong offset!");
static_assert(offsetof(FUILoading3DGeneral, Lines) == 0x000020, "Member 'FUILoading3DGeneral::Lines' has a wrong offset!");
static_assert(offsetof(FUILoading3DGeneral, PlayerData) == 0x000030, "Member 'FUILoading3DGeneral::PlayerData' has a wrong offset!");

// ScriptStruct BattlePrototype.UIMain3DBGCameraSettingTableRow
// 0x0020 (0x0028 - 0x0008)
struct FUIMain3DBGCameraSettingTableRow final : public FTableRowBase
{
public:
	struct FUIMain3DBGCameraSetting               Setting;                                           // 0x0008(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIMain3DBGCameraSettingTableRow) == 0x000008, "Wrong alignment on FUIMain3DBGCameraSettingTableRow");
static_assert(sizeof(FUIMain3DBGCameraSettingTableRow) == 0x000028, "Wrong size on FUIMain3DBGCameraSettingTableRow");
static_assert(offsetof(FUIMain3DBGCameraSettingTableRow, Setting) == 0x000008, "Member 'FUIMain3DBGCameraSettingTableRow::Setting' has a wrong offset!");

// ScriptStruct BattlePrototype.UIMain3DCharacterEquipSettingTableRow
// 0x0078 (0x0080 - 0x0008)
struct FUIMain3DCharacterEquipSettingTableRow final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUIMain3DCharacterEquipSetting         Setting;                                           // 0x0010(0x0070)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIMain3DCharacterEquipSettingTableRow) == 0x000010, "Wrong alignment on FUIMain3DCharacterEquipSettingTableRow");
static_assert(sizeof(FUIMain3DCharacterEquipSettingTableRow) == 0x000080, "Wrong size on FUIMain3DCharacterEquipSettingTableRow");
static_assert(offsetof(FUIMain3DCharacterEquipSettingTableRow, Setting) == 0x000010, "Member 'FUIMain3DCharacterEquipSettingTableRow::Setting' has a wrong offset!");

// ScriptStruct BattlePrototype.UIMain3DCharacterSceneSettingTableRow
// 0x0808 (0x0810 - 0x0008)
struct FUIMain3DCharacterSceneSettingTableRow final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUIMain3DCharacterSceneSetting         Setting;                                           // 0x0010(0x0800)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIMain3DCharacterSceneSettingTableRow) == 0x000010, "Wrong alignment on FUIMain3DCharacterSceneSettingTableRow");
static_assert(sizeof(FUIMain3DCharacterSceneSettingTableRow) == 0x000810, "Wrong size on FUIMain3DCharacterSceneSettingTableRow");
static_assert(offsetof(FUIMain3DCharacterSceneSettingTableRow, Setting) == 0x000010, "Member 'FUIMain3DCharacterSceneSettingTableRow::Setting' has a wrong offset!");

// ScriptStruct BattlePrototype.UIMain3DViewModeSetting
// 0x0024 (0x0024 - 0x0000)
struct FUIMain3DViewModeSetting final
{
public:
	float                                         RotationSpeed;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationPitchLimitMin;                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationPitchLimitMax;                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveLimitX;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveLimitY;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomSpeed;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomInLimitLength;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomOutLimitLength;                                // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIMain3DViewModeSetting) == 0x000004, "Wrong alignment on FUIMain3DViewModeSetting");
static_assert(sizeof(FUIMain3DViewModeSetting) == 0x000024, "Wrong size on FUIMain3DViewModeSetting");
static_assert(offsetof(FUIMain3DViewModeSetting, RotationSpeed) == 0x000000, "Member 'FUIMain3DViewModeSetting::RotationSpeed' has a wrong offset!");
static_assert(offsetof(FUIMain3DViewModeSetting, RotationPitchLimitMin) == 0x000004, "Member 'FUIMain3DViewModeSetting::RotationPitchLimitMin' has a wrong offset!");
static_assert(offsetof(FUIMain3DViewModeSetting, RotationPitchLimitMax) == 0x000008, "Member 'FUIMain3DViewModeSetting::RotationPitchLimitMax' has a wrong offset!");
static_assert(offsetof(FUIMain3DViewModeSetting, MoveSpeed) == 0x00000C, "Member 'FUIMain3DViewModeSetting::MoveSpeed' has a wrong offset!");
static_assert(offsetof(FUIMain3DViewModeSetting, MoveLimitX) == 0x000010, "Member 'FUIMain3DViewModeSetting::MoveLimitX' has a wrong offset!");
static_assert(offsetof(FUIMain3DViewModeSetting, MoveLimitY) == 0x000014, "Member 'FUIMain3DViewModeSetting::MoveLimitY' has a wrong offset!");
static_assert(offsetof(FUIMain3DViewModeSetting, ZoomSpeed) == 0x000018, "Member 'FUIMain3DViewModeSetting::ZoomSpeed' has a wrong offset!");
static_assert(offsetof(FUIMain3DViewModeSetting, ZoomInLimitLength) == 0x00001C, "Member 'FUIMain3DViewModeSetting::ZoomInLimitLength' has a wrong offset!");
static_assert(offsetof(FUIMain3DViewModeSetting, ZoomOutLimitLength) == 0x000020, "Member 'FUIMain3DViewModeSetting::ZoomOutLimitLength' has a wrong offset!");

// ScriptStruct BattlePrototype.UIMain3DViewModeSettingTableRow
// 0x0028 (0x0030 - 0x0008)
struct FUIMain3DViewModeSettingTableRow final : public FTableRowBase
{
public:
	struct FUIMain3DViewModeSetting               Setting;                                           // 0x0008(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIMain3DViewModeSettingTableRow) == 0x000008, "Wrong alignment on FUIMain3DViewModeSettingTableRow");
static_assert(sizeof(FUIMain3DViewModeSettingTableRow) == 0x000030, "Wrong size on FUIMain3DViewModeSettingTableRow");
static_assert(offsetof(FUIMain3DViewModeSettingTableRow, Setting) == 0x000008, "Member 'FUIMain3DViewModeSettingTableRow::Setting' has a wrong offset!");

// ScriptStruct BattlePrototype.OneQuestRewardChoiceIndex
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FOneQuestRewardChoiceIndex final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOneQuestRewardChoiceIndex) == 0x000008, "Wrong alignment on FOneQuestRewardChoiceIndex");
static_assert(sizeof(FOneQuestRewardChoiceIndex) == 0x000048, "Wrong size on FOneQuestRewardChoiceIndex");

// ScriptStruct BattlePrototype.OneSaveLoadChoiceIndex
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FOneSaveLoadChoiceIndex final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOneSaveLoadChoiceIndex) == 0x000008, "Wrong alignment on FOneSaveLoadChoiceIndex");
static_assert(sizeof(FOneSaveLoadChoiceIndex) == 0x000048, "Wrong size on FOneSaveLoadChoiceIndex");

// ScriptStruct BattlePrototype.OneSaveLoadListAnime
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FOneSaveLoadListAnime final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOneSaveLoadListAnime) == 0x000008, "Wrong alignment on FOneSaveLoadListAnime");
static_assert(sizeof(FOneSaveLoadListAnime) == 0x000030, "Wrong size on FOneSaveLoadListAnime");

// ScriptStruct BattlePrototype.ShopLineupCell
// 0x0008 (0x0010 - 0x0008)
struct FShopLineupCell final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopLineupCell) == 0x000008, "Wrong alignment on FShopLineupCell");
static_assert(sizeof(FShopLineupCell) == 0x000010, "Wrong size on FShopLineupCell");
static_assert(offsetof(FShopLineupCell, ItemId) == 0x000008, "Member 'FShopLineupCell::ItemId' has a wrong offset!");

// ScriptStruct BattlePrototype.TitleListAnime
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FTitleListAnime final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTitleListAnime) == 0x000008, "Wrong alignment on FTitleListAnime");
static_assert(sizeof(FTitleListAnime) == 0x000038, "Wrong size on FTitleListAnime");

// ScriptStruct BattlePrototype.OneTutoOperationStack
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FOneTutoOperationStack final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOneTutoOperationStack) == 0x000004, "Wrong alignment on FOneTutoOperationStack");
static_assert(sizeof(FOneTutoOperationStack) == 0x00000C, "Wrong size on FOneTutoOperationStack");

// ScriptStruct BattlePrototype.WorldmapOpenDataSortlistDataCell
// 0x0010 (0x0018 - 0x0008)
struct FWorldmapOpenDataSortlistDataCell final : public FTableRowBase
{
public:
	int32                                         MainLocationID;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LocationId;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaId;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PortalID;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWorldmapOpenDataSortlistDataCell) == 0x000008, "Wrong alignment on FWorldmapOpenDataSortlistDataCell");
static_assert(sizeof(FWorldmapOpenDataSortlistDataCell) == 0x000018, "Wrong size on FWorldmapOpenDataSortlistDataCell");
static_assert(offsetof(FWorldmapOpenDataSortlistDataCell, MainLocationID) == 0x000008, "Member 'FWorldmapOpenDataSortlistDataCell::MainLocationID' has a wrong offset!");
static_assert(offsetof(FWorldmapOpenDataSortlistDataCell, LocationId) == 0x00000C, "Member 'FWorldmapOpenDataSortlistDataCell::LocationId' has a wrong offset!");
static_assert(offsetof(FWorldmapOpenDataSortlistDataCell, AreaId) == 0x000010, "Member 'FWorldmapOpenDataSortlistDataCell::AreaId' has a wrong offset!");
static_assert(offsetof(FWorldmapOpenDataSortlistDataCell, PortalID) == 0x000014, "Member 'FWorldmapOpenDataSortlistDataCell::PortalID' has a wrong offset!");

// ScriptStruct BattlePrototype.WorldmapBatchOpenDataBitlistDataCell
// 0x0010 (0x0018 - 0x0008)
struct FWorldmapBatchOpenDataBitlistDataCell final : public FTableRowBase
{
public:
	int32                                         LocationId;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaId;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PortalID;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWorldmapBatchOpenDataBitlistDataCell) == 0x000008, "Wrong alignment on FWorldmapBatchOpenDataBitlistDataCell");
static_assert(sizeof(FWorldmapBatchOpenDataBitlistDataCell) == 0x000018, "Wrong size on FWorldmapBatchOpenDataBitlistDataCell");
static_assert(offsetof(FWorldmapBatchOpenDataBitlistDataCell, LocationId) == 0x000008, "Member 'FWorldmapBatchOpenDataBitlistDataCell::LocationId' has a wrong offset!");
static_assert(offsetof(FWorldmapBatchOpenDataBitlistDataCell, AreaId) == 0x00000C, "Member 'FWorldmapBatchOpenDataBitlistDataCell::AreaId' has a wrong offset!");
static_assert(offsetof(FWorldmapBatchOpenDataBitlistDataCell, PortalID) == 0x000010, "Member 'FWorldmapBatchOpenDataBitlistDataCell::PortalID' has a wrong offset!");

}

