#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ActionSystem

#include "Basic.hpp"

#include "ActionSystem_structs.hpp"
#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK::Params
{

// Function ActionSystem.ASAnimInstance.AnimNotify_StateChange
// 0x0008 (0x0008 - 0x0000)
struct ASAnimInstance_AnimNotify_StateChange final
{
public:
	class UASAnimNotify_StateChange*              Notify;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASAnimInstance_AnimNotify_StateChange) == 0x000008, "Wrong alignment on ASAnimInstance_AnimNotify_StateChange");
static_assert(sizeof(ASAnimInstance_AnimNotify_StateChange) == 0x000008, "Wrong size on ASAnimInstance_AnimNotify_StateChange");
static_assert(offsetof(ASAnimInstance_AnimNotify_StateChange, Notify) == 0x000000, "Member 'ASAnimInstance_AnimNotify_StateChange::Notify' has a wrong offset!");

// Function ActionSystem.ASAnimInstance.IsHitShift
// 0x0001 (0x0001 - 0x0000)
struct ASAnimInstance_IsHitShift final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASAnimInstance_IsHitShift) == 0x000001, "Wrong alignment on ASAnimInstance_IsHitShift");
static_assert(sizeof(ASAnimInstance_IsHitShift) == 0x000001, "Wrong size on ASAnimInstance_IsHitShift");
static_assert(offsetof(ASAnimInstance_IsHitShift, ReturnValue) == 0x000000, "Member 'ASAnimInstance_IsHitShift::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASAnimInstance.JumpDamageState
// 0x0001 (0x0001 - 0x0000)
struct ASAnimInstance_JumpDamageState final
{
public:
	EDamageState                                  State;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASAnimInstance_JumpDamageState) == 0x000001, "Wrong alignment on ASAnimInstance_JumpDamageState");
static_assert(sizeof(ASAnimInstance_JumpDamageState) == 0x000001, "Wrong size on ASAnimInstance_JumpDamageState");
static_assert(offsetof(ASAnimInstance_JumpDamageState, State) == 0x000000, "Member 'ASAnimInstance_JumpDamageState::State' has a wrong offset!");

// Function ActionSystem.ASAnimInstance.JumpMachineState
// 0x0020 (0x0020 - 0x0000)
struct ASAnimInstance_JumpMachineState final
{
public:
	class FString                                 MachinName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StateName;                                         // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASAnimInstance_JumpMachineState) == 0x000008, "Wrong alignment on ASAnimInstance_JumpMachineState");
static_assert(sizeof(ASAnimInstance_JumpMachineState) == 0x000020, "Wrong size on ASAnimInstance_JumpMachineState");
static_assert(offsetof(ASAnimInstance_JumpMachineState, MachinName) == 0x000000, "Member 'ASAnimInstance_JumpMachineState::MachinName' has a wrong offset!");
static_assert(offsetof(ASAnimInstance_JumpMachineState, StateName) == 0x000010, "Member 'ASAnimInstance_JumpMachineState::StateName' has a wrong offset!");

// Function ActionSystem.ASAnimInstance.ReceiveStateChange
// 0x0020 (0x0020 - 0x0000)
struct ASAnimInstance_ReceiveStateChange final
{
public:
	class FString                                 PreviousStateName;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NextStateName;                                     // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASAnimInstance_ReceiveStateChange) == 0x000008, "Wrong alignment on ASAnimInstance_ReceiveStateChange");
static_assert(sizeof(ASAnimInstance_ReceiveStateChange) == 0x000020, "Wrong size on ASAnimInstance_ReceiveStateChange");
static_assert(offsetof(ASAnimInstance_ReceiveStateChange, PreviousStateName) == 0x000000, "Member 'ASAnimInstance_ReceiveStateChange::PreviousStateName' has a wrong offset!");
static_assert(offsetof(ASAnimInstance_ReceiveStateChange, NextStateName) == 0x000010, "Member 'ASAnimInstance_ReceiveStateChange::NextStateName' has a wrong offset!");

// Function ActionSystem.ASAnimInstance.SendCommand
// 0x0018 (0x0018 - 0x0000)
struct ASAnimInstance_SendCommand final
{
public:
	class FString                                 Command;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForce;                                            // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ASAnimInstance_SendCommand) == 0x000008, "Wrong alignment on ASAnimInstance_SendCommand");
static_assert(sizeof(ASAnimInstance_SendCommand) == 0x000018, "Wrong size on ASAnimInstance_SendCommand");
static_assert(offsetof(ASAnimInstance_SendCommand, Command) == 0x000000, "Member 'ASAnimInstance_SendCommand::Command' has a wrong offset!");
static_assert(offsetof(ASAnimInstance_SendCommand, bForce) == 0x000010, "Member 'ASAnimInstance_SendCommand::bForce' has a wrong offset!");

// Function ActionSystem.ASAnimInstance.SetDynamicSubMachine
// 0x0028 (0x0028 - 0x0000)
struct ASAnimInstance_SetDynamicSubMachine final
{
public:
	class FString                                 AnimNodeName;                                      // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StateName;                                         // 0x0010(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UASStateMachine*                  StateMachineAsset;                                 // 0x0020(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASAnimInstance_SetDynamicSubMachine) == 0x000008, "Wrong alignment on ASAnimInstance_SetDynamicSubMachine");
static_assert(sizeof(ASAnimInstance_SetDynamicSubMachine) == 0x000028, "Wrong size on ASAnimInstance_SetDynamicSubMachine");
static_assert(offsetof(ASAnimInstance_SetDynamicSubMachine, AnimNodeName) == 0x000000, "Member 'ASAnimInstance_SetDynamicSubMachine::AnimNodeName' has a wrong offset!");
static_assert(offsetof(ASAnimInstance_SetDynamicSubMachine, StateName) == 0x000010, "Member 'ASAnimInstance_SetDynamicSubMachine::StateName' has a wrong offset!");
static_assert(offsetof(ASAnimInstance_SetDynamicSubMachine, StateMachineAsset) == 0x000020, "Member 'ASAnimInstance_SetDynamicSubMachine::StateMachineAsset' has a wrong offset!");

// Function ActionSystem.ASAnimInstance.HasTag
// 0x000C (0x000C - 0x0000)
struct ASAnimInstance_HasTag final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ASAnimInstance_HasTag) == 0x000004, "Wrong alignment on ASAnimInstance_HasTag");
static_assert(sizeof(ASAnimInstance_HasTag) == 0x00000C, "Wrong size on ASAnimInstance_HasTag");
static_assert(offsetof(ASAnimInstance_HasTag, Tag) == 0x000000, "Member 'ASAnimInstance_HasTag::Tag' has a wrong offset!");
static_assert(offsetof(ASAnimInstance_HasTag, ReturnValue) == 0x000008, "Member 'ASAnimInstance_HasTag::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASCharacterBase.JumpMachineState
// 0x0020 (0x0020 - 0x0000)
struct ASCharacterBase_JumpMachineState final
{
public:
	class FString                                 MachinName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StateName;                                         // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASCharacterBase_JumpMachineState) == 0x000008, "Wrong alignment on ASCharacterBase_JumpMachineState");
static_assert(sizeof(ASCharacterBase_JumpMachineState) == 0x000020, "Wrong size on ASCharacterBase_JumpMachineState");
static_assert(offsetof(ASCharacterBase_JumpMachineState, MachinName) == 0x000000, "Member 'ASCharacterBase_JumpMachineState::MachinName' has a wrong offset!");
static_assert(offsetof(ASCharacterBase_JumpMachineState, StateName) == 0x000010, "Member 'ASCharacterBase_JumpMachineState::StateName' has a wrong offset!");

// Function ActionSystem.ASCharacterBase.ReceiveStateChange
// 0x0020 (0x0020 - 0x0000)
struct ASCharacterBase_ReceiveStateChange final
{
public:
	class FString                                 PreviousStateName;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NextStateName;                                     // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASCharacterBase_ReceiveStateChange) == 0x000008, "Wrong alignment on ASCharacterBase_ReceiveStateChange");
static_assert(sizeof(ASCharacterBase_ReceiveStateChange) == 0x000020, "Wrong size on ASCharacterBase_ReceiveStateChange");
static_assert(offsetof(ASCharacterBase_ReceiveStateChange, PreviousStateName) == 0x000000, "Member 'ASCharacterBase_ReceiveStateChange::PreviousStateName' has a wrong offset!");
static_assert(offsetof(ASCharacterBase_ReceiveStateChange, NextStateName) == 0x000010, "Member 'ASCharacterBase_ReceiveStateChange::NextStateName' has a wrong offset!");

// Function ActionSystem.ASCharacterBase.SendAnimCommand
// 0x0018 (0x0018 - 0x0000)
struct ASCharacterBase_SendAnimCommand final
{
public:
	class FString                                 Command;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Force;                                             // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ASCharacterBase_SendAnimCommand) == 0x000008, "Wrong alignment on ASCharacterBase_SendAnimCommand");
static_assert(sizeof(ASCharacterBase_SendAnimCommand) == 0x000018, "Wrong size on ASCharacterBase_SendAnimCommand");
static_assert(offsetof(ASCharacterBase_SendAnimCommand, Command) == 0x000000, "Member 'ASCharacterBase_SendAnimCommand::Command' has a wrong offset!");
static_assert(offsetof(ASCharacterBase_SendAnimCommand, Force) == 0x000010, "Member 'ASCharacterBase_SendAnimCommand::Force' has a wrong offset!");

// Function ActionSystem.ASCharacterBase.ServerStateChange
// 0x000C (0x000C - 0x0000)
struct ASCharacterBase_ServerStateChange final
{
public:
	int32                                         MachineIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreviousState;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextState;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASCharacterBase_ServerStateChange) == 0x000004, "Wrong alignment on ASCharacterBase_ServerStateChange");
static_assert(sizeof(ASCharacterBase_ServerStateChange) == 0x00000C, "Wrong size on ASCharacterBase_ServerStateChange");
static_assert(offsetof(ASCharacterBase_ServerStateChange, MachineIndex) == 0x000000, "Member 'ASCharacterBase_ServerStateChange::MachineIndex' has a wrong offset!");
static_assert(offsetof(ASCharacterBase_ServerStateChange, PreviousState) == 0x000004, "Member 'ASCharacterBase_ServerStateChange::PreviousState' has a wrong offset!");
static_assert(offsetof(ASCharacterBase_ServerStateChange, NextState) == 0x000008, "Member 'ASCharacterBase_ServerStateChange::NextState' has a wrong offset!");

// Function ActionSystem.ASCharacterBase.GetAnimTags
// 0x0010 (0x0010 - 0x0000)
struct ASCharacterBase_GetAnimTags final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASCharacterBase_GetAnimTags) == 0x000008, "Wrong alignment on ASCharacterBase_GetAnimTags");
static_assert(sizeof(ASCharacterBase_GetAnimTags) == 0x000010, "Wrong size on ASCharacterBase_GetAnimTags");
static_assert(offsetof(ASCharacterBase_GetAnimTags, ReturnValue) == 0x000000, "Member 'ASCharacterBase_GetAnimTags::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASCharacterBase.HasAnimTag
// 0x000C (0x000C - 0x0000)
struct ASCharacterBase_HasAnimTag final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ASCharacterBase_HasAnimTag) == 0x000004, "Wrong alignment on ASCharacterBase_HasAnimTag");
static_assert(sizeof(ASCharacterBase_HasAnimTag) == 0x00000C, "Wrong size on ASCharacterBase_HasAnimTag");
static_assert(offsetof(ASCharacterBase_HasAnimTag, Tag) == 0x000000, "Member 'ASCharacterBase_HasAnimTag::Tag' has a wrong offset!");
static_assert(offsetof(ASCharacterBase_HasAnimTag, ReturnValue) == 0x000008, "Member 'ASCharacterBase_HasAnimTag::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASCharacter.ClientNotifyHit
// 0x00A8 (0x00A8 - 0x0000)
struct ASCharacter_ClientNotifyHit final
{
public:
	class AASCharacter*                           OtherCharacter;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Impact;                                            // 0x0008(0x0088)(ConstParm, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UASDamageType>              DamageTypeClass;                                   // 0x0090(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0098(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              ShotDirection;                                     // 0x009C(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASCharacter_ClientNotifyHit) == 0x000008, "Wrong alignment on ASCharacter_ClientNotifyHit");
static_assert(sizeof(ASCharacter_ClientNotifyHit) == 0x0000A8, "Wrong size on ASCharacter_ClientNotifyHit");
static_assert(offsetof(ASCharacter_ClientNotifyHit, OtherCharacter) == 0x000000, "Member 'ASCharacter_ClientNotifyHit::OtherCharacter' has a wrong offset!");
static_assert(offsetof(ASCharacter_ClientNotifyHit, Impact) == 0x000008, "Member 'ASCharacter_ClientNotifyHit::Impact' has a wrong offset!");
static_assert(offsetof(ASCharacter_ClientNotifyHit, DamageTypeClass) == 0x000090, "Member 'ASCharacter_ClientNotifyHit::DamageTypeClass' has a wrong offset!");
static_assert(offsetof(ASCharacter_ClientNotifyHit, Damage) == 0x000098, "Member 'ASCharacter_ClientNotifyHit::Damage' has a wrong offset!");
static_assert(offsetof(ASCharacter_ClientNotifyHit, ShotDirection) == 0x00009C, "Member 'ASCharacter_ClientNotifyHit::ShotDirection' has a wrong offset!");

// Function ActionSystem.ASCharacter.ClientTakeDamage
// 0x0028 (0x0028 - 0x0000)
struct ASCharacter_ClientTakeDamage final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamageEvent                           DamageEvent;                                       // 0x0008(0x0010)(ConstParm, Parm, NativeAccessSpecifierPublic)
	class AController*                            EventInstigator;                                   // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASCharacter_ClientTakeDamage) == 0x000008, "Wrong alignment on ASCharacter_ClientTakeDamage");
static_assert(sizeof(ASCharacter_ClientTakeDamage) == 0x000028, "Wrong size on ASCharacter_ClientTakeDamage");
static_assert(offsetof(ASCharacter_ClientTakeDamage, Damage) == 0x000000, "Member 'ASCharacter_ClientTakeDamage::Damage' has a wrong offset!");
static_assert(offsetof(ASCharacter_ClientTakeDamage, DamageEvent) == 0x000008, "Member 'ASCharacter_ClientTakeDamage::DamageEvent' has a wrong offset!");
static_assert(offsetof(ASCharacter_ClientTakeDamage, EventInstigator) == 0x000018, "Member 'ASCharacter_ClientTakeDamage::EventInstigator' has a wrong offset!");
static_assert(offsetof(ASCharacter_ClientTakeDamage, DamageCauser) == 0x000020, "Member 'ASCharacter_ClientTakeDamage::DamageCauser' has a wrong offset!");

// Function ActionSystem.ASCharacter.ClientTakePointDamage
// 0x00C0 (0x00C0 - 0x0000)
struct ASCharacter_ClientTakePointDamage final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPointDamageEvent                      DamageEvent;                                       // 0x0008(0x00A8)(ConstParm, Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AController*                            EventInstigator;                                   // 0x00B0(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x00B8(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASCharacter_ClientTakePointDamage) == 0x000008, "Wrong alignment on ASCharacter_ClientTakePointDamage");
static_assert(sizeof(ASCharacter_ClientTakePointDamage) == 0x0000C0, "Wrong size on ASCharacter_ClientTakePointDamage");
static_assert(offsetof(ASCharacter_ClientTakePointDamage, Damage) == 0x000000, "Member 'ASCharacter_ClientTakePointDamage::Damage' has a wrong offset!");
static_assert(offsetof(ASCharacter_ClientTakePointDamage, DamageEvent) == 0x000008, "Member 'ASCharacter_ClientTakePointDamage::DamageEvent' has a wrong offset!");
static_assert(offsetof(ASCharacter_ClientTakePointDamage, EventInstigator) == 0x0000B0, "Member 'ASCharacter_ClientTakePointDamage::EventInstigator' has a wrong offset!");
static_assert(offsetof(ASCharacter_ClientTakePointDamage, DamageCauser) == 0x0000B8, "Member 'ASCharacter_ClientTakePointDamage::DamageCauser' has a wrong offset!");

// Function ActionSystem.ASCharacter.JumpDamageState
// 0x0001 (0x0001 - 0x0000)
struct ASCharacter_JumpDamageState final
{
public:
	EDamageState                                  State;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASCharacter_JumpDamageState) == 0x000001, "Wrong alignment on ASCharacter_JumpDamageState");
static_assert(sizeof(ASCharacter_JumpDamageState) == 0x000001, "Wrong size on ASCharacter_JumpDamageState");
static_assert(offsetof(ASCharacter_JumpDamageState, State) == 0x000000, "Member 'ASCharacter_JumpDamageState::State' has a wrong offset!");

// Function ActionSystem.ASCharacter.OnAttackOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct ASCharacter_OnAttackOverlap final
{
public:
	class UPrimitiveComponent*                    MyComp;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             SweepResult;                                       // 0x0018(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00A0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ASCharacter_OnAttackOverlap) == 0x000008, "Wrong alignment on ASCharacter_OnAttackOverlap");
static_assert(sizeof(ASCharacter_OnAttackOverlap) == 0x0000A8, "Wrong size on ASCharacter_OnAttackOverlap");
static_assert(offsetof(ASCharacter_OnAttackOverlap, MyComp) == 0x000000, "Member 'ASCharacter_OnAttackOverlap::MyComp' has a wrong offset!");
static_assert(offsetof(ASCharacter_OnAttackOverlap, OtherActor) == 0x000008, "Member 'ASCharacter_OnAttackOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(ASCharacter_OnAttackOverlap, OtherComp) == 0x000010, "Member 'ASCharacter_OnAttackOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(ASCharacter_OnAttackOverlap, SweepResult) == 0x000018, "Member 'ASCharacter_OnAttackOverlap::SweepResult' has a wrong offset!");
static_assert(offsetof(ASCharacter_OnAttackOverlap, ReturnValue) == 0x0000A0, "Member 'ASCharacter_OnAttackOverlap::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASCharacter.ServerNotifyHit
// 0x00A8 (0x00A8 - 0x0000)
struct ASCharacter_ServerNotifyHit final
{
public:
	class AASCharacter*                           OtherCharacter;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Impact;                                            // 0x0008(0x0088)(ConstParm, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UASDamageType>              DamageTypeClass;                                   // 0x0090(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0098(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              ShotDirection;                                     // 0x009C(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASCharacter_ServerNotifyHit) == 0x000008, "Wrong alignment on ASCharacter_ServerNotifyHit");
static_assert(sizeof(ASCharacter_ServerNotifyHit) == 0x0000A8, "Wrong size on ASCharacter_ServerNotifyHit");
static_assert(offsetof(ASCharacter_ServerNotifyHit, OtherCharacter) == 0x000000, "Member 'ASCharacter_ServerNotifyHit::OtherCharacter' has a wrong offset!");
static_assert(offsetof(ASCharacter_ServerNotifyHit, Impact) == 0x000008, "Member 'ASCharacter_ServerNotifyHit::Impact' has a wrong offset!");
static_assert(offsetof(ASCharacter_ServerNotifyHit, DamageTypeClass) == 0x000090, "Member 'ASCharacter_ServerNotifyHit::DamageTypeClass' has a wrong offset!");
static_assert(offsetof(ASCharacter_ServerNotifyHit, Damage) == 0x000098, "Member 'ASCharacter_ServerNotifyHit::Damage' has a wrong offset!");
static_assert(offsetof(ASCharacter_ServerNotifyHit, ShotDirection) == 0x00009C, "Member 'ASCharacter_ServerNotifyHit::ShotDirection' has a wrong offset!");

// Function ActionSystem.ASCharacter.ServerTakeDamage
// 0x0028 (0x0028 - 0x0000)
struct ASCharacter_ServerTakeDamage final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamageEvent                           DamageEvent;                                       // 0x0008(0x0010)(ConstParm, Parm, NativeAccessSpecifierPublic)
	class AController*                            EventInstigator;                                   // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASCharacter_ServerTakeDamage) == 0x000008, "Wrong alignment on ASCharacter_ServerTakeDamage");
static_assert(sizeof(ASCharacter_ServerTakeDamage) == 0x000028, "Wrong size on ASCharacter_ServerTakeDamage");
static_assert(offsetof(ASCharacter_ServerTakeDamage, Damage) == 0x000000, "Member 'ASCharacter_ServerTakeDamage::Damage' has a wrong offset!");
static_assert(offsetof(ASCharacter_ServerTakeDamage, DamageEvent) == 0x000008, "Member 'ASCharacter_ServerTakeDamage::DamageEvent' has a wrong offset!");
static_assert(offsetof(ASCharacter_ServerTakeDamage, EventInstigator) == 0x000018, "Member 'ASCharacter_ServerTakeDamage::EventInstigator' has a wrong offset!");
static_assert(offsetof(ASCharacter_ServerTakeDamage, DamageCauser) == 0x000020, "Member 'ASCharacter_ServerTakeDamage::DamageCauser' has a wrong offset!");

// Function ActionSystem.ASCharacter.ServerTakePointDamage
// 0x00C0 (0x00C0 - 0x0000)
struct ASCharacter_ServerTakePointDamage final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPointDamageEvent                      DamageEvent;                                       // 0x0008(0x00A8)(ConstParm, Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AController*                            EventInstigator;                                   // 0x00B0(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x00B8(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASCharacter_ServerTakePointDamage) == 0x000008, "Wrong alignment on ASCharacter_ServerTakePointDamage");
static_assert(sizeof(ASCharacter_ServerTakePointDamage) == 0x0000C0, "Wrong size on ASCharacter_ServerTakePointDamage");
static_assert(offsetof(ASCharacter_ServerTakePointDamage, Damage) == 0x000000, "Member 'ASCharacter_ServerTakePointDamage::Damage' has a wrong offset!");
static_assert(offsetof(ASCharacter_ServerTakePointDamage, DamageEvent) == 0x000008, "Member 'ASCharacter_ServerTakePointDamage::DamageEvent' has a wrong offset!");
static_assert(offsetof(ASCharacter_ServerTakePointDamage, EventInstigator) == 0x0000B0, "Member 'ASCharacter_ServerTakePointDamage::EventInstigator' has a wrong offset!");
static_assert(offsetof(ASCharacter_ServerTakePointDamage, DamageCauser) == 0x0000B8, "Member 'ASCharacter_ServerTakePointDamage::DamageCauser' has a wrong offset!");

// Function ActionSystem.ASCharacterMovementComponent.SendAnimCommand
// 0x0018 (0x0018 - 0x0000)
struct ASCharacterMovementComponent_SendAnimCommand final
{
public:
	class FString                                 Command;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Force;                                             // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ASCharacterMovementComponent_SendAnimCommand) == 0x000008, "Wrong alignment on ASCharacterMovementComponent_SendAnimCommand");
static_assert(sizeof(ASCharacterMovementComponent_SendAnimCommand) == 0x000018, "Wrong size on ASCharacterMovementComponent_SendAnimCommand");
static_assert(offsetof(ASCharacterMovementComponent_SendAnimCommand, Command) == 0x000000, "Member 'ASCharacterMovementComponent_SendAnimCommand::Command' has a wrong offset!");
static_assert(offsetof(ASCharacterMovementComponent_SendAnimCommand, Force) == 0x000010, "Member 'ASCharacterMovementComponent_SendAnimCommand::Force' has a wrong offset!");

// Function ActionSystem.ASCharacterMovementComponent.SetDirectMove
// 0x0010 (0x0010 - 0x0000)
struct ASCharacterMovementComponent_SetDirectMove final
{
public:
	struct FVector                                MoveVelocity;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceMaxSpeed;                                    // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ASCharacterMovementComponent_SetDirectMove) == 0x000004, "Wrong alignment on ASCharacterMovementComponent_SetDirectMove");
static_assert(sizeof(ASCharacterMovementComponent_SetDirectMove) == 0x000010, "Wrong size on ASCharacterMovementComponent_SetDirectMove");
static_assert(offsetof(ASCharacterMovementComponent_SetDirectMove, MoveVelocity) == 0x000000, "Member 'ASCharacterMovementComponent_SetDirectMove::MoveVelocity' has a wrong offset!");
static_assert(offsetof(ASCharacterMovementComponent_SetDirectMove, bForceMaxSpeed) == 0x00000C, "Member 'ASCharacterMovementComponent_SetDirectMove::bForceMaxSpeed' has a wrong offset!");

// Function ActionSystem.ASCharacterMovementComponent.SetImpulse
// 0x0010 (0x0010 - 0x0000)
struct ASCharacterMovementComponent_SetImpulse final
{
public:
	struct FVector                                Impulse;                                           // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVelocityChange;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ASCharacterMovementComponent_SetImpulse) == 0x000004, "Wrong alignment on ASCharacterMovementComponent_SetImpulse");
static_assert(sizeof(ASCharacterMovementComponent_SetImpulse) == 0x000010, "Wrong size on ASCharacterMovementComponent_SetImpulse");
static_assert(offsetof(ASCharacterMovementComponent_SetImpulse, Impulse) == 0x000000, "Member 'ASCharacterMovementComponent_SetImpulse::Impulse' has a wrong offset!");
static_assert(offsetof(ASCharacterMovementComponent_SetImpulse, bVelocityChange) == 0x00000C, "Member 'ASCharacterMovementComponent_SetImpulse::bVelocityChange' has a wrong offset!");

// Function ActionSystem.ASCharacterMovementComponent.GetLastNavMoveVelocity
// 0x000C (0x000C - 0x0000)
struct ASCharacterMovementComponent_GetLastNavMoveVelocity final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASCharacterMovementComponent_GetLastNavMoveVelocity) == 0x000004, "Wrong alignment on ASCharacterMovementComponent_GetLastNavMoveVelocity");
static_assert(sizeof(ASCharacterMovementComponent_GetLastNavMoveVelocity) == 0x00000C, "Wrong size on ASCharacterMovementComponent_GetLastNavMoveVelocity");
static_assert(offsetof(ASCharacterMovementComponent_GetLastNavMoveVelocity, ReturnValue) == 0x000000, "Member 'ASCharacterMovementComponent_GetLastNavMoveVelocity::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASCharacterMovementComponent.HasAnimTag
// 0x000C (0x000C - 0x0000)
struct ASCharacterMovementComponent_HasAnimTag final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ASCharacterMovementComponent_HasAnimTag) == 0x000004, "Wrong alignment on ASCharacterMovementComponent_HasAnimTag");
static_assert(sizeof(ASCharacterMovementComponent_HasAnimTag) == 0x00000C, "Wrong size on ASCharacterMovementComponent_HasAnimTag");
static_assert(offsetof(ASCharacterMovementComponent_HasAnimTag, Tag) == 0x000000, "Member 'ASCharacterMovementComponent_HasAnimTag::Tag' has a wrong offset!");
static_assert(offsetof(ASCharacterMovementComponent_HasAnimTag, ReturnValue) == 0x000008, "Member 'ASCharacterMovementComponent_HasAnimTag::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASCollisionCapsuleComponent.OnAttackBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct ASCollisionCapsuleComponent_OnAttackBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASCollisionCapsuleComponent_OnAttackBeginOverlap) == 0x000008, "Wrong alignment on ASCollisionCapsuleComponent_OnAttackBeginOverlap");
static_assert(sizeof(ASCollisionCapsuleComponent_OnAttackBeginOverlap) == 0x0000A8, "Wrong size on ASCollisionCapsuleComponent_OnAttackBeginOverlap");
static_assert(offsetof(ASCollisionCapsuleComponent_OnAttackBeginOverlap, OverlappedComponent) == 0x000000, "Member 'ASCollisionCapsuleComponent_OnAttackBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(ASCollisionCapsuleComponent_OnAttackBeginOverlap, OtherActor) == 0x000008, "Member 'ASCollisionCapsuleComponent_OnAttackBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(ASCollisionCapsuleComponent_OnAttackBeginOverlap, OtherComp) == 0x000010, "Member 'ASCollisionCapsuleComponent_OnAttackBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(ASCollisionCapsuleComponent_OnAttackBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'ASCollisionCapsuleComponent_OnAttackBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(ASCollisionCapsuleComponent_OnAttackBeginOverlap, bFromSweep) == 0x00001C, "Member 'ASCollisionCapsuleComponent_OnAttackBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(ASCollisionCapsuleComponent_OnAttackBeginOverlap, SweepResult) == 0x000020, "Member 'ASCollisionCapsuleComponent_OnAttackBeginOverlap::SweepResult' has a wrong offset!");

// Function ActionSystem.ASCollisionCapsuleComponent.OnAttackEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct ASCollisionCapsuleComponent_OnAttackEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ASCollisionCapsuleComponent_OnAttackEndOverlap) == 0x000008, "Wrong alignment on ASCollisionCapsuleComponent_OnAttackEndOverlap");
static_assert(sizeof(ASCollisionCapsuleComponent_OnAttackEndOverlap) == 0x000020, "Wrong size on ASCollisionCapsuleComponent_OnAttackEndOverlap");
static_assert(offsetof(ASCollisionCapsuleComponent_OnAttackEndOverlap, OverlappedComponent) == 0x000000, "Member 'ASCollisionCapsuleComponent_OnAttackEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(ASCollisionCapsuleComponent_OnAttackEndOverlap, OtherActor) == 0x000008, "Member 'ASCollisionCapsuleComponent_OnAttackEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(ASCollisionCapsuleComponent_OnAttackEndOverlap, OtherComp) == 0x000010, "Member 'ASCollisionCapsuleComponent_OnAttackEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(ASCollisionCapsuleComponent_OnAttackEndOverlap, OtherBodyIndex) == 0x000018, "Member 'ASCollisionCapsuleComponent_OnAttackEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function ActionSystem.ASCollisionComponent.OnAttackBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct ASCollisionComponent_OnAttackBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASCollisionComponent_OnAttackBeginOverlap) == 0x000008, "Wrong alignment on ASCollisionComponent_OnAttackBeginOverlap");
static_assert(sizeof(ASCollisionComponent_OnAttackBeginOverlap) == 0x0000A8, "Wrong size on ASCollisionComponent_OnAttackBeginOverlap");
static_assert(offsetof(ASCollisionComponent_OnAttackBeginOverlap, OverlappedComponent) == 0x000000, "Member 'ASCollisionComponent_OnAttackBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(ASCollisionComponent_OnAttackBeginOverlap, OtherActor) == 0x000008, "Member 'ASCollisionComponent_OnAttackBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(ASCollisionComponent_OnAttackBeginOverlap, OtherComp) == 0x000010, "Member 'ASCollisionComponent_OnAttackBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(ASCollisionComponent_OnAttackBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'ASCollisionComponent_OnAttackBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(ASCollisionComponent_OnAttackBeginOverlap, bFromSweep) == 0x00001C, "Member 'ASCollisionComponent_OnAttackBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(ASCollisionComponent_OnAttackBeginOverlap, SweepResult) == 0x000020, "Member 'ASCollisionComponent_OnAttackBeginOverlap::SweepResult' has a wrong offset!");

// Function ActionSystem.ASCollisionComponent.OnAttackEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct ASCollisionComponent_OnAttackEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ASCollisionComponent_OnAttackEndOverlap) == 0x000008, "Wrong alignment on ASCollisionComponent_OnAttackEndOverlap");
static_assert(sizeof(ASCollisionComponent_OnAttackEndOverlap) == 0x000020, "Wrong size on ASCollisionComponent_OnAttackEndOverlap");
static_assert(offsetof(ASCollisionComponent_OnAttackEndOverlap, OverlappedComponent) == 0x000000, "Member 'ASCollisionComponent_OnAttackEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(ASCollisionComponent_OnAttackEndOverlap, OtherActor) == 0x000008, "Member 'ASCollisionComponent_OnAttackEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(ASCollisionComponent_OnAttackEndOverlap, OtherComp) == 0x000010, "Member 'ASCollisionComponent_OnAttackEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(ASCollisionComponent_OnAttackEndOverlap, OtherBodyIndex) == 0x000018, "Member 'ASCollisionComponent_OnAttackEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function ActionSystem.ASCollisionGroupComponent.OnAttackBeginOverlap
// 0x00A0 (0x00A0 - 0x0000)
struct ASCollisionGroupComponent_OnAttackBeginOverlap final
{
public:
	class UPrimitiveComponent*                    MyComp;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             SweepResult;                                       // 0x0018(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASCollisionGroupComponent_OnAttackBeginOverlap) == 0x000008, "Wrong alignment on ASCollisionGroupComponent_OnAttackBeginOverlap");
static_assert(sizeof(ASCollisionGroupComponent_OnAttackBeginOverlap) == 0x0000A0, "Wrong size on ASCollisionGroupComponent_OnAttackBeginOverlap");
static_assert(offsetof(ASCollisionGroupComponent_OnAttackBeginOverlap, MyComp) == 0x000000, "Member 'ASCollisionGroupComponent_OnAttackBeginOverlap::MyComp' has a wrong offset!");
static_assert(offsetof(ASCollisionGroupComponent_OnAttackBeginOverlap, OtherActor) == 0x000008, "Member 'ASCollisionGroupComponent_OnAttackBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(ASCollisionGroupComponent_OnAttackBeginOverlap, OtherComp) == 0x000010, "Member 'ASCollisionGroupComponent_OnAttackBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(ASCollisionGroupComponent_OnAttackBeginOverlap, SweepResult) == 0x000018, "Member 'ASCollisionGroupComponent_OnAttackBeginOverlap::SweepResult' has a wrong offset!");

// Function ActionSystem.ASCollisionGroupComponent.OnAttackEndOverlap
// 0x0018 (0x0018 - 0x0000)
struct ASCollisionGroupComponent_OnAttackEndOverlap final
{
public:
	class UPrimitiveComponent*                    MyComp;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASCollisionGroupComponent_OnAttackEndOverlap) == 0x000008, "Wrong alignment on ASCollisionGroupComponent_OnAttackEndOverlap");
static_assert(sizeof(ASCollisionGroupComponent_OnAttackEndOverlap) == 0x000018, "Wrong size on ASCollisionGroupComponent_OnAttackEndOverlap");
static_assert(offsetof(ASCollisionGroupComponent_OnAttackEndOverlap, MyComp) == 0x000000, "Member 'ASCollisionGroupComponent_OnAttackEndOverlap::MyComp' has a wrong offset!");
static_assert(offsetof(ASCollisionGroupComponent_OnAttackEndOverlap, OtherActor) == 0x000008, "Member 'ASCollisionGroupComponent_OnAttackEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(ASCollisionGroupComponent_OnAttackEndOverlap, OtherComp) == 0x000010, "Member 'ASCollisionGroupComponent_OnAttackEndOverlap::OtherComp' has a wrong offset!");

// Function ActionSystem.ASCollisionGroupComponent.SetActiveCollision
// 0x0001 (0x0001 - 0x0000)
struct ASCollisionGroupComponent_SetActiveCollision final
{
public:
	bool                                          Active;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASCollisionGroupComponent_SetActiveCollision) == 0x000001, "Wrong alignment on ASCollisionGroupComponent_SetActiveCollision");
static_assert(sizeof(ASCollisionGroupComponent_SetActiveCollision) == 0x000001, "Wrong size on ASCollisionGroupComponent_SetActiveCollision");
static_assert(offsetof(ASCollisionGroupComponent_SetActiveCollision, Active) == 0x000000, "Member 'ASCollisionGroupComponent_SetActiveCollision::Active' has a wrong offset!");

// Function ActionSystem.ASCollisionGroupComponent.StartAttack
// 0x0008 (0x0008 - 0x0000)
struct ASCollisionGroupComponent_StartAttack final
{
public:
	int32                                         HitCount;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitInterval;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASCollisionGroupComponent_StartAttack) == 0x000004, "Wrong alignment on ASCollisionGroupComponent_StartAttack");
static_assert(sizeof(ASCollisionGroupComponent_StartAttack) == 0x000008, "Wrong size on ASCollisionGroupComponent_StartAttack");
static_assert(offsetof(ASCollisionGroupComponent_StartAttack, HitCount) == 0x000000, "Member 'ASCollisionGroupComponent_StartAttack::HitCount' has a wrong offset!");
static_assert(offsetof(ASCollisionGroupComponent_StartAttack, HitInterval) == 0x000004, "Member 'ASCollisionGroupComponent_StartAttack::HitInterval' has a wrong offset!");

// Function ActionSystem.ASCollisionInterface.OnAttackOverlapCallback
// 0x00A8 (0x00A8 - 0x0000)
struct ASCollisionInterface_OnAttackOverlapCallback final
{
public:
	class UPrimitiveComponent*                    MyComp;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             SweepResult;                                       // 0x0018(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00A0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ASCollisionInterface_OnAttackOverlapCallback) == 0x000008, "Wrong alignment on ASCollisionInterface_OnAttackOverlapCallback");
static_assert(sizeof(ASCollisionInterface_OnAttackOverlapCallback) == 0x0000A8, "Wrong size on ASCollisionInterface_OnAttackOverlapCallback");
static_assert(offsetof(ASCollisionInterface_OnAttackOverlapCallback, MyComp) == 0x000000, "Member 'ASCollisionInterface_OnAttackOverlapCallback::MyComp' has a wrong offset!");
static_assert(offsetof(ASCollisionInterface_OnAttackOverlapCallback, OtherActor) == 0x000008, "Member 'ASCollisionInterface_OnAttackOverlapCallback::OtherActor' has a wrong offset!");
static_assert(offsetof(ASCollisionInterface_OnAttackOverlapCallback, OtherComp) == 0x000010, "Member 'ASCollisionInterface_OnAttackOverlapCallback::OtherComp' has a wrong offset!");
static_assert(offsetof(ASCollisionInterface_OnAttackOverlapCallback, SweepResult) == 0x000018, "Member 'ASCollisionInterface_OnAttackOverlapCallback::SweepResult' has a wrong offset!");
static_assert(offsetof(ASCollisionInterface_OnAttackOverlapCallback, ReturnValue) == 0x0000A0, "Member 'ASCollisionInterface_OnAttackOverlapCallback::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASSMStateMachineInterface.GetAndUpdateContinuousSameDamageReaction
// 0x0001 (0x0001 - 0x0000)
struct ASSMStateMachineInterface_GetAndUpdateContinuousSameDamageReaction final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASSMStateMachineInterface_GetAndUpdateContinuousSameDamageReaction) == 0x000001, "Wrong alignment on ASSMStateMachineInterface_GetAndUpdateContinuousSameDamageReaction");
static_assert(sizeof(ASSMStateMachineInterface_GetAndUpdateContinuousSameDamageReaction) == 0x000001, "Wrong size on ASSMStateMachineInterface_GetAndUpdateContinuousSameDamageReaction");
static_assert(offsetof(ASSMStateMachineInterface_GetAndUpdateContinuousSameDamageReaction, ReturnValue) == 0x000000, "Member 'ASSMStateMachineInterface_GetAndUpdateContinuousSameDamageReaction::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASSMStateMachineInterface.IsNeedResetStateMachine
// 0x000C (0x000C - 0x0000)
struct ASSMStateMachineInterface_IsNeedResetStateMachine final
{
public:
	float                                         ElapsedTime;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResetSecond;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ASSMStateMachineInterface_IsNeedResetStateMachine) == 0x000004, "Wrong alignment on ASSMStateMachineInterface_IsNeedResetStateMachine");
static_assert(sizeof(ASSMStateMachineInterface_IsNeedResetStateMachine) == 0x00000C, "Wrong size on ASSMStateMachineInterface_IsNeedResetStateMachine");
static_assert(offsetof(ASSMStateMachineInterface_IsNeedResetStateMachine, ElapsedTime) == 0x000000, "Member 'ASSMStateMachineInterface_IsNeedResetStateMachine::ElapsedTime' has a wrong offset!");
static_assert(offsetof(ASSMStateMachineInterface_IsNeedResetStateMachine, ResetSecond) == 0x000004, "Member 'ASSMStateMachineInterface_IsNeedResetStateMachine::ResetSecond' has a wrong offset!");
static_assert(offsetof(ASSMStateMachineInterface_IsNeedResetStateMachine, ReturnValue) == 0x000008, "Member 'ASSMStateMachineInterface_IsNeedResetStateMachine::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASSMStateMachineInterface.UpdatePreviousElapsedTime
// 0x0004 (0x0004 - 0x0000)
struct ASSMStateMachineInterface_UpdatePreviousElapsedTime final
{
public:
	float                                         ElapsedTime;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASSMStateMachineInterface_UpdatePreviousElapsedTime) == 0x000004, "Wrong alignment on ASSMStateMachineInterface_UpdatePreviousElapsedTime");
static_assert(sizeof(ASSMStateMachineInterface_UpdatePreviousElapsedTime) == 0x000004, "Wrong size on ASSMStateMachineInterface_UpdatePreviousElapsedTime");
static_assert(offsetof(ASSMStateMachineInterface_UpdatePreviousElapsedTime, ElapsedTime) == 0x000000, "Member 'ASSMStateMachineInterface_UpdatePreviousElapsedTime::ElapsedTime' has a wrong offset!");

// Function ActionSystem.ASSMTransitionNodeInterface.MakeRulesShareable
// 0x0018 (0x0018 - 0x0000)
struct ASSMTransitionNodeInterface_MakeRulesShareable final
{
public:
	class UASSMTransitionNode*                    Caller;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 Remap;                                             // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASSMTransitionNodeInterface_MakeRulesShareable) == 0x000008, "Wrong alignment on ASSMTransitionNodeInterface_MakeRulesShareable");
static_assert(sizeof(ASSMTransitionNodeInterface_MakeRulesShareable) == 0x000018, "Wrong size on ASSMTransitionNodeInterface_MakeRulesShareable");
static_assert(offsetof(ASSMTransitionNodeInterface_MakeRulesShareable, Caller) == 0x000000, "Member 'ASSMTransitionNodeInterface_MakeRulesShareable::Caller' has a wrong offset!");
static_assert(offsetof(ASSMTransitionNodeInterface_MakeRulesShareable, Remap) == 0x000008, "Member 'ASSMTransitionNodeInterface_MakeRulesShareable::Remap' has a wrong offset!");

// Function ActionSystem.ASSMTransitionNodeInterface.PropagateRulesSettings
// 0x0010 (0x0010 - 0x0000)
struct ASSMTransitionNodeInterface_PropagateRulesSettings final
{
public:
	class UASSMTransitionNode*                    Caller;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SharedRulesIdx;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ASSMTransitionNodeInterface_PropagateRulesSettings) == 0x000008, "Wrong alignment on ASSMTransitionNodeInterface_PropagateRulesSettings");
static_assert(sizeof(ASSMTransitionNodeInterface_PropagateRulesSettings) == 0x000010, "Wrong size on ASSMTransitionNodeInterface_PropagateRulesSettings");
static_assert(offsetof(ASSMTransitionNodeInterface_PropagateRulesSettings, Caller) == 0x000000, "Member 'ASSMTransitionNodeInterface_PropagateRulesSettings::Caller' has a wrong offset!");
static_assert(offsetof(ASSMTransitionNodeInterface_PropagateRulesSettings, SharedRulesIdx) == 0x000008, "Member 'ASSMTransitionNodeInterface_PropagateRulesSettings::SharedRulesIdx' has a wrong offset!");

// Function ActionSystem.ASSMTransitionNodeInterface.TransferSharedCustomRules
// 0x0018 (0x0018 - 0x0000)
struct ASSMTransitionNodeInterface_TransferSharedCustomRules final
{
public:
	class UASSMTransitionNode*                    Caller;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UASTransition_Base*                     Custom;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SharedRulesIdx;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ASSMTransitionNodeInterface_TransferSharedCustomRules) == 0x000008, "Wrong alignment on ASSMTransitionNodeInterface_TransferSharedCustomRules");
static_assert(sizeof(ASSMTransitionNodeInterface_TransferSharedCustomRules) == 0x000018, "Wrong size on ASSMTransitionNodeInterface_TransferSharedCustomRules");
static_assert(offsetof(ASSMTransitionNodeInterface_TransferSharedCustomRules, Caller) == 0x000000, "Member 'ASSMTransitionNodeInterface_TransferSharedCustomRules::Caller' has a wrong offset!");
static_assert(offsetof(ASSMTransitionNodeInterface_TransferSharedCustomRules, Custom) == 0x000008, "Member 'ASSMTransitionNodeInterface_TransferSharedCustomRules::Custom' has a wrong offset!");
static_assert(offsetof(ASSMTransitionNodeInterface_TransferSharedCustomRules, SharedRulesIdx) == 0x000010, "Member 'ASSMTransitionNodeInterface_TransferSharedCustomRules::SharedRulesIdx' has a wrong offset!");
static_assert(offsetof(ASSMTransitionNodeInterface_TransferSharedCustomRules, ReturnValue) == 0x000014, "Member 'ASSMTransitionNodeInterface_TransferSharedCustomRules::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASState_BlueprintBase.ReceiveBeginPlay
// 0x0008 (0x0008 - 0x0000)
struct ASState_BlueprintBase_ReceiveBeginPlay final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASState_BlueprintBase_ReceiveBeginPlay) == 0x000008, "Wrong alignment on ASState_BlueprintBase_ReceiveBeginPlay");
static_assert(sizeof(ASState_BlueprintBase_ReceiveBeginPlay) == 0x000008, "Wrong size on ASState_BlueprintBase_ReceiveBeginPlay");
static_assert(offsetof(ASState_BlueprintBase_ReceiveBeginPlay, AnimInstance) == 0x000000, "Member 'ASState_BlueprintBase_ReceiveBeginPlay::AnimInstance' has a wrong offset!");

// Function ActionSystem.ASState_BlueprintBase.ReceiveTick
// 0x0010 (0x0010 - 0x0000)
struct ASState_BlueprintBase_ReceiveTick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimInstance*                          AnimInstance;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASState_BlueprintBase_ReceiveTick) == 0x000008, "Wrong alignment on ASState_BlueprintBase_ReceiveTick");
static_assert(sizeof(ASState_BlueprintBase_ReceiveTick) == 0x000010, "Wrong size on ASState_BlueprintBase_ReceiveTick");
static_assert(offsetof(ASState_BlueprintBase_ReceiveTick, DeltaTime) == 0x000000, "Member 'ASState_BlueprintBase_ReceiveTick::DeltaTime' has a wrong offset!");
static_assert(offsetof(ASState_BlueprintBase_ReceiveTick, AnimInstance) == 0x000008, "Member 'ASState_BlueprintBase_ReceiveTick::AnimInstance' has a wrong offset!");

// Function ActionSystem.ASState_BlueprintBase.SetBlendSpaceInput
// 0x000C (0x000C - 0x0000)
struct ASState_BlueprintBase_SetBlendSpaceInput final
{
public:
	struct FVector                                NewBlendInput;                                     // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASState_BlueprintBase_SetBlendSpaceInput) == 0x000004, "Wrong alignment on ASState_BlueprintBase_SetBlendSpaceInput");
static_assert(sizeof(ASState_BlueprintBase_SetBlendSpaceInput) == 0x00000C, "Wrong size on ASState_BlueprintBase_SetBlendSpaceInput");
static_assert(offsetof(ASState_BlueprintBase_SetBlendSpaceInput, NewBlendInput) == 0x000000, "Member 'ASState_BlueprintBase_SetBlendSpaceInput::NewBlendInput' has a wrong offset!");

// Function ActionSystem.ASState_BlueprintBase.SetPlayRate
// 0x0004 (0x0004 - 0x0000)
struct ASState_BlueprintBase_SetPlayRate final
{
public:
	float                                         NewRate;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASState_BlueprintBase_SetPlayRate) == 0x000004, "Wrong alignment on ASState_BlueprintBase_SetPlayRate");
static_assert(sizeof(ASState_BlueprintBase_SetPlayRate) == 0x000004, "Wrong size on ASState_BlueprintBase_SetPlayRate");
static_assert(offsetof(ASState_BlueprintBase_SetPlayRate, NewRate) == 0x000000, "Member 'ASState_BlueprintBase_SetPlayRate::NewRate' has a wrong offset!");

// Function ActionSystem.ASState_BlueprintBase.GetAnimTime
// 0x0004 (0x0004 - 0x0000)
struct ASState_BlueprintBase_GetAnimTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASState_BlueprintBase_GetAnimTime) == 0x000004, "Wrong alignment on ASState_BlueprintBase_GetAnimTime");
static_assert(sizeof(ASState_BlueprintBase_GetAnimTime) == 0x000004, "Wrong size on ASState_BlueprintBase_GetAnimTime");
static_assert(offsetof(ASState_BlueprintBase_GetAnimTime, ReturnValue) == 0x000000, "Member 'ASState_BlueprintBase_GetAnimTime::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASState_BlueprintBase.GetAnimTimeLength
// 0x0004 (0x0004 - 0x0000)
struct ASState_BlueprintBase_GetAnimTimeLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASState_BlueprintBase_GetAnimTimeLength) == 0x000004, "Wrong alignment on ASState_BlueprintBase_GetAnimTimeLength");
static_assert(sizeof(ASState_BlueprintBase_GetAnimTimeLength) == 0x000004, "Wrong size on ASState_BlueprintBase_GetAnimTimeLength");
static_assert(offsetof(ASState_BlueprintBase_GetAnimTimeLength, ReturnValue) == 0x000000, "Member 'ASState_BlueprintBase_GetAnimTimeLength::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASTransition_BlueprintBase.CheckCommand
// 0x0018 (0x0018 - 0x0000)
struct ASTransition_BlueprintBase_CheckCommand final
{
public:
	class FString                                 Command;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ASTransition_BlueprintBase_CheckCommand) == 0x000008, "Wrong alignment on ASTransition_BlueprintBase_CheckCommand");
static_assert(sizeof(ASTransition_BlueprintBase_CheckCommand) == 0x000018, "Wrong size on ASTransition_BlueprintBase_CheckCommand");
static_assert(offsetof(ASTransition_BlueprintBase_CheckCommand, Command) == 0x000000, "Member 'ASTransition_BlueprintBase_CheckCommand::Command' has a wrong offset!");
static_assert(offsetof(ASTransition_BlueprintBase_CheckCommand, ReturnValue) == 0x000010, "Member 'ASTransition_BlueprintBase_CheckCommand::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASTransition_BlueprintBase.CheckCommandState
// 0x0018 (0x0018 - 0x0000)
struct ASTransition_BlueprintBase_CheckCommandState final
{
public:
	class FString                                 Command;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimCommandState                             ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ASTransition_BlueprintBase_CheckCommandState) == 0x000008, "Wrong alignment on ASTransition_BlueprintBase_CheckCommandState");
static_assert(sizeof(ASTransition_BlueprintBase_CheckCommandState) == 0x000018, "Wrong size on ASTransition_BlueprintBase_CheckCommandState");
static_assert(offsetof(ASTransition_BlueprintBase_CheckCommandState, Command) == 0x000000, "Member 'ASTransition_BlueprintBase_CheckCommandState::Command' has a wrong offset!");
static_assert(offsetof(ASTransition_BlueprintBase_CheckCommandState, ReturnValue) == 0x000010, "Member 'ASTransition_BlueprintBase_CheckCommandState::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASTransition_BlueprintBase.GetAnimTime
// 0x0004 (0x0004 - 0x0000)
struct ASTransition_BlueprintBase_GetAnimTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASTransition_BlueprintBase_GetAnimTime) == 0x000004, "Wrong alignment on ASTransition_BlueprintBase_GetAnimTime");
static_assert(sizeof(ASTransition_BlueprintBase_GetAnimTime) == 0x000004, "Wrong size on ASTransition_BlueprintBase_GetAnimTime");
static_assert(offsetof(ASTransition_BlueprintBase_GetAnimTime, ReturnValue) == 0x000000, "Member 'ASTransition_BlueprintBase_GetAnimTime::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASTransition_BlueprintBase.GetAnimTimeLength
// 0x0004 (0x0004 - 0x0000)
struct ASTransition_BlueprintBase_GetAnimTimeLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASTransition_BlueprintBase_GetAnimTimeLength) == 0x000004, "Wrong alignment on ASTransition_BlueprintBase_GetAnimTimeLength");
static_assert(sizeof(ASTransition_BlueprintBase_GetAnimTimeLength) == 0x000004, "Wrong size on ASTransition_BlueprintBase_GetAnimTimeLength");
static_assert(offsetof(ASTransition_BlueprintBase_GetAnimTimeLength, ReturnValue) == 0x000000, "Member 'ASTransition_BlueprintBase_GetAnimTimeLength::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASTransition_BlueprintBase.GetElapsedTime
// 0x0004 (0x0004 - 0x0000)
struct ASTransition_BlueprintBase_GetElapsedTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASTransition_BlueprintBase_GetElapsedTime) == 0x000004, "Wrong alignment on ASTransition_BlueprintBase_GetElapsedTime");
static_assert(sizeof(ASTransition_BlueprintBase_GetElapsedTime) == 0x000004, "Wrong size on ASTransition_BlueprintBase_GetElapsedTime");
static_assert(offsetof(ASTransition_BlueprintBase_GetElapsedTime, ReturnValue) == 0x000000, "Member 'ASTransition_BlueprintBase_GetElapsedTime::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASTransition_BlueprintBase.IsPlayEnd
// 0x0001 (0x0001 - 0x0000)
struct ASTransition_BlueprintBase_IsPlayEnd final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASTransition_BlueprintBase_IsPlayEnd) == 0x000001, "Wrong alignment on ASTransition_BlueprintBase_IsPlayEnd");
static_assert(sizeof(ASTransition_BlueprintBase_IsPlayEnd) == 0x000001, "Wrong size on ASTransition_BlueprintBase_IsPlayEnd");
static_assert(offsetof(ASTransition_BlueprintBase_IsPlayEnd, ReturnValue) == 0x000000, "Member 'ASTransition_BlueprintBase_IsPlayEnd::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASTransition_BlueprintBase.IsPlayEndForce
// 0x0001 (0x0001 - 0x0000)
struct ASTransition_BlueprintBase_IsPlayEndForce final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ASTransition_BlueprintBase_IsPlayEndForce) == 0x000001, "Wrong alignment on ASTransition_BlueprintBase_IsPlayEndForce");
static_assert(sizeof(ASTransition_BlueprintBase_IsPlayEndForce) == 0x000001, "Wrong size on ASTransition_BlueprintBase_IsPlayEndForce");
static_assert(offsetof(ASTransition_BlueprintBase_IsPlayEndForce, ReturnValue) == 0x000000, "Member 'ASTransition_BlueprintBase_IsPlayEndForce::ReturnValue' has a wrong offset!");

// Function ActionSystem.ASTransition_BlueprintBase.ReceiveCanEnter
// 0x0010 (0x0010 - 0x0000)
struct ASTransition_BlueprintBase_ReceiveCanEnter final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ASTransition_BlueprintBase_ReceiveCanEnter) == 0x000008, "Wrong alignment on ASTransition_BlueprintBase_ReceiveCanEnter");
static_assert(sizeof(ASTransition_BlueprintBase_ReceiveCanEnter) == 0x000010, "Wrong size on ASTransition_BlueprintBase_ReceiveCanEnter");
static_assert(offsetof(ASTransition_BlueprintBase_ReceiveCanEnter, AnimInstance) == 0x000000, "Member 'ASTransition_BlueprintBase_ReceiveCanEnter::AnimInstance' has a wrong offset!");
static_assert(offsetof(ASTransition_BlueprintBase_ReceiveCanEnter, ReturnValue) == 0x000008, "Member 'ASTransition_BlueprintBase_ReceiveCanEnter::ReturnValue' has a wrong offset!");

}

